<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>THM-Careers in Cyber(网络安全职业介绍)-学习</title>
    <url>/2024/01/16/THM-Careers%20in%20Cyber(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：了解网络安全领域的不同职业。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络安全行业有许多不同的工作种类，主要分为进攻性安全（对目标进行渗透测试以及产出漏洞报告）和防御性安全（防御、调查网络攻击）。</p>
<p>本文将通过提供有关各种网络安全角色的基础信息介绍来帮助你了解网络安全领域的职业情况；在本文的内容中还会给出一些相关的链接，这些链接将指向Tryhackme平台上的不同学习路径，你可以使用这些路径进行学习从而培养你的网络安全技能（这里指的是基础级别的技能）。</p>
<h2 id="安全分析师-Security-Analyst"><a href="#安全分析师-Security-Analyst" class="headerlink" title="安全分析师(Security Analyst)"></a>安全分析师(Security Analyst)</h2><p>此职业主要负责维护组织的数据安全性。安全分析师是跨组织构建安全措施以保护公司免受攻击不可或缺的一部分，分析师将探索和评估公司网络，以发现可操作的数据并建议工程师制定预防措施。 此工作角色需要与各种利益相关者合作，以了解安全要求和安全形势。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/5504f125b74401f8633bccd831e4c785.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>与各利益相关者合作，分析整个公司的网络安全</li>
<li>编制有关网络安全的持续报告，记录安全问题和建议采取的应对措施</li>
<li>结合对新攻击工具和新攻击趋势的研究：制定安全计划、制定跨团队维护数据安全所需的措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="安全工程师-Security-Engineer"><a href="#安全工程师-Security-Engineer" class="headerlink" title="安全工程师(Security Engineer)"></a>安全工程师(Security Engineer)</h2><p>此职业主要负责设计、监控和维护安全控制、网络和系统，以帮助防御各种网络攻击。安全工程师基于威胁情报和漏洞信息来开发和实施安全解决方案——威胁情报和漏洞信息通常来自安全团队成员。 安全工程师致力于规避各种攻击，包括 Web 应用程序攻击、网络威胁以及不断发展的新型攻击趋势和策略，最终目标是保持并采用安全措施来降低攻击风险和数据丢失风险。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/037b40529f9a15660ee458245c8c14dc.png"
                      alt="img" style="zoom: 50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>跨软件测试和筛选安全措施。</li>
<li>监控网络和报告 以更新系统和缓解漏洞威胁。</li>
<li>确定并实施系统所需的安全解决方案，以获得最佳安全性。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="应急响应人员-Incident-Responder"><a href="#应急响应人员-Incident-Responder" class="headerlink" title="应急响应人员(Incident Responder)"></a>应急响应人员(Incident Responder)</h2><p>此职业主要负责 在攻击者的操作仍在开展时识别并缓解攻击。应急响应人员需要对安全漏洞做出富有成效和高效的响应，工作职责是为组织制定计划、政策和协议，以便在攻击事件发生期间和攻击事件发生后得到执行。这通常是一个压力很大的职位，随着网络攻击的展开，应急响应人员需要实时对攻击进行评估和响应，常用的事件响应指标包括 MTTD、MTTA 和 MTTR等——即平均检测、确认和恢复时间（从网络攻击事件中），应急响应的目的是实现快速有效的响应，保持公司财务状况并避免公司受到负面的违规影响。</p>
<p>简而言之，应急响应人员最终需要保护公司的数据、声誉和财务状况免受网络攻击的影响。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/6a48b0ea257a587d560ffef4b28f4d35.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>制定并采用全面、可操作的事件响应计划</li>
<li>保持强大的安全最佳实践并支持事件响应措施</li>
<li>完成事件后报告并为未来的攻击做准备，适应攻击事件并从攻击事件中吸取教训</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="数字取证审查员-Digital-Forensics-Examiner"><a href="#数字取证审查员-Digital-Forensics-Examiner" class="headerlink" title="数字取证审查员(Digital Forensics Examiner)"></a>数字取证审查员(Digital Forensics Examiner)</h2><p>此职业主要负责进行数字取证以调查网络安全事件和网络安全犯罪行为。如果你喜欢扮演侦探，这可能是一个完美的网络安全工作；如果你是执法部门的一员，你将专注于收集和分析证据以帮助破案：指控有罪者并且为无辜者正名；另一方面，如果你的工作属于保护公司网络的范畴，你将使用数字取证技能来分析事件，例如找出网络攻击者违反法律的证据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/22747e6c2cffce6de0c93f456784be37.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>在遵守法律程序的同时收集数字证据</li>
<li>分析数字证据以找到与案件相关的答案</li>
<li>记录你的发现并在相关案例中进行报告</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="恶意软件分析师-Malware-Analyst"><a href="#恶意软件分析师-Malware-Analyst" class="headerlink" title="恶意软件分析师(Malware Analyst)"></a>恶意软件分析师(Malware Analyst)</h2><p>此职业主要负责分析所有类型的恶意软件以更多地了解它们的工作原理和作用。恶意软件分析师的工作包括分析可疑程序、发现软件的恶意行为并编写有关报告。 恶意软件分析师有时也被称为<em><strong>逆向工程师</strong></em>，因为他们的核心任务围绕着 将已经编译的程序从机器语言转换为可读代码，通常是将低级计算机语言转换为高级语言，这项工作要求恶意软件分析师具有强大的编程背景，尤其是要了解汇编语言和 C 语言等。</p>
<p>恶意软件分析师的最终目标是了解恶意程序执行的所有活动，了解如何检测和报告软件的恶意行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/49b9585d464f633da235ad1ac6e657d8.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对恶意程序进行静态分析，这需要进行逆向工程。</li>
<li>通过观察受控环境中的活动对恶意软件样本进行动态分析。</li>
<li>记录并报告所有发现。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="渗透测试人员-Penetration-Tester"><a href="#渗透测试人员-Penetration-Tester" class="headerlink" title="渗透测试人员(Penetration Tester)"></a>渗透测试人员(Penetration Tester)</h2><p>此职业主要负责测试技术产品的安全漏洞。渗透测试人员也被称为道德黑客，渗透测试人员的工作职责是测试公司内部系统和软件的安全性——通过尝试系统化的黑客攻击行为来发现安全缺陷和安全漏洞。 渗透测试人员利用所发现的漏洞来评估每个实例的风险，然后，公司可以利用相关的漏洞报告来纠正安全问题，以防止现实世界中的网络攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1b9ac0842dca3efabbc15387fc4f0261.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对计算机系统、网络和基于 Web 的应用程序进行测试。</li>
<li>执行安全评估、安全审计和安全分析策略。</li>
<li>完成评估并进行报告，推荐攻击预防措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="红队人员-Red-Teamer"><a href="#红队人员-Red-Teamer" class="headerlink" title="红队人员(Red Teamer)"></a>红队人员(Red Teamer)</h2><p>此职业主要负责在攻防中扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全反馈。红队与渗透测试员有相似之处，但是红队是一个具有更有针对性的工作角色。渗透测试人员往往希望发现系统中的许多漏洞，以保持网络防御的良好状态；而红队则负责测试公司的攻击检测和响应能力，红队人员需要模仿网络罪犯的行为、模拟恶意攻击、保留访问权限(留后门)并避免被发现。红队评估行动往往可以运行一个月之久，这通常是由公司外部的团队来进行的，这些外部团队往往会对拥有成熟安全程序的组织开展红队评估。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/4fa8afd51656c084df33a42566709610.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li><p>模拟威胁行为者的角色，发现可利用的漏洞、维持访问权限（留后门）并避免被发现。</p>
</li>
<li><p>评估目标组织的安全控制、威胁情报和事件响应程序。</p>
</li>
<li><p>完成评估并进行报告，为公司提供可操作的数据以避免真实世界的攻击实例。</p>
</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/redteaming" >https://tryhackme.com/path/outline/redteaming <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Defensive Security(防御性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Defensive%20Security(%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/defensivesecurityhq" >https://tryhackme.com/room/defensivesecurityhq <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：介绍防御性安全和相关主题，例如威胁情报、SOC、DFIR 和 SIEM。</p>
<h2 id="防御性安全简介"><a href="#防御性安全简介" class="headerlink" title="防御性安全简介"></a>防御性安全简介</h2><p>进攻性安全专注于一件事：闯入系统。 进攻性安全领域的职业人员可以通过利用现有错误、滥用不安全的设置以及利用未强制执行的访问控制策略等方式侵入目标系统。 红队和渗透测试人员专注于进攻性安全。</p>
<p>防御性安全在某种程度上与进攻性安全相反，它涉及两个主要任务：</p>
<ul>
<li>防止入侵发生</li>
<li>在入侵发生时检测入侵并做出正确响应</li>
</ul>
<p>蓝队是防御性安全领域的一部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232248643-1808428703.png"
                      alt="image"
                ></p>
<p>一些与防御性安全相关的任务：</p>
<ul>
<li><p>培养用户网络安全意识：对用户进行网络安全培训有助于防止针对系统的各种攻击。</p>
</li>
<li><p>记录和管理资产：我们需要知道我们必须妥善管理和保护的系统和设备的类型。</p>
</li>
<li><p>更新和修补系统：确保计算机、服务器和网络设备针对任何已知漏洞（弱点）进行正确的版本更新和补丁修补。</p>
</li>
<li><p>设置预防性安全设备：防火墙和入侵防御系统 (IPS) 是预防性安全的重要组成部分。 防火墙可以控制哪些网络流量可以进入系统或网络，以及哪些流量可以离开系统或网络。 IPS 会阻止任何符合当前规则和攻击特征的网络流量。</p>
</li>
<li><p>设置日志记录和监控设备：如果没有进行适当的网络日志记录和网络监控，就不可能检测到恶意活动和入侵行为。 如果我们管理的网络中出现了新的未经授权的可疑设备，我们应该能够及时知道。</p>
</li>
</ul>
<p>防御性安全还有很多要求，上面的列表只涵盖了几个常见的安全任务。</p>
<p>以下是防御性安全的常见相关主题</p>
<ul>
<li>安全运营中心 (SOC)</li>
<li>威胁情报</li>
<li>数字取证和事件响应 (DFIR)</li>
<li>恶意软件分析</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319104624034.png"
                      alt="image-20230319104624034"
                ></p>
<h2 id="防御性安全相关领域介绍"><a href="#防御性安全相关领域介绍" class="headerlink" title="防御性安全相关领域介绍"></a>防御性安全相关领域介绍</h2><p>在本小节中，我们将涵盖与防御性安全相关的两个主要主题：</p>
<ul>
<li>安全运营中心 (SOC)，涵盖了威胁情报处理。</li>
<li>数字取证和事件响应 (DFIR)，涵盖了恶意软件分析。</li>
</ul>
<h3 id="安全运营中心-SOC"><a href="#安全运营中心-SOC" class="headerlink" title="安全运营中心(SOC)"></a>安全运营中心(SOC)</h3><p>安全运营中心(SOC-Security Operations Center) 是一个由网络安全专业人员所组成的团队，主要负责监控网络及其系统以检测恶意网络安全事件。</p>
<p>SOC 的一些主要兴趣领域是：</p>
<ul>
<li><p>漏洞：每当发现系统漏洞（弱点）时，必须通过安装适当的更新包或者补丁来修复漏洞，当修复方案不可用时，则应采取必要的措施来防止攻击者利用漏洞。 尽管修复漏洞对 SOC 至关重要，但这项任务实际上不一定会分配给他们来完成。</p>
</li>
<li><p>策略违规：我们可以将安全策略视为保护网络和系统所需的一组规则；例如，如果用户将公司机密数据上传到公开的在线存储服务，则可能违反了安全策略。</p>
</li>
<li><p>未经授权的活动：如果用户的登录名和密码被盗取，那么攻击者就可以使用盗取到的凭据进行登录行为；SOC 需要检测此类事件 并在攻击者造成进一步损坏之前尽快进行阻止。</p>
</li>
<li><p>网络入侵：无论你的安全性有多好，攻击者进行入侵的机会总是存在。当用户单击恶意链接或攻击者利用公共服务器时，也可能会发生网络入侵事件；不管怎样，当网络入侵发生时，我们就必须尽快检测到它，以防止进一步的破坏。</p>
</li>
</ul>
<p>SOC的安全操作涵盖了各种任务以保护公司网络及系统，其中也包含了威胁情报处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232324077-921784249.png"
                      alt="image"
                ></p>
<h4 id="威胁情报-Threat-Intelligence"><a href="#威胁情报-Threat-Intelligence" class="headerlink" title="威胁情报(Threat Intelligence)"></a>威胁情报(Threat Intelligence)</h4><p>在网络安全中：情报指的是你收集到的关于实际和潜在敌人的信息，威胁指的是任何可能破坏系统或对系统产生不利影响的行为。</p>
<p>威胁情报旨在收集信息，以帮助公司更好地应对潜在的攻击者，了解威胁情报的目的是实现威胁知情防御；不同的公司会吸引不同类型的网络攻击者，一些攻击者可能会试图从移动运营商处窃取客户数据，另外一些攻击者可能会有兴趣破坏炼油厂的网络以使其停止生产。</p>
<p>典型的网络攻击者包括出于政治原因工作的国家网络军队以及出于财务目的行事的勒索软件组织，基于公司（目标）的性质，我们就可以知道预期的攻击者类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232336558-1363855465.png"
                      alt="image"
                ></p>
<p>情报需要数据，我们必须收集、处理和分析数据：我们首先需要进行数据收集，具体的数据收集来源分为本地来源（例如网络日志）和公共来源（例如网络论坛）；得到数据之后，我们还需要对数据进行处理，数据处理旨在将数据排列成适合分析的格式；最后是数据分析阶段，此阶段旨在找到有关攻击者及其动机的更多信息，另外，数据分析还旨在创建建议列表和可操作步骤列表。</p>
<p>威胁情报可以让我们了解潜在攻击者的战术、技术和程序，妥善处理威胁情报的好处是：我们可以识别威胁参与者（对手），预测他们的攻击活动，最终能够减轻他们的攻击危害并能及时准备响应策略。</p>
<h3 id="数字取证和事件响应-DFIR"><a href="#数字取证和事件响应-DFIR" class="headerlink" title="数字取证和事件响应(DFIR)"></a>数字取证和事件响应(DFIR)</h3><p>接下来我们将介绍数字取证和事件响应 (DFIR-Digital Forensics and Incident Response)，主要将涵盖以下内容：</p>
<ul>
<li>数字取证</li>
<li>事件响应</li>
<li>恶意软件分析</li>
</ul>
<h4 id="数字取证-Digital-Forensics"><a href="#数字取证-Digital-Forensics" class="headerlink" title="数字取证(Digital Forensics)"></a>数字取证(Digital Forensics)</h4><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p>在防御性安全方面，数字取证的重点转移到了分析攻击证据、分析攻击者以及分析其他领域：如知识产权盗窃、网络间谍活动、拥有未经授权的内容等。 </p>
<p>数字取证将侧重于不同的区域，例如：</p>
<ul>
<li><p>文件系统：分析来自于系统存储的数字取证图像（低级副本）可以揭示很多信息，例如分析已安装的程序、已创建的文件、部分被覆盖的文件和已删除的文件等。</p>
</li>
<li><p>系统内存：如果攻击者在内存中运行他们的恶意程序而不将其保存到磁盘中，那么获取系统内存的取证图像（低级副本）是分析恶意程序内容和了解恶意攻击的最佳方式。</p>
</li>
<li><p>系统日志：每台客户端和服务器计算机都维护着不同的日志文件来记录正在发生的事情。因此，日志文件能够提供大量关于系统上发生的事情的信息，即使攻击者试图清除他们的行为痕迹，也可能会留下一些线索。</p>
</li>
<li><p>网络日志：遍历网络中的网络数据包日志将有助于回答是否正在发生攻击、是否已经被攻击以及攻击行为所造成的后果是什么。</p>
</li>
</ul>
<h4 id="事件响应-Incident-Response"><a href="#事件响应-Incident-Response" class="headerlink" title="事件响应(Incident Response)"></a>事件响应(Incident Response)</h4><p>事件，在网络安全中通常是指发生数据泄露或发生网络攻击；但是，在某些情况下，有些事件可能不是那么重要，例如配置错误、入侵企图或违反安全策略的行为。</p>
<p>网络攻击的常见示例包括：攻击者使我们的网络或系统无法访问、攻击者破坏（更改）公共网站和发生数据泄露（攻击者窃取公司数据）等。 那么我们将如何应对网络攻击？事件响应指定了出现网络攻击情况时应遵循的方法，事件响应的目的是在网络攻击事件中减少损坏并在尽可能短的时间内恢复正常。在理想情况下，公司的相关安全部门应该制定一个准备好进行事件响应的计划。</p>
<p>事件响应过程的四个主要阶段是：</p>
<ul>
<li><p>准备阶段：这需要一支训练有素并且已经准备好处理安全事件的团队，在理想情况下，要尽量采取各种安全措施来防止事故发生。</p>
</li>
<li><p>检测和分析阶段：事件响应团队要拥有必要的资源来检测安全事件是否发生；此外，事件响应团队还必须进一步分析任何已经检测到的事件以了解其严重性。</p>
</li>
<li><p>遏制、根除和恢复阶段：一旦检测到事件发生，最重要的是要阻止事件影响其他系统、消除恶意事件并恢复受影响的系统。例如，当我们发现一个系统感染了计算机病毒，我们要及时阻止（遏制）病毒传播到其他系统，清除（根除）病毒程序，并使系统恢复正常工作状态。</p>
</li>
<li><p>事后活动阶段：成功恢复系统工作后，要生成一份相关的报告，分享以及吸取教训，以防止未来发生类似事件。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232401249-375105017.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421125545564.png"
                      alt="image-20230421125545564"
                ></p>
<h4 id="恶意软件分析-Malware-Analysis"><a href="#恶意软件分析-Malware-Analysis" class="headerlink" title="恶意软件分析(Malware Analysis)"></a>恶意软件分析(Malware Analysis)</h4><p>Malware 代表恶意软件，软件是指可以保存在磁盘上或通过网络发送的程序、文档和文件。 </p>
<p>恶意软件包括多种类型，例如：</p>
<ul>
<li><p>病毒(Virus)是将自身附加到程序中的一段代码（是程序的一部分），它旨在从一台计算机传播到另一台计算机； 此外，一旦病毒感染了计算机，它就会通过更改、覆盖和删除文件来发挥危害作用，最终导致的结果是让计算机运行速度变慢直至计算机无法正常使用。</p>
</li>
<li><p>特洛伊木马(Trojan Horse)是一种程序，它会显示自己具有一个理想的正常功能，但实际上程序中还隐藏了一些恶意功能；例如，受害者可能会从可疑网站下载视频播放器，而这个视频播放器可能实际上是一个木马程序，从而攻击者可以完全控制受害者的系统。</p>
</li>
<li><p>勒索软件(Ransomware)是一种加密用户文件的恶意程序，加密会使文件在不知道加密密码的情况下变为不可读状态；用户只有选择支付“赎金”，攻击者才可能会向用户提供加密密码来对用户文件进行解密。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232423140-422842004.png"
                      alt="image"
                ></p>
<p>恶意软件分析旨在使用各种方式了解恶意程序，从而保护网络和系统的安全环境：</p>
<ul>
<li><p>静态分析：在不运行恶意程序的前提下对恶意程序进行检查。通常，这需要扎实的汇编语言知识（处理器的指令集，即计算机的基本指令）。</p>
</li>
<li><p>动态分析：受控环境中运行恶意软件并监控其活动 以进行分析，动态分析可以让你观察恶意软件在运行时的具体行为。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319125337268.png"
                      alt="image-20230319125337268"
                ></p>
<h2 id="关于防御性安全的简单实例"><a href="#关于防御性安全的简单实例" class="headerlink" title="关于防御性安全的简单实例"></a>关于防御性安全的简单实例</h2><p><strong>模拟场景介绍</strong></p>
<p>作为安全分析师，你接下来将要执行一个典型任务：</p>
<p>你是负责保护银行的安全运营中心 (SOC-Security Operations Center) 的成员，该银行的SOC使用了安全信息和事件管理 (SIEM-Security Information and Event Management) 系统，SIEM 会通过各种来源收集与安全相关的信息和事件，并通过一个系统呈现它们；例如，如果用户多次尝试登录失败或者有来自意外地理位置的登录尝试行为，你将收到相关的消息通知；此外，随着机器学习的出现，SIEM 还会自动检测某些异常行为，例如某个用户在凌晨 3 点登录，而通常情况下用户应该只在工作时间进行登录。</p>
<p>在本小节的实例中，我们将与 SIEM 交互以实时监控网络和系统上的不同事件。有些事件是典型的、无害的，而有些特殊事件可能需要我们进一步干预，我们将在实例中找到被标记为红色的事件，记下相关信息，然后单击相关记录以开始进一步检查。</p>
<p>在对可疑事件的进一步检查中，我们需要尝试了解有关可疑活动或事件的更多信息，可疑事件警告可能是由某个具体事件触发的，这可能会关联到本地用户、本地计算机或远程 IP 地址。在现实世界中，如果要发送和接收邮件，你需要知道一个实际地址；同样，在网络环境中，你需要一个 IP 地址才能通过 Internet 发送和接收数据，IP 地址是允许你通过 Internet 进行通信的逻辑地址。我们需要检查事件警告触发的原因以确认相关的事件是否确实是恶意的，如果确定是恶意事件，我们就需要采取相应的措施，比如向 SOC 中的其他成员进行报告并屏蔽恶意事件相关的 IP 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232447698-1553382882.png"
                      alt="image"
                ></p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例</em></p>
<p>part1：检查 SIEM 仪表面板中的警报消息，从警报中找到可疑 IP 地址(143.110.250.149)，记下它，然后单击警报消息继续。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133244202.png"
                      alt="image-20230319133244202" style="zoom: 67%;" 
                >

<p>part2：Internet 上有一些网站允许你检查某个 IP 地址的信誉以查看它是否是恶意的或可疑的；让我们对在part1中发现的可疑 IP 地址进行检查。</p>
<p><em>tips：有许多开源数据库，例如 <a class="link"   href="https://www.abuseipdb.com/" >AbuseIPDB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://talosintelligence.com/" >Cisco Talos Intelligence <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，你可以在其中对 IP 地址执行信誉和位置检查，大多数安全分析师使用这些工具来帮助他们进行警报调查；你还可以通过报告恶意 IP（例如，在 AbuseIPDB 上）来使 Internet 更安全。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133328927.png"
                      alt="image-20230319133328927" style="zoom:50%;" 
                >

<p>part3：查看检查结果，现在我们知道 IP 地址143.110.250.149是恶意的，我们需要将其上报给相关的工作人员。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319131240191.png"
                      alt="image-20230319131240191" style="zoom:80%;" 
                >

<p>part4：如果这只是失败的身份验证尝试，我们不必太担心，但是我们还注意到此恶意 IP 地址有成功的登录尝试记录，所以我们有必要将这一事件上报；我们要将此事件上报给负责相关工作的公司人员。（我们将事件上报给 SOC Team Lead——安全运营中心团队负责人）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319132739037.png"
                      alt="image-20230319132739037" style="zoom: 67%;" 
                >

<p>part5：经过事件上报后，我们已获得阻止恶意 IP 地址(143.110.250.149)访问目标公司的权限，我们可以执行阻止规则，通过防火墙阻止恶意 IP 地址访问目标公司。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133554203.png"
                      alt="image-20230319133554203" style="zoom: 67%;" 
                >

<p>part6：我们成功完成了这个简单实例，最后我们获取到以下flag内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133708037.png"
                      alt="image-20230319133708037"
                ></p>
<blockquote>
<p>最后获取到的flag内容是：THM{THREAT-BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318231923119.png"
                      alt="image-20230318231923119"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Offensive Security(进攻性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Offensive%20Security(%E8%BF%9B%E6%94%BB%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：对进攻性安全概念进行简单的讲解。</p>
<h2 id="攻击模拟示例"><a href="#攻击模拟示例" class="headerlink" title="攻击模拟示例"></a>攻击模拟示例</h2><p>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，我们需要完成的操作是：攻击一个名为 FakeBank 的web应用程序（一个虚拟的银行web应用程序）。</p>
<p>我们将使用一个名为“GoBuster”的命令行工具来暴力破解 FakeBank 网站以查找隐藏目录或者页面，GoBuster 将使用一个包含潜在的页面名称或目录名称的字典，并尝试将该字典中的每一条记录和初始目标网站的url进行拼接，然后会逐个访问拼接之后的url，如果某个拼接之后的url所对应的网站页面真实存在，我们就能在GoBuster 的输出中得到对应的有效结果。</p>
<p><strong>步骤1）打开终端</strong></p>
<p>终端，也称为命令行，允许我们在不使用图形用户界面的情况下与计算机交互。</p>
<p><strong>步骤2）查找隐藏的网站页面</strong></p>
<p>大多数公司的网站都会有一个管理门户页面，此页面让公司员工能够访问基本的管理控制功能以进行一些日常操作。对于银行而言，员工可能需要将资金转入或者转出客户账户，如果网站页面不设为私有，那么攻击者就可能会找到显示敏感数据的隐藏页面或者允许访问网站管理控件的隐藏页面。</p>
<p>我们将在终端中键入以下命令，以使用 GoBuster（命令行安全工具）查找 FakeBank 网站上可能隐藏的页面。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的命令中，<code>-u</code>选项 将指定我们需要进行扫描的目标网站，<code>-w</code>选项 将指定用于进行遍历的字典以帮助我们查找隐藏页面。</p>
<p>GoBuster 会使用字典中的每条记录来扫描目标网站，从而查找目标网站上可能存在的隐藏页面；最终我们在GoBuster的输出结果中 可以看到目标网站上确实存在的隐藏目录（Status: 200表示相关页面确实存在）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318222340492.png"
                      alt="image-20230318222340492"
                ></p>
<p><strong>步骤3）攻击目标应用程序</strong></p>
<p>你应该已经找到了一个秘密的银行转账页面，这个页面(&#x2F;bank-transfer)允许你在银行账户之间进行转账。</p>
<p>攻击者可以利用隐藏的银行转账页面从任何银行账户中窃取资金，这对银行来说是一个严重的安全风险；作为一名有道德的黑客，你应该（在获得许可的情况下）从目标公司的应用程序中尝试发现此漏洞，并在黑客利用这个漏洞之前将其报告给银行以便进行及时修复。</p>
<p><strong>答题</strong></p>
<p><em>尝试在虚拟实验环境中对目标进行攻击，从银行账户号2276向你的账户（账户号8881）转账 2000美元。</em></p>
<p>在终端界面输入以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224310889.png"
                      alt="image-20230318224310889"
                ></p>
<p>访问找到的隐藏目录：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224411171.png"
                      alt="image-20230318224411171" style="zoom:50%;" 
                >

<p>进行转账操作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224527032.png"
                      alt="image-20230318224527032" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224604085.png"
                      alt="image-20230318224604085" style="zoom:50%;" 
                >

<p>返回初始的银行账户页面–查看最终答案：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224830196.png"
                      alt="image-20230318224830196" style="zoom:50%;" 
                >

<blockquote>
<p>最终显示的答案为：BANK-HACKED</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224849820.png"
                      alt="image-20230318224849820"
                ></p>
<h2 id="什么是进攻性安全？"><a href="#什么是进攻性安全？" class="headerlink" title="什么是进攻性安全？"></a>什么是进攻性安全？</h2><p>简而言之，进攻性安全就是尝试闯入目标计算机系统、利用软件本身的错误并找到应用程序中的漏洞以获得对目标的未授权访问的过程。</p>
<p>要打败黑客，你就需要像黑客一样行事，作为合法的网络安全人员，你需要在网络犯罪分子发动攻击之前发现目标系统的漏洞并推荐漏洞补丁。</p>
<p>以下是关于进攻性安全职业角色的简短描述：</p>
<ul>
<li>渗透测试员 - 负责测试技术产品以发现可利用的安全漏洞。</li>
<li>红队 - 扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全防护措施反馈。</li>
<li>安全工程师 - 设计、监控和维护安全控制、网络和系统，以帮助防止网络攻击。</li>
</ul>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>主题样式Demo</title>
    <url>/2024/01/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>THM-Operating System Security(操作系统安全介绍)-学习</title>
    <url>/2024/01/16/THM-Operating%20System%20Security(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/operatingsystemsecurity" >https://tryhackme.com/room/operatingsystemsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍操作系统安全，并演示 Linux系统 上的 SSH 身份验证实例。</p>
<h2 id="操作系统安全简介"><a href="#操作系统安全简介" class="headerlink" title="操作系统安全简介"></a>操作系统安全简介</h2><p>每天当你使用智能手机或者笔记本电脑以及其他任何类型的计算机时，你都会直接或间接地与操作系统进行交互；常用的操作系统包括 MS Windows、macOS、iOS、Android、Chrome OS 和 Linux。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/41f5388e5280b8a769158537e4372eae.png"
                      alt="img"
                ></p>
<p>什么是操作系统？ 要定义操作系统，我们首先需要知道一个计算机术语：硬件。</p>
<p>计算机硬件是指所有可以用手触摸到的计算机部件和外围设备。硬件包括屏幕、键盘、打印机、U盘和主板；其中主板包含了许多组件，特别是中央处理器（CPU）和内存芯片（RAM），主板通常会连接存储设备（HDD-机械硬盘 或 SSD-固态硬盘）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322012635473.png"
                      alt="image-20230322012635473"
                ></p>
<p>主板是计算机的关键部分，从键盘和鼠标到屏幕和打印机的所有其他硬件都将连接到计算机主板；但是，如果你想在计算机中运行自己喜欢的程序或者应用程序，硬件组件本身是没办法直接被使用的，所以我们需要一个操作系统来控制和“驱动”这些硬件组件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322013136875.png"
                      alt="image-20230322013136875"
                ></p>
<p>操作系统 (OS) 是位于硬件与你正在运行的应用程序或者程序之间的层。</p>
<p>你日常使用的示例程序可能包括网络浏览器，例如 Firefox、Safari 和 Chrome，以及消息传递应用程序，例如 Signal、WhatsApp 和 Telegram。所有的程序和应用程序都不能直接在计算机硬件上运行，但是，它们能够运行在操作系统上，操作系统能够允许程序按照特定的规则去访问硬件。</p>
<p>某些操作系统专为在笔记本电脑和个人台式机上运行而设计，例如 MS Windows 11 和 macOS；还有某些操作系统专为智能手机而设计，例如 Android 和 iOS；另外还有用于服务器的操作系统，例如 <a class="link"   href="https://www.microsoft.com/en-us/windows-server/" >MS Windows Server 2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.ibm.com/products/aix" >IBM AIX <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://www.oracle.com/solaris" >Oracle Solaris <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>；最后，还有一些在个人计算机上以及在服务器上都能被使用的操作系统，比如Linux。</p>
<p>下图是2022 年 1 月期间收集的数据，这些数据显示了当时 用于浏览互联网的不同操作系统的流行程度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322014002536.png"
                      alt="image-20230322014002536"
                ></p>
<p>你的智能手机可能运行在 Android 或 iOS操作系统上，并且其中可能拥有关于你的大量私人数据，包括：</p>
<ol>
<li>与家人和朋友的私人谈话</li>
<li>与家人和朋友的私人照片</li>
<li>你用于个人和工作通信的电子邮件客户端</li>
<li>保存在网络浏览器中密码（甚至保存在笔记中的密码）</li>
<li>电子银行应用程序</li>
</ol>
<p>关于机密和私人数据的清单可能还有更多内容，你应该不会希望你所不信任的人打开你的手机并浏览你的照片、对话和应用程序；因此，你需要保护好自己的手机及其操作系统的安全。</p>
<p>保护私人数据同样适用于 运行了 MS Windows、macOS、Linux 等操作系统的笔记本电脑或计算机，你的计算机中很可能包含了大量信息，例如：</p>
<ol>
<li>与你的工作或大学相关的机密文件</li>
<li>你的私人个人文件，例如你的身份证或护照复印件</li>
<li>你所使用的电子邮件程序，例如 MS Outlook、Mozilla Thunderbird等</li>
<li>你保存在网络浏览器和其他应用程序中的密码</li>
<li>你的数码相机和智能手机中的照片的复印件</li>
</ol>
<p>这些关于私人信息的列表可能会很长，具体内容取决于用户类型。</p>
<p>考虑到所保存的数据的性质，你肯定会希望能够尽量确保个人信息安全，而当我们谈论到信息安全时，我们应该想到要保护好以下几点：</p>
<ul>
<li>机密性(Confidentiality)：你希望确保 机密的和私人的文件、信息仅供指定人员使用。</li>
<li>完整性(Integrity)：任何人都不能篡改存储在你的系统上的文件 或者 篡改你在网络上传输的文件。</li>
<li>可用性(Availability)：你希望你的笔记本电脑或智能手机在你决定使用时能够随时处于可用状态。</li>
</ul>
<p>tips：Confidentiality、Integrity、Availability——即CIA三合一模型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322015625614.png"
                      alt="image-20230322015625614"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213504737.png"
                      alt="image-20230320213504737"
                ></p>
<h2 id="关于操作系统安全的常见示例"><a href="#关于操作系统安全的常见示例" class="headerlink" title="关于操作系统安全的常见示例"></a>关于操作系统安全的常见示例</h2><p>正如我们在上一小节中所提到的，操作系统安全将涉及针对以下几个方面的攻击：</p>
<ul>
<li>Confidentiality-机密性</li>
<li>Integrity-完整性</li>
<li>Availability-可用性</li>
</ul>
<p>在本小节，我们将重点关注恶意用户所针对的三个安全缺陷：</p>
<ol>
<li>身份验证中的弱密码</li>
<li>弱文件权限</li>
<li>恶意程序</li>
</ol>
<h3 id="身份验证中的弱密码"><a href="#身份验证中的弱密码" class="headerlink" title="身份验证中的弱密码"></a>身份验证中的弱密码</h3><p>身份验证是验证你身份的行为，无论是本地系统还是远程系统，身份验证可以通过三种主要方式实现：</p>
<ul>
<li>你知道的信息，例如密码或 PIN 码。</li>
<li>你是什么，例如指纹。</li>
<li>你拥有的东西，例如可以接收 SMS(短信服务) 消息的电话号码。</li>
</ul>
<p>由于密码是最常见的身份验证形式，因此它们也是最容易受到攻击的。许多用户倾向于在网站上使用容易猜到的简单密码 或者 在多个网站上使用相同的密码；此外，一些用户是设置密码时 会依赖个人详细信息，例如出生日期和宠物的名字等，他们认为这很容易记忆并且不会被攻击者知道（事实上攻击者已经意识到了：用户在设置密码时，会倾向于依赖个人详细信息）。</p>
<p>2019 年 4 月 21 日 英国国家网络安全中心 (NCSC) 发布了 <a class="link"   href="https://www.ncsc.gov.uk/blog-post/passwords-passwords-everywhere" >100,000 个最常用密码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的列表，让我们看看常用的前 20 个密码(Top20)。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Rank	          Password</span><br><span class="line">1	              123456</span><br><span class="line">2	              123456789</span><br><span class="line">3	              qwerty</span><br><span class="line">4	              password</span><br><span class="line">5	              111111</span><br><span class="line">6	              12345678</span><br><span class="line">7	              abc123</span><br><span class="line">8	              1234567</span><br><span class="line">9	              password1</span><br><span class="line">10	              12345</span><br><span class="line">11	              1234567890</span><br><span class="line">12	              123123</span><br><span class="line">13	              000000</span><br><span class="line">14	              iloveyou</span><br><span class="line">15	              1234</span><br><span class="line">16	              1q2w3e4r5t</span><br><span class="line">17	              qwertyuiop</span><br><span class="line">18	              123</span><br><span class="line">19	              monkey</span><br><span class="line">20	              dragon</span><br></pre></td></tr></table></figure></div>

<p>阅读以上Top20密码列表：我们可以看到 123、1234、12345、…、123456789 和 1234567890 都在列表中，password、iloveyou、monkey、dragon等也是常用的英文，而在英文字典中没有的无含义词包括 qwerty、qwertyuiop 和 1q2w3e4r5t，这些看似复杂的(无含义词)密码 其实也非常容易预测，因为它们是遵循键盘布局进行输入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1510e4bd81418a2937060f9c55dad593.gif"
                      alt="img"
                ></p>
<p>简而言之，如果攻击者可以猜出你的任何在线帐户（例如你的电子邮件或社交媒体帐户）的密码，他们将能够直接访问你的私人数据。 因此，选择复杂的密码，并且在不同的账户下使用不同的密码是至关重要的。</p>
<h3 id="弱文件权限"><a href="#弱文件权限" class="headerlink" title="弱文件权限"></a>弱文件权限</h3><p>适当的安全性决定了最小特权原则。在工作环境中，你希望任何文件都只有那些需要访问它才能完成工作的人 有权进行访问；在个人层面上，假设你计划与家人或朋友一起去旅行，你可能只希望与参加该旅行的人共享与旅行计划相关的所有文件，而不想直接公开让所有人共享此类文件——这就是最小特权原则。简而言之，最小特权原则是指：我们要确定“谁才可以访问什么？”。</p>
<p>弱文件权限会使攻击者很容易针对机密性和完整性进行攻击：攻击者可以攻击机密性，因为弱权限允许他们访问他们不应该访问的文件；攻击者也可以攻击完整性，因为他们能够修改他们不应该进行编辑的文件。</p>
<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>我们要举的最后一个例子是恶意程序，根据恶意程序的类型，它们可以针对机密性、完整性和可用性进行攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/f0a69acdee2506b2898e34fc231fe94b.png"
                      alt="img" style="zoom:50%;" 
                >

<p>某些类型的恶意程序（例如特洛伊木马）允许攻击者访问你的系统，因此，攻击者将能够读取你的文件甚至修改你的文件。</p>
<p>某些类型的恶意程序会针对可用性进行攻击，例如勒索软件(ransomware)。勒索软件是一种能够加密用户文件的恶意程序，加密能够使文件在不知道加密密码的情况下变得不可读，换句话说，文件在没有进行解密（逆向加密）的情况下会变成乱码。在勒索软件事件中，攻击者往往会为用户提供恢复文件可用性的方法，攻击者会让用户重新获得对其原始文件的访问权限：当用户愿意支付“赎金-ransom”时，攻击者则会向用户提供加密密码以进行解密。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213351214.png"
                      alt="image-20230320213351214"
                ></p>
<h2 id="关于操作系统安全的简单实例"><a href="#关于操作系统安全的简单实例" class="headerlink" title="关于操作系统安全的简单实例"></a>关于操作系统安全的简单实例</h2><p>在典型的网络攻击中，攻击者可能会试图获得对远程目标系统的访问权，我们可以通过诱使目标运行恶意文件或者通过直接获取用户名、密码来完成此类攻击。</p>
<p>在本小节我们将重点关注：通过获取用户名、密码来获得对远程目标系统的访问权。 在发现有效用户名后，我们往往可以尝试“猜测”对应的密码，此外，我们也将进一步尝试将权限提升到系统管理员。</p>
<p>系统管理员账号身份在安卓、苹果、Linux系统上被称为<strong>root</strong>，而在 MS Windows 系统上，管理员账号身份会被称为<strong>administrator</strong>，root 账户和administrator 账户对目标系统都具有完全不受限制的访问权限。</p>
<p>在本小节中，我们将使用Linux系统进行练习，我们将可能使用以下 Linux 命令：</p>
<ul>
<li><code>whoami</code></li>
<li><code>ssh USERNAME@MACHINE_IP</code></li>
<li><code>ls</code></li>
<li><code>cat FILENAME</code></li>
<li><code>history</code></li>
</ul>
<p><strong>模拟场景</strong>：</p>
<p>我们受雇检查某家公司的安全性，当我们查看客户的办公室环境时，我们注意到其中一个桌子上有留有一张便条，上面有两个词：sammie 和 dragon，让我们猜测一下 dragon 是不是 Sammie用户 在目标机器 (MACHINE_IP)上所使用的密码？在 AttackBox 的终端中，我们将尝试通过执行<code>ssh sammie@MACHINE_IP</code>命令来登录到 Sammie 的ssh帐户，远程目标系统会要求你提供 sammie 的密码——我们输入 dragon 进行尝试。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322173552863.png"
                      alt="image-20230322173552863"
                ></p>
<p>AttackBox 终端上的登录交互如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@MACHINE_IP</span></span><br><span class="line">sammie@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Tue  1 Mar 13:20:32 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.03              Processes:              216</span><br><span class="line">  Usage of /:   51.8% of 6.53GB   Users logged in:        1</span><br><span class="line">  Memory usage: 17%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 09:46:11 2022 from MACHINE_IP</span><br></pre></td></tr></table></figure></div>

<p>成功通过ssh完成登录后，我们可以使用<code>whoami</code>命令 来验证当前用户身份是否为–sammie；我们可以使用 <code>ls</code>(list 的缩写)命令 来列出当前目录中的文件，此命令将显示出当前目录中的所有文件，但隐藏文件并不会显示；如果要显示任何文本文件的内容，我们可以使用命令 <code>cat FILENAME</code>，cat是concatenate 的缩写，此命令将在终端屏幕上打印出文本文件的内容。</p>
<p>在下面的终端交互中，我们看到了四个命令的使用情况：<code>ssh</code>、<code>whoami</code>、<code>ls</code> 和 <code>cat</code> 。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@10.20.30.130</span></span><br><span class="line">sammie@10.20.30.130&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 14:45:53 2022 from 10.20.30.1</span><br><span class="line">sammie@beginner-os-security:~$ whoami</span><br><span class="line">sammie</span><br><span class="line">sammie@beginner-os-security:~$ ls</span><br><span class="line">country.txt  draft.md  icon.png  password.txt  profile.jpg</span><br><span class="line">sammie@beginner-os-security:~$ cat draft.md </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Operating System Security</span></span><br><span class="line"></span><br><span class="line">Reusing passwords means that your password for other sites becomes exposed if one service is hacked.</span><br><span class="line">sammie@beginner-os-security:~$</span><br></pre></td></tr></table></figure></div>

<p>接下来，我们将介绍的最后一个命令是 <code>history</code>，此命令将在终端界面打印出用户曾经使用的命令；当你使用<code>history</code>命令之后，也许能在终端输出结果中找到一些敏感信息。</p>
<p>假设我们已经知道了另外两个可以访问目标机器的用户名：</p>
<ul>
<li><em><strong>johnny</strong></em></li>
<li><em><strong>linda</strong></em></li>
</ul>
<p>如果以上两个用户都很少考虑安全性，我们可以使用多种方式来猜测这两个用户的密码，此处我们将列出以下两种情况：</p>
<ul>
<li>如果你未以 sammie用户 或任何其他用户身份完成ssh登录操作，你可以直接使用 <code>ssh johnny@MACHINE_IP</code>命令并手动尝试输入多个密码进行猜测，以查看哪个密码对 johnny用户 有效。</li>
<li>如果你已经以 sammie用户 或任何其他用户身份完成了ssh登录操作，你可以使用 <code>su - johnny</code>命令 来切换用户身份，并手动尝试输入一个又一个密码，以查看哪个密码对 johnny用户 有效。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题：</strong></em></p>
<ol>
<li>根据本文所介绍的Top 7 常用密码，让我们尝试找出 Johnny 的密码，用户 johnny 的密码是什么？</li>
<li>以 Johnny 身份登录后，使用<code>history</code>命令检查 Johnny 曾经键入过的命令，我们发现Johnny错误地把 root 密码当成命令输入过，root密码的内容是什么？</li>
<li>以 Johnny 身份登录后，使用命令 <code>su - root</code> 切换到 root 帐户(并输入root密码通过身份验证)，查看根目录下的flag.txt的内容，flag.txt的内容是什么？</li>
</ol>
<p><em><strong>操作：</strong></em></p>
<p>我们可以使用以下命令针对目标机器进行ssh登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh johnny@10.10.210.242</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">经过登录尝试发现可用密码：abc123</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181721434.png"
                      alt="image-20230322181721434"
                ></p>
<blockquote>
<p>用户 johnny 的密码是：abc123</p>
</blockquote>
<p>成功完成ssh登录后，输入<code>history</code>命令：发现root用户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181911146.png"
                      alt="image-20230322181911146"
                ></p>
<blockquote>
<p>root用户的密码为：happyHack!NG 。</p>
</blockquote>
<p>切换用户身份到root（使用我们刚才找到的密码完成身份验证），以root用户身份查找flag.txt文件 并获取其文本内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322182319042.png"
                      alt="image-20230322182319042"
                ></p>
<blockquote>
<p>flag.txt的内容是：THM{YouGotRoot} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320214350583.png"
                      alt="image-20230320214350583"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Web Application Security(Web应用程序安全介绍)-学习</title>
    <url>/2024/01/16/THM-Web%20Application%20Security(Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introwebapplicationsecurity" >https://tryhackme.com/room/introwebapplicationsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解 Web 应用程序并探索它们的一些常见安全问题</p>
<h2 id="Web应用程序简介"><a href="#Web应用程序简介" class="headerlink" title="Web应用程序简介"></a>Web应用程序简介</h2><p>我们每个人都会在我们的计算机上使用不同的程序。 一般来说，当程序在计算机上运行时，就将使用计算机的处理能力和存储功能，而且，要使用一个程序，我们还需要先安装它。如果我们想不经过安装操作就直接使用程序应该怎么办？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124001893.png"
                      alt="image-20230421124001893"
                ></p>
<p>Web 应用程序类似于普通的“程序”，并且只要我们的计算机上有一个现代的、标准的 Web 浏览器，例如 Firefox、Safari 或 Chrome等，我们就可以不经安装而直接使用Web应用程序——当我们想运行Web应用程序时，我们无需安装 运行时所需的每个程序，只需直接访问相关浏览器页面即可。 </p>
<p>以下是关于 Web 应用程序的一些示例：</p>
<ul>
<li>网络邮件，例如 Tutanota、Protonmail、Outlook 和 Gmail</li>
<li>在线办公套件，如 Microsoft Office 365（Word、Excel 和 PowerPoint）、Google Drive（Docs、Sheets 和 Slides）和 Zoho Office（Writer、Sheet 和 Show）</li>
<li>在线购物网站，例如 Amazon.com、AliExpress 和 Etsy</li>
</ul>
<p>其他示例还包括网上银行、汇款、天气预报和网络社交媒体等，成千上万的Web应用程序提供了数不胜数的在线服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124018938.png"
                      alt="image-20230421124018938"
                ></p>
<p>Web 应用程序的概念是一个在远程服务器上运行的程序，而服务器是指连续运行以“服务”用户客户端的计算机系统，在这种情况下，服务器将运行特定类型的程序，并且这些程序可以通过Web浏览器被访问。</p>
<p>以一个在线购物 Web 应用程序为例，此 Web 应用程序将从数据库服务器中读取有关产品及其详细信息的数据，数据库将用于 以有组织的方式存储信息，在本例中这些数据可能会包括有关产品、客户和发票的信息。（数据库服务器会负责许多功能，包括对数据库进行读取、搜索和写入等操作） </p>
<p>一个在线购物 Web 应用程序在运行时 可能需要访问多个数据库，例如：</p>
<ul>
<li>产品数据库：该数据库包含有关产品的详细信息，例如名称、图像、规格和价格。</li>
<li>客户数据库：该数据库包含与客户相关的所有详细信息，例如姓名、地址、电子邮件和电话号码。</li>
<li>销售数据库：我们希望在这个数据库中看到每个客户购买了什么以及他们是如何支付的。</li>
</ul>
<p>我们已经大概了解了存储在任何在线购物系统中的信息量，假如攻击者设法利用（破解）Web 应用程序并窃取客户的数据库内容，那么这将给公司及相关客户带来重大损失。</p>
<p>下图显示了在Online购物网站上搜索商品可能将发生什么，在最简单的Online购物网站中，搜索商品可能会经历以下四个步骤：</p>
<ol>
<li><p>用户在搜索字段中输入项目名称或相关关键字，Web 浏览器会将被搜索的关键字发送给在线购物 Web 应用程序。</p>
</li>
<li><p>Web 应用程序查询（搜索）产品数据库以查找用户所提交的关键字。</p>
</li>
<li><p>产品数据库将与用户提供的关键字相匹配的搜索结果返回给 Web 应用程序。</p>
</li>
<li><p>Web 应用程序将结果格式化为友好可读的网页页面并将它们返回给用户以供浏览。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224615610.png"
                      alt="image-20230319224615610"
                ></p>
<p>从用户的角度来看，他们只会访问到一个隐藏所有技术基础设施的在线商店页面。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224808863.png"
                      alt="image-20230319224808863" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<blockquote>
<p>Browser - 浏览器</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319213257215.png"
                      alt="image-20230319213257215"
                ></p>
<h2 id="Web-应用程序常见安全风险"><a href="#Web-应用程序常见安全风险" class="headerlink" title="Web 应用程序常见安全风险"></a>Web 应用程序常见安全风险</h2><p>假设你想从网上商店购买商品，你就会希望能够在相关 Web 应用程序上执行某些功能，用户完成一个在线商品订单可能分为以下几个步骤：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319225857754.png"
                      alt="image-20230319225857754"
                ></p>
<p>针对 Web 应用程序的常见攻击有很多，下面简单介绍一些攻击方式：</p>
<ul>
<li><p>在登录网站时：攻击者可以通过进行多次登录尝试来枚举发现有效密码；攻击者能够使用密码字典和一些自动化工具来针对登录页面来进行多次测试。(暴力枚举)</p>
</li>
<li><p>在搜索产品时：攻击者可以通过在搜索字段中添加特定字符和代码来尝试破坏目标系统；攻击者的目的是让目标系统返回它不应该返回的数据或者执行它不应该执行的程序。(注入类攻击)</p>
</li>
<li><p>在提供付款细节时：攻击者会检查 和付款细节相关的数据 是以明文形式发送还是使用了弱加密；加密是指 让数据在不知道密钥或密码的情况下变得不可读。(明文、弱加密)</p>
</li>
</ul>
<p>tips：本小节只介绍一些针对Web应用程序的攻击方式 而并非全部。</p>
<h3 id="身份识别和验证错误"><a href="#身份识别和验证错误" class="headerlink" title="身份识别和验证错误"></a>身份识别和验证错误</h3><p>身份识别(Identification)是指 可以对用户身份进行唯一识别的能力，而身份验证(authentication)是指 可以证明用户实际身份和用户所声称的身份相符合的能力；当用户登录网上商店时，正常情况下：商店必须先识别用户的身份并进行身份验证，然后才能让用户使用该在线购物系统。</p>
<p>如果网站的身份识别和身份验证机制不佳，那么在网站登录界面就可能存在一些漏洞，关于此类漏洞的示例有：</p>
<ul>
<li><p>目标网站允许攻击者使用暴力枚举；攻击者能够尝试多次输入不同密码以进行登录操作——通常攻击者会使用自动化工具来暴力枚举，从而找到有效的登录凭据。</p>
</li>
<li><p>目标网站允许正常用户使用弱密码；弱密码通常很容易被攻击者猜到。</p>
</li>
<li><p>目标网站以明文形式存储用户密码；如果此时攻击者能够设法读取包含密码的文件，那么他们就能够获知存储的密码内容。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319234328832.png"
                      alt="image-20230319234328832"
                ></p>
<h3 id="损坏的访问控制机制"><a href="#损坏的访问控制机制" class="headerlink" title="损坏的访问控制机制"></a>损坏的访问控制机制</h3><p>访问控制(Access control)机制 能够确保每个用户只能访问与其角色或工作相关的文件（文档、图像等）；例如，公司的网站管理员应该不希望市场部的某人能够直接访问（阅读）财务部的文档。</p>
<p>与访问控制相关的示例漏洞包括：</p>
<ul>
<li><p>网站管理员未能应用最小权限原则并为用户提供超出其需要的访问权限；例如，在线客户应该能够查看商品的价格，但他们不应该能够更改商品价格。</p>
</li>
<li><p>攻击者能够使用用户的唯一标识符查看或修改他人的帐户信息；例如，你应该不希望一个银行客户能够查看另一个客户的交易详情。</p>
</li>
<li><p>攻击者能够以未经身份验证的用户身份 浏览需要身份验证（登录）的页面；例如，我们不应该让任何人在登录之前就能查看到网络邮件内容。</p>
</li>
</ul>
<h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><p>注入攻击是指 对 Web 应用程序中的注入类漏洞进行利用，在注入类漏洞存在的情况下：攻击者可以插入恶意代码作为用户输入内容的一部分。</p>
<p>注入类漏洞存在的一个原因是 目标网站缺乏对“用户输入”的适当验证和清理。</p>
<h3 id="未成功加密"><a href="#未成功加密" class="headerlink" title="未成功加密"></a>未成功加密</h3><p>此类漏洞的存在是由于发生了与密码学相关的错误，密码学侧重于数据的加密和解密过程，加密是指 对明文内容使用加密算法计算以得到密文；对于没有密钥解密的人来说，经过加密产生的密文是无法读懂的，换句话说，加密能够确保没有人可以在不知道密钥的情况下直接读取数据，只有使用密钥进行解密 才能将密文转换回原始明文。</p>
<p>未成功加密(加密失败)的例子包括：</p>
<ul>
<li>目标网站以明文形式发送敏感数据，例如，网站使用 HTTP 协议而不是 HTTPS 协议； HTTP 是用于访问 Web 的协议，而 HTTPS 是 HTTP 的安全版本，攻击者可以阅读通过 HTTP 协议发送的所有内容，但不能阅读使用 HTTPS 协议发送的内容。</li>
<li>目标网站依赖弱密码算法进行加密（很容易被破解）；有一种古老的密码算法是将每个字母移位一个，例如，将“TRY HACK ME”变成“USZ IBDL NF”，如果使用这种加密算法就很容易被攻击者破解密文。</li>
<li>目标网站使用默认或弱密钥进行加密；破解使用 1234 作为密钥的加密并不困难，所以如果使用弱密钥加密就很容易被攻击者破解。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124046841.png"
                      alt="image-20230421124046841"
                ></p>
<p><strong>答题</strong></p>
<blockquote>
<p>Identification and Authentication Failure 身份识别和身份验证错误</p>
<p>Cryptographic Failures 未成功加密（加密失败）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319214337998.png"
                      alt="image-20230319214337998"
                ></p>
<h2 id="Web-应用程序安全实例"><a href="#Web-应用程序安全实例" class="headerlink" title="Web 应用程序安全实例"></a>Web 应用程序安全实例</h2><p>本小节将调查一个存在<u>不安全直接对象引用</u> (IDOR漏洞) 的易受攻击的示例网站。</p>
<p>IDOR漏洞属于损坏的访问控制机制的一种，所谓 损坏的访问控制机制 意味着攻击者可以访问不适合他们访问的信息 或者 执行不适合他们执行的操作。</p>
<p>Web 服务器能够接收用户提供的输入以检索对象（文件、数据、文档），这些被检索的对象可能是按顺序编号的；我们假设当前用户有权访问名为 IMG_1003.JPG 的照片，我们可能会猜测 Web服务器上还存在IMG_1002.JPG照片 和 IMG_1004.JPG照片；然而，即使我们已经知道了图像文件的名称，Web 应用程序也不应该向我们提供某些图像。一般来说，如果Web应用程序对“用户输入”的信任度过高，就可能会出现IDOR漏洞，换句话说，此时 Web 应用程序并没有严格验证用户是否有权访问所请求的对象。</p>
<p>即使知道了某个用户或某个产品相关的正确 URL 也不一定意味着当前用户应该能够访问这些 URL（所以这需要我们进行实际的访问验证）。假设我们已经知道某个产品页面的URL： <a class="link"   href="https://store.tryhackme.thm/products/product?id=52" >https://store.tryhackme.thm/products/product?id=52 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ；我们可以期望此 URL 会提供有关编号为 52 的产品详细信息；如果在数据库中，产品数据项是将按顺序分配编号的，那么攻击者就可以尝试使用其他数字 如 51 或 53来取代URL中的 52；一旦目标 Web 应用程序存在IDOR漏洞，那么攻击者就可能会访问到 其他已停用产品或未发布产品的相关页面。</p>
<p>让我们考虑一个更关键的例子(此例基于目标系统存在IDOR漏洞的前提条件下)，假设有一个URL <a class="link"   href="https://store.tryhackme.thm/customers/user?id=16" >https://store.tryhackme.thm/customers/user?id=16 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这个URL将返回 id&#x3D;16 的用户相关页面；同样，我们希望用户所对应的 ID 号是连续的，那么攻击者就可以尝试在URL中使用其他ID号 并可能成功访问到其他用户帐户所相关的页面（进而能够查看到其他用户的敏感信息）。</p>
<p>IDOR漏洞也适用于访问一些按顺序命名并存储的文件；例如，攻击者在URL中看到007.txt，那么可以尝试使用其他文件名称，如001.txt、006.txt等。(此例基于目标系统存在IDOR漏洞的前提条件下)</p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215632445.png"
                      alt="image-20230319215632445" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220131634.png"
                      alt="image-20230319220131634" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220240818.png"
                      alt="image-20230319220240818" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag内容为：THM{IDOR_EXPLORED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215450568.png"
                      alt="image-20230319215450568"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Network Security(网络安全介绍)-学习</title>
    <url>/2024/01/16/THM-Network%20Security(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/intronetworksecurity" >https://tryhackme.com/room/intronetworksecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍网络安全概念，了解基本的网络攻击步骤，并尝试完成一个侵入目标服务器的实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机网络是一组相互连接的计算机和设备，而网络安全则侧重于保护这些设备以及连接它们的链路的安全。（更准确地说，网络安全包括了保护计算机网络及其数据的机密性、完整性和可用性的一切安全设备、安全技术和过程）</p>
<p>网络安全由不同的硬件和软件解决方案组成，以实现既定的安全目标。网络安全的硬件解决方案是指 你在网络中设置的用于保护网络安全的设备，这些设备是硬件，所以你可以在现实中接触到它们。硬件设备可能类似于下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322195255546.png"
                      alt="image-20230322195255546"
                ></p>
<p>网络安全硬件设备的示例包括：</p>
<ul>
<li>防火墙设备：防火墙将根据一组预定义的规则来允许和阻止连接，它将限制什么可以进入网络 和 什么可以离开网络。</li>
<li>入侵检测系统 (IDS) 设备：IDS 会检测系统入侵、网络入侵以及入侵企图，它会尝试检测攻击者侵入你的网络的企图。</li>
<li>入侵防御系统 (IPS) 设备：IPS 可阻止检测到的入侵行为和入侵企图，它旨在防止攻击者闯入你的网络。</li>
<li>虚拟专用网络 (VPN) 集线器设备：VPN 可确保网络流量无法被第三方读取或更改，它保护发送的数据的机密性（secrecy）和完整性。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200053263.png"
                      alt="image-20230322200053263"
                ></p>
<p>另一方面，网络安全也有软件解决方案，常见的例子有：</p>
<ul>
<li>防病毒软件：你可以在计算机或者智能手机上安装防病毒软件以检测恶意文件并阻止它们的执行。</li>
<li>主机防火墙：与防火墙设备（硬件设备）不同，主机防火墙是作为操作系统的一部分而被提供的程序，或者是安装在操作系统上的程序。例如，MS Windows 操作系统中就包含了 Windows Defender 防火墙程序，Apple macOS 中也包含了应用防火墙(application firewal)，以上两者都是主机防火墙。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200919536.png"
                      alt="image-20230322200919536"
                ></p>
<p>根据 IBM Security 发布的<a class="link"   href="https://newsroom.ibm.com/2021-07-28-IBM-Report-Cost-of-a-Data-Breach-Hits-Record-High-During-Pandemic" >《2021 年数据泄露成本报告》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，2021 年数据泄露平均每起事件给公司造成 424 万美元的损失，而 2020 年为 386 万美元，平均成本因行业和国家&#x2F;地区而异。 例如，医疗行业数据泄露的平均总成本为 923 万美元，而教育行业则为 379 万美元。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>Windows Defender 防火墙是什么类型的防火墙：Host Firewall</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215249669.png"
                      alt="image-20230320215249669"
                ></p>
<h2 id="网络攻击步骤介绍"><a href="#网络攻击步骤介绍" class="headerlink" title="网络攻击步骤介绍"></a>网络攻击步骤介绍</h2><p>每个“操作”的执行 都需要拥有某种形式的计划才能最终取得成功。假如你对野生动物摄影感兴趣，除非你完全不在乎结果，否则你不能只是拿起相机就直接前往丛林进行摄影，为了安全、成功地进行野生动物摄影之旅，你往往需要更多地去了解你想要用相机拍摄的动物(这包括动物的习性和你要避免的危险)；以上例子同样适用于针对目标网络进行攻击的网络安全行动。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322201637351.png"
                      alt="image-20230322201637351"
                ></p>
<p>闯入目标网络通常包括多个步骤，根据<a class="link"   href="https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html" >洛克希德·马丁公司 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的说法，网络杀伤链有七个步骤：</p>
<ol>
<li>Recon(侦察)：Recon，是reconnaissance(侦察)的缩写，指的是攻击者将在此阶段 试图尽可能多地了解目标，主要包括——目标的服务器类型、操作系统、IP 地址、用户名和电子邮件地址等信息，获取到这些信息将有利于网络攻击成功。</li>
<li>Weaponization(武器化(：这一步是指准备一个带有恶意组件的文件，例如，相关恶意组件能够为攻击者提供远程访问。</li>
<li>Delivery(投递)：投递是指通过任何可行的方式将“武器化”的文件投递给目标，例如通过电子邮件或者U盘进行投递。</li>
<li>Exploitation(利用)：当用户打开（攻击者所投递的）恶意文件时，用户所使用的系统就会执行恶意组件。</li>
<li>Installation(安装)：经过上一步的恶意组件执行之后，目标系统就会被安装上恶意软件。</li>
<li>Command &amp; Control(命令与控制-C2)：恶意软件的成功安装会为攻击者提供对目标系统的命令和控制能力。</li>
<li>Actions on Objectives(针对目标的行动)：在获得对一个目标系统的控制权后，攻击者就能够达到他们的行动目标，关于行动目标的示例：数据泄露（一旦成功窃取到了目标系统的数据，即代表攻击者达到行动目标）。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322204848872.png"
                      alt="image-20230322204848872" style="zoom:67%;" 
                >

<p>关于网络攻击步骤的另一个类比是：对目标房屋感兴趣的小偷。小偷在开始行动之前，往往会花一些时间了解目标房屋，谁住在那里，他们什么时候离开以及什么时候回家，小偷还会确定目标房屋是否有安装安全摄像头以及警报系统，一旦收集到足够的信息，小偷就会制定最佳的进入策略。关于物理盗窃的计划和执行在某种程度上也类似于旨在闯入网络并窃取数据的恶意攻击行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/a8e61f1f9a2ea3612d3bf84f9a11f41c.png"
                      alt="a8e61f1f9a2ea3612d3bf84f9a11f41c" 
                >

<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>攻击者在网络杀伤链的哪一步收集有关目标的信息：Recon (侦察)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215635939.png"
                      alt="image-20230320215635939"
                ></p>
<h2 id="网络安全实例"><a href="#网络安全实例" class="headerlink" title="网络安全实例"></a>网络安全实例</h2><p>在本小节的实例中，我们将尝试侵入目标 Linux 系统。</p>
<p>我们攻击的第一步是侦察；我们可以使用不同的工具来加快我们的侦察活动，这些工具将收集与目标相关的各个方面的信息。</p>
<p>为了简单起见，我们将在此使用Nmap工具，Nmap是 Network Mapper 的缩写，它是一个网络扫描器，可以帮助我们发现正在运行的机器（存活主机）以及在这些机器上运行的任何对外界可见的程序（计算机服务）。我们可以通过在终端提示符下运行 <code>nmap MACHINE_IP</code>命令来扫描目标IP：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tips：在实际执行命令时，我们直接用目标ip地址代替下面命令中的MACHINE_IP。</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">nmap MACHINE_IP</span></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-06 17:38 EEST</span><br><span class="line">Nmap scan report for MACHINE_IP</span><br><span class="line">Host is up (0.00024s latency).</span><br><span class="line">Not shown: 997 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">21/tcp open  ftp</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.33 seconds</span><br></pre></td></tr></table></figure></div>

<p>我们发现了三个服务正在运行：</p>
<ol>
<li>FTP 服务器：FTP 代表文件传输协议，用于在机器之间传输文件。</li>
<li>SSH 服务器：SSH 代表 Secure Shell，用于安全远程登录，换句话说，它允许你在远程系统上安全地执行命令。</li>
<li>HTTP 服务器：HTTP 代表超文本传输协议，用于web服务，每当你在网站上浏览网页时，你都在使用 HTTP协议 或 HTTPS协议，HTTPS 是 HTTP 的安全（加密）版本。</li>
</ol>
<p>你还可以注意到 Nmap 会根据主机是否收到任何响应来报告主机是否已启动（存活），这有助于我们知道什么时候目标机器将显示没有端口打开或者显示没有端口可访问。</p>
<p>让我们尝试收集有关 FTP 服务器的更多信息：</p>
<ol>
<li>我们将在 AttackBox 的终端中输入 <code>ftp MACHINE_IP</code> 命令来连接到目标的 FTP 服务器。</li>
<li>接下来我们尝试使用login anonymous登录，看看这个FTP服务器是否支持匿名登录。</li>
<li>成功完成匿名登录之后，我们可以尝试使用命令 ls（list的缩写）来查看可用的文件，我们能得到文件名列表及文件的详细信息。</li>
<li>如果你对所发现的任何文件感到好奇，可以使用 <code>get filename</code> 命令来进行下载，比如我想知道 secret.txt 文件包含什么，所以使用 <code>get secret.txt</code> 命令来进行文件下载。</li>
<li>成功下载文件之后，键入 <code>exit</code> 或 <code>bye</code> 即可退出 FTP 客户端。</li>
</ol>
<p>与目标FTP服务器的交互过程将如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ftp MACHINE_IP</span></span><br><span class="line">Connected to MACHINE_IP (MACHINE_IP).</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (MACHINE_IP:root): anonymous</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">227 Entering Passive Mode (10,20,30,130,181,190).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 ftp      ftp        425351 Apr 06 11:22 2680-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           356 Apr 06 11:22 2680.epub</span><br><span class="line">-rw-r--r--    1 ftp      ftp        251857 Apr 06 11:22 55317-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           358 Apr 06 11:22 55317.epub</span><br><span class="line">-rwxr-xr-x    1 ftp      ftp           214 Apr 06 11:22 backup.sh</span><br><span class="line">-rw-r--r--    1 ftp      ftp            23 Apr 06 11:22 secret.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">get secret.txt</span> </span><br><span class="line">local: secret.txt remote: secret.txt</span><br><span class="line">227 Entering Passive Mode (10,20,30,130,159,46).</span><br><span class="line">150 Opening BINARY mode data connection for secret.txt (23 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">23 bytes received in 0.00107 secs (21.48 Kbytes/sec)</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">221 Goodbye.</span><br></pre></td></tr></table></figure></div>

<p>我们注意到上述FTP服务器中一共有六个文件：三个 txt 文件、两个 epub 文件和一个 sh 文件。txt和epub扩展名分别用于文本文件和电子书文件，而 sh 扩展名则表示该文件是一个 shell 脚本，shell 脚本通常会包含一组需要重复执行的命令。</p>
<p>在我们使用 FTP 命令 <code>get secret.txt</code>下载文件secret.txt 并使用<code>exit</code>退出 FTP 客户端之后，我们就会返回到攻击机的终端界面；此时我们可以在攻击机的终端界面中使用<code>cat secret.txt</code>命令来显示 secret.txt 文件的文本内容。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> secret.txt</span> </span><br><span class="line">password: [redacted]   #实际上这行会显示密码信息，此处的redacted表示隐藏（相当于马赛克）的意思</span><br></pre></td></tr></table></figure></div>

<p>我们得到了一个无意中复制到公共 FTP 服务器上的账户密码明文，让我们试试看它是否适用于 root 帐户（root账户在Linux系统上拥有完全的权限，可以读写任何文件，能够安装和删除任何程序）。在攻击机终端界面，我们可以输入 <code>ssh root@MACHINE_IP</code>来进行ssh登录，随后我们将被要求输入root账号的密码以进行身份验证，我们直接尝试输入我们在 FTP 服务器上发现的密码明文即可。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ssh root@MACHINE_IP</span></span><br><span class="line">root@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-107-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Thu  7 Apr 08:16:42 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.15              Processes:              225</span><br><span class="line">  Usage of /:   64.6% of 6.53GB   Users logged in:        0</span><br><span class="line">  Memory usage: 19%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Thu Apr  7 07:53:28 2022 from 10.10.10.1</span><br></pre></td></tr></table></figure></div>

<p>以 root 身份完成ssh登录后，我们就可以完全控制目标服务器了，为了查找目标文件 我们可以使用以下 Linux 命令：</p>
<ol>
<li>使用<code>pwd</code>命令，pwd是print working directory 的缩写，此命令可用来查看我们在系统中的当前位置。</li>
<li>使用<code>ls</code>命令来列出文件信息，查看文件列表中有无目标文件。</li>
<li>使用<code>cat flag.txt</code>命令来查看文件内容。</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt  snap</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p>因为我们以 root 身份完成了登录，所以我们可以完全访问所有文件，包括其他用户的文件，我们可以执行以下 Linux 命令进行探索：</p>
<ol>
<li><p>使用<code>cd /home</code> 命令转到包含所有用户主目录的目录吗，cd 是 change directory（更改目录）的缩写。</p>
</li>
<li><p>我们在&#x2F;home目录中运行<code>ls</code>命令，查看系统的所有用户名称，因为我们拥有系统管理员（root）权限，所以我们可以直接检查其他用户的主文件夹下的内容。</p>
</li>
<li><p>使用<code>cd librarian</code>命令进入用户librarian的目录。</p>
</li>
<li><p>使用 <code>pwd</code> 命令以查看我们在系统中的当前位置（ &#x2F;home&#x2F;librarian）。</p>
</li>
<li><p>使用<code>ls</code>命令显示 librarian 目录下的文件信息，查看文件列表中有无目标文件。</p>
</li>
<li><p>我们可以使用<code>cat flag.txt</code>命令打印文本文件内容到终端界面。</p>
</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> /home</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">ftpsecure  librarian  strategos</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> librarian/</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/librarian</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/a708c20aa1243c8e2be30bb9e74bd663.png"
                      alt="img"
                ></p>
<p>让我们总结一下我们在本小节中的工作，我们的目标是获取 IP 地址为MACHINE_IP的目标系统的root访问权限：</p>
<ol>
<li>我们使用 nmap 来了解目标机器正在运行的服务。</li>
<li>我们连接到目标机的 FTP 服务器以了解有关其配置的更多信息。</li>
<li>我们发现一个包含root密码的文件被错误地复制到了FTP服务器中的公共文件夹下。</li>
<li>我们使用找到的密码，以root用户身份来进行ssh登录。</li>
<li>最终，我们获得了所有用户文件的访问权限（因为此时的用户身份为root）。</li>
</ol>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题</strong></em></p>
<ol>
<li>secret.txt文件内容中的密码是什么？</li>
<li>&#x2F;root目录中的flag.txt文件内容是什么？</li>
<li>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是什么？</li>
</ol>
<p><em><strong>操作</strong></em></p>
<p>使用nmap进行端口扫描：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -sC -T4 10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221312517.png"
                      alt="image-20230322221312517"
                ></p>
<blockquote>
<p>目标机器上存在FTP服务且允许进行匿名登录</p>
</blockquote>
<p>针对目标机的ftp服务进行匿名登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ftp 10.10.98.42</span><br><span class="line">anonymous</span><br><span class="line">ls</span><br><span class="line">get secret.txt </span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221546534.png"
                      alt="image-20230322221546534"
                ></p>
<p>下载完敏感文件后，在攻击机终端查看到该文件内容为root用户的密码明文，所以我们基于已知密码 直接尝试以root用户身份进行ssh登录：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat secret.txt #password: ABC789xyz123</span><br><span class="line"></span><br><span class="line">ssh root@10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221617429.png"
                      alt="image-20230322221617429"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221757084.png"
                      alt="image-20230322221757084"
                ></p>
<blockquote>
<p>secret.txt文件内容中的密码是：ABC789xyz123 。</p>
</blockquote>
<p>成功完成ssh登录成功后，我们获得了root权限，接下来我们将查找目标系统上的目标文本文件并查看相关的文本内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br><span class="line"></span><br><span class="line">cd /home</span><br><span class="line">ls</span><br><span class="line">cd /home/librarian/</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322222032954.png"
                      alt="image-20230322222032954"
                ></p>
<blockquote>
<p>&#x2F;root目录中的flag.txt文件内容是：THM{FTP_SERVER_OWNED} 。</p>
<p>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是：THM{LIBRARIAN_ACCOUNT_COMPROMISED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215901969.png"
                      alt="image-20230320215901969"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Digital Forensics(数字取证介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Digital%20Forensics(%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introdigitalforensics" >https://tryhackme.com/room/introdigitalforensics <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数字取证及其相关流程，并完成相关的简单实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232751118.png"
                      alt="image-20230322232751118"
                ></p>
<p>考虑以下场景——执法人员到达了犯罪现场，然而，这个犯罪现场的一部分包括了数字设备和数字媒体；数字设备包括台式电脑、笔记本电脑、数码相机、音乐播放器和智能手机等，而数字媒体则包括 CD、DVD、USB 闪存驱动器和外部存储设备。这就引出了以下几个问题：</p>
<ul>
<li>警方应如何收集智能手机和笔记本电脑等设备中的数字证据？ 如果计算机和智能手机正在运行，应遵循哪些工作程序进行处理？</li>
<li>如何传输数字证据？例如，在移动计算机时是否有某些最佳实践方案可以遵循？</li>
<li>如何分析收集到的数字证据？个人设备的数据存储量可能在数十 GB 到数 TB 之间，应该如何进行分析？</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232730081.png"
                      alt="image-20230322232730081"
                ></p>
<p>假设嫌疑人拥有如上图所示的可疑数字设备和可疑数字媒体，我们可以进行快速查看并调查一些可能存有关键证据的数字设备、媒体；除了台式电脑之外，我们还注意到嫌疑人桌面上有平板电脑、智能手机、数码相机和 USB 闪存驱动器，这些设备及媒体中的任何一个都可能包含有助于案件调查的大量信息，执法者为了将这些设备作为证据进行处理 就需要用到数字取证技术。</p>
<p>更正式地说，数字取证就是应用计算机科学为达到法律目的而对数字证据展开调查。数字取证可用于进行以下两种类型的调查：</p>
<ol>
<li>公共部门调查，是指由政府和执法机构开展的调查，他们将参与犯罪调查或者民事调查。</li>
<li>私营部门调查，是指公司机构通过指派私人调查员进行的调查，无论是内部调查还是外包调查，它们都是由违反公司政策的行为而引发的调查。</li>
</ol>
<p>无论是调查犯罪行为还是调查违反公司政策的行为，部分证据都可能会与数字设备和数字媒体有关，这就是数字取证技术发挥作用并试图确定到底发生了什么的地方，没有训练有素的数字取证调查员的辛勤工作，就不可能正确地处理任何数字证据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232853397.png"
                      alt="image-20230322232853397"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320220915406.png"
                      alt="image-20230320220915406"
                ></p>
<h2 id="数字取证流程"><a href="#数字取证流程" class="headerlink" title="数字取证流程"></a>数字取证流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322234317128.png"
                      alt="image-20230322234317128"
                ></p>
<p>假如你是一名数字取证调查员，你可能会看到与上图所示场景相类似的现场情况，为了扮演好数字取证调查员的角色，你接下来应该做什么？在获得适当的合法授权后，进行数字取证的基本计划如下：</p>
<ol>
<li><p>获取证据：收集可疑的笔记本电脑、存储设备、数码相机等数字设备。（注意：当笔记本电脑和计算机在打开状态时 需要进行特殊处理，但本文在此不做深入介绍）</p>
</li>
<li><p>建立监管链(Establish a chain of custody)：适当填写相关表格（可基于<a class="link"   href="https://www.nist.gov/document/sample-chain-custody-formdocx" >表格样本 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），这一步的目的是要确保只有经过授权的调查人员才能访问数字证据，以保证没有其他人可以篡改证据。</p>
</li>
<li><p>将证据放在安全的容器中：你要确保数字证据不被损坏，对于智能手机而言，你需要确保它们无法访问网络，以免被其他人远程擦除数据。</p>
</li>
<li><p>将证据传送到你的数字取证实验室。</p>
</li>
</ol>
<p>在数字取证实验室中，相关的操作过程如下：</p>
<ol>
<li><p>从安全容器中检索数字证据。</p>
</li>
<li><p>创建证据的取证副本：取证副本需要使用高级软件进行创建 以避免修改原始数据。</p>
</li>
<li><p>将数字证据返回到安全容器：之后你将处理取证副本，如果你不小心损坏了取证副本，你可以随时再创建一个新副本。</p>
</li>
<li><p>在取证工作站上处理取证副本。</p>
</li>
</ol>
<p>以上步骤改编自<a class="link"   href="https://www.cengageasia.com/TitleDetails/isbn/9781337568944" >《计算机取证和调查指南》第 6 版 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>简而言之，进行数字取证时要注意以下几点：</p>
<ul>
<li><p>适当的搜查权限：调查人员不能在没有适当的法律权限的情况下 开始进行数字取证操作。</p>
</li>
<li><p>监管链：这对于随时跟踪谁在持有数字证据是必要的。</p>
</li>
<li><p>数学验证：通过使用一种特殊的数学函数，该函数称为散列（hash-哈希）函数，我们可以确认原数字文件未被修改。</p>
</li>
<li><p>使用经过验证的工具：应对数字取证中使用的工具进行验证，以确保它们能够正常工作；例如，如果你正在创建磁盘映像，你希望能够确保 最终得到的取证映像与磁盘上的原数据相同。</p>
</li>
<li><p>可重复性：只要具备适当的技能和工具，就可以复制数字取证的结果。</p>
</li>
<li><p>报告：数字取证调查以一份报告结束，该报告将显示与所发现案件相关的证据。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322235500854.png"
                      alt="image-20230322235500854"
                ></p>
<h2 id="数字取证的简单实例"><a href="#数字取证的简单实例" class="headerlink" title="数字取证的简单实例"></a>数字取证的简单实例</h2><p>我们在数字设备上所做的一切，从智能手机到电脑，都会留下痕迹，让我们看看我们如何在后续调查中使用它。</p>
<p>本小节实例场景介绍：我们的猫Gado被绑架了，绑架者向我们发送了一份包含他们要求的 MS Word 文档格式的文档；为了方便起见，我们已将相关文档转换为了 PDF 格式并从 MS Word 文件中提取出了图像；我们接下来要对 目标pdf文件 以及 目标jpg文件 进行简单的数字取证分析。</p>
<p>你可以通过使用TryHackMe中和本文相关的实验房间页面–下载附件到你的本地机器上进行检查；或者直接打开 在对应实验房间页面所部署的 AttackBox 上的终端，然后转到目录 &#x2F;root&#x2F;Rooms&#x2F;introdigitalforensics 进行文件检查。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用TryHackMe所提供的AttackBox上的终端</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> /root/Rooms</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> introdigitalforensics</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">letter-image.jpg  ransom-letter.doc  ransom-letter.pdf  ransom-lettter-2.zip</span><br></pre></td></tr></table></figure></div>

<p><strong>文档元数据</strong></p>
<p>当你创建简单的文本文件 TXT 时，操作系统会自动保存一些元数据，例如文件创建日期和上次修改日期；而当你使用更高级的编辑器（例如 MS Word）进行文件创建时，会有更多的信息被保留在文件的元数据中。 有多种读取文件元数据的方法，你可以使用一些官方查看器&#x2F;编辑器打开文件读取元数据 或者 选择使用合适的取证工具对文件进行元数据读取，请注意，如果你将原始文件导出为其他格式如 PDF 格式，则将保留原始文档的大部分元数据，这具体取决于你所使用的 PDF 编辑器。</p>
<p> 如果我们要从PDF 文件中获取信息，我们可以尝试使用 <em><strong>pdfinfo</strong></em>工具 来读取pdf文件的元数据。使用 <em><strong>pdfinfo</strong></em> 会显示与 PDF 文件相关的各种元数据，例如标题、主题、作者、创建者和创建日期。 （如果你使用的是 Kali Linux 并且没有安装 <em><strong>pdfinfo</strong></em>，则可用 <code>sudo apt install poppler-utils</code> 命令来进行安装）</p>
<p>以下为使用<code>pdfinfo DOCUMENT.pdf</code>命令的示例。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">pdfinfo DOCUMENT.pdf</span> </span><br><span class="line">Creator:        Microsoft® Word for Office 365</span><br><span class="line">Producer:       Microsoft® Word for Office 365</span><br><span class="line">CreationDate:   Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">ModDate:        Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">Tagged:         yes</span><br><span class="line">UserProperties: no</span><br><span class="line">Suspects:       no</span><br><span class="line">Form:           none</span><br><span class="line">JavaScript:     no</span><br><span class="line">Pages:          20</span><br><span class="line">Encrypted:      no</span><br><span class="line">Page size:      595.32 x 841.92 pts (A4)</span><br><span class="line">Page rot:       0</span><br><span class="line">File size:      560362 bytes</span><br><span class="line">Optimized:      no</span><br><span class="line">PDF version:    1.7</span><br></pre></td></tr></table></figure></div>

<p>以上 PDF 元数据清楚地表明它是在 2018 年 10 月 10 日使用 MS Word for Office 365 创建的。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 pdfinfo，找出和本实验房间页面所提供的pdf附件相关的作者信息。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/Rooms</span><br><span class="line">cd introdigitalforensics</span><br><span class="line">ls</span><br><span class="line">pdfinfo ransom-letter.pdf</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180941729.png"
                      alt="image-20230323180941729"
                ></p>
<blockquote>
<p>目标pdf文件作者是：Ann Gree Shepherd</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323172932309.png"
                      alt="image-20230323172932309"
                ></p>
<p><strong>照片 EXIF 数据</strong></p>
<p>EXIF 代表 可交换图像文件格式(Exchangeable Image File Format)，它是将元数据保存到图像文件的标准。每当你使用智能手机或数码相机拍照时，图像中都会嵌入大量信息，以下是可以在原始数字图像中找到的元数据示例：</p>
<ul>
<li>相机型号&#x2F;智能手机型号</li>
<li>拍摄图像的日期和时间</li>
<li>照片设置，例如焦距、光圈、快门速度和 ISO 设置等</li>
</ul>
<p>由于智能手机可能配备了 GPS 传感器，因此也很有可能通过照片找到嵌入在图像中的 GPS 坐标(GPS 坐标，即纬度和经度)，这通常会暴露出照片的拍摄地点。</p>
<p>有许多在线和离线工具可以从图像中读取 EXIF 数据，比如命令行工具 <code>exiftool</code> ，<code>exiftool</code> 可用于读取和写入各种文件类型（例如 JPEG 图像）中的元数据。 （如果你使用的攻击机是Kali Linux 并且没有安装 <code>exiftool</code>，则可以输入 <code>sudo apt install libimage-exiftool-perl</code> 命令安装<code>exiftool</code>）</p>
<p>只要执行简单的 <code>exiftool IMAGE</code>命令，就能读取嵌入到图像文件中的所有 EXIF 数据：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">exiftool IMAGE.jpg</span></span><br><span class="line">[...]</span><br><span class="line">GPS Position : 51 deg 31&#x27; 4.00&quot; N, 0 deg 5&#x27; 48.30&quot; W</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></div>

<p>如果我们通过在线地图搜索上述得到的坐标位置，则将了解有关照片拍摄位置的更多信息。我们可以在 <a class="link"   href="https://www.bing.com/maps" >Microsoft Bing 地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或者 <a class="link"   href="https://www.google.com/maps" >谷歌地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上搜索 51° 31’ 4.00” N，0° 5’ 48.30” W ，我们会发现这些坐标将表明 目标照片是在一个非常靠近伦敦博物馆的地方拍摄的（我们用 ° 替换 deg，以便我们使用地图搜索），同时，我们还能注意到 以上坐标在搜索页面上会被转换为十进制表示——51.517776,-0.09675 。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 exiftool 或任何类似工具，尝试找到 和本实验房间页面所提供的图像附件相关的街道名称。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">exiftool letter-image.jpg | grep GPS</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323181841107.png"
                      alt="image-20230323181841107"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180223367.png"
                      alt="image-20230323180223367"
                ></p>
<blockquote>
<p>从 exiftool 获得的 GPS 坐标是 51 deg 30’ 51.90” N，0 deg 5’ 38.73” W （在使用地图检索时，请用 ° 替换 deg 并在搜索前 删除数字和 ° 符号之间的空格）。</p>
<p>最终我们将使用在线地图搜索以下坐标：51°30’51.9”N 0°05’38.7”W</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175531086.png"
                      alt="image-20230323175531086"
                ></p>
<p><em>问题：继续分析以上图像附件，拍摄目标照片所用的相机型号名称是什么？(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">要仅显示带有单词“Camera”的行，可以使用 exiftool PHOTO.jpg | grep Camera 命令</span></span><br><span class="line">exiftool letter-image.jpg | grep Camera</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323182006160.png"
                      alt="image-20230323182006160"
                ></p>
<blockquote>
<p>拍摄目标照片所用的相机型号名称为：Canon EOS R6</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175540323.png"
                      alt="image-20230323175540323"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Security Operations(安全运营介绍)-学习</title>
    <url>/2024/01/16/THM-Security%20Operations(%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/securityoperations" >https://tryhackme.com/room/securityoperations <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解安全运营中心(SOC)的相关职责、服务和数据来源。</p>
<h2 id="安全运营简介"><a href="#安全运营简介" class="headerlink" title="安全运营简介"></a>安全运营简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/47bec18ccc60451eda390ef07b4daf54.png"
                      alt="An image showing a Security Operations Center: a team of IT security professionals tasked with monitoring a company&#39;s network and systems."
                ></p>
<p>安全运营中心 (SOC) 是一类 IT 安全专业人员团队，负责每周 7 天、每天 24 小时监控公司的网络和系统，他们监控的目的是：</p>
<ul>
<li><p>查找网络上的漏洞（Find vulnerabilities on the network）：漏洞可以被攻击者利用，以执行超出许可级别的操作，在网络上的任何设备（操作系统和程序）中都可能发现漏洞，包括服务器设备或计算机设备等；在现实情况中，SOC 可能会发现一组必须针对已发布的特定漏洞进行修补的 MS Windows 计算机。严格来说，查找并发现漏洞不一定是 SOC 的责任范畴，但是，未修复的漏洞肯定会影响整个公司的安全级别。</p>
</li>
<li><p>检测未经授权的活动（Detect unauthorized activity）：例如，攻击者发现了某个员工的用户名和密码并使用这些凭据登录到公司系统——这就是一种未经过授权的活动，而在攻击者造成任何损害之前快速检测到未经授权的活动至关重要；有许多线索可以帮助我们检测到发生了未经授权的活动，例如登录ip所对应的地理位置异常等。</p>
</li>
<li><p>发现策略违规（Discover policy violations）：安全策略是一组规则和程序，旨在保护公司免受安全威胁并确保公司数据的合规性，什么行为被视为违规因公司而异，比如：下载盗版媒体文件、不安全地发送公司机密文件等行为。</p>
</li>
<li><p>检测入侵（Detect intrusions）：入侵是指针对系统和网络进行攻击或窃密的行为，例如攻击者对目标Web 应用程序进行漏洞利用，或者攻击者诱导用户访问恶意站点并感染用户计算机等。</p>
</li>
<li><p>支持事件响应（Support with the incident response）：此处的事件指的是安全事件，事件可以是策略违规、攻击入侵企图或者其他更具破坏性的网络攻击行为，例如发现了某个重大漏洞正在被攻击者利用；正确应对严重安全事件并非易事，而SOC 可以支持事件响应团队更好地处理安全事件。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<blockquote>
<p>SOC代表：Security Operations Center（安全运营中心）</p>
<p>SOC每天监控网络多少小时：24</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222314909.png"
                      alt="image-20230320222314909"
                ></p>
<h2 id="安全运营的要素"><a href="#安全运营的要素" class="headerlink" title="安全运营的要素"></a>安全运营的要素</h2><p>在本小节中，我们将讨论：</p>
<ul>
<li>SOC 所依赖的示例数据源。</li>
<li>SOC 所提供的服务。</li>
<li>一个示例场景。</li>
</ul>
<p><strong>数据源（Data Sources）</strong></p>
<p>SOC 将通过多种数据源来监控网络环境中是否存在入侵迹象并检测任何恶意行为，其中一些数据来源是：</p>
<ul>
<li>服务器日志：网络上有多种类型的服务器，例如邮件服务器、Web 服务器和 MS Windows 网络上的域控制器等，日志会包含有关各种活动的信息，例如成功和失败的登录尝试等；在服务器日志中，我们可以找到大量和服务器相关的活动信息。</li>
<li>DNS 活动：DNS 代表域名系统，它是负责将域名（例如 tryhackme.com）转换为 IP 地址（例如 10.3.13.37）的协议，同时也支持其他与域名相关的查询；DNS 查询的一个类比是 用户询问“我怎样才能到达 TryHackMe？” 然后就会有人回复一个对应的邮政地址。在实际情况中，如果有人试图浏览 tryhackme.com，DNS 服务器就会对这个域名进行解析，并会将相关的 DNS 查询记录到监控中；SOC 可以仅通过检查 DNS 查询记录来收集有关内部系统尝试与之进行通信的域名的信息。 </li>
<li>防火墙日志：防火墙是一种控制网络数据包进出网络的设备，主要通过放行数据包或者阻断数据包来进行控制流量；因此，防火墙日志可以揭示 有关哪些数据包通过了或者试图通过防火墙的相关大量信息。</li>
<li>DHCP 日志：DHCP 代表的是动态主机配置协议，它主要负责 为尝试连接到某个指定网络的计算机系统分配 IP 地址。DHCP 请求的一个类比是 当你进入一家高级餐厅时，服务员会说欢迎你并引导你到一张空桌子处；使用了DHCP协议后，你无需手动配置即可尝试让你的电脑加入某个网络，因为DHCP 会自动为你的设备提供 加入网络所需的网络设置。通过检查 DHCP 事务，SOC 就可以了解加入到某个指定网络的设备的信息。</li>
</ul>
<p>以上只是一些最常见的数据源，另外还有许多其他资源可用于帮助完善网络安全监控 以及 有利于 SOC 完成其他工作任务；SOC 可能还会使用 安全信息和事件管理系统 (SIEM-Security Information and Event Management) 来开展工作， SIEM 会聚合来自于不同来源的数据信息，以便于 SOC 可以有效地关联数据并响应攻击事件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/ff0d15f07e9889f26931fa5665a4c871.png"
                      alt="img"
                ></p>
<p><strong>SOC服务（SOC Services）</strong></p>
<p>SOC 服务可分为反应式服务和主动式服务。</p>
<p>反应式服务是指在检测到入侵或恶意事件后启动的任务，包括以下示例：</p>
<ul>
<li>监控安全态势：这是 SOC 的主要职责，它包括监控网络和计算机的相关安全警报、安全通知，并根据需要做出及时响应。</li>
<li>漏洞管理：这是指发现公司系统中的漏洞并修补（修复）它们，SOC 可以协助完成这项任务，但不一定要亲自执行它。</li>
<li>恶意软件分析：SOC 可能需要获取网络中的恶意程序，SOC 可以通过在受控环境中执行恶意程序来进行基本的恶意软件分析，但是，更高级的分析需要由其他专门的安全团队来完成。</li>
<li>入侵检测：入侵检测系统 (IDS) 可用于检测和记录入侵行为和一些可疑数据包，而SOC 的工作就是维护这样一个系统，监控其警报，并根据需要检查其日志。</li>
<li>报告：报告安全事件和警报至关重要，及时进行报告 对于确保工作流程顺畅和支持合规性要求是必要的措施。</li>
</ul>
<p>主动式服务是指在没有任何入侵迹象的情况下由 SOC 处理的任务，需要 SOC 执行的主动服务示例包括：</p>
<ul>
<li><p>网络安全监控（NSM-Network security monitoring）：侧重于监控网络数据和分析流量以检测是否存在入侵迹象。</p>
</li>
<li><p>威胁搜寻：威胁搜寻指的是 SOC 先假定入侵行为已经发生 然后再进行验证，SOC会通过搜寻网络安全威胁 以明确某种入侵行为是否存在。</p>
</li>
<li><p>威胁情报：威胁情报侧重于了解潜在的攻击者及其攻击策略、攻击技术，从而提高公司的防御能力。收集威胁情报的目的是为了建立威胁知情防御。</p>
</li>
</ul>
<p>除了以上服务外，SOC 提供的其他服务还包括网络安全培训，该服务将帮助提高用户的安全意识并为用户提供扎实的安全培训，这可以避免发生过多的数据泄露事件以及网络入侵行为。</p>
<p><strong>示例场景（Example Scenario）</strong></p>
<p>SOC 中有一个角色是 SOC 分析师，SOC 分析师主要负责网络安全监控和日志管理。 </p>
<p>让我们考虑以下场景：在监控网络流量时，SOC 分析师注意到 当前受监控的网络环境中 存在每分钟重复一次的特定 DNS 查询行为，这种行为并不像是用户在正常浏览网络。</p>
<p>SOC 分析师可能的应对流程如下：</p>
<ol>
<li><p>SOC 分析师检查 DNS 查询的来源并将源头确定为网络上的一台笔记本电脑。</p>
</li>
<li><p>SOC 分析师将这台笔记本隔离并检查该机器是否有感染迹象，结果发现该机器上有一个进程（程序）正在使用 DNS 与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师通过查看计算机日志发现该计算机是在访问恶意网站后被感染的，这种感染的结果是：受害计算机通过将消息隐藏在 DNS 查询中来与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师将这台笔记本电脑清理干净，并开始进行威胁搜寻以确保没有其他计算机被感染。</p>
</li>
</ol>
<p><strong>答题</strong></p>
<blockquote>
<p>NSM代表：Network security monitoring（网络安全监控）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322231522117.png"
                      alt="image-20230322231522117"
                ></p>
<h2 id="关于SOC的实例"><a href="#关于SOC的实例" class="headerlink" title="关于SOC的实例"></a>关于SOC的实例</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/4d68ffe73a45b4974a36d0947d4b27d8.png"
                      alt="img"
                ></p>
<p>防火墙是一种检查进入和离开网络或系统的网络数据包的设备，我们可以使用防火墙来阻止一些正在进行的网络攻击，最基本的防火墙检查类型包括：</p>
<ul>
<li><p>源 IP 地址和目标 IP 地址：IP 地址是允许你通过 Internet 进行通信的逻辑地址。你可以把 IP 地址类比为邮政地址，例如，一家公司需要使用一个有效的邮政地址来发送和接收包裹，你可以进而将 IP 数据包想象成一个邮递包裹。</p>
</li>
<li><p>源端口号和目标端口号（在适用的情况下）：一台计算机有一个 IP 地址，此外，计算机上的每个程序还需要一个对应的端口号才能通过网络进行通信。你可以把端口号类比为一家公司内的房间号。</p>
</li>
</ul>
<p>基本的防火墙规则可能类似于以下内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">源IP地址     目标IP地址    源端口 目标端口  操作</span><br><span class="line"></span><br><span class="line">172.16.4.1  10.10.10.41   ANY    80      PASS（通过）</span><br><span class="line">172.16.8.1  10.10.10.81   ANY    23      DROP（丢弃）</span><br></pre></td></tr></table></figure></div>

<p>以上两条规则规定了以下内容：</p>
<ul>
<li>所有从源 IP 地址 172.16.4.1 到目标 IP 地址 10.10.10.41 并且到目标端口号 80 的 IP 数据包都会被防火墙允许，相关的数据包可以通过防火墙。</li>
<li>所有从源 IP 地址 172.16.8.1 到目标 IP 地址 10.10.10.81 并且到目标端口号 23 的 IP 数据包都会被防火墙阻塞，相关的数据包会被丢弃——无法通过防火墙。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p>我们将模拟在防火墙级别拦截恶意IP地址所发出的数据包，这需要我们快速添加一些防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230516322.png"
                      alt="image-20230323230516322"
                ></p>
<p>发现恶意ip及其数据包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230712062.png"
                      alt="image-20230323230712062"
                ></p>
<p>快速添加防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230832936.png"
                      alt="image-20230323230832936"
                ></p>
<p>成功拦截并得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230915180.png"
                      alt="image-20230323230915180"
                ></p>
<blockquote>
<p>最后得到的flag内容为：THM{ATTACK_BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222055186.png"
                      alt="image-20230320222055186"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>在Kali中配置clash代理(含终端流量)</title>
    <url>/2024/01/18/%E5%9C%A8Kali%E4%B8%AD%E9%85%8D%E7%BD%AEclash%E4%BB%A3%E7%90%86(%E5%90%AB%E7%BB%88%E7%AB%AF%E6%B5%81%E9%87%8F)/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文内容概述：</p>
<ul>
<li>在Kali中安装clash；</li>
<li>在Kali中配置终端流量代理，以便终端命令在必要的时候可以走代理流量；</li>
<li>在Kali中配置浏览器端流量代理，以便通过kali机器访问谷歌等网站；</li>
<li>解决在使用BurpSuite抓包时遇到的“谷歌recaptcha验证码国内调试”等相关问题。</li>
</ul>
<h2 id="下载Clash"><a href="#下载Clash" class="headerlink" title="下载Clash"></a>下载Clash</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.15.1/clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">gunzip clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64-v1.15.1 clash#重命名文件夹</span><br><span class="line"></span><br><span class="line">cd clash/</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64 clash#重命名文件</span><br><span class="line"></span><br><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure></div>

<h2 id="配置clash节点-请自行购买vpn节点"><a href="#配置clash节点-请自行购买vpn节点" class="headerlink" title="配置clash节点(请自行购买vpn节点)"></a>配置clash节点(请自行购买vpn节点)</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nano /root/.config/clash/config.yaml#将config.yaml配置文件内容更换为已订阅的VPN节点文件内容√</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可能需要手动复制粘贴节点文件内容</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230745920-1379638961.png"
                      alt="image-20230505071036891"
                ></p>
<h2 id="Kali终端流量代理设置"><a href="#Kali终端流量代理设置" class="headerlink" title="Kali终端流量代理设置"></a>Kali终端流量代理设置</h2><h3 id="修改proxychains4配置文件"><a href="#修改proxychains4配置文件" class="headerlink" title="修改proxychains4配置文件"></a>修改proxychains4配置文件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/proxychains4.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在配置文件的末尾部分 添加以下两行</span></span><br><span class="line">http 127.0.0.1 7890       #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br><span class="line">socks5 127.0.0.1 7890     #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230746676-1972959411.png"
                      alt="image-20230505071106289"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747239-1590817637.png"
                      alt="image-20230501215816004"
                ></p>
<h3 id="通过终端启动clash程序"><a href="#通过终端启动clash程序" class="headerlink" title="通过终端启动clash程序"></a>通过终端启动clash程序</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/hekeats/桌面/clash</span><br><span class="line">./clash</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747812-1957154928.png"
                      alt="image-20230501215450971"
                ></p>
<p>在浏览器中访问<code>http://clash.razord.top/</code> ，此URL对应的是clash的图形用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748314-203330223.png"
                      alt="image-20230501215534594"
                ></p>
<h3 id="测试终端流量代理"><a href="#测试终端流量代理" class="headerlink" title="测试终端流量代理"></a>测试终端流量代理</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试终端流量是否被成功代理，返回结果为ok则说明终端代理配置成功！</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在所有想走代理的终端命令前面添加proxychains4即可</span></span><br><span class="line">proxychains4 curl -sSf http://www.google.com &gt; /dev/null    #test ok √</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748722-1178580563.png"
                      alt="image-20230501215340251"
                ></p>
<h2 id="浏览器端流量代理设置"><a href="#浏览器端流量代理设置" class="headerlink" title="浏览器端流量代理设置"></a>浏览器端流量代理设置</h2><h3 id="添加浏览器代理"><a href="#添加浏览器代理" class="headerlink" title="添加浏览器代理"></a>添加浏览器代理</h3><p>以下两种方法任选其一即可：</p>
<ul>
<li><p>使用浏览器代理插件，以火狐浏览器为例，使用FoxyProxy添加代理<code>127.0.0.1 7890</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749103-359792420.png"
                      alt="image-20230501220409534"
                ></p>
</li>
<li><p>打开本地浏览器设置，在网络设置中选择手动配置代理，并填写<code>127.0.0.1 7890</code>。</p>
<p>通过地址栏快捷访问浏览器的设置界面：<code>about:preferences</code>。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749427-1894573037.png"
                      alt="image-20230501222137401"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749757-395404947.png"
                      alt="image-20230501220932834"
                ></p>
<p>tips：上述端口号<code>7890</code>可通过查看配置文件<code>/root/.config/clash/config.yaml</code>得知。</p>
<h3 id="测试浏览器端流量代理"><a href="#测试浏览器端流量代理" class="headerlink" title="测试浏览器端流量代理"></a>测试浏览器端流量代理</h3><p>配置好浏览器代理之后，访问 <a class="link"   href="http://www.google.com/" >www.google.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，查看页面响应情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750113-568475238.png"
                      alt="image-20230501230523149"
                ></p>
<h2 id="BurpSuite和calsh代理兼容问题"><a href="#BurpSuite和calsh代理兼容问题" class="headerlink" title="BurpSuite和calsh代理兼容问题"></a>BurpSuite和calsh代理兼容问题</h2><p>在使用BurpSuite抓包时，如果遇到google recaptcha等需要VPN才能访问的验证码机制，我们就需要重新配置本地浏览器代理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750487-443165563.png"
                      alt="image-20230501221558317"
                ></p>
<p>tips：设置好8080端口代理，这样BurpSuite才能抓到数据包。</p>
<p>然后打开BurpSuite，进入到“用户选项”下的“Connections(连接)”子选项卡界面，添加并编辑上游代理规则：</p>
<p>注意：新版BurpSuite要先点击“设置”按钮，才能开始选择“用户选项”。</p>
<p><u>中文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750855-1248001512.png"
                      alt="image-20230501223436455"
                ></p>
<p><u>英文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230751240-481769820.png"
                      alt="image-20230501223806392"
                ></p>
<p>参考资料：</p>
<ul>
<li><a class="link"   href="https://www.iculture.cc/cybersecurity/pig=265" >https://www.iculture.cc/cybersecurity/pig=265 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7223566884502011959" >https://juejin.cn/post/7223566884502011959 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash" >https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>常见问题-FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Extending Your Network(网络扩展基础介绍)-学习</title>
    <url>/2024/01/18/THM-Extending%20Your%20Network(%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/extendingyournetwork" >https://tryhackme.com/room/extendingyournetwork <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些用于将网络扩展到 Internet(互联网公网) 的技术以及这样做的动机。</p>
<h2 id="端口转发介绍"><a href="#端口转发介绍" class="headerlink" title="端口转发介绍"></a>端口转发介绍</h2><p>端口转发是应用程序和服务连接到 Internet(互联网公网) 所需的重要步骤，如果没有端口转发，应用程序和服务(如web服务)只能对同一直连网络中的设备可用。</p>
<p>以下面的网络为例：在以下网络中，IP地址为“192.168.1.10”的服务器在端口80上运行着web服务，但该网络上只有另外两台计算机能够访问此web服务。(这种网络被称为内部网络)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163246516.png"
                      alt="image-20230327163246516"
                ></p>
<p>如果网络管理员想让公众(通过互联网)访问上图中的网站，管理员就必须实现端口转发，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163735248.png"
                      alt="image-20230327163735248"
                ></p>
<p>通过上图这种设计，网络2现在可以使用网络1的公共IP地址(82.62.51.70)并通过80端口访问运行在网络1上的web服务器。</p>
<p>我们很容易将端口转发行为与防火墙的行为混淆，但是这两者是不一样的；防火墙能够决定流量是否可以通过某些端口(即使这些端口是通过端口转发开放的)。</p>
<p><em>tips：端口转发是在网络中的路由器上配置的。</em></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327165324795.png"
                      alt="image-20230327165324795"
                ></p>
<h2 id="防火墙简介"><a href="#防火墙简介" class="headerlink" title="防火墙简介"></a>防火墙简介</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/roomicon.png"
                      alt="img" style="zoom:50%;" 
                >

<p>防火墙是网络中的一种设备，它负责确定允许哪些流量进入网络和退出网络，防火墙可以被视为网络的边界安全。网络管理员可以根据多种因素将防火墙配置为允许或拒绝某些流量进入或退出网络，例如：</p>
<ul>
<li>流量从哪里来？ （防火墙是否被告知：接受&#x2F;拒绝来自特定网络的流量？）</li>
<li>流量要往哪里去？ （防火墙是否被告知：接受&#x2F;拒绝发往特定网络的流量？）</li>
<li>流量流向哪个端口？ （防火墙是否被告知：仅接受&#x2F;拒绝发往端口 80 的流量？）</li>
<li>流量使用什么协议？ （防火墙是否被告知：接受&#x2F;拒绝 UDP、TCP 或两者的流量？）</li>
</ul>
<p><em><strong>tips：防火墙将通过执行数据包检查来确定以上这些问题的答案。</strong></em></p>
<p>防火墙有各种各样的形状和大小：从可以处理大量数据的专用硬件(通常存在于像企业这样的大型网络中)到住宅路由器(通常存在于家庭网络中)或者Snort软件(一种开源入侵防御系统-IPS)，防火墙可以分为2到5类。</p>
<p>我们将在下面介绍两种主要类型的防火墙：</p>
<ul>
<li>Stateful（有状态）：这种类型的防火墙将使用来自连接的全部信息，这种防火墙不是基于单个数据包检查，而是<em><strong>基于整个连接来确定设备的行为</strong></em>；与无状态防火墙相比，有状态防火墙会消耗很多资源，因为相关的流量决策是动态的，例如，有状态防火墙可以让TCP三次握手过程中的第一部分执行失败；如果来自主机的连接不正常，这将阻塞整个设备。</li>
<li>Stateless（无状态）：这种类型的防火墙将使用一组静态规则来<em><strong>确定单个数据包是否可接受</strong></em>，例如，某设备发送了一个坏数据包并不意味着此设备随后都将会被阻塞；虽然无状态防火墙比其他防火墙使用更少的资源，但无状态防火墙的表现也更笨，例如，无状态防火墙只有在定义了规则时才有效，如果规则没有完全匹配，那么此规则实际上将是无用的；当从一组主机接收大量流量时(例如发生了分布式拒绝服务攻击-DDoS攻击)，无状态防火墙将变得非常有用。</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327173045469.png"
                      alt="image-20230327173045469"
                ></p>
<h2 id="防火墙模拟示例"><a href="#防火墙模拟示例" class="headerlink" title="防火墙模拟示例"></a>防火墙模拟示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：正确配置防火墙规则以防止设备超载——示例中的203.0.110.1网站正在遭到攻击，请快速添加一些防火墙规则来阻止服务器崩溃（红色的数据包来自于攻击者的机器）。</em></p>
<p>添加规则：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180344996.png"
                      alt="image-20230327180344996" style="zoom: 67%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180155107.png"
                      alt="image-20230327180155107"
                ></p>
<blockquote>
<p>最后得到的flag是：THM{FIREWALLS_RULE} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327175546858.png"
                      alt="image-20230327175546858"
                ></p>
<h2 id="VPN基础"><a href="#VPN基础" class="headerlink" title="VPN基础"></a>VPN基础</h2><p>虚拟专用网络(VPN-Virtual Private Network)是一种允许不同网络上的设备通过在Internet(互联网公网)上彼此之间创建专用路径(称为隧道)进行安全通信的技术，在此隧道内连接的多个设备将形成它们自己的专用网络。</p>
<p>只有同一网络中的设备(如企业的内部网络)可以直接通信，而VPN允许两个局点相连，让我们看看下图，其中有三个网络：</p>
<ol>
<li>Network #1 (Office #1)</li>
<li>Network #2 (Office #2)</li>
<li>Network #3 (两个设备通过VPN连接)</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180844134.png"
                      alt="image-20230327180844134"
                ></p>
<p>连接在Network#3上的设备仍然是Network#1和Network#2的一部分，但这些设备同时也形成了一个私有网络(Network#3)，只有通过相关的VPN连接的设备才能在这个专用网络(Network#3)上进行通信。</p>
<p>让我们介绍VPN提供的一些其他好处:</p>
<ul>
<li>允许不同地理位置的网络进行连接：例如，拥有多个办公室网络的企业会发现VPN是有益的，因为这意味着可以从办公室网络 直接访问远程服务器或基础设施等资源。</li>
<li>提供隐秘性：VPN使用了加密技术来保护数据，这意味着数据包只能在发送它的设备和目的地之间被理解，这些数据不容易被嗅探；VPN加密技术在有公共WiFi的地方可能很有用处，因为普通的公共WiFi网络并不提供加密；你可以使用VPN来保护你所使用的流量不被其他人查看。</li>
<li>提供匿名性：记者和其他活动人士可以依靠VPN技术 在言论自由受到控制的国家安全地报道全球问题；通常，你所使用的流量可以被你的ISP和其他中介机构查看，并能因此被跟踪，而VPN所提供的匿名级别也仅仅与网络上的其他设备如何尊重隐私有关，例如，使用一个会记录所有数据或者历史的VPN 本质上与不使用VPN的效果是一样的。</li>
</ul>
<p>例如TryHackMe网站可以使用VPN技术 将你的本地机和一些易受攻击的机器连接起来，并且不允许那些易受攻击的机器能被公众直接在互联网上访问，这意味着:</p>
<ul>
<li><p>你可以安全地与 TryHackMe网站所提供的那些易受攻击的机器 进行交互，从而进行攻击模拟；</p>
</li>
<li><p>服务提供商如ISP不会认为你在使用本地机攻击互联网上的正常机器(因为攻击正常机器可能违反了ISP的服务条款)；</p>
</li>
<li><p>使用VPN也为TryHackMe网站提供了安全性，因为 TryHackMe所提供的易受攻击的机器 无法直接通过Internet被公众访问。</p>
</li>
</ul>
<p>多年以来，VPN技术经过了不断改进，下面让我们来探讨一些现有的VPN技术：</p>
<ul>
<li><p>PPP：PPP是指点对点协议，它能提供加密以及数字验证功能，使用了PPP技术的VPN会通过私钥和公共证书(类似于SSH)来工作，如果要成功建立VPN连接，那么私钥和证书就必须完成匹配，但是，基于PPP技术进行传输的数据 并不能单独离开网络(即不可路由)；此外，PPTP将使用PPP技术来进行身份验证并提供数据加密。</p>
</li>
<li><p>PPTP：点对点隧道协议(PPTP-<strong>P</strong>oint-to-<strong>P</strong>oint <strong>T</strong>unneling <strong>P</strong>rotocol)是一种“允许PPP数据在网络中传输并离开网络”的技术，PPTP协议非常容易设置，大多数设备都支持它，然而，与其他VPN方案相比，PPTP是弱加密的。</p>
</li>
<li><p>IPSec：IPsec (Internet Protocol Security)将使用现有的IP (Internet Protocol)框架对数据进行加密，与其他VPN方案相比，IPSec更难建立，但只要建立完成，IPSec就能使用强大的加密功能，并且IPSec技术在许多设备上都能得到支持。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327202321786.png"
                      alt="image-20230327202321786"
                ></p>
<h2 id="局域网-LAN-网络设备"><a href="#局域网-LAN-网络设备" class="headerlink" title="局域网(LAN)网络设备"></a>局域网(LAN)网络设备</h2><p><strong>路由器（Router）</strong></p>
<p>路由器的工作是连接网络并在网络之间传递数据，它是通过使用路由来做到这一点的(因此得名路由器)。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据；路由器运行在OSI模型的第3层(网络层)，它通常具有交互式界面(如网页界面或控制台界面)，这能够允许管理员配置各种规则，如配置端口转发规则或配置防火墙规则。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用以采用最优路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327203318544.png"
                      alt="image-20230327203318544"
                ></p>
<p><em>tips：路由器是专用设备，它的功能与交换机不同。</em></p>
<p>从上图的例子中，我们可以看到计算机A的网络通过中间的路由器连接到计算机B的网络——共有两条路由路径可供选择，接下来的问题是：我们将采取什么路由路径？</p>
<p>使用不同的协议将决定采取不同的路由路径，此外，路径的选择还包括以下因素：</p>
<ul>
<li><p>哪条路径最短？（数据包需要通过的设备最少）</p>
</li>
<li><p>哪条路径最可靠？（之前在该路径上是否丢失过数据包）</p>
</li>
<li><p>哪条路径有更快的物理传输介质(铜缆线或光纤)？</p>
</li>
</ul>
<p><strong>交换机（Switch）</strong></p>
<p>交换机是一种专用的网络设备，它负责在网络上提供连接到多个设备的方法——一个交换机可以通过以太网电缆连接多个设备(从3到63个)。</p>
<p>交换机可以在OSI模型的第二层(数据链路层)和第三层(网络层)同时工作，然而，这是具有排他性的——第二层交换机不能在第三层运行。</p>
<p>以下图中的第二层交换机为例，交换机将通过MAC地址把帧(此处不是数据包，因为IP协议已被剥离)转发到它所连接的设备上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327210327136.png"
                      alt="image-20230327210327136"
                ></p>
<p><em><strong>tips：上图中的交换机是第二层交换机，OSI模型的第二层是数据链路层，所以上图中的交换机只负责将帧(数据帧)发送到正确的设备上。</strong></em></p>
<p>第三层交换机能够在OSI模型的第三层（网络层）工作，第三层交换机比第二层交换机更复杂，因为它还可以执行路由器的一些职责；也就是说，第三层交换机能向设备发送帧(就像第二层交换机一样)，并能使用IP协议将数据包路由到其他设备。</p>
<p>第三层交换机的使用还涉及到了VLAN(虚拟局域网)技术，我们稍后将介绍VLAN，先假设我们有以下IP地址备用：</p>
<ul>
<li>192.168.1.1</li>
<li>192.168.2.1</li>
</ul>
<p>虚拟局域网(<strong>V</strong>irtual <strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork)技术 能够允许网络中的特定设备被虚拟分割，这种分割意味着相关的网络设备可以在互联网连接等方面受益，同时相关的网络设备也将被分区处理；由VLAN技术所形成的网络隔离能够提供安全性，因为这意味着将由适当的规则来决定特定设备如何相互通信，这种网络隔离如下图所示：</p>
<p><em>tips：下图中的交换机是第三层交换机，下图示例将使用交换机划分VLAN，然后给VLAN分配IP。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327212506663.png"
                      alt="image-20230327212506663"
                ></p>
<p>如上图所示：“销售部门”和“会计部门”都能够访问Internet(互联网公网)，但这两个部门网络之间并不能实现相互通信(尽管这两个部门都连接到同一个交换机)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327214314866.png"
                      alt="image-20230327214314866"
                ></p>
<h2 id="网络模拟器示例"><a href="#网络模拟器示例" class="headerlink" title="网络模拟器示例"></a>网络模拟器示例</h2><p>部署附加到此示例的静态站点，用一个简单的网络模拟器进行实验。此模拟器将分解 数据包从点A传输到点B所需要的每一步，请尝试从computer1发送一个TCP包到computer3并得到一个flag。</p>
<p>注意：请使用Chrome或Firefox浏览器完成此练习。</p>
<p><strong>答题</strong></p>
<p>从 computer1 发送TCP包到 computer3 ：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012723958.png"
                      alt="image-20230327012723958" style="zoom:50%;" 
                >

<p>得到的flag结果：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012919841.png"
                      alt="image-20230327012919841" style="zoom:50%;" 
                >

<blockquote>
<p>得到的flag为：THM{YOU’VE_GOT_DATA} 。</p>
</blockquote>
<p>对应的网络日志的内容（在TCP连接全过程中 所记录的日志如下）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Starting TCP/IP Handshake between computer1 and computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Sending SYN Packet from computer1 to computer3</span></span><br><span class="line">ROUTING: computer1 says computer3 is not on my local network sending to gateway: router</span><br><span class="line">ARP REQUEST: Who has router tell computer1</span><br><span class="line">ARP RESPONSE: Hey computer1, I am router</span><br><span class="line">ARP REQUEST: Who has computer3 tell router</span><br><span class="line">ARP RESPONSE: Hey router, I am computer3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received SYN Packet from computer1, sending SYN/ACK Packet to computer1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer1 received SYN/ACK Packet from computer3, sending ACK packet to computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received ACK packet from computer1, Handshake Complete</span></span><br><span class="line">TCP: Sending TCP packet from computer1 to computer3</span><br><span class="line">TCP: computer3 received TCP Packet from computer1, sending ACK Packet to computer1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>网络日志中共有 5 个HANDSHAKE条目。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327013125313.png"
                      alt="image-20230327013125313"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OSI Model(OSI模型介绍)-学习</title>
    <url>/2024/01/18/THM-OSI%20Model(OSI%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/osimodelzi" >https://tryhackme.com/room/osimodelzi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解决定跨网络处理数据的各个阶段的基本网络框架。</p>
<h2 id="什么是OSI模型？"><a href="#什么是OSI模型？" class="headerlink" title="什么是OSI模型？"></a>什么是OSI模型？</h2><p>OSI模型(开放系统互连模型-Open Systems Interconnection Model)是网络中使用的绝对基本模型，这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。</p>
<p>OSI模型的主要好处之一是：当与其他设备进行通信时，网络上的设备可以具有不同的功能和设计，而且在遵循OSI模型一致性的网络上发送的数据也可以被其他设备理解。</p>
<p>OSI模型由七层组成，从第7层到第1层，每一层都有不同的职责。</p>
<p>数据传递在OSI的每一层都会发生特定的过程，OSI的每一层都会将部分信息添加到原数据中，这个过程被称为封装，下图为OSI模型示意图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326005100677.png"
                      alt="image-20230326005100677" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326005200447.png"
                      alt="image-20230326005200447"
                ></p>
<h2 id="Layer-7-应用层-Application"><a href="#Layer-7-应用层-Application" class="headerlink" title="Layer 7 - 应用层(Application)"></a>Layer 7 - 应用层(Application)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/application.png"
                      alt="img"
                ></p>
<p>OSI模型的应用层是你最熟悉的一层，这种熟悉程度是因为应用程序层是协议和规则所在的层，应用层用于确定用户应该如何与发送或接收的数据进行交互。</p>
<p>日常的应用程序，如电子邮件客户端、浏览器或文件服务器浏览软件(如FileZilla) 等，它们能够为用户提供一个友好的图形用户界面(GUI)，这个GUI可用于用户与数据（发送的数据或接收的数据）进行交互；应用层中还包括了DNS协议(域名系统)，DNS能将网站地址转换为IP地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010503208.png"
                      alt="image-20230326010503208"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010536829.png"
                      alt="image-20230326010536829"
                ></p>
<h2 id="Layer-6-表示层-Presentation"><a href="#Layer-6-表示层-Presentation" class="headerlink" title="Layer 6 - 表示层(Presentation)"></a>Layer 6 - 表示层(Presentation)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/presentation.png"
                      alt="img"
                ></p>
<p>OSI模型的第6层是标准化开始发生的层。软件开发人员可以以不同的方式开发应用程序，例如电子邮件客户端等，而无论应用程序如何工作，数据仍然需要以相同的方式进行处理。</p>
<p>这一层能够充当数据与应用层(第7层)之间的翻译器。接收信息的计算机也能理解以一种格式发送到计算机的数据以另一种格式发送，例如：当你通过某种类型的电子邮件客户端发送电子邮件时，其他用户可能使用的是另一种电子邮件客户端来接收信息，但是电子邮件的内容仍然能够正常显示。</p>
<p>数据加密（如访问安全站点时使用HTTPS协议）等安全特性也将在表示层得到应用。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326154514416.png"
                      alt="image-20230326154514416"
                ></p>
<h2 id="Layer-5-会话层-Session"><a href="#Layer-5-会话层-Session" class="headerlink" title="Layer 5 - 会话层(Session)"></a>Layer 5 - 会话层(Session)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/session.png"
                      alt="img"
                ></p>
<p>一旦数据从表示层(第6层)正确地转换或格式化，会话层(第5层)将开始创建到数据目的地(另一台计算机)的连接。当连接建立后，将同时创建一个会话，并且当该连接处于活动状态时，对应的会话也将处于活动状态。</p>
<p>会话层(第5层)将使两台计算机同步，以确保它们在发送数据和接收数据之前处于同一页面上，一旦相关的检查到位，会话层将开始把要发送的数据分成更小的数据块，并开始一次一个地发送这些数据块(Packets-数据包)；这种对数据分块处理的方式是有益的，因为如果连接发生丢失，则仅有尚未发送的部分数据块需要再次发送——而不需要重新发送全部数据块。</p>
<p>值得注意的是，会话是唯一的——这意味着数据不能在不同的会话之间传输，而只能在相同会话之间传输（一个会话将包含两端：发送数据端和接收数据端）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326155132061.png"
                      alt="image-20230326155132061"
                ></p>
<h2 id="Layer-4-传输层-Transport"><a href="#Layer-4-传输层-Transport" class="headerlink" title="Layer 4 - 传输层(Transport)"></a>Layer 4 - 传输层(Transport)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/transport.png"
                      alt="img"
                ></p>
<p>OSI模型的第4层在通过网络传输数据方面起着至关重要的作用。当数据在设备之间发送时，它将遵循以下两种不同的协议之一：</p>
<ul>
<li>TCP（传输控制协议）</li>
<li>UDP（用户数据报协议）</li>
</ul>
<p><strong>TCP协议</strong></p>
<p>传输控制协议（TCP-<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol）在设计时考虑到了数据传输的可靠性；并且TCP协议在发送数据和接收数据所需的时间内，将在两个设备之间保持恒定的连接——TCP协议是面向连接的。</p>
<p>不仅如此，TCP还在其设计中加入了错误检查，错误检查能够确认从会话层(第5层)发送的小块数据已经按顺序（按发送数据的顺序）被接收和重新组装。</p>
<p>让我们总结一下TCP的优点和缺点：</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，则无法使用整个数据块；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。</li>
</ul>
<p>TCP主要用于文件共享、互联网浏览或发送电子邮件等情况，因为这些服务要求数据是准确和完整的，而TCP协议的特性能够满足这些要求。</p>
<p>在下图的例子中，我们可以看到一张照片是如何被分解成来自“网络服务器”的小数据块(称为数据包)，而接收数据的计算机会将照片重新按正确的顺序完成构建。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326164124956.png"
                      alt="image-20230326164124956"
                ></p>
<p><strong>UDP协议</strong></p>
<p>现在让我们介绍用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)。UDP协议远不如TCP协议先进，它没有TCP所提供的多种特性，如错误检查和数据传输的可靠性。任何基于UDP协议发送的数据都无法确保不会发生数据丢失，UDP协议在进行数据传输时并没有实现设备的同步过程，UDP的特性是：无连接、不可靠、快速传输。</p>
<p>让我们总结一下UDP的优点和缺点：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>我们使用与上面相同的例子，假设我们基于UDP协议传输数据，我们现在可以看到“接收数据的计算机”仅接收到数据包 #1 和 #3，这意味着图像发生了丢失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326170113306.png"
                      alt="image-20230326170113306"
                ></p>
<p>UDP协议在需要发送小块数据的情况下很有用，例如，用于发现设备的协议(ARP协议和DHCP协议)或者视频流等更大的文件(视频的某些部分出现像素化是可允许的，像素化部分代表了对应数据的丢失)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326160454354.png"
                      alt="image-20230326160454354"
                ></p>
<h2 id="Layer-3-网络层-Network"><a href="#Layer-3-网络层-Network" class="headerlink" title="Layer 3 - 网络层(Network)"></a>Layer 3 - 网络层(Network)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/network.png"
                      alt="img"
                ></p>
<p>OSI模型的第三层(网络层)是路由和重新组装数据之处，而路由能够确定发送数据块时应该选择的最优路径。</p>
<p>网络层的一些协议确切地确定了数据到达设备的“最佳”路径，这些协议包括了开放最短路径优先协议(OSPF-Open Shortest Path First)和路由信息协议(RIP-Routing Information Protocol)；此外，路径的选择还由以下因素决定：</p>
<ul>
<li>哪条路径最短?也就是说，数据包需要通过的设备最少。</li>
<li>哪条路径最可靠?例如，之前在该路径上丢失过数据包吗?</li>
<li>哪条路径的物理连接更快?例如，一条路径是使用铜缆线连接(较慢)还是光纤连接(相当快)?</li>
</ul>
<p>在这一层，一切都是通过IP地址(如192.168.1.100)进行处理的，能够使用IP地址发送数据包的路由器等设备也被称为第三层设备，因为它们能够在OSI模型的第三层工作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174126984.png"
                      alt="image-20230326174126984"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174251520.png"
                      alt="image-20230326174251520"
                ></p>
<h2 id="Layer-2-数据链路层-Data-Link"><a href="#Layer-2-数据链路层-Data-Link" class="headerlink" title="Layer 2 - 数据链路层(Data Link)"></a>Layer 2 - 数据链路层(Data Link)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/datalink.png"
                      alt="img"
                ></p>
<p>数据链路层着重于数据传输过程中的物理寻址。该层级将接收来自网络层的数据包(包括远程计算机的IP地址)，并会在数据包中添加接收端点的物理MAC(媒体访问控制)地址。</p>
<p>在每一台联网计算机内部都有一个网络接口卡(NIC- Network Interface Card)，它带有一个唯一的MAC(Media Access Control)地址作为标识；MAC地址由制造商设置，并刻入网络接口卡中，MAC地址不能被改变——尽管MAC地址可以被欺骗；当信息通过网络发送时，实际上是使用物理地址来确定将信息发送到哪里。此外，以适合传输的格式表示数据也是数据链路层的工作之一。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175234403.png"
                      alt="image-20230326175234403"
                ></p>
<h2 id="Layer-1-物理层-Physical"><a href="#Layer-1-物理层-Physical" class="headerlink" title="Layer 1 - 物理层(Physical)"></a>Layer 1 - 物理层(Physical)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/physical.png"
                      alt="img"
                ></p>
<p>物理层包括了在网络中所使用的硬件的物理组件，是OSI模型的最低层，这些设备将使用电信号在二进制编号系统( 0 和 1 )中相互传输数据。</p>
<p>例如，以太网电缆连接设备：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326180259445.png"
                      alt="image-20230326180259445" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175520887.png"
                      alt="image-20230326175520887"
                ></p>
<h2 id="OSI实例练习"><a href="#OSI实例练习" class="headerlink" title="OSI实例练习"></a>OSI实例练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p>根据数据发送时在OSI七层中所经过的顺序完成模拟实验，并得到最后的flag。</p>
<p><em>tips：使用左、右方向键控制移动，使用空格键进行爬楼。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181243963.png"
                      alt="image-20230326181243963" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181212728.png"
                      alt="image-20230326181212728" style="zoom: 67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{OSI_DUNGEON_ESCAPED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326180750610.png"
                      alt="image-20230326180750610"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to LAN(局域网基础介绍)-学习</title>
    <url>/2024/01/18/THM-Intro%20to%20LAN(%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introtolan" >https://tryhackme.com/room/introtolan <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些支持专用网络的技术和设计。</p>
<h2 id="局域网-LAN-Local-Area-Network-拓扑简介"><a href="#局域网-LAN-Local-Area-Network-拓扑简介" class="headerlink" title="局域网(LAN-Local Area Network)拓扑简介"></a>局域网(LAN-Local Area Network)拓扑简介</h2><p>多年以来，人们对各种网络设计进行了试验和实施，在网络中，当我们提到术语“拓扑-Topology”时，实际上指的是当前网络的设计或外观。下面我们将讨论一下这些拓扑的优缺点。</p>
<h3 id="Star-Topology（星型拓扑）"><a href="#Star-Topology（星型拓扑）" class="headerlink" title="Star Topology（星型拓扑）"></a><strong>Star Topology（星型拓扑）</strong></h3><p>星型拓扑结构的主要前提是设备通过中央网络设备(如交换机或集线器)单独连接；尽管成本高昂，但由于其可靠性和可伸缩性，这种拓扑在今天仍是最常见的。</p>
<p>在星型拓扑结构中 发送到设备的任何信息都是通过此设备所连接的中心设备发送的，下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于这种拓扑结构需要更多的电缆布线和购买专用的网络设备，因此它比其他任何拓扑结构都要昂贵。然而，尽管增加了成本，星型拓扑结构也确实提供了一些显著的优势：例如，这种拓扑本质上将具有更强的可伸缩性，这意味着随着网络需求的增加，我们可以很容易地添加更多设备。</p>
<p>但不幸的是，随着网络规模越来越大，在星星拓扑中保持网络功能所需的维护成本就越高，而这种对维护的依赖增加也会使得故障排除变得更加困难。此外，星形拓扑仍然可能失效(尽管这种拓扑结构减少了失效的可能性)，例如，如果连接各个设备的集中式硬件出现故障，那么这些设备将不再能够继续发送或接收数据，值得庆幸的是，这些集中式硬件设备通常都很健壮。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211744823.png"
                      alt="image-20230325211744823" style="zoom:50%;" 
                >

<h3 id="Bus-Topology（总线拓扑）"><a href="#Bus-Topology（总线拓扑）" class="headerlink" title="Bus Topology（总线拓扑）"></a><strong>Bus Topology（总线拓扑）</strong></h3><p>总线拓扑中的各个设备在连接时 依赖于主干电缆的单一连接，此类拓扑结构中的设备就类似于树的叶子，因为在某种意义上，设备(叶子)起源于主干电缆上的分支。</p>
<p>下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于发送到每个设备的所有数据都沿着同一条电缆传输，所以如果总线拓扑中的各个设备同时请求数据，就很容易让数据传输变得缓慢和阻塞。当数据传输的阻塞情况达到瓶颈后，就会导致故障排除变得非常困难，因为在进行故障排除时——很难确定哪个设备正在经历“由于所有数据都沿着相同的路线传输而导致数据阻塞”。</p>
<p>尽管如此，总线拓扑仍然是一种更容易配置且成本更低的拓扑结构，它主要的花费在于购买连接各个设备的电缆或专用网络设备。</p>
<p>总线拓扑的另一个缺点是在发生故障时几乎没有冗余，这个缺点的存在是因为：如果在主干电缆上有一个单点故障，即电缆线突然断了，那么设备就不能再沿着总线接收或传输数据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211804758.png"
                      alt="image-20230325211804758" style="zoom:50%;" 
                >

<h3 id="Ring-Topology（环型拓扑）"><a href="#Ring-Topology（环型拓扑）" class="headerlink" title="Ring Topology（环型拓扑）"></a><strong>Ring Topology（环型拓扑）</strong></h3><p>环形拓扑(也称为令牌拓扑)，在此拓扑中将由计算机等设备直接相互连接形成环路，这意味着几乎不需要电缆布线（只需要一点点电缆布线），也不太依赖于星型拓扑结构中的专用硬件。</p>
<p>环形拓扑的工作原理是通过环路发送数据，直到数据到达目标设备，在这个过程中会使用环路上的其他设备转发数据。有趣的是，在这个拓扑中，如果一个设备本身没有任何数据要发送，那么它只会转发从另一个设备接收到的数据；而如果该设备恰好有数据要发送，它会先发送自己的数据，然后再转发来自于其他设备的数据。</p>
<p>因为数据在这个拓扑结构中只有一个传输方向，所以很容易排除出现的任何故障；然而，这是一把双刃剑，因为单向传输在网络中并不是一种有效的数据传输方式，在总线拓扑中传输数据时，数据必须先访问多个设备才能最终到达预期的目标设备。</p>
<p>环形拓扑不太容易出现数据传输瓶颈，因为在总线拓扑结构中，大量流量不会在任何时候同时通过网络传输。然而，这种拓扑结构的设计也意味着：如果剪断电缆或损坏设备则将导致整个网络中断。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211833122.png"
                      alt="image-20230325211833122" style="zoom:50%;" 
                >

<h3 id="什么是交换机（Switch）？"><a href="#什么是交换机（Switch）？" class="headerlink" title="什么是交换机（Switch）？"></a><strong>什么是交换机（Switch）？</strong></h3><p>交换机是网络中的专用设备，它被设计用于聚合多个其他设备，如计算机、打印机或使用以太网的任何其他具有网络功能的设备；这些不同的设备都将插入交换机的端口。交换机通常存在于较大的网络中，如企业、学校或类似规模的网络，在这种环境下将有许多设备需要被连接到网络，此时交换机可以通过4、8、16、24、32、64端口来连接大量的设备。</p>
<p>交换机比它们的次要对应物(集线器&#x2F;中继器)更有效，交换机会跟踪哪些设备连接到哪个端口，因此，当交换机接收到一个数据包时，就不会像集线器那样将该数据包重复发送到每个端口，而是直接将数据包通过已知端口发送给预定的目标即可，从而减少了网络流量的消耗。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325122204859.png"
                      alt="image-20230325122204859"
                ></p>
<p>交换机和路由器都可以相互连接，这样做可通过为数据添加多条路径来增加网络的冗余(可靠性)——如果一条路走不通，就可以用另一条路。虽然这可能会降低网络的整体性能，因为数据包要花费更长的时间来传输，但这尽量保证了网络没有停机时间——考虑到其他替代方案，降低网络的整体性能只是一个很小的代价。</p>
<h3 id="什么是路由器（Router）？"><a href="#什么是路由器（Router）？" class="headerlink" title="什么是路由器（Router）？"></a><strong>什么是路由器（Router）？</strong></h3><p>路由器的工作是连接网络并在网络之间传递数据，它通过使用路由(因此得名路由器)来做到这一点。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325121757937.png"
                      alt="image-20230325121757937"
                ></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：该实验环境将带我们了解不同网络拓扑结构中的缺陷。</em></p>
<p>在环形拓扑结构中，所有设备都连接到其他两个设备，形成一个完整的圆圈，数据包从一个设备传输到下一个设备，直到到达目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214051829.png"
                      alt="image-20230325214051829" style="zoom:50%;" 
                >

<p>环形拓扑的主要缺陷之一是，如果设备故障或电缆损坏，则数据将不再传递，网络中的设备也无法再相互通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214218366.png"
                      alt="image-20230325214218366" style="zoom:50%;" 
                >

<p>在总线拓扑中，所有设备都连接到一根电缆上，这根电缆通常被称为主干电缆，数据将顺着主干电缆沿左右两个方向发送，直到到达数据包的目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214458459.png"
                      alt="image-20230325214458459" style="zoom:50%;" 
                >

<p>总线拓扑的一个主要缺陷是它不能处理大量数据，如果同时发送的数据包过多，就会导致网络关闭：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214722436.png"
                      alt="image-20230325214722436" style="zoom:50%;" 
                >

<p>在星型拓扑中，所有设备都通过自己的电缆连接到中央交换机&#x2F;集线器，每个数据包都将通过中央交换机发送：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214952528.png"
                      alt="image-20230325214952528" style="zoom:50%;" 
                >

<p>如果交换机发生故障，则网络将不再工作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325215037202.png"
                      alt="image-20230325215037202" style="zoom:50%;" 
                >

<p>完成上述步骤，最后得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325215123783.png"
                      alt="image-20230325215123783"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{TOPOLOGY_FLAWS} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325213845669.png"
                      alt="image-20230325213845669"
                ></p>
<h2 id="子网划分入门"><a href="#子网划分入门" class="headerlink" title="子网划分入门"></a>子网划分入门</h2><p>在现实世界中，你可以找到各种形状和大小的网络，而子网划分是将网络内部划分为更小的微型网络的术语。你可以把子网划分想象成你正在给你的朋友们切蛋糕，只有一定份额的蛋糕可以分给大家，但每个人都想要得到一块蛋糕，子网划分就是由你来决定谁将得到哪块蛋糕（最后还需要保留一部分未划分区域）。</p>
<p>以一家企业为例，企业中有不同的部门，比如:</p>
<ul>
<li>会计（Accounting）</li>
<li>金融（Finance）</li>
<li>人力资源（Human Resources）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325220009334.png"
                      alt="image-20230325220009334" style="zoom:50%;" 
                >

<p>在现实生活中，你知道要把信息发送到正确的企业部门，在网络中也同样需要知道这一点；网络管理员将使用子网划分来分类网络和分配网络的特定部分。</p>
<p>子网划分将通过划分网络中可以容纳的主机数量来实现，这将用一组被称为子网掩码的数字表示，让我们查看下图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325220503766.png"
                      alt="image-20230325220503766"
                ></p>
<p>我们知道，一个IP地址由四个“八位二进制数”组成，共四个字节，而子网掩码也是如此，子网掩码同样是被表示为四个字节(1个字节占8个二进制位，共32位)的一组数字，每个字节的范围是从0到255(0-255)。</p>
<p>子网通过三种不同的方式使用IP地址：</p>
<ul>
<li>标识网络地址（network address）</li>
<li>标识主机地址（host address）</li>
<li>标识默认网关（default gateway）</li>
</ul>
<p>让我们了解一下以上三种方式的目的，如下所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325221335603.png"
                      alt="image-20230325221335603"
                ></p>
<p>tips：默认网关是网络中的一个特殊设备，它能够向另一个网络上的设备发送信息。</p>
<p>在像家庭网络这样的小型网络中，你的计算机设备将处于一个子网中，你不太可能在这样的小型网络中需要一次连接超过254个设备；而像企业这样的大型网络中，将会有更多的设备(如各企业部门的pc、打印机、相机和传感器等)，在大型网络中更加需要进行子网划分。</p>
<p>子网划分提供了一系列好处，包括:</p>
<ul>
<li>效率</li>
<li>安全</li>
<li>完全控制</li>
</ul>
<p>我们将在以后继续探索子网划分是如何提供好处的，现在我们只需要了解子网划分所提供的安全元素；让我们以街上的咖啡馆为例，假设某家咖啡馆有两个网络：</p>
<ul>
<li>一个网络用于员工、收银机和其他店内联网设备。</li>
<li>一个网络供公众使用WiFi。</li>
</ul>
<p>子网划分允许你将以上例子中的两个网络彼此分开，同时还能连接到互联网等更大的网络。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325225950872.png"
                      alt="image-20230325225950872"
                ></p>
<h2 id="ARP协议介绍"><a href="#ARP协议介绍" class="headerlink" title="ARP协议介绍"></a>ARP协议介绍</h2><p>回顾我们上文所述，网络中的设备可以有两个标识符： MAC 地址和 IP 地址；而通过ARP协议可以允许设备在网络中识别自己，ARP协议即地址解析协议（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol ）。</p>
<p>简而言之，ARP协议允许设备将其MAC地址与网络上的IP地址相关联，网络上的每个设备都将保存与其他设备关联的MAC地址的日志；每当一个设备希望与另一个设备进行通信时，它将向整个网络发送广播以搜索目标设备，也就是说——网络中的设备可以通过ARP协议找到目标设备的MAC地址(即物理标识符)从而进行通信。</p>
<p><strong>ARP协议是如何工作的?</strong></p>
<p>网络中的每个设备都有一个用于存储信息的分类账簿，被称为缓存，在ARP协议的上下文中，这个缓存会存储网络上其他设备的标识符。</p>
<p>为了将这两个标识符(IP地址和MAC地址)映射在一起，ARP协议会发送两种类型的消息：</p>
<ul>
<li>ARP Request（ARP请求）</li>
<li>ARP Reply（ARP应答）</li>
</ul>
<p>当发送ARP请求时，初始源设备会向网络上的其他设备广播一条消息，以询问其他设备的MAC地址是否与初始源设备所请求的IP地址相匹配；如果某个设备确实有初始源设备所请求的IP地址（此设备即为初始目标设备），则会向初始源设备返回一个ARP应答消息以进行确认，初始源设备随后将记住这一映射关系，并将其存储在初始源设备的缓存中(以一个ARP条目的形式存储)。</p>
<p>这个过程如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325233634467.png"
                      alt="image-20230325233634467" style="zoom: 67%;" 
                >

<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325234520603.png"
                      alt="image-20230325234520603"
                ></p>
<h2 id="DHCP协议介绍"><a href="#DHCP协议介绍" class="headerlink" title="DHCP协议介绍"></a>DHCP协议介绍</h2><p>IP 地址可以手动分配，方法是将 IP 手动绑定到设备，IP 地址也可以自动分配，最常见的是使用动态主机配置协议（DHCP）服务器。当设备连接到网络时，如果尚未手动为其分配 IP 地址，它则会发出一个请求消息（DHCP Discover）以查看网络上是否有任何 DHCP 服务器，然后 DHCP 服务器将回复一个包含原设备可用的 IP 地址信息的消息（DHCP Offer）给原设备，紧接着原设备将再发送一个请求消息（DHCP Request）以确认它需要这个被提供的 IP 地址，最后，DHCP服务器将会发送一个应答消息（DHCP ACK）以确认IP分配操作已经完成，此后原设备就可以开始使用由DHCP服务器所提供的 IP 地址。</p>
<p>tips：DHCP-<strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol（动态主机配置协议）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325235958781.png"
                      alt="image-20230325235958781" style="zoom: 67%;" 
                >

<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326000851046.png"
                      alt="image-20230326000851046"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Packets &amp; Frames(了解数据包和帧)-学习</title>
    <url>/2024/01/18/THM-Packets&amp;Frames(%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E5%92%8C%E5%B8%A7)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/packetsframes" >https://tryhackme.com/room/packetsframes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数据如何被分成更小的部分并通过网络传输到另一台设备。</p>
<h2 id="什么是数据包和帧？"><a href="#什么是数据包和帧？" class="headerlink" title="什么是数据包和帧？"></a>什么是数据包和帧？</h2><p>数据包和帧是小块的数据，当它们组合在一起时，就构成了更大的信息或消息；然而，数据包和帧在OSI模型中是两种不同的东西，帧位于OSI的第2层——数据链路层，这意味着帧不包含IP地址这样的信息。类比案例：你可以想象把一个信封放在另外一个信封里，然后邮寄完整的信封，此完整信封对应的是发送的数据包，一旦打开完整信封，里面仍然会存在并包含一些数据(也就是一个帧)。</p>
<p>数据包和帧的组合过程被称为封装，在这个阶段中，我们可以安全地假设：任何包含IP地址的信息指的都是数据包，而当封装好的信息被剥离时，我们谈论的信息则是帧本身。</p>
<p>数据包是跨网络设备传输数据的有效方式，由于这些数据是分小块传输的，所以此时在整个网络中发生数据传输阻塞的几率 比一次性发送大消息进而造成传输阻塞的几率要小。</p>
<p>当你从网站加载图像时，该图像不会作为一个整体发送到你的计算机，而是在你的计算机上由小块图像开始重建进而得到一个完整图像；下面的图片说明了以上过程，来自于网站的图像将被分成三个数据包，当数据包到达计算机时，图像就会开始重建，最终形成完整的图像。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326193818536.png"
                      alt="image-20230326193818536"
                ></p>
<p>数据包有不同的结构，这些结构取决于正在发送的数据包的类型，网络上充满了各种标准和协议，这些标准和协议充当了设备上如何处理数据包的一组规则。</p>
<p>使用了协议的数据包将有一组标头，其中包含跨网络发送的数据的附加信息。</p>
<p>一些值得注意的标头信息包括：</p>
<ul>
<li>Time to Live（生存时间）：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Checksum（校验和）：该字段能够为TCP&#x2F;IP等协议提供完整性检查，如果数据被更改了，那么此时的Checksum值将变得与预期的Checksum值不同。</li>
<li>Source Address（源地址）：该字段表示发送数据包的设备的IP地址，这样数据就知道该返回到哪里。</li>
<li>Destination Address（目标地址）：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
</ul>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326201110685.png"
                      alt="image-20230326201110685"
                ></p>
<h2 id="TCP-IP（三次握手）介绍"><a href="#TCP-IP（三次握手）介绍" class="headerlink" title="TCP&#x2F;IP（三次握手）介绍"></a>TCP&#x2F;IP（三次握手）介绍</h2><p>传输控制协议(TCP-Transmission Control Protocol)是在网络中使用的一个规则。</p>
<p>基于TCP&#x2F;IP协议集的TCP&#x2F;IP模型与OSI模型非常相似，TCP&#x2F;IP模型由四层分级组成，可以说是OSI模型的一个简化版本，TCP&#x2F;IP模型所包含的分层有:</p>
<ul>
<li>Application（应用层）</li>
<li>Transport（传输层）</li>
<li>Internet（网际层）</li>
<li>Network Interface（网络接口层）</li>
</ul>
<p>与OSI模型的工作原理非常相似，数据包在经过TCP&#x2F;IP模型的每一层时都会被添加部分信息——这个过程被称为封装，而与此过程相反的是解封装。</p>
<p><strong>关于TCP协议</strong></p>
<p>TCP协议的一个定义特征是它是基于连接的，这意味着在发送数据之前，TCP必须在客户端和作为服务器的设备之间建立起一个持续的连接；因此，TCP能够保证发送的任何数据都会在另一端被正确地接收到，这个数据发送和接收过程被称为TCP&#x2F;IP三次握手。</p>
<p>下面是关于TCP优点和缺点的比较:</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，那么整个数据块就不能使用（必须重新发送）；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多的工作（计算）。</li>
</ul>
<p>TCP数据包还将包含 在封装过程中所添加的被称为标头的信息部分，接下来让我们了解一些重要的TCP标头信息：</p>
<ul>
<li>Source Port（源端口）：发送方为发送TCP数据包而开放的端口，该值是随机选择的(从0-65535之间 选择尚未使用的端口)。</li>
<li>Destination Port（目标端口）：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Source IP（源IP地址）：这是发送数据包的设备的IP地址。</li>
<li>Destination IP（目标IP地址）：这是数据包要到达的设备的IP地址。</li>
<li>Sequence Number（序列号）：当TCP连接建立时，所传输的第一段数据将被赋予一个随机数。</li>
<li>Acknowledgement Number（确认号）：在一段数据被赋予序列号之后，下一段数据的序列号值将会是序列号+ 1。</li>
<li>Checksum（校验和）：这个值可用于对TCP数据包的完整性进行检查，如果校验和的值在数据传输过程中发生了变化，则说明数据已经被损坏。</li>
<li>Data（数据）：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
<li>Flag（标志）：这个TCP标头决定了在三次握手过程中任一设备应该如何处理数据包，特定的标志将决定特定的行为。</li>
</ul>
<p><strong>TCP&#x2F;IP三次握手</strong></p>
<p>接下来，我们将讨论TCP&#x2F;IP三次握手——这是用于在两个设备之间建立连接的过程的术语。</p>
<p>TCP&#x2F;IP三次握手会使用一些特殊的信息进行交流，下面是一些主要的信息：</p>
<ul>
<li>1-SYN：SYN消息是客户端在握手过程中发送的初始数据包。这个包用于发起连接并同步两个设备。</li>
<li>2-SYN&#x2F;ACK：此数据包将由接收设备(服务器)发送，以确认来自客户端的同步尝试。</li>
<li>3-ACK：客户端或服务器都可以使用确认数据包来确认已经成功接收了一系列消息&#x2F;数据包。</li>
<li>4-DATA：一旦两个设备建立了连接，数据(例如文件的字节)就会通过“DATA”消息发送。</li>
<li>5-FIN：此数据包可用于在TCP连接完成后 干净地(正确地)关闭TCP连接。</li>
<li>RST：RST数据包能够立刻终止所有的TCP通信，如果使用了RST数据包则表明在TCP握手过程中存在一些问题——比如发生了服务或应用程序异常以及系统资源不足等故障。</li>
</ul>
<p>下图显示了Alice和Bob之间正常的TCP三次握手过程，在现实生活中，这将发生在两个设备之间：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326214033986.png"
                      alt="image-20230326214033986"
                ></p>
<p>在TCP三次握手过程中，客户端所发送的数据将被赋予一个随机数序列，这个数字序列接下来将进行重构并递增1；两台计算机设备必须就相同的数字序列达成一致，才能以正确的顺序发送数据，这个顺序是在三个步骤中商定的（下面步骤中的序列号是随机值）：</p>
<ul>
<li>SYN-Client：客户端将设置用于同步的SYN标志位并生成一个随机初始序列号(ISN)——0 。</li>
<li>SYN&#x2F;ACK-Server：服务器端将设置SYN标志位和ACK标志位并生成一个随机初始序列号(5000)，并对客户端的初始序列号(0)进行确认（ACK&#x3D;0+1）。</li>
<li>ACK-Client： 客户端设置ACK标志位，并对服务器端的初始序列号(5000)进行确认（ACK&#x3D;5000+1）。</li>
</ul>
<p>tips：SYNchronise-SYN(同步)，ACKnowledge-ACK(确认)，Initial Sequence Number-ISN(初始序列号)；以上步骤的结果——客户端ISN+1，服务器端ISN+1。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326221426557.png"
                      alt="image-20230326221426557" style="zoom: 50%;" 
                >

<p><strong>TCP连接的关闭</strong></p>
<p>接下来，让我们简单介绍一下TCP连接关闭背后的过程。</p>
<p>首先，一旦源设备确定目标设备成功接收了所有数据，那么TCP连接就将要被关闭；因为TCP会在设备上占用一些系统资源，所以最好在不需要的时候尽快关闭TCP连接。</p>
<p>为了启动TCP连接的关闭过程，设备将发送一个“FIN”数据包到另一个设备，当然，这仍基于TCP协议，其他设备也必须确认这个“FIN”数据包。</p>
<p>让我们像前文一样使用Alice和Bob来展示这个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326223520503.png"
                      alt="image-20230326223520503"
                ></p>
<p>在上图中，我们可以看到Alice首先向Bob发送一个“FIN”包，当Bob收到这个消息之后，Bob会让Alice知道他已经收到消息(ACK)，并且Bob将表示他也想要关闭连接(FIN)，而Alice在收到来自于Bob的消息(ACK+FIN)之后，将进行最终的确认(ACK)——结果是TCP连接被成功关闭。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326224720813.png"
                      alt="image-20230326224720813"
                ></p>
<h2 id="关于三次握手的模拟练习"><a href="#关于三次握手的模拟练习" class="headerlink" title="关于三次握手的模拟练习"></a>关于三次握手的模拟练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：以正确的顺序重新组装TCP握手过程，以帮助 Alice 和 Bob 进行通信，在 Alice 与 Bob 的对话结束后会给出一个flag值。</em></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em><strong>Part1：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225206394.png"
                      alt="image-20230326225206394" style="zoom:50%;" 
                >

<p><em><strong>Part2：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225315154.png"
                      alt="image-20230326225315154" style="zoom:50%;" 
                >

<p><em><strong>Part3：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225411070.png"
                      alt="image-20230326225411070" style="zoom:50%;" 
                >

<p><em><strong>Part4：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225512847.png"
                      alt="image-20230326225512847" style="zoom:50%;" 
                >

<p><em><strong>Part5：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225632300.png"
                      alt="image-20230326225632300" style="zoom:50%;" 
                >

<p><em><strong>Part6：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225759731.png"
                      alt="image-20230326225759731" style="zoom:50%;" 
                >

<p><em><strong>Part7：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225838033.png"
                      alt="image-20230326225838033" style="zoom:50%;" 
                >

<p><em><strong>Part8：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225910031.png"
                      alt="image-20230326225910031" style="zoom:50%;" 
                >

<p>对话结束，得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225933032.png"
                      alt="image-20230326225933032"
                ></p>
<blockquote>
<p>最后得到的flag值为：THM{TCP_CHATTER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225109100.png"
                      alt="image-20230326225109100"
                ></p>
<h2 id="UDP-IP介绍"><a href="#UDP-IP介绍" class="headerlink" title="UDP&#x2F;IP介绍"></a>UDP&#x2F;IP介绍</h2><p>用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)是另一种用于设备之间进行数据通信的协议。</p>
<p>与TCP不同，UDP是一种无状态协议，它不需要通过在两个设备之间保持恒定的连接来发送数据；UDP协议不会发生三次握手过程，两个互相通信的设备之间也不存在任何同步。</p>
<p>UDP主要用于应用程序可以容忍数据丢失的情况下(如视频流程序或语音聊天程序)，下面是对UDP协议的优缺点比较：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>如前所述，在两台设备之间建立UDP连接时不会发生任何过程，这意味着UDP不考虑数据是否被接收，也没有TCP所提供的保护措施（例如保护数据完整性）。</p>
<p>UDP数据包比TCP数据包简单得多，并且有更少的标头，然而，这两个协议也能共享一些标准的标头，如下所示：</p>
<ul>
<li>Time to Live (TTL-生存时间)：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Source Address(源地址)：发送数据包的设备的IP地址，以便数据知道返回到哪里。</li>
<li>Destination Address(目标地址)：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
<li>Source Port(源端口)：此值是发送方为发送TCP数据包而打开的端口，该端口号的值是随机选择的(从0-65535之间 选择尚未被使用的端口)。</li>
<li>Destination Port(目标端口)：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Data(数据)：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
</ul>
<p>通过UDP通信与通过TCP通信的过程是不同的，我们应该记住UDP协议是无状态的，在UDP传输数据期间并不会发送确认数据包（ACK）</p>
<p>下图显示了Alice和Bob之间的正常UDP通信，在现实生活中，UDP通信过程将发生在两个设备之间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234005977.png"
                      alt="image-20230326234005977"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234125159.png"
                      alt="image-20230326234125159"
                ></p>
<h2 id="端口基础介绍-相关实例练习"><a href="#端口基础介绍-相关实例练习" class="headerlink" title="端口基础介绍&amp;相关实例练习"></a>端口基础介绍&amp;相关实例练习</h2><p><strong>端口基础介绍</strong></p>
<p>Port(端口)是数据进行交换的关键点，Port也有港口的含义，此名称或许恰如其分；你可以想象在海边有一个又一个港口，所有想要靠岸停放的船舶都必须前往与船舶尺寸和船舶用途相匹配的港口，例如，一艘游轮不能停靠在为渔船而建造的港口处，反之亦然。</p>
<p>这些端口会规定什么服务才可以使用什么端口号——如果某个服务和某个端口不兼容，就不能为该服务分配此端口；网络设备在相互通信时也将使用端口来执行一些严格的规则，当两个设备建立起连接之后，设备所发送或接收的任何数据都将通过端口进行通信。</p>
<p>在计算机中，端口号所对应的是 0 到 65535 之间的数值。</p>
<p>由于端口的范围可以是0-65535之间的任何数值，因此很快就会出现难以跟踪哪个应用程序正在使用哪个端口的风险，值得庆幸的是，我们能够将应用程序、软件和行为与一组标准规则相关联；例如，通过强制任何web浏览器的数据都必须通过端口80发送，软件开发人员可以设计出多种使用80端口进行通信的web浏览器，如Chrome浏览器、Firefox浏览器等，而这些浏览器最终都能以相同的方式解释数据。</p>
<p>这意味着现在所有的浏览器都有一个共同的标准规则——通过80端口发送数据；但是浏览器的外观、使用感觉和易用性则取决于设计师或用户的个人选择。</p>
<p>除了web浏览器的标准规则是“使用端口80进行通信”之外，其他一些协议也已经分配了对应的标准规则，接下来我们将探讨 和一些其他协议相对应的标准规则：</p>
<p><em>tips：任何在 0 到 1024 之间的端口都被称为普通端口。</em></p>
<ul>
<li><strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol (<strong>FTP</strong>协议)：文件传输协议；默认使用21端口；此协议用于构建在客户机-服务器(C&#x2F;S)模型上的文件共享应用程序，这意味着你可以从FTP服务器上下载文件。</li>
<li><strong>S</strong>ecure <strong>Sh</strong>ell (<strong>SSH</strong>协议)：安全外壳协议；默认使用22端口；该协议可用于通过基于文本的管理界面安全地登录目标系统。</li>
<li><strong>H</strong>yper<strong>T</strong>ext Transfer Protocol (<strong>HTTP</strong>协议)：超文本传输协议；默认使用80端口；这个协议为万维网(WWW)提供了基础，你的浏览器能够使用该协议来访问或者下载网页上的文本、图像和视频等资源。</li>
<li><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure (<strong>HTTPS</strong>协议)：超文本传输安全协议；默认使用443端口；该协议与HTTP协议相同，但是另外还增加了安全加密特性。</li>
<li><strong>S</strong>erver <strong>M</strong>essage <strong>B</strong>lock (<strong>SMB</strong>协议)：服务器消息块协议，是一种网络文件系统访问协议；默认使用445端口；该协议类似于文件传输协议(FTP)，但是，除了文件之外，SMB协议还允许你共享打印机等设备。</li>
<li><strong>R</strong>emote <strong>D</strong>esktop <strong>P</strong>rotocol (<strong>RDP</strong>协议)：远程桌面协议；默认使用3389端口；该协议是一种使用可视桌面界面登录目标系统的安全方法(与SSH协议基于文本界面的限制不同)。</li>
</ul>
<p>我们在此只是简单地介绍了网络安全中的一些常见协议，你可以在以下链接中找到1024个常用端口列表：</p>
<blockquote>
<p><a class="link"   href="http://www.vmaxx.net/techinfo/ports.htm" >http://www.vmaxx.net/techinfo/ports.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>注意：上述这些协议只是默认会遵循标准规则来使用端口，也就是说，你其实可以在不同的端口上来管理与协议交互的应用程序，而不只是使用标准端口(比如在8080端口上而不是在80标准端口上运行web服务器)；但是应用程序将假定遵循标准规则来使用端口，因此你在通过浏览器访问目标服务器时——必须在URL的最后提供冒号(:)并加上具体的端口号。</p>
<p><strong>实例练习</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过端口“1234”连接到目标IP地址“8.8.8.8”，最后将收到一个flag。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327011252012.png"
                      alt="image-20230327011252012" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{YOU_CONNECTED_TO_A_PORT} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230327011307845.png"
                      alt="image-20230327011307845"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-What is Networking？(什么是网络？)-学习</title>
    <url>/2024/01/18/THM-What%20is%20Networking%EF%BC%9F(%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%EF%BC%9F)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/whatisnetworking" >https://tryhackme.com/room/whatisnetworking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：学习一些关于计算机网络的基础知识。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络是连接在一起的东西，例如，你的朋友圈：你们都因为相似的兴趣、爱好、技能和类型而联系在一起。</p>
<p>网络可以在各行各业中找到:</p>
<ul>
<li>城市公共交通系统</li>
<li>国家电网等基础设施</li>
<li>你和邻居会见和互相问候</li>
<li>邮寄信件和包裹的邮政系统</li>
</ul>
<p>在计算机领域，网络的概念和上述例子类似，只是分散到了各个技术设备上；以你的手机为例，你拥有它的原因是为了获取东西。我们将介绍这些设备如何相互通信以及它们遵循什么规则。</p>
<p>在计算机领域，一个网络可以由2个到数十亿个设备组成，这些设备包括你的笔记本电脑和手机，安全摄像头，交通信号灯，甚至农场。</p>
<p>网络已经融入了我们的日常生活，无论是收集天气数据，还是为家庭供电，甚至是确定谁在道路上有优先通行权都和网络有所关联；由于网络是嵌入在现代社会中的，所以网络也是网络安全中必须掌握的一个基本概念。</p>
<p>以下图为例，Alice, Bob和Jim已经组成了他们的网络。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111701678.png"
                      alt="image-20230325111701678"
                ></p>
<p>网络有各种各样的形状和大小，这也是我们将在本文中讨论的内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111758447.png"
                      alt="image-20230325111758447"
                ></p>
<h2 id="什么是互联网？"><a href="#什么是互联网？" class="headerlink" title="什么是互联网？"></a>什么是互联网？</h2><p>现在我们已经了解了什么是网络，以及在计算机中网络是如何定义的(在计算机领域：网络表示多个连接的设备)，让我们来探索什么是互联网。</p>
<p>互联网是一个巨大的网络，它由许许多多小网络组成。基于上一小节中的例子，现在让我们想象 Alice 交了一些名叫 Zayn 和 Toby 的新朋友，她想把他们介绍给Bob和Jim，而问题是Alice是唯一一个和Zayn和Toby说同一种语言的人，所以Alice必须成为传达信息的信使。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325112358537.png"
                      alt="image-20230325112358537"
                ></p>
<p>因为Alice会说两种语言，上图中的其他人可以通过Alice实现互相交流——这从而形成一个新的网络。</p>
<p>互联网的第一次迭代是在20世纪60年代末的 ARPANET 项目中，该项目由美国国防部资助，是第一个记录在案的计算机网络；然而，直到1989年，蒂姆·伯纳斯·李 才通过创建万维网(WWW-<strong>W</strong>orld <strong>W</strong>ide <strong>W</strong>eb) 发明了我们现在所知道的互联网，至此，互联网才开始被用作存储和共享信息的存储库(就像今天一样)。</p>
<p>让我们将上面例子中的Alice的朋友网络与计算机设备联系起来，互联网看起来将像下面这类图表的放大版:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325113424671.png"
                      alt="image-20230325113424671"
                ></p>
<p>如前所述，互联网是由许多小型网络连接在一起组成的；这些小网络被称为专用网络(private networks)，连接这些小网络的网络被称为公共网络(private networks)——也就是Internet 。所以，我们可以概括得出，计算机网络可以是以下两种类型之一：</p>
<ul>
<li>Private network（专用网络）</li>
<li>Public network（公共网络）</li>
</ul>
<p>tips：在网络上，计算机设备将使用一组标签来标识自己。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325114031504.png"
                      alt="image-20230325114031504"
                ></p>
<h2 id="识别网络上的设备"><a href="#识别网络上的设备" class="headerlink" title="识别网络上的设备"></a>识别网络上的设备</h2><p>为了通信和维持秩序，网络上的设备必须具有识别性和可识别性，如果你都不知道你在和谁说话，那么网络又有什么用呢?</p>
<p>计算机网络中的设备与人类非常相似，人类有两种被识别的方式:</p>
<ul>
<li>名字</li>
<li>指纹</li>
</ul>
<p>我们可以改变名字，但是我们不能改变指纹，每个人都有自己的一套指纹，这意味着即使改了名字，我们仍然有唯一的身份标识；在网络中的计算机设备具有类似的被识别方式：</p>
<ul>
<li>IP地址</li>
<li>媒体访问控制(MAC-Media Access Control)地址——可以把它看作是一个类似于序列号的地址。</li>
</ul>
<h3 id="IP-Addresses"><a href="#IP-Addresses" class="headerlink" title="IP Addresses"></a><strong>IP Addresses</strong></h3><p>简单地说，IP地址(或Internet协议)可以在一段时间内用作识别网络上的主机的方式，然后该IP地址也可以（在前一个设备使用该IP地址的时间过期后）与另一个设备相关联，而不会使IP地址发生改变。</p>
<p>让我们精确地划分IP地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325182903071.png"
                      alt="image-20230325182903071"
                ></p>
<p>IP地址是一组共32位的二进制数字，可分为4个8位二进制数，这些 <u>8位二进制数(<em><strong>octet</strong></em>)</u> 的值将被汇总为网络设备的IP地址；这组数字是通过被称为 IP 寻址和子网划分的技术计算出来的，此处需要理解的重点是：IP 地址可以因设备而异，但不能在同一个网络中同时被多个设备使用。</p>
<p>tips：一个字节由8个二进制位组成，所以一个IPv4地址共四个字节。</p>
<p>IP地址遵循一组被称为协议的标准，这些协议是网络的主干，迫使许多设备使用同一种语言进行通信；设备既可以在私有网络（专用网络）上，也可以在公共网络上。根据设备所处的位置，将决定它们所拥有的IP地址类型：公共IP地址或者私有IP地址。</p>
<p>公共地址可用于在Internet上识别设备，而私有地址可用于在其他设备之中识别设备。以下面的表格和截图为例，假如我们有两个设备在专用网络（私有网络）上:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185159663.png"
                      alt="image-20230325185159663"
                ></p>
<p>以上两台设备将能够使用它们的私有IP地址相互通信，但是，从这两台设备发送到Internet的任何数据都将被相同的公共IP地址识别。公共IP地址可由你的互联网服务提供商(ISP-Internet Service Provider)提供，并且按月收费。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185615792.png"
                      alt="image-20230325185615792"
                ></p>
<p>随着越来越多的设备联网，想要获得一个未被使用的公共地址也变得越来越难。根据网络行业巨头思科公司的估计，到2021年底，将有大约500亿台设备连接到互联网(<a class="link"   href="https://www.cisco.com/c/dam/en_us/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf" >思科, 2021 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)。但是IP地址不止一个版本，到目前为止，我们只讨论了一个版本的互联网协议寻址方案，即 IPv4 ，它使用的是一个具有2^32(42.9亿)个IP地址的编号系统。</p>
<p>IPv6是互联网协议寻址方案的新迭代版本，能够帮助解决IP地址短缺的问题，IPv6有一些好处：</p>
<ul>
<li>支持最多2^128(340万亿+)个IP地址，有助于解决IPv4面临的地址短缺问题。</li>
<li>由于采用了新的方法，IPv6的效率更高。</li>
</ul>
<p>下面的截图显示了IPv6地址和IPv4地址的实例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325191000099.png"
                      alt="image-20230325191000099"
                ></p>
<h3 id="MAC-Addresses"><a href="#MAC-Addresses" class="headerlink" title="MAC Addresses"></a><strong>MAC Addresses</strong></h3><p>网络上的设备都有一个物理网络接口，和接口对应的是该设备主板上的一个微型芯片板；设备的物理网络接口会由制造芯片的工厂分配一个唯一的地址，此地址被称为MAC(媒体访问控制-<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol)地址。MAC地址是一个具有十二个字符的十六进制数字(十六进制：是一种以16为基数的数字系统，可用于在计算机中表示数字)，每一位十六进制的数字都代表两个字符，在具体表示十六进制数时会用冒号分隔，这些冒号是分隔符，例如：<code>a4:c3:f0:85:ac:2d</code>。</p>
<p>MAC地址的前六个字符（前三位MAC地址）代表制作物理网络接口的公司，MAC地址的后六个字符则是唯一的数字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325192759185.png"
                      alt="image-20230325192759185"
                ></p>
<p>然而，关于MAC地址的一个有趣的事是，它们可以被伪造或“欺骗”。当一台联网设备使用MAC地址伪装成另一台设备时，就会发生MAC地址欺骗，当MAC地址欺骗发生时，通常会破坏一些实现得很差的安全设计，这些（安全性差的）安全设计会假设在网络上通信的设备是可信的。以下面的场景为例：如果防火墙已被配置为允许管理员 MAC 地址之间发生任何通信，如果一个设备伪造或“欺骗”管理员的MAC地址，防火墙就会认为它正在接收来自管理员的通信（而实际上并没有）。</p>
<p>咖啡馆和酒店等场所在使用“Guest”或“Public”Wi-Fi时经常会使用MAC地址进行控制，这种配置可以提供更好的服务，也就是说，如果你愿意为每台设备支付费用，就可以以一定的价格获得更快的连接。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中 部署交互式实验环境并回答下面问题。</p>
<p><em>tips：此交互式实验环境模拟了酒店的Wi-Fi网络，你必须为上网服务付费。你可以注意到路由器不允许Bob的数据包(蓝色)进入TryHackMe网站，并将这些数据包放入垃圾箱中，但是Alice的数据包(绿色)却可以通过，因为Alice已经支付了使用Wi-Fi所需的费用；现在我们尝试将Bob的MAC地址更改为与Alice的MAC地址相同，看看会发生什么事情。</em></p>
<p>正常的通信情况：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200205269.png"
                      alt="image-20230325200205269" style="zoom:50%;" 
                >

<p>伪装MAC地址进行通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200413832.png"
                      alt="image-20230325200413832" style="zoom:50%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200323536.png"
                      alt="image-20230325200323536"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{YOU_GOT_ON_TRYHACKME} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200012653.png"
                      alt="image-20230325200012653"
                ></p>
<h2 id="关于Ping-ICMP"><a href="#关于Ping-ICMP" class="headerlink" title="关于Ping (ICMP)"></a>关于Ping (ICMP)</h2><p>Ping是我们可用的最基本的网络工具之一。Ping使用ICMP (Internet Control Message Protocol)报文来判断设备之间连接的性能，例如连接是否存在或者连接是否可靠。</p>
<p>如下面的截图所示，ICMP报文在设备之间传输所花费的时间可通过ping来测量；这种测量是使用 ICMP 的回波数据包(echo packet)和来自目标设备的 ICMP 回波应答(echo reply)来完成的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325115450514.png"
                      alt="image-20230325115450514"
                ></p>
<p>Ping可以针对网络上的设备执行，例如你的家庭网络或者网站等资源。ping工具易于使用，并能安装在Linux和Windows等操作系统上，执行 ping 命令的简单语法是 <code>ping IP address or website URL</code> 。</p>
<p>基于上面的ping命令示例截图：我们正在ping一个私有地址为192.168.1.254的设备，我们可以看到已发送了6个ICMP数据包（手动按ctrl+c按键停止ping命令），所有这些数据包是在平均5.3秒的时间内收到的。</p>
<p><strong>答题</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答下面问题。</p>
<p><em>tips：在部署的实验环境中对地址“8.8.8.8”使用ping命令。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120527199.png"
                      alt="image-20230325120527199"
                ></p>
<blockquote>
<p>执行ping命令得到的flag为：THM{I_PINGED_THE_SERVER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120413513.png"
                      alt="image-20230325120413513"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-DNS in detail(DNS基础详解)-学习</title>
    <url>/2024/01/21/THM-DNS%20in%20detail(DNS%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/dnsindetail" >https://tryhackme.com/room/dnsindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解DNS协议是如何工作的，以及DNS如何帮助我们访问互联网服务。</p>
<h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 指 Domain Name System，即域名系统，DNS能为我们提供一种简单的方式来与互联网上的设备进行通信，而不需要记住复杂的IP地址。</p>
<p>就像每个家庭都有一个唯一的地址能够用来直接发送和接收邮件一样，互联网上的每台计算机也都有自己唯一的地址能够用于通信，这个地址被称为IP地址。</p>
<p>IP地址的格式如下：104.26.10.229，主要由4组0 ~ 255的二进制数字组成，中间用英文句点号隔开。当你想用浏览器来访问一个网站时，选择记住和目标网站相对应的那组复杂的IP地址 可能并不太方便，这就是DNS可以帮助我们的地方。在使用了DNS协议之后，我们就不需要记住类似于 104.26.10.229 的IP地址，而是可以选择记住和IP地址对应的域名如：tryhackme.com 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231452919.png"
                      alt="image-20230327231452919"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231521741.png"
                      alt="image-20230327231521741"
                ></p>
<h2 id="域层次结构"><a href="#域层次结构" class="headerlink" title="域层次结构"></a>域层次结构</h2><p><strong>Domain Hierarchy示意图</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233305530.png"
                      alt="image-20230327233305530"
                ></p>
<p><strong>Top-Level Domain(TLD-顶级域)</strong></p>
<p>TLD指的是域名最右边的部分，例如，tryhackme.com的顶级域名是.com；TLD有两种类型，包括gTLD(通用顶级域)和ccTLD(国家代码顶级域)。</p>
<p>在计算机历史上，通用顶级域名主要用于告诉用户“域名的用途”，例如，.com用于商业目的，.org用于组织，.edu用于教育，.gov用于政府；而ccTLD的用途是表示地理位置，例如.ca表示位于加拿大的网站，.co.uk表示位于英国的网站等等。基于用户需求，新的通用顶级域名在大量涌入，包括.online，.club，.website，.biz等等。</p>
<p>要查看超过2000个顶级域名的完整列表，请访问以下链接：</p>
<p><a class="link"   href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt" >https://data.iana.org/TLD/tlds-alpha-by-domain.txt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>tips：gTLD - Generic Top Level、ccTLD - Country Code Top Level Domain 。</em></p>
<p><strong>Second-Level Domain(二级域)</strong></p>
<p>以tryhackme.com为例，.com部分是TLD，tryhackme部分则是二级域名。在进行域名注册时，二级域名被限制最长可使用63个字符+顶级域名(TLD)，在具体的二级域名部分只能使用”<code>a-z</code>“、”<code>0-9</code>“和连字符”<code>-</code>“(不能以连字符开头或结尾，也不能使用连续的连字符)。</p>
<p><strong>Subdomain(子域)</strong></p>
<p>在一个完整的域名中，子域位于二级域的左侧，两者之间将使用英文句点分隔，例如，在一个域名 admin.tryhackme.com 中，admin部分就是子域。</p>
<p>子域名的创建限制与二级域名相同，都被限制为最长可用63个字符，并且同样只能使用A -z 0-9和连字符(不能以连字符开头或结尾或使用连续连字符)。</p>
<p>在一个域名中，我们可以同时使用多个子域，只要用英文句点分隔即可，由此我们便能创建一个较长的域名，例如 jupiter.servers.tryhackme.com ，但是域名的整体长度必须控制在253个字符以内，也就是说：在域名整体长度没超过限制的情况下，我们可以为一个域名创建多个子域名且无数量限制。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328001000917.png"
                      alt="image-20230328001000917"
                ></p>
<h2 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h2><p>我们已经知道DNS可用于寻找目标网站，此外，还存在多种类型的DNS记录，接下来我们将介绍一些常见的DNS记录类型。</p>
<p><strong>A 记录</strong></p>
<p>此类DNS记录将被解析为IPv4地址，例如：<code>104.26.10.229</code></p>
<p><strong>AAAA 记录</strong></p>
<p>此类DNS记录将被解析为IPv6地址，例如：<code>2606:4700:20::681a:be5</code></p>
<p><strong>CNAME 记录</strong></p>
<p>此类DNS记录将被解析到另一个域名，例如，TryHackMe的在线商店有一个子域名store.tryhackme.com，它能返回一个CNAME记录shops.shopify.com，然后再向shops.shopify.com发出另一个DNS请求，就能计算出相关的IP地址。</p>
<p><strong>MX 记录</strong></p>
<p>此类DNS记录将被解析为 处理你正在查询的域的电子邮件服务器地址，例如 tryhackme.com 的MX记录响应可能为 alt1.aspmx.l.google.com ；这类记录还会带有一个优先级值，此值将告诉客户端以什么顺序来尝试访问电子邮件服务器，如果主电子邮件服务器宕机，则可以将电子邮件发送到备份电子邮件服务器。</p>
<p><strong>TXT 记录</strong></p>
<p>TXT记录是自由文本字段，任何基于文本的数据都可以存储在其中。TXT记录有多种用途，一些常见的用途是 列出有权代表域发送电子邮件的服务器(这可以帮助对抗垃圾邮件和钓鱼邮件)，TXT记录还可用于 在注册第三方服务时验证域名的所有权。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003618226.png"
                      alt="image-20230328003618226"
                ></p>
<h2 id="发出DNS请求"><a href="#发出DNS请求" class="headerlink" title="发出DNS请求"></a>发出DNS请求</h2><p><strong>当你发出DNS请求时会发生什么？</strong></p>
<ol>
<li>当你请求一个域名时，你的计算机首先会检查它自身的本地缓存，看看你最近是否查询过这个地址(即查看缓存中是否已经为目标网站存储了一个相关的 IP 地址)，如果发现本地缓存中无相关记录，你的计算机则将向递归(<em><strong>recursive</strong></em>)DNS服务器发送DNS请求。</li>
<li>递归DNS服务器通常会由你的Internet 服务提供商(即ISP，在中国是移动、联通等)提供，但你也可以选择一些其他的递归DNS服务器。递归DNS服务器会带有一个关于“最近查找过的域名”的本地缓存，如果在此缓存中找到结果，则相关的信息将被发送回你的计算机，你的DNS请求也会在这里结束(这种域名请求情况对于谷歌、Facebook、Twitter等受欢迎以及域名请求频率很高的网站服务来说很常见)。如果在递归DNS服务器的本地缓存中无法找到域名请求的结果，接下来就会开始从互联网的根DNS服务器尝试寻找关于域名请求的正确答案。</li>
<li>根DNS服务器是互联网的DNS主干，它们的工作是将域名请求重定向到正确的顶级域服务器，重定向的结果取决于你的域名请求内容：例如，如果你请求<a class="link"   href="http://www.tryhackme.com,那么根dns服务器将识别到.com的顶级域名,并会将你指向处理.com地址的正确tld(顶级域)服务器./" >www.tryhackme.com，那么根DNS服务器将识别到.com的顶级域名，并会将你指向处理.com地址的正确TLD(顶级域)服务器。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>TLD服务器会保存“在哪里能找到响应DNS请求的权威服务器”的记录。权威服务器通常也被称为域的名称服务器，例如<a class="link"   href="http://www.tryhackme.com/" >www.tryhackme.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的名称服务器是<code>kip.ns.cloudflare.com</code>和<code>uma.ns.cloudflare.com</code>，一个域名可能会有多个域名服务器，这是为了形成备份以防宕机。（简而言之：当 TLD 服务器收到我们的域名请求时，TLD服务器会将域名请求信息传递给适当的权威名称服务器，而权威名称服务器主要用于直接存储域的 DNS 记录）</li>
<li>权威DNS服务器是负责存储特定域名的DNS记录的服务器，并且能对所存储的DNS记录进行及时更新。基于DNS记录的不同类型会有多条DNS记录内容，而这些与你的域名请求相关的DNS记录都存储在权威DNS服务器中，当域名请求到达权威DNS服务器之后，权威DNS服务器会将这些与你的域名请求相关的DNS记录 发送回递归DNS服务器，递归DNS服务器将会为这些DNS记录缓存一个本地副本 以备将来的请求所需，然后这些DNS记录将被转发回 发出域名请求的原始客户端机器。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328113758899.png"
                      alt="image-20230328113758899"
                ></p>
<p>Tips：每个DNS记录都会带有一个TTL（Time To Live-生存时间）值，这个值是一个以秒表示的数字，所有不超过TTL时间的DNS记录都会持续存储在计算机的本地缓存中，如果本地缓存中的DNS记录过期，那么在下次请求域名时，你可能需要再次获取相关的DNS记录（这将重复上述过程）。通过使用计算机本地缓存中的DNS记录——可以节省每次与目标服务器进行通信时 所消耗的DNS请求响应时间。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003958971.png"
                      alt="image-20230328003958971"
                ></p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：在模拟界面构建请求以进行DNS查询并查看结果。</em></p>
<p>查询 shop.website.thm 的CNAME记录：<code>nslookup --type=CNAME shop.website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232336558.png"
                      alt="image-20230327232336558"
                ></p>
<blockquote>
<p>shop.website.thm 的CNAME记录是：shops.myshopify.com 。</p>
</blockquote>
<p>查询 website.thm 的TXT记录：<code>nslookup --type=TXT website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232618617.png"
                      alt="image-20230327232618617"
                ></p>
<blockquote>
<p>website.thm 的TXT记录是：THM{7012BBA60997F35A9516C2E16D2944FF} 。</p>
</blockquote>
<p>查看 website.thm 的MX记录的数字优先级值：<code>nslookup --type=MX website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232832550.png"
                      alt="image-20230327232832550"
                ></p>
<blockquote>
<p>website.thm 的MX记录的数字优先级值为：30 。</p>
</blockquote>
<p>查看 website.thm 的A记录的IP地址：<code>nslookup --type=A website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233114182.png"
                      alt="image-20230327233114182"
                ></p>
<blockquote>
<p>website.thm 的A记录的IP地址为：10.10.10.10 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233202973.png"
                      alt="image-20230327233202973"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-HTTP in detail(HTTP协议介绍)-学习</title>
    <url>/2024/01/27/THM-HTTP%20in%20detail(HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/httpindetail" >https://tryhackme.com/room/httpindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何使用 HTTP 协议向 Web 服务器请求内容。</p>
<h2 id="什么是-HTTP-S"><a href="#什么是-HTTP-S" class="headerlink" title="什么是 HTTP(S)?"></a>什么是 HTTP(S)?</h2><p><strong>什么是 HTTP？ （HyperText Transfer Protocol-超文本传输协议）</strong></p>
<p>HTTP 是你浏览网站时使用的，由 Tim Berners-Lee 和他的团队在 1989-1991 年间开发。 HTTP 是用于与web服务器进行通信以便传输网页数据的一组规则，这些网页数据包括 HTML、图像、视频等。</p>
<p><strong>什么是 HTTPS？ （HyperText Transfer Protocol Secure）</strong></p>
<p>HTTPS 是 HTTP 的安全版本。 HTTPS 数据经过了加密处理，因此它不仅可以阻止第三方看到你正在接收和发送的数据内容，而且还可以确保你正在与正确的 Web 服务器进行通信（而不是其他冒充你所访问的目标web服务器的东西）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118214001544.png"
                      alt="image-20221118214001544"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118215932057.png"
                      alt="image-20221118215932057"
                ></p>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>当我们访问一个网站时，你的浏览器将需要向一个web服务器发出请求，以获得诸如 HTML、图像等资源，并根据来自web服务器的响应得到下载权限。在此之前，你需要明确地告诉浏览器如何获取以及在哪里访问具体的资源文件，这里就需要 URL 来提供一些帮助。</p>
<p><strong>什么是 URL? (Uniform Resource Locator)</strong></p>
<p>如果你使用过互联网，那么你就使用过 URL，URL 主要用于指示如何访问互联网上的资源。下面的图片显示了一个 URL 的所有特性(它可能不会在每个请求中使用所有特性)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119090841555.png"
                      alt="image-20221119090841555"
                ></p>
<ul>
<li>Scheme：这说明了使用什么协议来访问资源，如HTTP、HTTPS、FTP(文件传输协议)。</li>
<li>User：有些服务需要认证以完成登录，你可以在URL中输入用户名和密码进行登录。</li>
<li>Host&#x2F;Domain：你希望访问的服务器的域名或IP地址。</li>
<li>Port：你将要连接到的端口，通常HTTP协议将使用 80 端口，HTTPS协议将使用 443 端口，但是这些协议也可以选择使用 1 - 65535 之间的任何端口号。</li>
<li>Path：你试图访问的资源的文件名或位置。</li>
<li>Query String：可以发送到请求路径的额外信息位。例如，&#x2F;blog?id &#x3D;1 将告诉blog path你希望接收id为1的博客文章。</li>
<li>Fragment：这是对所请求的实际页面上的位置的引用。这通常用于具有较长内容的页面，并且可以将页面的某一部分直接链接到该引用；因此，只要用户通过该URL访问页面，就可以看到链接所对应的部分内容。</li>
</ul>
<p><strong>发出请求</strong></p>
<p>只需要一行”GET &#x2F; HTTP&#x2F;1.1”就可以向web服务器发出请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119092848618.png"
                      alt="image-20221119092848618"
                ></p>
<p>但为了获得更丰富的网络体验，你还需要通过请求消息发送其他数据，这些数据将通过请求报头进行发送，在请求报头中也会包含一些额外的信息，以提供给与你进行通信的web服务器。</p>
<p><strong>请求示例（由浏览器客户端发送至服务器端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: tryhackme.com</span><br><span class="line">User-Agent: Mozilla/5.0 Firefox/87.0</span><br><span class="line">Referer: https://tryhackme.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>分解以上请求示例的每一行:</p>
<ul>
<li>第1行：这个请求将发送GET方法(详见本文的HTTP方法小节)，用<code>/</code>请求主页，并告诉web服务器我们正在使用的HTTP协议版本为<code>1.1</code>。</li>
<li>第2行：我们将告诉web服务器我们想要访问域名为<code>tryhackme.com</code>的网站。</li>
<li>第3行：我们将告诉web服务器我们正在使用Firefox 87版本浏览器。</li>
<li>第4行：我们正在告诉web服务器，将我们指向当前页面的来源网址（引用页）是<code>https://tryhackme.com</code></li>
<li>第5行：HTTP请求总是以空行结束，以通知web服务器该HTTP请求已经完成。</li>
</ul>
<p><strong>响应示例（由服务器端发送至浏览器客户端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.15.8</span><br><span class="line">Date: Fri, 09 Apr 2021 13:34:03 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 98</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TryHackMe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Welcome To TryHackMe.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>分解以上响应示例的每一行:</p>
<ul>
<li><p>第1行：HTTP 1.1是服务器正在使用的HTTP协议版本，然后是HTTP状态码(在本例中为“200 Ok”)，它告诉我们该响应对应的请求已经成功完成。</p>
</li>
<li><p>第2行：这告诉我们web服务器使用的软件和其版本号。</p>
</li>
<li><p>第3行：web服务器的当前日期、时间和时区。</p>
</li>
<li><p>第4行：Content-Type报头会告诉客户端该web服务器将要发送什么类型的信息，比如HTML、图像、视频、pdf、XML。</p>
</li>
<li><p>第5行：Content-Length将告诉客户端该响应的长度，这样我们就可以确认没有发生数据丢失。</p>
</li>
<li><p>第6行：HTTP响应包含一个空行，用于确认HTTP响应的结束。</p>
</li>
<li><p>第7-14行：被请求的信息，在本例中是关于目标主页的html代码。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119100339290.png"
                      alt="image-20221119100339290"
                ></p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP 方法是客户端在发出 HTTP 请求时显示其预期操作的一种方式。有很多 HTTP 方法，在此我们将介绍最常见的方法，在大多数情况下你将处理的是 GET 和 POST 方法。</p>
<p>GET 请求：用于从 Web 服务器中获取信息。</p>
<p>POST 请求：用于向 Web 服务器提交数据并可能创建新记录。</p>
<p>PUT 请求：用于向 Web 服务器提交数据以更新信息。</p>
<p>DELETE 请求：用于从Web服务器中删除信息&#x2F;记录。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119101025366.png"
                      alt="image-20221119101025366"
                ></p>
<h2 id="HTTP状态代码"><a href="#HTTP状态代码" class="headerlink" title="HTTP状态代码"></a>HTTP状态代码</h2><p><strong>HTTP状态码</strong></p>
<p>在前面的叙述中，你能了解到当 HTTP 服务器发出响应时，第一行总是会包含一个状态代码，该状态码用于通知客户端所发出请求对应的结果以及针对请求的可能处理方式。 这些状态码可以分为 5 个不同的范围：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119110901244.png"
                      alt="image-20221119110901244"
                ></p>
<p><strong>常见的HTTP状态码</strong></p>
<p>有很多不同的 HTTP 状态码，这还不包括应用程序自己定义的状态码，我们将介绍一些你可能遇到的最常见的 HTTP 响应状态码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111632793.png"
                      alt="image-20221119111632793"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111654255.png"
                      alt="image-20221119111654255"
                ></p>
<h2 id="请求标头和响应标头"><a href="#请求标头和响应标头" class="headerlink" title="请求标头和响应标头"></a>请求标头和响应标头</h2><p>标头是你在发出请求时可以发送到 Web 服务器的额外数据位。</p>
<p>虽然在发出 HTTP 请求时没有严格要求标头，但在缺少标头的情况下，你会发现你很难正确地查看网站。</p>
<p><strong>常见的请求头</strong></p>
<p>以下是从客户端（通常是你的浏览器）发送到服务器端的标头信息。</p>
<p>Host：一些 Web 服务器可能会在多个网站上托管内容，因此通过提供主机标头，你可以告诉web服务器你需要访问哪个网站，否则你只会收到web服务器对应的默认网站的响应。</p>
<p>User-Agent：这是你所使用的浏览器软件类型和版本号，告诉web服务器你的浏览器软件类型能帮助它为你的浏览器正确格式化网站，而且网站相关的 HTML、JavaScript 和 CSS 的一些元素只在某些浏览器中可用。</p>
<p>Content-Length：当向 Web 服务器发送数据时，例如当浏览器通过表单向web服务器发送数据时，Content-Length将告诉 Web 服务器该 Web 请求所期望的数据长度，这样web服务器就可以确保它在响应浏览器请求时并不会丢失任何数据。</p>
<p>Accept-Encoding：这将告诉web服务器 当前使用的浏览器支持什么类型的压缩方法，这样数据就可以变小以便通过互联网进行传输。</p>
<p>Cookie：Cookie 是发送到服务器以帮助记住你的信息的数据。</p>
<p><strong>常见的响应头</strong></p>
<p>以下是发出请求后从服务器端返回给浏览器客户端的标头信息。</p>
<p>Set-Cookie：表示浏览器端要存储的Cookie信息，之后每次浏览器发出请求时，Cookie值都会发送回 Web 服务器。</p>
<p>Cache-Control：在再次请求之前，响应内容在浏览器缓存中将存储多长时间。</p>
<p>Content-Type：这将告诉客户端 从web服务器端所返回的数据类型，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用Content-Type标头，浏览器才能知道如何处理数据。</p>
<p>Content-Encoding：在通过 Internet 发送数据时，web服务器将使用什么方法压缩数据以使其更小。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119173812275.png"
                      alt="image-20221119173812275"
                ></p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>Cookie是存储在你的计算机上的一小段数据。 当你从web服务器收到“Set-Cookie”标头时，对应的Cookie信息将被浏览器保存，然后，你发出的每一个进一步请求，都会将 Cookie 数据发送回web服务器。 由于 HTTP 是无状态的（不跟踪你之前的请求），所以 Cookie 可用于提醒web服务器你的身份、网站的一些个人设置或者你以前是否访问过该网站。 </p>
<p>让我们看一下下面这个 HTTP 请求示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119181012864.png"
                      alt="image-20221119181012864"
                ></p>
<p>Cookie 可用于多种用途，但最常用于网站身份验证。 cookie 值通常不会是一个可以让你直接看到密码的明文字符串，而会是一个令牌-token（具有不容易被猜到的唯一密码）。</p>
<p><strong>查看你的 Cookie</strong></p>
<p>你可以使用浏览器中的开发者工具查看你的浏览器向网站发送了哪些 cookie。 </p>
<p>打开开发人员工具后，单击“网络”选项卡。 此选项卡将向你显示你的浏览器已请求的所有资源的列表，你可以单击每一个子项以查看请求和响应的详细分类信息。 如果你的浏览器发送了 cookie，你将在请求消息的“Cookie”选项卡上看到具体的cookie内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119223656762.png"
                      alt="image-20221119223656762"
                ></p>
<h2 id="发送请求-练习"><a href="#发送请求-练习" class="headerlink" title="发送请求-练习"></a>发送请求-练习</h2><p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231104215.png"
                      alt="image-20221119231104215"
                ></p>
<p>问题一：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231159570.png"
                      alt="image-20221119231159570"
                ></p>
<p>问题二：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231302404.png"
                      alt="image-20221119231302404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../articleimg/image-20221119231321822.png"
                      alt="image-20221119231321822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231429010.png"
                      alt="image-20221119231429010"
                ></p>
<p>问题三：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231552049.png"
                      alt="image-20221119231552049"
                ></p>
<p>问题四：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231713945.png"
                      alt="image-20221119231713945"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231851305.png"
                      alt="image-20221119231851305"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231940989.png"
                      alt="image-20221119231940989"
                ></p>
<p>问题五：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232113263.png"
                      alt="image-20221119232113263"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232238841.png"
                      alt="image-20221119232238841"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232319559.png"
                      alt="image-20221119232319559"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119230941300.png"
                      alt="image-20221119230941300"
                ></p>
]]></content>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
</search>
