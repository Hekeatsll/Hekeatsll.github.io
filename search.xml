<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>THM-Careers in Cyber(网络安全职业介绍)-学习</title>
    <url>/2024/01/16/THM-Careers%20in%20Cyber(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%8C%E4%B8%9A%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：了解网络安全领域的不同职业。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络安全行业有许多不同的工作种类，主要分为进攻性安全（对目标进行渗透测试以及产出漏洞报告）和防御性安全（防御、调查网络攻击）。</p>
<p>本文将通过提供有关各种网络安全角色的基础信息介绍来帮助你了解网络安全领域的职业情况；在本文的内容中还会给出一些相关的链接，这些链接将指向Tryhackme平台上的不同学习路径，你可以使用这些路径进行学习从而培养你的网络安全技能（这里指的是基础级别的技能）。</p>
<h2 id="安全分析师-Security-Analyst"><a href="#安全分析师-Security-Analyst" class="headerlink" title="安全分析师(Security Analyst)"></a>安全分析师(Security Analyst)</h2><p>此职业主要负责维护组织的数据安全性。安全分析师是跨组织构建安全措施以保护公司免受攻击不可或缺的一部分，分析师将探索和评估公司网络，以发现可操作的数据并建议工程师制定预防措施。 此工作角色需要与各种利益相关者合作，以了解安全要求和安全形势。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/5504f125b74401f8633bccd831e4c785.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>与各利益相关者合作，分析整个公司的网络安全</li>
<li>编制有关网络安全的持续报告，记录安全问题和建议采取的应对措施</li>
<li>结合对新攻击工具和新攻击趋势的研究：制定安全计划、制定跨团队维护数据安全所需的措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="安全工程师-Security-Engineer"><a href="#安全工程师-Security-Engineer" class="headerlink" title="安全工程师(Security Engineer)"></a>安全工程师(Security Engineer)</h2><p>此职业主要负责设计、监控和维护安全控制、网络和系统，以帮助防御各种网络攻击。安全工程师基于威胁情报和漏洞信息来开发和实施安全解决方案——威胁情报和漏洞信息通常来自安全团队成员。 安全工程师致力于规避各种攻击，包括 Web 应用程序攻击、网络威胁以及不断发展的新型攻击趋势和策略，最终目标是保持并采用安全措施来降低攻击风险和数据丢失风险。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/037b40529f9a15660ee458245c8c14dc.png"
                      alt="img" style="zoom: 50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>跨软件测试和筛选安全措施。</li>
<li>监控网络和报告 以更新系统和缓解漏洞威胁。</li>
<li>确定并实施系统所需的安全解决方案，以获得最佳安全性。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="应急响应人员-Incident-Responder"><a href="#应急响应人员-Incident-Responder" class="headerlink" title="应急响应人员(Incident Responder)"></a>应急响应人员(Incident Responder)</h2><p>此职业主要负责 在攻击者的操作仍在开展时识别并缓解攻击。应急响应人员需要对安全漏洞做出富有成效和高效的响应，工作职责是为组织制定计划、政策和协议，以便在攻击事件发生期间和攻击事件发生后得到执行。这通常是一个压力很大的职位，随着网络攻击的展开，应急响应人员需要实时对攻击进行评估和响应，常用的事件响应指标包括 MTTD、MTTA 和 MTTR等——即平均检测、确认和恢复时间（从网络攻击事件中），应急响应的目的是实现快速有效的响应，保持公司财务状况并避免公司受到负面的违规影响。</p>
<p>简而言之，应急响应人员最终需要保护公司的数据、声誉和财务状况免受网络攻击的影响。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/6a48b0ea257a587d560ffef4b28f4d35.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>制定并采用全面、可操作的事件响应计划</li>
<li>保持强大的安全最佳实践并支持事件响应措施</li>
<li>完成事件后报告并为未来的攻击做准备，适应攻击事件并从攻击事件中吸取教训</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="数字取证审查员-Digital-Forensics-Examiner"><a href="#数字取证审查员-Digital-Forensics-Examiner" class="headerlink" title="数字取证审查员(Digital Forensics Examiner)"></a>数字取证审查员(Digital Forensics Examiner)</h2><p>此职业主要负责进行数字取证以调查网络安全事件和网络安全犯罪行为。如果你喜欢扮演侦探，这可能是一个完美的网络安全工作；如果你是执法部门的一员，你将专注于收集和分析证据以帮助破案：指控有罪者并且为无辜者正名；另一方面，如果你的工作属于保护公司网络的范畴，你将使用数字取证技能来分析事件，例如找出网络攻击者违反法律的证据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/22747e6c2cffce6de0c93f456784be37.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>在遵守法律程序的同时收集数字证据</li>
<li>分析数字证据以找到与案件相关的答案</li>
<li>记录你的发现并在相关案例中进行报告</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="恶意软件分析师-Malware-Analyst"><a href="#恶意软件分析师-Malware-Analyst" class="headerlink" title="恶意软件分析师(Malware Analyst)"></a>恶意软件分析师(Malware Analyst)</h2><p>此职业主要负责分析所有类型的恶意软件以更多地了解它们的工作原理和作用。恶意软件分析师的工作包括分析可疑程序、发现软件的恶意行为并编写有关报告。 恶意软件分析师有时也被称为<em><strong>逆向工程师</strong></em>，因为他们的核心任务围绕着 将已经编译的程序从机器语言转换为可读代码，通常是将低级计算机语言转换为高级语言，这项工作要求恶意软件分析师具有强大的编程背景，尤其是要了解汇编语言和 C 语言等。</p>
<p>恶意软件分析师的最终目标是了解恶意程序执行的所有活动，了解如何检测和报告软件的恶意行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/49b9585d464f633da235ad1ac6e657d8.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对恶意程序进行静态分析，这需要进行逆向工程。</li>
<li>通过观察受控环境中的活动对恶意软件样本进行动态分析。</li>
<li>记录并报告所有发现。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/blueteam" >https://tryhackme.com/path/outline/blueteam <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/soclevel1" >https://tryhackme.com/path/outline/soclevel1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="渗透测试人员-Penetration-Tester"><a href="#渗透测试人员-Penetration-Tester" class="headerlink" title="渗透测试人员(Penetration Tester)"></a>渗透测试人员(Penetration Tester)</h2><p>此职业主要负责测试技术产品的安全漏洞。渗透测试人员也被称为道德黑客，渗透测试人员的工作职责是测试公司内部系统和软件的安全性——通过尝试系统化的黑客攻击行为来发现安全缺陷和安全漏洞。 渗透测试人员利用所发现的漏洞来评估每个实例的风险，然后，公司可以利用相关的漏洞报告来纠正安全问题，以防止现实世界中的网络攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1b9ac0842dca3efabbc15387fc4f0261.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li>对计算机系统、网络和基于 Web 的应用程序进行测试。</li>
<li>执行安全评估、安全审计和安全分析策略。</li>
<li>完成评估并进行报告，推荐攻击预防措施。</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/presecurity" >https://tryhackme.com/path/outline/presecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="红队人员-Red-Teamer"><a href="#红队人员-Red-Teamer" class="headerlink" title="红队人员(Red Teamer)"></a>红队人员(Red Teamer)</h2><p>此职业主要负责在攻防中扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全反馈。红队与渗透测试员有相似之处，但是红队是一个具有更有针对性的工作角色。渗透测试人员往往希望发现系统中的许多漏洞，以保持网络防御的良好状态；而红队则负责测试公司的攻击检测和响应能力，红队人员需要模仿网络罪犯的行为、模拟恶意攻击、保留访问权限(留后门)并避免被发现。红队评估行动往往可以运行一个月之久，这通常是由公司外部的团队来进行的，这些外部团队往往会对拥有成熟安全程序的组织开展红队评估。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/4fa8afd51656c084df33a42566709610.png"
                      alt="img" style="zoom:50%;" 
                >

<p><strong>职责</strong></p>
<ul>
<li><p>模拟威胁行为者的角色，发现可利用的漏洞、维持访问权限（留后门）并避免被发现。</p>
</li>
<li><p>评估目标组织的安全控制、威胁情报和事件响应程序。</p>
</li>
<li><p>完成评估并进行报告，为公司提供可操作的数据以避免真实世界的攻击实例。</p>
</li>
</ul>
<p><strong>Tryhackme平台提供的相关学习路径（基础级别技能）</strong></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/jrpenetrationtester" >https://tryhackme.com/path/outline/jrpenetrationtester <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/pentesting" >https://tryhackme.com/path/outline/pentesting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://tryhackme.com/path/outline/redteaming" >https://tryhackme.com/path/outline/redteaming <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Defensive Security(防御性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Defensive%20Security(%E9%98%B2%E5%BE%A1%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/defensivesecurityhq" >https://tryhackme.com/room/defensivesecurityhq <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：介绍防御性安全和相关主题，例如威胁情报、SOC、DFIR 和 SIEM。</p>
<h2 id="防御性安全简介"><a href="#防御性安全简介" class="headerlink" title="防御性安全简介"></a>防御性安全简介</h2><p>进攻性安全专注于一件事：闯入系统。 进攻性安全领域的职业人员可以通过利用现有错误、滥用不安全的设置以及利用未强制执行的访问控制策略等方式侵入目标系统。 红队和渗透测试人员专注于进攻性安全。</p>
<p>防御性安全在某种程度上与进攻性安全相反，它涉及两个主要任务：</p>
<ul>
<li>防止入侵发生</li>
<li>在入侵发生时检测入侵并做出正确响应</li>
</ul>
<p>蓝队是防御性安全领域的一部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232248643-1808428703.png"
                      alt="image"
                ></p>
<p>一些与防御性安全相关的任务：</p>
<ul>
<li><p>培养用户网络安全意识：对用户进行网络安全培训有助于防止针对系统的各种攻击。</p>
</li>
<li><p>记录和管理资产：我们需要知道我们必须妥善管理和保护的系统和设备的类型。</p>
</li>
<li><p>更新和修补系统：确保计算机、服务器和网络设备针对任何已知漏洞（弱点）进行正确的版本更新和补丁修补。</p>
</li>
<li><p>设置预防性安全设备：防火墙和入侵防御系统 (IPS) 是预防性安全的重要组成部分。 防火墙可以控制哪些网络流量可以进入系统或网络，以及哪些流量可以离开系统或网络。 IPS 会阻止任何符合当前规则和攻击特征的网络流量。</p>
</li>
<li><p>设置日志记录和监控设备：如果没有进行适当的网络日志记录和网络监控，就不可能检测到恶意活动和入侵行为。 如果我们管理的网络中出现了新的未经授权的可疑设备，我们应该能够及时知道。</p>
</li>
</ul>
<p>防御性安全还有很多要求，上面的列表只涵盖了几个常见的安全任务。</p>
<p>以下是防御性安全的常见相关主题</p>
<ul>
<li>安全运营中心 (SOC)</li>
<li>威胁情报</li>
<li>数字取证和事件响应 (DFIR)</li>
<li>恶意软件分析</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319104624034.png"
                      alt="image-20230319104624034"
                ></p>
<h2 id="防御性安全相关领域介绍"><a href="#防御性安全相关领域介绍" class="headerlink" title="防御性安全相关领域介绍"></a>防御性安全相关领域介绍</h2><p>在本小节中，我们将涵盖与防御性安全相关的两个主要主题：</p>
<ul>
<li>安全运营中心 (SOC)，涵盖了威胁情报处理。</li>
<li>数字取证和事件响应 (DFIR)，涵盖了恶意软件分析。</li>
</ul>
<h3 id="安全运营中心-SOC"><a href="#安全运营中心-SOC" class="headerlink" title="安全运营中心(SOC)"></a>安全运营中心(SOC)</h3><p>安全运营中心(SOC-Security Operations Center) 是一个由网络安全专业人员所组成的团队，主要负责监控网络及其系统以检测恶意网络安全事件。</p>
<p>SOC 的一些主要兴趣领域是：</p>
<ul>
<li><p>漏洞：每当发现系统漏洞（弱点）时，必须通过安装适当的更新包或者补丁来修复漏洞，当修复方案不可用时，则应采取必要的措施来防止攻击者利用漏洞。 尽管修复漏洞对 SOC 至关重要，但这项任务实际上不一定会分配给他们来完成。</p>
</li>
<li><p>策略违规：我们可以将安全策略视为保护网络和系统所需的一组规则；例如，如果用户将公司机密数据上传到公开的在线存储服务，则可能违反了安全策略。</p>
</li>
<li><p>未经授权的活动：如果用户的登录名和密码被盗取，那么攻击者就可以使用盗取到的凭据进行登录行为；SOC 需要检测此类事件 并在攻击者造成进一步损坏之前尽快进行阻止。</p>
</li>
<li><p>网络入侵：无论你的安全性有多好，攻击者进行入侵的机会总是存在。当用户单击恶意链接或攻击者利用公共服务器时，也可能会发生网络入侵事件；不管怎样，当网络入侵发生时，我们就必须尽快检测到它，以防止进一步的破坏。</p>
</li>
</ul>
<p>SOC的安全操作涵盖了各种任务以保护公司网络及系统，其中也包含了威胁情报处理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232324077-921784249.png"
                      alt="image"
                ></p>
<h4 id="威胁情报-Threat-Intelligence"><a href="#威胁情报-Threat-Intelligence" class="headerlink" title="威胁情报(Threat Intelligence)"></a>威胁情报(Threat Intelligence)</h4><p>在网络安全中：情报指的是你收集到的关于实际和潜在敌人的信息，威胁指的是任何可能破坏系统或对系统产生不利影响的行为。</p>
<p>威胁情报旨在收集信息，以帮助公司更好地应对潜在的攻击者，了解威胁情报的目的是实现威胁知情防御；不同的公司会吸引不同类型的网络攻击者，一些攻击者可能会试图从移动运营商处窃取客户数据，另外一些攻击者可能会有兴趣破坏炼油厂的网络以使其停止生产。</p>
<p>典型的网络攻击者包括出于政治原因工作的国家网络军队以及出于财务目的行事的勒索软件组织，基于公司（目标）的性质，我们就可以知道预期的攻击者类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232336558-1363855465.png"
                      alt="image"
                ></p>
<p>情报需要数据，我们必须收集、处理和分析数据：我们首先需要进行数据收集，具体的数据收集来源分为本地来源（例如网络日志）和公共来源（例如网络论坛）；得到数据之后，我们还需要对数据进行处理，数据处理旨在将数据排列成适合分析的格式；最后是数据分析阶段，此阶段旨在找到有关攻击者及其动机的更多信息，另外，数据分析还旨在创建建议列表和可操作步骤列表。</p>
<p>威胁情报可以让我们了解潜在攻击者的战术、技术和程序，妥善处理威胁情报的好处是：我们可以识别威胁参与者（对手），预测他们的攻击活动，最终能够减轻他们的攻击危害并能及时准备响应策略。</p>
<h3 id="数字取证和事件响应-DFIR"><a href="#数字取证和事件响应-DFIR" class="headerlink" title="数字取证和事件响应(DFIR)"></a>数字取证和事件响应(DFIR)</h3><p>接下来我们将介绍数字取证和事件响应 (DFIR-Digital Forensics and Incident Response)，主要将涵盖以下内容：</p>
<ul>
<li>数字取证</li>
<li>事件响应</li>
<li>恶意软件分析</li>
</ul>
<h4 id="数字取证-Digital-Forensics"><a href="#数字取证-Digital-Forensics" class="headerlink" title="数字取证(Digital Forensics)"></a>数字取证(Digital Forensics)</h4><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p>在防御性安全方面，数字取证的重点转移到了分析攻击证据、分析攻击者以及分析其他领域：如知识产权盗窃、网络间谍活动、拥有未经授权的内容等。 </p>
<p>数字取证将侧重于不同的区域，例如：</p>
<ul>
<li><p>文件系统：分析来自于系统存储的数字取证图像（低级副本）可以揭示很多信息，例如分析已安装的程序、已创建的文件、部分被覆盖的文件和已删除的文件等。</p>
</li>
<li><p>系统内存：如果攻击者在内存中运行他们的恶意程序而不将其保存到磁盘中，那么获取系统内存的取证图像（低级副本）是分析恶意程序内容和了解恶意攻击的最佳方式。</p>
</li>
<li><p>系统日志：每台客户端和服务器计算机都维护着不同的日志文件来记录正在发生的事情。因此，日志文件能够提供大量关于系统上发生的事情的信息，即使攻击者试图清除他们的行为痕迹，也可能会留下一些线索。</p>
</li>
<li><p>网络日志：遍历网络中的网络数据包日志将有助于回答是否正在发生攻击、是否已经被攻击以及攻击行为所造成的后果是什么。</p>
</li>
</ul>
<h4 id="事件响应-Incident-Response"><a href="#事件响应-Incident-Response" class="headerlink" title="事件响应(Incident Response)"></a>事件响应(Incident Response)</h4><p>事件，在网络安全中通常是指发生数据泄露或发生网络攻击；但是，在某些情况下，有些事件可能不是那么重要，例如配置错误、入侵企图或违反安全策略的行为。</p>
<p>网络攻击的常见示例包括：攻击者使我们的网络或系统无法访问、攻击者破坏（更改）公共网站和发生数据泄露（攻击者窃取公司数据）等。 那么我们将如何应对网络攻击？事件响应指定了出现网络攻击情况时应遵循的方法，事件响应的目的是在网络攻击事件中减少损坏并在尽可能短的时间内恢复正常。在理想情况下，公司的相关安全部门应该制定一个准备好进行事件响应的计划。</p>
<p>事件响应过程的四个主要阶段是：</p>
<ul>
<li><p>准备阶段：这需要一支训练有素并且已经准备好处理安全事件的团队，在理想情况下，要尽量采取各种安全措施来防止事故发生。</p>
</li>
<li><p>检测和分析阶段：事件响应团队要拥有必要的资源来检测安全事件是否发生；此外，事件响应团队还必须进一步分析任何已经检测到的事件以了解其严重性。</p>
</li>
<li><p>遏制、根除和恢复阶段：一旦检测到事件发生，最重要的是要阻止事件影响其他系统、消除恶意事件并恢复受影响的系统。例如，当我们发现一个系统感染了计算机病毒，我们要及时阻止（遏制）病毒传播到其他系统，清除（根除）病毒程序，并使系统恢复正常工作状态。</p>
</li>
<li><p>事后活动阶段：成功恢复系统工作后，要生成一份相关的报告，分享以及吸取教训，以防止未来发生类似事件。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232401249-375105017.png"
                      alt="image"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421125545564.png"
                      alt="image-20230421125545564"
                ></p>
<h4 id="恶意软件分析-Malware-Analysis"><a href="#恶意软件分析-Malware-Analysis" class="headerlink" title="恶意软件分析(Malware Analysis)"></a>恶意软件分析(Malware Analysis)</h4><p>Malware 代表恶意软件，软件是指可以保存在磁盘上或通过网络发送的程序、文档和文件。 </p>
<p>恶意软件包括多种类型，例如：</p>
<ul>
<li><p>病毒(Virus)是将自身附加到程序中的一段代码（是程序的一部分），它旨在从一台计算机传播到另一台计算机； 此外，一旦病毒感染了计算机，它就会通过更改、覆盖和删除文件来发挥危害作用，最终导致的结果是让计算机运行速度变慢直至计算机无法正常使用。</p>
</li>
<li><p>特洛伊木马(Trojan Horse)是一种程序，它会显示自己具有一个理想的正常功能，但实际上程序中还隐藏了一些恶意功能；例如，受害者可能会从可疑网站下载视频播放器，而这个视频播放器可能实际上是一个木马程序，从而攻击者可以完全控制受害者的系统。</p>
</li>
<li><p>勒索软件(Ransomware)是一种加密用户文件的恶意程序，加密会使文件在不知道加密密码的情况下变为不可读状态；用户只有选择支付“赎金”，攻击者才可能会向用户提供加密密码来对用户文件进行解密。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232423140-422842004.png"
                      alt="image"
                ></p>
<p>恶意软件分析旨在使用各种方式了解恶意程序，从而保护网络和系统的安全环境：</p>
<ul>
<li><p>静态分析：在不运行恶意程序的前提下对恶意程序进行检查。通常，这需要扎实的汇编语言知识（处理器的指令集，即计算机的基本指令）。</p>
</li>
<li><p>动态分析：受控环境中运行恶意软件并监控其活动 以进行分析，动态分析可以让你观察恶意软件在运行时的具体行为。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319125337268.png"
                      alt="image-20230319125337268"
                ></p>
<h2 id="关于防御性安全的简单实例"><a href="#关于防御性安全的简单实例" class="headerlink" title="关于防御性安全的简单实例"></a>关于防御性安全的简单实例</h2><p><strong>模拟场景介绍</strong></p>
<p>作为安全分析师，你接下来将要执行一个典型任务：</p>
<p>你是负责保护银行的安全运营中心 (SOC-Security Operations Center) 的成员，该银行的SOC使用了安全信息和事件管理 (SIEM-Security Information and Event Management) 系统，SIEM 会通过各种来源收集与安全相关的信息和事件，并通过一个系统呈现它们；例如，如果用户多次尝试登录失败或者有来自意外地理位置的登录尝试行为，你将收到相关的消息通知；此外，随着机器学习的出现，SIEM 还会自动检测某些异常行为，例如某个用户在凌晨 3 点登录，而通常情况下用户应该只在工作时间进行登录。</p>
<p>在本小节的实例中，我们将与 SIEM 交互以实时监控网络和系统上的不同事件。有些事件是典型的、无害的，而有些特殊事件可能需要我们进一步干预，我们将在实例中找到被标记为红色的事件，记下相关信息，然后单击相关记录以开始进一步检查。</p>
<p>在对可疑事件的进一步检查中，我们需要尝试了解有关可疑活动或事件的更多信息，可疑事件警告可能是由某个具体事件触发的，这可能会关联到本地用户、本地计算机或远程 IP 地址。在现实世界中，如果要发送和接收邮件，你需要知道一个实际地址；同样，在网络环境中，你需要一个 IP 地址才能通过 Internet 发送和接收数据，IP 地址是允许你通过 Internet 进行通信的逻辑地址。我们需要检查事件警告触发的原因以确认相关的事件是否确实是恶意的，如果确定是恶意事件，我们就需要采取相应的措施，比如向 SOC 中的其他成员进行报告并屏蔽恶意事件相关的 IP 地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/2857591-20230416232447698-1553382882.png"
                      alt="image"
                ></p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例</em></p>
<p>part1：检查 SIEM 仪表面板中的警报消息，从警报中找到可疑 IP 地址(143.110.250.149)，记下它，然后单击警报消息继续。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133244202.png"
                      alt="image-20230319133244202" style="zoom: 67%;" 
                >

<p>part2：Internet 上有一些网站允许你检查某个 IP 地址的信誉以查看它是否是恶意的或可疑的；让我们对在part1中发现的可疑 IP 地址进行检查。</p>
<p><em>tips：有许多开源数据库，例如 <a class="link"   href="https://www.abuseipdb.com/" >AbuseIPDB <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://talosintelligence.com/" >Cisco Talos Intelligence <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，你可以在其中对 IP 地址执行信誉和位置检查，大多数安全分析师使用这些工具来帮助他们进行警报调查；你还可以通过报告恶意 IP（例如，在 AbuseIPDB 上）来使 Internet 更安全。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133328927.png"
                      alt="image-20230319133328927" style="zoom:50%;" 
                >

<p>part3：查看检查结果，现在我们知道 IP 地址143.110.250.149是恶意的，我们需要将其上报给相关的工作人员。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319131240191.png"
                      alt="image-20230319131240191" style="zoom:80%;" 
                >

<p>part4：如果这只是失败的身份验证尝试，我们不必太担心，但是我们还注意到此恶意 IP 地址有成功的登录尝试记录，所以我们有必要将这一事件上报；我们要将此事件上报给负责相关工作的公司人员。（我们将事件上报给 SOC Team Lead——安全运营中心团队负责人）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319132739037.png"
                      alt="image-20230319132739037" style="zoom: 67%;" 
                >

<p>part5：经过事件上报后，我们已获得阻止恶意 IP 地址(143.110.250.149)访问目标公司的权限，我们可以执行阻止规则，通过防火墙阻止恶意 IP 地址访问目标公司。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133554203.png"
                      alt="image-20230319133554203" style="zoom: 67%;" 
                >

<p>part6：我们成功完成了这个简单实例，最后我们获取到以下flag内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319133708037.png"
                      alt="image-20230319133708037"
                ></p>
<blockquote>
<p>最后获取到的flag内容是：THM{THREAT-BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318231923119.png"
                      alt="image-20230318231923119"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Offensive Security(进攻性安全介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Offensive%20Security(%E8%BF%9B%E6%94%BB%E6%80%A7%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/careersincyber" >https://tryhackme.com/room/careersincyber <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：对进攻性安全概念进行简单的讲解。</p>
<h2 id="攻击模拟示例"><a href="#攻击模拟示例" class="headerlink" title="攻击模拟示例"></a>攻击模拟示例</h2><p>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，我们需要完成的操作是：攻击一个名为 FakeBank 的web应用程序（一个虚拟的银行web应用程序）。</p>
<p>我们将使用一个名为“GoBuster”的命令行工具来暴力破解 FakeBank 网站以查找隐藏目录或者页面，GoBuster 将使用一个包含潜在的页面名称或目录名称的字典，并尝试将该字典中的每一条记录和初始目标网站的url进行拼接，然后会逐个访问拼接之后的url，如果某个拼接之后的url所对应的网站页面真实存在，我们就能在GoBuster 的输出中得到对应的有效结果。</p>
<p><strong>步骤1）打开终端</strong></p>
<p>终端，也称为命令行，允许我们在不使用图形用户界面的情况下与计算机交互。</p>
<p><strong>步骤2）查找隐藏的网站页面</strong></p>
<p>大多数公司的网站都会有一个管理门户页面，此页面让公司员工能够访问基本的管理控制功能以进行一些日常操作。对于银行而言，员工可能需要将资金转入或者转出客户账户，如果网站页面不设为私有，那么攻击者就可能会找到显示敏感数据的隐藏页面或者允许访问网站管理控件的隐藏页面。</p>
<p>我们将在终端中键入以下命令，以使用 GoBuster（命令行安全工具）查找 FakeBank 网站上可能隐藏的页面。</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p>在上面的命令中，<code>-u</code>选项 将指定我们需要进行扫描的目标网站，<code>-w</code>选项 将指定用于进行遍历的字典以帮助我们查找隐藏页面。</p>
<p>GoBuster 会使用字典中的每条记录来扫描目标网站，从而查找目标网站上可能存在的隐藏页面；最终我们在GoBuster的输出结果中 可以看到目标网站上确实存在的隐藏目录（Status: 200表示相关页面确实存在）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318222340492.png"
                      alt="image-20230318222340492"
                ></p>
<p><strong>步骤3）攻击目标应用程序</strong></p>
<p>你应该已经找到了一个秘密的银行转账页面，这个页面(&#x2F;bank-transfer)允许你在银行账户之间进行转账。</p>
<p>攻击者可以利用隐藏的银行转账页面从任何银行账户中窃取资金，这对银行来说是一个严重的安全风险；作为一名有道德的黑客，你应该（在获得许可的情况下）从目标公司的应用程序中尝试发现此漏洞，并在黑客利用这个漏洞之前将其报告给银行以便进行及时修复。</p>
<p><strong>答题</strong></p>
<p><em>尝试在虚拟实验环境中对目标进行攻击，从银行账户号2276向你的账户（账户号8881）转账 2000美元。</em></p>
<p>在终端界面输入以下命令：</p>
<div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">gobuster -u http://fakebank.com -w wordlist.txt <span class="built_in">dir</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224310889.png"
                      alt="image-20230318224310889"
                ></p>
<p>访问找到的隐藏目录：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224411171.png"
                      alt="image-20230318224411171" style="zoom:50%;" 
                >

<p>进行转账操作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224527032.png"
                      alt="image-20230318224527032" style="zoom:50%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224604085.png"
                      alt="image-20230318224604085" style="zoom:50%;" 
                >

<p>返回初始的银行账户页面–查看最终答案：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224830196.png"
                      alt="image-20230318224830196" style="zoom:50%;" 
                >

<blockquote>
<p>最终显示的答案为：BANK-HACKED</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230318224849820.png"
                      alt="image-20230318224849820"
                ></p>
<h2 id="什么是进攻性安全？"><a href="#什么是进攻性安全？" class="headerlink" title="什么是进攻性安全？"></a>什么是进攻性安全？</h2><p>简而言之，进攻性安全就是尝试闯入目标计算机系统、利用软件本身的错误并找到应用程序中的漏洞以获得对目标的未授权访问的过程。</p>
<p>要打败黑客，你就需要像黑客一样行事，作为合法的网络安全人员，你需要在网络犯罪分子发动攻击之前发现目标系统的漏洞并推荐漏洞补丁。</p>
<p>以下是关于进攻性安全职业角色的简短描述：</p>
<ul>
<li>渗透测试员 - 负责测试技术产品以发现可利用的安全漏洞。</li>
<li>红队 - 扮演对抗者的角色，攻击目标组织并从敌人的角度提供网络安全防护措施反馈。</li>
<li>安全工程师 - 设计、监控和维护安全控制、网络和系统，以帮助防止网络攻击。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>主题样式Demo</title>
    <url>/2024/01/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>THM-Operating System Security(操作系统安全介绍)-学习</title>
    <url>/2024/01/16/THM-Operating%20System%20Security(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/operatingsystemsecurity" >https://tryhackme.com/room/operatingsystemsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍操作系统安全，并演示 Linux系统 上的 SSH 身份验证实例。</p>
<h2 id="操作系统安全简介"><a href="#操作系统安全简介" class="headerlink" title="操作系统安全简介"></a>操作系统安全简介</h2><p>每天当你使用智能手机或者笔记本电脑以及其他任何类型的计算机时，你都会直接或间接地与操作系统进行交互；常用的操作系统包括 MS Windows、macOS、iOS、Android、Chrome OS 和 Linux。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/41f5388e5280b8a769158537e4372eae.png"
                      alt="img"
                ></p>
<p>什么是操作系统？ 要定义操作系统，我们首先需要知道一个计算机术语：硬件。</p>
<p>计算机硬件是指所有可以用手触摸到的计算机部件和外围设备。硬件包括屏幕、键盘、打印机、U盘和主板；其中主板包含了许多组件，特别是中央处理器（CPU）和内存芯片（RAM），主板通常会连接存储设备（HDD-机械硬盘 或 SSD-固态硬盘）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322012635473.png"
                      alt="image-20230322012635473"
                ></p>
<p>主板是计算机的关键部分，从键盘和鼠标到屏幕和打印机的所有其他硬件都将连接到计算机主板；但是，如果你想在计算机中运行自己喜欢的程序或者应用程序，硬件组件本身是没办法直接被使用的，所以我们需要一个操作系统来控制和“驱动”这些硬件组件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322013136875.png"
                      alt="image-20230322013136875"
                ></p>
<p>操作系统 (OS) 是位于硬件与你正在运行的应用程序或者程序之间的层。</p>
<p>你日常使用的示例程序可能包括网络浏览器，例如 Firefox、Safari 和 Chrome，以及消息传递应用程序，例如 Signal、WhatsApp 和 Telegram。所有的程序和应用程序都不能直接在计算机硬件上运行，但是，它们能够运行在操作系统上，操作系统能够允许程序按照特定的规则去访问硬件。</p>
<p>某些操作系统专为在笔记本电脑和个人台式机上运行而设计，例如 MS Windows 11 和 macOS；还有某些操作系统专为智能手机而设计，例如 Android 和 iOS；另外还有用于服务器的操作系统，例如 <a class="link"   href="https://www.microsoft.com/en-us/windows-server/" >MS Windows Server 2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.ibm.com/products/aix" >IBM AIX <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 和 <a class="link"   href="https://www.oracle.com/solaris" >Oracle Solaris <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>；最后，还有一些在个人计算机上以及在服务器上都能被使用的操作系统，比如Linux。</p>
<p>下图是2022 年 1 月期间收集的数据，这些数据显示了当时 用于浏览互联网的不同操作系统的流行程度。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322014002536.png"
                      alt="image-20230322014002536"
                ></p>
<p>你的智能手机可能运行在 Android 或 iOS操作系统上，并且其中可能拥有关于你的大量私人数据，包括：</p>
<ol>
<li>与家人和朋友的私人谈话</li>
<li>与家人和朋友的私人照片</li>
<li>你用于个人和工作通信的电子邮件客户端</li>
<li>保存在网络浏览器中密码（甚至保存在笔记中的密码）</li>
<li>电子银行应用程序</li>
</ol>
<p>关于机密和私人数据的清单可能还有更多内容，你应该不会希望你所不信任的人打开你的手机并浏览你的照片、对话和应用程序；因此，你需要保护好自己的手机及其操作系统的安全。</p>
<p>保护私人数据同样适用于 运行了 MS Windows、macOS、Linux 等操作系统的笔记本电脑或计算机，你的计算机中很可能包含了大量信息，例如：</p>
<ol>
<li>与你的工作或大学相关的机密文件</li>
<li>你的私人个人文件，例如你的身份证或护照复印件</li>
<li>你所使用的电子邮件程序，例如 MS Outlook、Mozilla Thunderbird等</li>
<li>你保存在网络浏览器和其他应用程序中的密码</li>
<li>你的数码相机和智能手机中的照片的复印件</li>
</ol>
<p>这些关于私人信息的列表可能会很长，具体内容取决于用户类型。</p>
<p>考虑到所保存的数据的性质，你肯定会希望能够尽量确保个人信息安全，而当我们谈论到信息安全时，我们应该想到要保护好以下几点：</p>
<ul>
<li>机密性(Confidentiality)：你希望确保 机密的和私人的文件、信息仅供指定人员使用。</li>
<li>完整性(Integrity)：任何人都不能篡改存储在你的系统上的文件 或者 篡改你在网络上传输的文件。</li>
<li>可用性(Availability)：你希望你的笔记本电脑或智能手机在你决定使用时能够随时处于可用状态。</li>
</ul>
<p>tips：Confidentiality、Integrity、Availability——即CIA三合一模型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322015625614.png"
                      alt="image-20230322015625614"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213504737.png"
                      alt="image-20230320213504737"
                ></p>
<h2 id="关于操作系统安全的常见示例"><a href="#关于操作系统安全的常见示例" class="headerlink" title="关于操作系统安全的常见示例"></a>关于操作系统安全的常见示例</h2><p>正如我们在上一小节中所提到的，操作系统安全将涉及针对以下几个方面的攻击：</p>
<ul>
<li>Confidentiality-机密性</li>
<li>Integrity-完整性</li>
<li>Availability-可用性</li>
</ul>
<p>在本小节，我们将重点关注恶意用户所针对的三个安全缺陷：</p>
<ol>
<li>身份验证中的弱密码</li>
<li>弱文件权限</li>
<li>恶意程序</li>
</ol>
<h3 id="身份验证中的弱密码"><a href="#身份验证中的弱密码" class="headerlink" title="身份验证中的弱密码"></a>身份验证中的弱密码</h3><p>身份验证是验证你身份的行为，无论是本地系统还是远程系统，身份验证可以通过三种主要方式实现：</p>
<ul>
<li>你知道的信息，例如密码或 PIN 码。</li>
<li>你是什么，例如指纹。</li>
<li>你拥有的东西，例如可以接收 SMS(短信服务) 消息的电话号码。</li>
</ul>
<p>由于密码是最常见的身份验证形式，因此它们也是最容易受到攻击的。许多用户倾向于在网站上使用容易猜到的简单密码 或者 在多个网站上使用相同的密码；此外，一些用户是设置密码时 会依赖个人详细信息，例如出生日期和宠物的名字等，他们认为这很容易记忆并且不会被攻击者知道（事实上攻击者已经意识到了：用户在设置密码时，会倾向于依赖个人详细信息）。</p>
<p>2019 年 4 月 21 日 英国国家网络安全中心 (NCSC) 发布了 <a class="link"   href="https://www.ncsc.gov.uk/blog-post/passwords-passwords-everywhere" >100,000 个最常用密码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的列表，让我们看看常用的前 20 个密码(Top20)。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">Rank	          Password</span><br><span class="line">1	              123456</span><br><span class="line">2	              123456789</span><br><span class="line">3	              qwerty</span><br><span class="line">4	              password</span><br><span class="line">5	              111111</span><br><span class="line">6	              12345678</span><br><span class="line">7	              abc123</span><br><span class="line">8	              1234567</span><br><span class="line">9	              password1</span><br><span class="line">10	              12345</span><br><span class="line">11	              1234567890</span><br><span class="line">12	              123123</span><br><span class="line">13	              000000</span><br><span class="line">14	              iloveyou</span><br><span class="line">15	              1234</span><br><span class="line">16	              1q2w3e4r5t</span><br><span class="line">17	              qwertyuiop</span><br><span class="line">18	              123</span><br><span class="line">19	              monkey</span><br><span class="line">20	              dragon</span><br></pre></td></tr></table></figure></div>

<p>阅读以上Top20密码列表：我们可以看到 123、1234、12345、…、123456789 和 1234567890 都在列表中，password、iloveyou、monkey、dragon等也是常用的英文，而在英文字典中没有的无含义词包括 qwerty、qwertyuiop 和 1q2w3e4r5t，这些看似复杂的(无含义词)密码 其实也非常容易预测，因为它们是遵循键盘布局进行输入的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/1510e4bd81418a2937060f9c55dad593.gif"
                      alt="img"
                ></p>
<p>简而言之，如果攻击者可以猜出你的任何在线帐户（例如你的电子邮件或社交媒体帐户）的密码，他们将能够直接访问你的私人数据。 因此，选择复杂的密码，并且在不同的账户下使用不同的密码是至关重要的。</p>
<h3 id="弱文件权限"><a href="#弱文件权限" class="headerlink" title="弱文件权限"></a>弱文件权限</h3><p>适当的安全性决定了最小特权原则。在工作环境中，你希望任何文件都只有那些需要访问它才能完成工作的人 有权进行访问；在个人层面上，假设你计划与家人或朋友一起去旅行，你可能只希望与参加该旅行的人共享与旅行计划相关的所有文件，而不想直接公开让所有人共享此类文件——这就是最小特权原则。简而言之，最小特权原则是指：我们要确定“谁才可以访问什么？”。</p>
<p>弱文件权限会使攻击者很容易针对机密性和完整性进行攻击：攻击者可以攻击机密性，因为弱权限允许他们访问他们不应该访问的文件；攻击者也可以攻击完整性，因为他们能够修改他们不应该进行编辑的文件。</p>
<h3 id="恶意程序"><a href="#恶意程序" class="headerlink" title="恶意程序"></a>恶意程序</h3><p>我们要举的最后一个例子是恶意程序，根据恶意程序的类型，它们可以针对机密性、完整性和可用性进行攻击。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/f0a69acdee2506b2898e34fc231fe94b.png"
                      alt="img" style="zoom:50%;" 
                >

<p>某些类型的恶意程序（例如特洛伊木马）允许攻击者访问你的系统，因此，攻击者将能够读取你的文件甚至修改你的文件。</p>
<p>某些类型的恶意程序会针对可用性进行攻击，例如勒索软件(ransomware)。勒索软件是一种能够加密用户文件的恶意程序，加密能够使文件在不知道加密密码的情况下变得不可读，换句话说，文件在没有进行解密（逆向加密）的情况下会变成乱码。在勒索软件事件中，攻击者往往会为用户提供恢复文件可用性的方法，攻击者会让用户重新获得对其原始文件的访问权限：当用户愿意支付“赎金-ransom”时，攻击者则会向用户提供加密密码以进行解密。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320213351214.png"
                      alt="image-20230320213351214"
                ></p>
<h2 id="关于操作系统安全的简单实例"><a href="#关于操作系统安全的简单实例" class="headerlink" title="关于操作系统安全的简单实例"></a>关于操作系统安全的简单实例</h2><p>在典型的网络攻击中，攻击者可能会试图获得对远程目标系统的访问权，我们可以通过诱使目标运行恶意文件或者通过直接获取用户名、密码来完成此类攻击。</p>
<p>在本小节我们将重点关注：通过获取用户名、密码来获得对远程目标系统的访问权。 在发现有效用户名后，我们往往可以尝试“猜测”对应的密码，此外，我们也将进一步尝试将权限提升到系统管理员。</p>
<p>系统管理员账号身份在安卓、苹果、Linux系统上被称为<strong>root</strong>，而在 MS Windows 系统上，管理员账号身份会被称为<strong>administrator</strong>，root 账户和administrator 账户对目标系统都具有完全不受限制的访问权限。</p>
<p>在本小节中，我们将使用Linux系统进行练习，我们将可能使用以下 Linux 命令：</p>
<ul>
<li><code>whoami</code></li>
<li><code>ssh USERNAME@MACHINE_IP</code></li>
<li><code>ls</code></li>
<li><code>cat FILENAME</code></li>
<li><code>history</code></li>
</ul>
<p><strong>模拟场景</strong>：</p>
<p>我们受雇检查某家公司的安全性，当我们查看客户的办公室环境时，我们注意到其中一个桌子上有留有一张便条，上面有两个词：sammie 和 dragon，让我们猜测一下 dragon 是不是 Sammie用户 在目标机器 (MACHINE_IP)上所使用的密码？在 AttackBox 的终端中，我们将尝试通过执行<code>ssh sammie@MACHINE_IP</code>命令来登录到 Sammie 的ssh帐户，远程目标系统会要求你提供 sammie 的密码——我们输入 dragon 进行尝试。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322173552863.png"
                      alt="image-20230322173552863"
                ></p>
<p>AttackBox 终端上的登录交互如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@MACHINE_IP</span></span><br><span class="line">sammie@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Tue  1 Mar 13:20:32 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.03              Processes:              216</span><br><span class="line">  Usage of /:   51.8% of 6.53GB   Users logged in:        1</span><br><span class="line">  Memory usage: 17%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 09:46:11 2022 from MACHINE_IP</span><br></pre></td></tr></table></figure></div>

<p>成功通过ssh完成登录后，我们可以使用<code>whoami</code>命令 来验证当前用户身份是否为–sammie；我们可以使用 <code>ls</code>(list 的缩写)命令 来列出当前目录中的文件，此命令将显示出当前目录中的所有文件，但隐藏文件并不会显示；如果要显示任何文本文件的内容，我们可以使用命令 <code>cat FILENAME</code>，cat是concatenate 的缩写，此命令将在终端屏幕上打印出文本文件的内容。</p>
<p>在下面的终端交互中，我们看到了四个命令的使用情况：<code>ssh</code>、<code>whoami</code>、<code>ls</code> 和 <code>cat</code> 。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@AttackBox# </span><span class="language-bash">ssh sammie@10.20.30.130</span></span><br><span class="line">sammie@10.20.30.130&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-100-generic x86_64)</span><br><span class="line"></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">Last login: Tue Mar  1 14:45:53 2022 from 10.20.30.1</span><br><span class="line">sammie@beginner-os-security:~$ whoami</span><br><span class="line">sammie</span><br><span class="line">sammie@beginner-os-security:~$ ls</span><br><span class="line">country.txt  draft.md  icon.png  password.txt  profile.jpg</span><br><span class="line">sammie@beginner-os-security:~$ cat draft.md </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Operating System Security</span></span><br><span class="line"></span><br><span class="line">Reusing passwords means that your password for other sites becomes exposed if one service is hacked.</span><br><span class="line">sammie@beginner-os-security:~$</span><br></pre></td></tr></table></figure></div>

<p>接下来，我们将介绍的最后一个命令是 <code>history</code>，此命令将在终端界面打印出用户曾经使用的命令；当你使用<code>history</code>命令之后，也许能在终端输出结果中找到一些敏感信息。</p>
<p>假设我们已经知道了另外两个可以访问目标机器的用户名：</p>
<ul>
<li><em><strong>johnny</strong></em></li>
<li><em><strong>linda</strong></em></li>
</ul>
<p>如果以上两个用户都很少考虑安全性，我们可以使用多种方式来猜测这两个用户的密码，此处我们将列出以下两种情况：</p>
<ul>
<li>如果你未以 sammie用户 或任何其他用户身份完成ssh登录操作，你可以直接使用 <code>ssh johnny@MACHINE_IP</code>命令并手动尝试输入多个密码进行猜测，以查看哪个密码对 johnny用户 有效。</li>
<li>如果你已经以 sammie用户 或任何其他用户身份完成了ssh登录操作，你可以使用 <code>su - johnny</code>命令 来切换用户身份，并手动尝试输入一个又一个密码，以查看哪个密码对 johnny用户 有效。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题：</strong></em></p>
<ol>
<li>根据本文所介绍的Top 7 常用密码，让我们尝试找出 Johnny 的密码，用户 johnny 的密码是什么？</li>
<li>以 Johnny 身份登录后，使用<code>history</code>命令检查 Johnny 曾经键入过的命令，我们发现Johnny错误地把 root 密码当成命令输入过，root密码的内容是什么？</li>
<li>以 Johnny 身份登录后，使用命令 <code>su - root</code> 切换到 root 帐户(并输入root密码通过身份验证)，查看根目录下的flag.txt的内容，flag.txt的内容是什么？</li>
</ol>
<p><em><strong>操作：</strong></em></p>
<p>我们可以使用以下命令针对目标机器进行ssh登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh johnny@10.10.210.242</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">经过登录尝试发现可用密码：abc123</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181721434.png"
                      alt="image-20230322181721434"
                ></p>
<blockquote>
<p>用户 johnny 的密码是：abc123</p>
</blockquote>
<p>成功完成ssh登录后，输入<code>history</code>命令：发现root用户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322181911146.png"
                      alt="image-20230322181911146"
                ></p>
<blockquote>
<p>root用户的密码为：happyHack!NG 。</p>
</blockquote>
<p>切换用户身份到root（使用我们刚才找到的密码完成身份验证），以root用户身份查找flag.txt文件 并获取其文本内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322182319042.png"
                      alt="image-20230322182319042"
                ></p>
<blockquote>
<p>flag.txt的内容是：THM{YouGotRoot} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230320214350583.png"
                      alt="image-20230320214350583"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Web Application Security(Web应用程序安全介绍)-学习</title>
    <url>/2024/01/16/THM-Web%20Application%20Security(Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introwebapplicationsecurity" >https://tryhackme.com/room/introwebapplicationsecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解 Web 应用程序并探索它们的一些常见安全问题</p>
<h2 id="Web应用程序简介"><a href="#Web应用程序简介" class="headerlink" title="Web应用程序简介"></a>Web应用程序简介</h2><p>我们每个人都会在我们的计算机上使用不同的程序。 一般来说，当程序在计算机上运行时，就将使用计算机的处理能力和存储功能，而且，要使用一个程序，我们还需要先安装它。如果我们想不经过安装操作就直接使用程序应该怎么办？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124001893.png"
                      alt="image-20230421124001893"
                ></p>
<p>Web 应用程序类似于普通的“程序”，并且只要我们的计算机上有一个现代的、标准的 Web 浏览器，例如 Firefox、Safari 或 Chrome等，我们就可以不经安装而直接使用Web应用程序——当我们想运行Web应用程序时，我们无需安装 运行时所需的每个程序，只需直接访问相关浏览器页面即可。 </p>
<p>以下是关于 Web 应用程序的一些示例：</p>
<ul>
<li>网络邮件，例如 Tutanota、Protonmail、Outlook 和 Gmail</li>
<li>在线办公套件，如 Microsoft Office 365（Word、Excel 和 PowerPoint）、Google Drive（Docs、Sheets 和 Slides）和 Zoho Office（Writer、Sheet 和 Show）</li>
<li>在线购物网站，例如 Amazon.com、AliExpress 和 Etsy</li>
</ul>
<p>其他示例还包括网上银行、汇款、天气预报和网络社交媒体等，成千上万的Web应用程序提供了数不胜数的在线服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124018938.png"
                      alt="image-20230421124018938"
                ></p>
<p>Web 应用程序的概念是一个在远程服务器上运行的程序，而服务器是指连续运行以“服务”用户客户端的计算机系统，在这种情况下，服务器将运行特定类型的程序，并且这些程序可以通过Web浏览器被访问。</p>
<p>以一个在线购物 Web 应用程序为例，此 Web 应用程序将从数据库服务器中读取有关产品及其详细信息的数据，数据库将用于 以有组织的方式存储信息，在本例中这些数据可能会包括有关产品、客户和发票的信息。（数据库服务器会负责许多功能，包括对数据库进行读取、搜索和写入等操作） </p>
<p>一个在线购物 Web 应用程序在运行时 可能需要访问多个数据库，例如：</p>
<ul>
<li>产品数据库：该数据库包含有关产品的详细信息，例如名称、图像、规格和价格。</li>
<li>客户数据库：该数据库包含与客户相关的所有详细信息，例如姓名、地址、电子邮件和电话号码。</li>
<li>销售数据库：我们希望在这个数据库中看到每个客户购买了什么以及他们是如何支付的。</li>
</ul>
<p>我们已经大概了解了存储在任何在线购物系统中的信息量，假如攻击者设法利用（破解）Web 应用程序并窃取客户的数据库内容，那么这将给公司及相关客户带来重大损失。</p>
<p>下图显示了在Online购物网站上搜索商品可能将发生什么，在最简单的Online购物网站中，搜索商品可能会经历以下四个步骤：</p>
<ol>
<li><p>用户在搜索字段中输入项目名称或相关关键字，Web 浏览器会将被搜索的关键字发送给在线购物 Web 应用程序。</p>
</li>
<li><p>Web 应用程序查询（搜索）产品数据库以查找用户所提交的关键字。</p>
</li>
<li><p>产品数据库将与用户提供的关键字相匹配的搜索结果返回给 Web 应用程序。</p>
</li>
<li><p>Web 应用程序将结果格式化为友好可读的网页页面并将它们返回给用户以供浏览。</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224615610.png"
                      alt="image-20230319224615610"
                ></p>
<p>从用户的角度来看，他们只会访问到一个隐藏所有技术基础设施的在线商店页面。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319224808863.png"
                      alt="image-20230319224808863" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<blockquote>
<p>Browser - 浏览器</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319213257215.png"
                      alt="image-20230319213257215"
                ></p>
<h2 id="Web-应用程序常见安全风险"><a href="#Web-应用程序常见安全风险" class="headerlink" title="Web 应用程序常见安全风险"></a>Web 应用程序常见安全风险</h2><p>假设你想从网上商店购买商品，你就会希望能够在相关 Web 应用程序上执行某些功能，用户完成一个在线商品订单可能分为以下几个步骤：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319225857754.png"
                      alt="image-20230319225857754"
                ></p>
<p>针对 Web 应用程序的常见攻击有很多，下面简单介绍一些攻击方式：</p>
<ul>
<li><p>在登录网站时：攻击者可以通过进行多次登录尝试来枚举发现有效密码；攻击者能够使用密码字典和一些自动化工具来针对登录页面来进行多次测试。(暴力枚举)</p>
</li>
<li><p>在搜索产品时：攻击者可以通过在搜索字段中添加特定字符和代码来尝试破坏目标系统；攻击者的目的是让目标系统返回它不应该返回的数据或者执行它不应该执行的程序。(注入类攻击)</p>
</li>
<li><p>在提供付款细节时：攻击者会检查 和付款细节相关的数据 是以明文形式发送还是使用了弱加密；加密是指 让数据在不知道密钥或密码的情况下变得不可读。(明文、弱加密)</p>
</li>
</ul>
<p>tips：本小节只介绍一些针对Web应用程序的攻击方式 而并非全部。</p>
<h3 id="身份识别和验证错误"><a href="#身份识别和验证错误" class="headerlink" title="身份识别和验证错误"></a>身份识别和验证错误</h3><p>身份识别(Identification)是指 可以对用户身份进行唯一识别的能力，而身份验证(authentication)是指 可以证明用户实际身份和用户所声称的身份相符合的能力；当用户登录网上商店时，正常情况下：商店必须先识别用户的身份并进行身份验证，然后才能让用户使用该在线购物系统。</p>
<p>如果网站的身份识别和身份验证机制不佳，那么在网站登录界面就可能存在一些漏洞，关于此类漏洞的示例有：</p>
<ul>
<li><p>目标网站允许攻击者使用暴力枚举；攻击者能够尝试多次输入不同密码以进行登录操作——通常攻击者会使用自动化工具来暴力枚举，从而找到有效的登录凭据。</p>
</li>
<li><p>目标网站允许正常用户使用弱密码；弱密码通常很容易被攻击者猜到。</p>
</li>
<li><p>目标网站以明文形式存储用户密码；如果此时攻击者能够设法读取包含密码的文件，那么他们就能够获知存储的密码内容。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319234328832.png"
                      alt="image-20230319234328832"
                ></p>
<h3 id="损坏的访问控制机制"><a href="#损坏的访问控制机制" class="headerlink" title="损坏的访问控制机制"></a>损坏的访问控制机制</h3><p>访问控制(Access control)机制 能够确保每个用户只能访问与其角色或工作相关的文件（文档、图像等）；例如，公司的网站管理员应该不希望市场部的某人能够直接访问（阅读）财务部的文档。</p>
<p>与访问控制相关的示例漏洞包括：</p>
<ul>
<li><p>网站管理员未能应用最小权限原则并为用户提供超出其需要的访问权限；例如，在线客户应该能够查看商品的价格，但他们不应该能够更改商品价格。</p>
</li>
<li><p>攻击者能够使用用户的唯一标识符查看或修改他人的帐户信息；例如，你应该不希望一个银行客户能够查看另一个客户的交易详情。</p>
</li>
<li><p>攻击者能够以未经身份验证的用户身份 浏览需要身份验证（登录）的页面；例如，我们不应该让任何人在登录之前就能查看到网络邮件内容。</p>
</li>
</ul>
<h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><p>注入攻击是指 对 Web 应用程序中的注入类漏洞进行利用，在注入类漏洞存在的情况下：攻击者可以插入恶意代码作为用户输入内容的一部分。</p>
<p>注入类漏洞存在的一个原因是 目标网站缺乏对“用户输入”的适当验证和清理。</p>
<h3 id="未成功加密"><a href="#未成功加密" class="headerlink" title="未成功加密"></a>未成功加密</h3><p>此类漏洞的存在是由于发生了与密码学相关的错误，密码学侧重于数据的加密和解密过程，加密是指 对明文内容使用加密算法计算以得到密文；对于没有密钥解密的人来说，经过加密产生的密文是无法读懂的，换句话说，加密能够确保没有人可以在不知道密钥的情况下直接读取数据，只有使用密钥进行解密 才能将密文转换回原始明文。</p>
<p>未成功加密(加密失败)的例子包括：</p>
<ul>
<li>目标网站以明文形式发送敏感数据，例如，网站使用 HTTP 协议而不是 HTTPS 协议； HTTP 是用于访问 Web 的协议，而 HTTPS 是 HTTP 的安全版本，攻击者可以阅读通过 HTTP 协议发送的所有内容，但不能阅读使用 HTTPS 协议发送的内容。</li>
<li>目标网站依赖弱密码算法进行加密（很容易被破解）；有一种古老的密码算法是将每个字母移位一个，例如，将“TRY HACK ME”变成“USZ IBDL NF”，如果使用这种加密算法就很容易被攻击者破解密文。</li>
<li>目标网站使用默认或弱密钥进行加密；破解使用 1234 作为密钥的加密并不困难，所以如果使用弱密钥加密就很容易被攻击者破解。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230421124046841.png"
                      alt="image-20230421124046841"
                ></p>
<p><strong>答题</strong></p>
<blockquote>
<p>Identification and Authentication Failure 身份识别和身份验证错误</p>
<p>Cryptographic Failures 未成功加密（加密失败）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319214337998.png"
                      alt="image-20230319214337998"
                ></p>
<h2 id="Web-应用程序安全实例"><a href="#Web-应用程序安全实例" class="headerlink" title="Web 应用程序安全实例"></a>Web 应用程序安全实例</h2><p>本小节将调查一个存在<u>不安全直接对象引用</u> (IDOR漏洞) 的易受攻击的示例网站。</p>
<p>IDOR漏洞属于损坏的访问控制机制的一种，所谓 损坏的访问控制机制 意味着攻击者可以访问不适合他们访问的信息 或者 执行不适合他们执行的操作。</p>
<p>Web 服务器能够接收用户提供的输入以检索对象（文件、数据、文档），这些被检索的对象可能是按顺序编号的；我们假设当前用户有权访问名为 IMG_1003.JPG 的照片，我们可能会猜测 Web服务器上还存在IMG_1002.JPG照片 和 IMG_1004.JPG照片；然而，即使我们已经知道了图像文件的名称，Web 应用程序也不应该向我们提供某些图像。一般来说，如果Web应用程序对“用户输入”的信任度过高，就可能会出现IDOR漏洞，换句话说，此时 Web 应用程序并没有严格验证用户是否有权访问所请求的对象。</p>
<p>即使知道了某个用户或某个产品相关的正确 URL 也不一定意味着当前用户应该能够访问这些 URL（所以这需要我们进行实际的访问验证）。假设我们已经知道某个产品页面的URL： <a class="link"   href="https://store.tryhackme.thm/products/product?id=52" >https://store.tryhackme.thm/products/product?id=52 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ；我们可以期望此 URL 会提供有关编号为 52 的产品详细信息；如果在数据库中，产品数据项是将按顺序分配编号的，那么攻击者就可以尝试使用其他数字 如 51 或 53来取代URL中的 52；一旦目标 Web 应用程序存在IDOR漏洞，那么攻击者就可能会访问到 其他已停用产品或未发布产品的相关页面。</p>
<p>让我们考虑一个更关键的例子(此例基于目标系统存在IDOR漏洞的前提条件下)，假设有一个URL <a class="link"   href="https://store.tryhackme.thm/customers/user?id=16" >https://store.tryhackme.thm/customers/user?id=16 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，这个URL将返回 id&#x3D;16 的用户相关页面；同样，我们希望用户所对应的 ID 号是连续的，那么攻击者就可以尝试在URL中使用其他ID号 并可能成功访问到其他用户帐户所相关的页面（进而能够查看到其他用户的敏感信息）。</p>
<p>IDOR漏洞也适用于访问一些按顺序命名并存储的文件；例如，攻击者在URL中看到007.txt，那么可以尝试使用其他文件名称，如001.txt、006.txt等。(此例基于目标系统存在IDOR漏洞的前提条件下)</p>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215632445.png"
                      alt="image-20230319215632445" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220131634.png"
                      alt="image-20230319220131634" style="zoom:67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319220240818.png"
                      alt="image-20230319220240818" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag内容为：THM{IDOR_EXPLORED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230319215450568.png"
                      alt="image-20230319215450568"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Network Security(网络安全介绍)-学习</title>
    <url>/2024/01/16/THM-Network%20Security(%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/intronetworksecurity" >https://tryhackme.com/room/intronetworksecurity <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：简单介绍网络安全概念，了解基本的网络攻击步骤，并尝试完成一个侵入目标服务器的实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>计算机网络是一组相互连接的计算机和设备，而网络安全则侧重于保护这些设备以及连接它们的链路的安全。（更准确地说，网络安全包括了保护计算机网络及其数据的机密性、完整性和可用性的一切安全设备、安全技术和过程）</p>
<p>网络安全由不同的硬件和软件解决方案组成，以实现既定的安全目标。网络安全的硬件解决方案是指 你在网络中设置的用于保护网络安全的设备，这些设备是硬件，所以你可以在现实中接触到它们。硬件设备可能类似于下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322195255546.png"
                      alt="image-20230322195255546"
                ></p>
<p>网络安全硬件设备的示例包括：</p>
<ul>
<li>防火墙设备：防火墙将根据一组预定义的规则来允许和阻止连接，它将限制什么可以进入网络 和 什么可以离开网络。</li>
<li>入侵检测系统 (IDS) 设备：IDS 会检测系统入侵、网络入侵以及入侵企图，它会尝试检测攻击者侵入你的网络的企图。</li>
<li>入侵防御系统 (IPS) 设备：IPS 可阻止检测到的入侵行为和入侵企图，它旨在防止攻击者闯入你的网络。</li>
<li>虚拟专用网络 (VPN) 集线器设备：VPN 可确保网络流量无法被第三方读取或更改，它保护发送的数据的机密性（secrecy）和完整性。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200053263.png"
                      alt="image-20230322200053263"
                ></p>
<p>另一方面，网络安全也有软件解决方案，常见的例子有：</p>
<ul>
<li>防病毒软件：你可以在计算机或者智能手机上安装防病毒软件以检测恶意文件并阻止它们的执行。</li>
<li>主机防火墙：与防火墙设备（硬件设备）不同，主机防火墙是作为操作系统的一部分而被提供的程序，或者是安装在操作系统上的程序。例如，MS Windows 操作系统中就包含了 Windows Defender 防火墙程序，Apple macOS 中也包含了应用防火墙(application firewal)，以上两者都是主机防火墙。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322200919536.png"
                      alt="image-20230322200919536"
                ></p>
<p>根据 IBM Security 发布的<a class="link"   href="https://newsroom.ibm.com/2021-07-28-IBM-Report-Cost-of-a-Data-Breach-Hits-Record-High-During-Pandemic" >《2021 年数据泄露成本报告》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，2021 年数据泄露平均每起事件给公司造成 424 万美元的损失，而 2020 年为 386 万美元，平均成本因行业和国家&#x2F;地区而异。 例如，医疗行业数据泄露的平均总成本为 923 万美元，而教育行业则为 379 万美元。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>Windows Defender 防火墙是什么类型的防火墙：Host Firewall</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215249669.png"
                      alt="image-20230320215249669"
                ></p>
<h2 id="网络攻击步骤介绍"><a href="#网络攻击步骤介绍" class="headerlink" title="网络攻击步骤介绍"></a>网络攻击步骤介绍</h2><p>每个“操作”的执行 都需要拥有某种形式的计划才能最终取得成功。假如你对野生动物摄影感兴趣，除非你完全不在乎结果，否则你不能只是拿起相机就直接前往丛林进行摄影，为了安全、成功地进行野生动物摄影之旅，你往往需要更多地去了解你想要用相机拍摄的动物(这包括动物的习性和你要避免的危险)；以上例子同样适用于针对目标网络进行攻击的网络安全行动。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322201637351.png"
                      alt="image-20230322201637351"
                ></p>
<p>闯入目标网络通常包括多个步骤，根据<a class="link"   href="https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html" >洛克希德·马丁公司 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的说法，网络杀伤链有七个步骤：</p>
<ol>
<li>Recon(侦察)：Recon，是reconnaissance(侦察)的缩写，指的是攻击者将在此阶段 试图尽可能多地了解目标，主要包括——目标的服务器类型、操作系统、IP 地址、用户名和电子邮件地址等信息，获取到这些信息将有利于网络攻击成功。</li>
<li>Weaponization(武器化(：这一步是指准备一个带有恶意组件的文件，例如，相关恶意组件能够为攻击者提供远程访问。</li>
<li>Delivery(投递)：投递是指通过任何可行的方式将“武器化”的文件投递给目标，例如通过电子邮件或者U盘进行投递。</li>
<li>Exploitation(利用)：当用户打开（攻击者所投递的）恶意文件时，用户所使用的系统就会执行恶意组件。</li>
<li>Installation(安装)：经过上一步的恶意组件执行之后，目标系统就会被安装上恶意软件。</li>
<li>Command &amp; Control(命令与控制-C2)：恶意软件的成功安装会为攻击者提供对目标系统的命令和控制能力。</li>
<li>Actions on Objectives(针对目标的行动)：在获得对一个目标系统的控制权后，攻击者就能够达到他们的行动目标，关于行动目标的示例：数据泄露（一旦成功窃取到了目标系统的数据，即代表攻击者达到行动目标）。</li>
</ol>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230322204848872.png"
                      alt="image-20230322204848872" style="zoom:67%;" 
                >

<p>关于网络攻击步骤的另一个类比是：对目标房屋感兴趣的小偷。小偷在开始行动之前，往往会花一些时间了解目标房屋，谁住在那里，他们什么时候离开以及什么时候回家，小偷还会确定目标房屋是否有安装安全摄像头以及警报系统，一旦收集到足够的信息，小偷就会制定最佳的进入策略。关于物理盗窃的计划和执行在某种程度上也类似于旨在闯入网络并窃取数据的恶意攻击行为。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/a8e61f1f9a2ea3612d3bf84f9a11f41c.png"
                      alt="a8e61f1f9a2ea3612d3bf84f9a11f41c" 
                >

<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><blockquote>
<p>攻击者在网络杀伤链的哪一步收集有关目标的信息：Recon (侦察)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215635939.png"
                      alt="image-20230320215635939"
                ></p>
<h2 id="网络安全实例"><a href="#网络安全实例" class="headerlink" title="网络安全实例"></a>网络安全实例</h2><p>在本小节的实例中，我们将尝试侵入目标 Linux 系统。</p>
<p>我们攻击的第一步是侦察；我们可以使用不同的工具来加快我们的侦察活动，这些工具将收集与目标相关的各个方面的信息。</p>
<p>为了简单起见，我们将在此使用Nmap工具，Nmap是 Network Mapper 的缩写，它是一个网络扫描器，可以帮助我们发现正在运行的机器（存活主机）以及在这些机器上运行的任何对外界可见的程序（计算机服务）。我们可以通过在终端提示符下运行 <code>nmap MACHINE_IP</code>命令来扫描目标IP：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">tips：在实际执行命令时，我们直接用目标ip地址代替下面命令中的MACHINE_IP。</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">nmap MACHINE_IP</span></span><br><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-04-06 17:38 EEST</span><br><span class="line">Nmap scan report for MACHINE_IP</span><br><span class="line">Host is up (0.00024s latency).</span><br><span class="line">Not shown: 997 closed tcp ports (reset)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">21/tcp open  ftp</span><br><span class="line">22/tcp open  ssh</span><br><span class="line">80/tcp open  http</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.33 seconds</span><br></pre></td></tr></table></figure></div>

<p>我们发现了三个服务正在运行：</p>
<ol>
<li>FTP 服务器：FTP 代表文件传输协议，用于在机器之间传输文件。</li>
<li>SSH 服务器：SSH 代表 Secure Shell，用于安全远程登录，换句话说，它允许你在远程系统上安全地执行命令。</li>
<li>HTTP 服务器：HTTP 代表超文本传输协议，用于web服务，每当你在网站上浏览网页时，你都在使用 HTTP协议 或 HTTPS协议，HTTPS 是 HTTP 的安全（加密）版本。</li>
</ol>
<p>你还可以注意到 Nmap 会根据主机是否收到任何响应来报告主机是否已启动（存活），这有助于我们知道什么时候目标机器将显示没有端口打开或者显示没有端口可访问。</p>
<p>让我们尝试收集有关 FTP 服务器的更多信息：</p>
<ol>
<li>我们将在 AttackBox 的终端中输入 <code>ftp MACHINE_IP</code> 命令来连接到目标的 FTP 服务器。</li>
<li>接下来我们尝试使用login anonymous登录，看看这个FTP服务器是否支持匿名登录。</li>
<li>成功完成匿名登录之后，我们可以尝试使用命令 ls（list的缩写）来查看可用的文件，我们能得到文件名列表及文件的详细信息。</li>
<li>如果你对所发现的任何文件感到好奇，可以使用 <code>get filename</code> 命令来进行下载，比如我想知道 secret.txt 文件包含什么，所以使用 <code>get secret.txt</code> 命令来进行文件下载。</li>
<li>成功下载文件之后，键入 <code>exit</code> 或 <code>bye</code> 即可退出 FTP 客户端。</li>
</ol>
<p>与目标FTP服务器的交互过程将如下所示：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ftp MACHINE_IP</span></span><br><span class="line">Connected to MACHINE_IP (MACHINE_IP).</span><br><span class="line">220 (vsFTPd 3.0.3)</span><br><span class="line">Name (MACHINE_IP:root): anonymous</span><br><span class="line">230 Login successful.</span><br><span class="line">Remote system type is UNIX.</span><br><span class="line">Using binary mode to transfer files.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">227 Entering Passive Mode (10,20,30,130,181,190).</span><br><span class="line">150 Here comes the directory listing.</span><br><span class="line">-rw-r--r--    1 ftp      ftp        425351 Apr 06 11:22 2680-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           356 Apr 06 11:22 2680.epub</span><br><span class="line">-rw-r--r--    1 ftp      ftp        251857 Apr 06 11:22 55317-0.txt</span><br><span class="line">-rw-r--r--    1 ftp      ftp           358 Apr 06 11:22 55317.epub</span><br><span class="line">-rwxr-xr-x    1 ftp      ftp           214 Apr 06 11:22 backup.sh</span><br><span class="line">-rw-r--r--    1 ftp      ftp            23 Apr 06 11:22 secret.txt</span><br><span class="line">226 Directory send OK.</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash">get secret.txt</span> </span><br><span class="line">local: secret.txt remote: secret.txt</span><br><span class="line">227 Entering Passive Mode (10,20,30,130,159,46).</span><br><span class="line">150 Opening BINARY mode data connection for secret.txt (23 bytes).</span><br><span class="line">226 Transfer complete.</span><br><span class="line">23 bytes received in 0.00107 secs (21.48 Kbytes/sec)</span><br><span class="line"><span class="meta prompt_">ftp&gt; </span><span class="language-bash"><span class="built_in">exit</span></span></span><br><span class="line">221 Goodbye.</span><br></pre></td></tr></table></figure></div>

<p>我们注意到上述FTP服务器中一共有六个文件：三个 txt 文件、两个 epub 文件和一个 sh 文件。txt和epub扩展名分别用于文本文件和电子书文件，而 sh 扩展名则表示该文件是一个 shell 脚本，shell 脚本通常会包含一组需要重复执行的命令。</p>
<p>在我们使用 FTP 命令 <code>get secret.txt</code>下载文件secret.txt 并使用<code>exit</code>退出 FTP 客户端之后，我们就会返回到攻击机的终端界面；此时我们可以在攻击机的终端界面中使用<code>cat secret.txt</code>命令来显示 secret.txt 文件的文本内容。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> secret.txt</span> </span><br><span class="line">password: [redacted]   #实际上这行会显示密码信息，此处的redacted表示隐藏（相当于马赛克）的意思</span><br></pre></td></tr></table></figure></div>

<p>我们得到了一个无意中复制到公共 FTP 服务器上的账户密码明文，让我们试试看它是否适用于 root 帐户（root账户在Linux系统上拥有完全的权限，可以读写任何文件，能够安装和删除任何程序）。在攻击机终端界面，我们可以输入 <code>ssh root@MACHINE_IP</code>来进行ssh登录，随后我们将被要求输入root账号的密码以进行身份验证，我们直接尝试输入我们在 FTP 服务器上发现的密码明文即可。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash">ssh root@MACHINE_IP</span></span><br><span class="line">root@MACHINE_IP&#x27;s password: </span><br><span class="line">Welcome to Ubuntu 20.04.4 LTS (GNU/Linux 5.4.0-107-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Thu  7 Apr 08:16:42 UTC 2022</span><br><span class="line"></span><br><span class="line">  System load:  0.15              Processes:              225</span><br><span class="line">  Usage of /:   64.6% of 6.53GB   Users logged in:        0</span><br><span class="line">  Memory usage: 19%               IPv4 address for ens33: MACHINE_IP</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line"> * Super-optimized for small spaces - read how we shrank the memory</span><br><span class="line">   footprint of MicroK8s to make it the smallest full K8s around.</span><br><span class="line"></span><br><span class="line">   https://ubuntu.com/blog/microk8s-memory-optimisation</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Last login: Thu Apr  7 07:53:28 2022 from 10.10.10.1</span><br></pre></td></tr></table></figure></div>

<p>以 root 身份完成ssh登录后，我们就可以完全控制目标服务器了，为了查找目标文件 我们可以使用以下 Linux 命令：</p>
<ol>
<li>使用<code>pwd</code>命令，pwd是print working directory 的缩写，此命令可用来查看我们在系统中的当前位置。</li>
<li>使用<code>ls</code>命令来列出文件信息，查看文件列表中有无目标文件。</li>
<li>使用<code>cat flag.txt</code>命令来查看文件内容。</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/root</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt  snap</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p>因为我们以 root 身份完成了登录，所以我们可以完全访问所有文件，包括其他用户的文件，我们可以执行以下 Linux 命令进行探索：</p>
<ol>
<li><p>使用<code>cd /home</code> 命令转到包含所有用户主目录的目录吗，cd 是 change directory（更改目录）的缩写。</p>
</li>
<li><p>我们在&#x2F;home目录中运行<code>ls</code>命令，查看系统的所有用户名称，因为我们拥有系统管理员（root）权限，所以我们可以直接检查其他用户的主文件夹下的内容。</p>
</li>
<li><p>使用<code>cd librarian</code>命令进入用户librarian的目录。</p>
</li>
<li><p>使用 <code>pwd</code> 命令以查看我们在系统中的当前位置（ &#x2F;home&#x2F;librarian）。</p>
</li>
<li><p>使用<code>ls</code>命令显示 librarian 目录下的文件信息，查看文件列表中有无目标文件。</p>
</li>
<li><p>我们可以使用<code>cat flag.txt</code>命令打印文本文件内容到终端界面。</p>
</li>
</ol>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> /home</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">ftpsecure  librarian  strategos</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cd</span> librarian/</span></span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">pwd</span></span></span><br><span class="line">/home/librarian</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">flag.txt</span><br><span class="line"><span class="meta prompt_">root@AttackBox# </span><span class="language-bash"><span class="built_in">cat</span> flag.txt</span> </span><br><span class="line">[redacted]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/a708c20aa1243c8e2be30bb9e74bd663.png"
                      alt="img"
                ></p>
<p>让我们总结一下我们在本小节中的工作，我们的目标是获取 IP 地址为MACHINE_IP的目标系统的root访问权限：</p>
<ol>
<li>我们使用 nmap 来了解目标机器正在运行的服务。</li>
<li>我们连接到目标机的 FTP 服务器以了解有关其配置的更多信息。</li>
<li>我们发现一个包含root密码的文件被错误地复制到了FTP服务器中的公共文件夹下。</li>
<li>我们使用找到的密码，以root用户身份来进行ssh登录。</li>
<li>最终，我们获得了所有用户文件的访问权限（因为此时的用户身份为root）。</li>
</ol>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p><em><strong>问题</strong></em></p>
<ol>
<li>secret.txt文件内容中的密码是什么？</li>
<li>&#x2F;root目录中的flag.txt文件内容是什么？</li>
<li>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是什么？</li>
</ol>
<p><em><strong>操作</strong></em></p>
<p>使用nmap进行端口扫描：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV -sC -T4 10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221312517.png"
                      alt="image-20230322221312517"
                ></p>
<blockquote>
<p>目标机器上存在FTP服务且允许进行匿名登录</p>
</blockquote>
<p>针对目标机的ftp服务进行匿名登录尝试：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ftp 10.10.98.42</span><br><span class="line">anonymous</span><br><span class="line">ls</span><br><span class="line">get secret.txt </span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221546534.png"
                      alt="image-20230322221546534"
                ></p>
<p>下载完敏感文件后，在攻击机终端查看到该文件内容为root用户的密码明文，所以我们基于已知密码 直接尝试以root用户身份进行ssh登录：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat secret.txt #password: ABC789xyz123</span><br><span class="line"></span><br><span class="line">ssh root@10.10.98.42</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221617429.png"
                      alt="image-20230322221617429"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322221757084.png"
                      alt="image-20230322221757084"
                ></p>
<blockquote>
<p>secret.txt文件内容中的密码是：ABC789xyz123 。</p>
</blockquote>
<p>成功完成ssh登录成功后，我们获得了root权限，接下来我们将查找目标系统上的目标文本文件并查看相关的文本内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br><span class="line"></span><br><span class="line">cd /home</span><br><span class="line">ls</span><br><span class="line">cd /home/librarian/</span><br><span class="line">ls</span><br><span class="line">cat flag.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322222032954.png"
                      alt="image-20230322222032954"
                ></p>
<blockquote>
<p>&#x2F;root目录中的flag.txt文件内容是：THM{FTP_SERVER_OWNED} 。</p>
<p>&#x2F;home&#x2F;librarian目录中的flag.txt文件内容是：THM{LIBRARIAN_ACCOUNT_COMPROMISED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320215901969.png"
                      alt="image-20230320215901969"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to Digital Forensics(数字取证介绍)-学习</title>
    <url>/2024/01/16/THM-Intro%20to%20Digital%20Forensics(%E6%95%B0%E5%AD%97%E5%8F%96%E8%AF%81%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introdigitalforensics" >https://tryhackme.com/room/introdigitalforensics <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数字取证及其相关流程，并完成相关的简单实例。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>取证是指应用科学技术来调查犯罪情况和确定事实。随着计算机和智能手机等数字系统的使用和普及，为了调查和数字系统相关的犯罪情况，一个新的取证学分支得以诞生：计算机取证——后来逐渐演变为数字取证。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232751118.png"
                      alt="image-20230322232751118"
                ></p>
<p>考虑以下场景——执法人员到达了犯罪现场，然而，这个犯罪现场的一部分包括了数字设备和数字媒体；数字设备包括台式电脑、笔记本电脑、数码相机、音乐播放器和智能手机等，而数字媒体则包括 CD、DVD、USB 闪存驱动器和外部存储设备。这就引出了以下几个问题：</p>
<ul>
<li>警方应如何收集智能手机和笔记本电脑等设备中的数字证据？ 如果计算机和智能手机正在运行，应遵循哪些工作程序进行处理？</li>
<li>如何传输数字证据？例如，在移动计算机时是否有某些最佳实践方案可以遵循？</li>
<li>如何分析收集到的数字证据？个人设备的数据存储量可能在数十 GB 到数 TB 之间，应该如何进行分析？</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232730081.png"
                      alt="image-20230322232730081"
                ></p>
<p>假设嫌疑人拥有如上图所示的可疑数字设备和可疑数字媒体，我们可以进行快速查看并调查一些可能存有关键证据的数字设备、媒体；除了台式电脑之外，我们还注意到嫌疑人桌面上有平板电脑、智能手机、数码相机和 USB 闪存驱动器，这些设备及媒体中的任何一个都可能包含有助于案件调查的大量信息，执法者为了将这些设备作为证据进行处理 就需要用到数字取证技术。</p>
<p>更正式地说，数字取证就是应用计算机科学为达到法律目的而对数字证据展开调查。数字取证可用于进行以下两种类型的调查：</p>
<ol>
<li>公共部门调查，是指由政府和执法机构开展的调查，他们将参与犯罪调查或者民事调查。</li>
<li>私营部门调查，是指公司机构通过指派私人调查员进行的调查，无论是内部调查还是外包调查，它们都是由违反公司政策的行为而引发的调查。</li>
</ol>
<p>无论是调查犯罪行为还是调查违反公司政策的行为，部分证据都可能会与数字设备和数字媒体有关，这就是数字取证技术发挥作用并试图确定到底发生了什么的地方，没有训练有素的数字取证调查员的辛勤工作，就不可能正确地处理任何数字证据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322232853397.png"
                      alt="image-20230322232853397"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320220915406.png"
                      alt="image-20230320220915406"
                ></p>
<h2 id="数字取证流程"><a href="#数字取证流程" class="headerlink" title="数字取证流程"></a>数字取证流程</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322234317128.png"
                      alt="image-20230322234317128"
                ></p>
<p>假如你是一名数字取证调查员，你可能会看到与上图所示场景相类似的现场情况，为了扮演好数字取证调查员的角色，你接下来应该做什么？在获得适当的合法授权后，进行数字取证的基本计划如下：</p>
<ol>
<li><p>获取证据：收集可疑的笔记本电脑、存储设备、数码相机等数字设备。（注意：当笔记本电脑和计算机在打开状态时 需要进行特殊处理，但本文在此不做深入介绍）</p>
</li>
<li><p>建立监管链(Establish a chain of custody)：适当填写相关表格（可基于<a class="link"   href="https://www.nist.gov/document/sample-chain-custody-formdocx" >表格样本 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>），这一步的目的是要确保只有经过授权的调查人员才能访问数字证据，以保证没有其他人可以篡改证据。</p>
</li>
<li><p>将证据放在安全的容器中：你要确保数字证据不被损坏，对于智能手机而言，你需要确保它们无法访问网络，以免被其他人远程擦除数据。</p>
</li>
<li><p>将证据传送到你的数字取证实验室。</p>
</li>
</ol>
<p>在数字取证实验室中，相关的操作过程如下：</p>
<ol>
<li><p>从安全容器中检索数字证据。</p>
</li>
<li><p>创建证据的取证副本：取证副本需要使用高级软件进行创建 以避免修改原始数据。</p>
</li>
<li><p>将数字证据返回到安全容器：之后你将处理取证副本，如果你不小心损坏了取证副本，你可以随时再创建一个新副本。</p>
</li>
<li><p>在取证工作站上处理取证副本。</p>
</li>
</ol>
<p>以上步骤改编自<a class="link"   href="https://www.cengageasia.com/TitleDetails/isbn/9781337568944" >《计算机取证和调查指南》第 6 版 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>简而言之，进行数字取证时要注意以下几点：</p>
<ul>
<li><p>适当的搜查权限：调查人员不能在没有适当的法律权限的情况下 开始进行数字取证操作。</p>
</li>
<li><p>监管链：这对于随时跟踪谁在持有数字证据是必要的。</p>
</li>
<li><p>数学验证：通过使用一种特殊的数学函数，该函数称为散列（hash-哈希）函数，我们可以确认原数字文件未被修改。</p>
</li>
<li><p>使用经过验证的工具：应对数字取证中使用的工具进行验证，以确保它们能够正常工作；例如，如果你正在创建磁盘映像，你希望能够确保 最终得到的取证映像与磁盘上的原数据相同。</p>
</li>
<li><p>可重复性：只要具备适当的技能和工具，就可以复制数字取证的结果。</p>
</li>
<li><p>报告：数字取证调查以一份报告结束，该报告将显示与所发现案件相关的证据。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322235500854.png"
                      alt="image-20230322235500854"
                ></p>
<h2 id="数字取证的简单实例"><a href="#数字取证的简单实例" class="headerlink" title="数字取证的简单实例"></a>数字取证的简单实例</h2><p>我们在数字设备上所做的一切，从智能手机到电脑，都会留下痕迹，让我们看看我们如何在后续调查中使用它。</p>
<p>本小节实例场景介绍：我们的猫Gado被绑架了，绑架者向我们发送了一份包含他们要求的 MS Word 文档格式的文档；为了方便起见，我们已将相关文档转换为了 PDF 格式并从 MS Word 文件中提取出了图像；我们接下来要对 目标pdf文件 以及 目标jpg文件 进行简单的数字取证分析。</p>
<p>你可以通过使用TryHackMe中和本文相关的实验房间页面–下载附件到你的本地机器上进行检查；或者直接打开 在对应实验房间页面所部署的 AttackBox 上的终端，然后转到目录 &#x2F;root&#x2F;Rooms&#x2F;introdigitalforensics 进行文件检查。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用TryHackMe所提供的AttackBox上的终端</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> /root/Rooms</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">cd</span> introdigitalforensics</span></span><br><span class="line"><span class="meta prompt_">root# </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">letter-image.jpg  ransom-letter.doc  ransom-letter.pdf  ransom-lettter-2.zip</span><br></pre></td></tr></table></figure></div>

<p><strong>文档元数据</strong></p>
<p>当你创建简单的文本文件 TXT 时，操作系统会自动保存一些元数据，例如文件创建日期和上次修改日期；而当你使用更高级的编辑器（例如 MS Word）进行文件创建时，会有更多的信息被保留在文件的元数据中。 有多种读取文件元数据的方法，你可以使用一些官方查看器&#x2F;编辑器打开文件读取元数据 或者 选择使用合适的取证工具对文件进行元数据读取，请注意，如果你将原始文件导出为其他格式如 PDF 格式，则将保留原始文档的大部分元数据，这具体取决于你所使用的 PDF 编辑器。</p>
<p> 如果我们要从PDF 文件中获取信息，我们可以尝试使用 <em><strong>pdfinfo</strong></em>工具 来读取pdf文件的元数据。使用 <em><strong>pdfinfo</strong></em> 会显示与 PDF 文件相关的各种元数据，例如标题、主题、作者、创建者和创建日期。 （如果你使用的是 Kali Linux 并且没有安装 <em><strong>pdfinfo</strong></em>，则可用 <code>sudo apt install poppler-utils</code> 命令来进行安装）</p>
<p>以下为使用<code>pdfinfo DOCUMENT.pdf</code>命令的示例。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">pdfinfo DOCUMENT.pdf</span> </span><br><span class="line">Creator:        Microsoft® Word for Office 365</span><br><span class="line">Producer:       Microsoft® Word for Office 365</span><br><span class="line">CreationDate:   Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">ModDate:        Wed Oct 10 21:47:53 2018 EEST</span><br><span class="line">Tagged:         yes</span><br><span class="line">UserProperties: no</span><br><span class="line">Suspects:       no</span><br><span class="line">Form:           none</span><br><span class="line">JavaScript:     no</span><br><span class="line">Pages:          20</span><br><span class="line">Encrypted:      no</span><br><span class="line">Page size:      595.32 x 841.92 pts (A4)</span><br><span class="line">Page rot:       0</span><br><span class="line">File size:      560362 bytes</span><br><span class="line">Optimized:      no</span><br><span class="line">PDF version:    1.7</span><br></pre></td></tr></table></figure></div>

<p>以上 PDF 元数据清楚地表明它是在 2018 年 10 月 10 日使用 MS Word for Office 365 创建的。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 pdfinfo，找出和本实验房间页面所提供的pdf附件相关的作者信息。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /root/Rooms</span><br><span class="line">cd introdigitalforensics</span><br><span class="line">ls</span><br><span class="line">pdfinfo ransom-letter.pdf</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180941729.png"
                      alt="image-20230323180941729"
                ></p>
<blockquote>
<p>目标pdf文件作者是：Ann Gree Shepherd</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323172932309.png"
                      alt="image-20230323172932309"
                ></p>
<p><strong>照片 EXIF 数据</strong></p>
<p>EXIF 代表 可交换图像文件格式(Exchangeable Image File Format)，它是将元数据保存到图像文件的标准。每当你使用智能手机或数码相机拍照时，图像中都会嵌入大量信息，以下是可以在原始数字图像中找到的元数据示例：</p>
<ul>
<li>相机型号&#x2F;智能手机型号</li>
<li>拍摄图像的日期和时间</li>
<li>照片设置，例如焦距、光圈、快门速度和 ISO 设置等</li>
</ul>
<p>由于智能手机可能配备了 GPS 传感器，因此也很有可能通过照片找到嵌入在图像中的 GPS 坐标(GPS 坐标，即纬度和经度)，这通常会暴露出照片的拍摄地点。</p>
<p>有许多在线和离线工具可以从图像中读取 EXIF 数据，比如命令行工具 <code>exiftool</code> ，<code>exiftool</code> 可用于读取和写入各种文件类型（例如 JPEG 图像）中的元数据。 （如果你使用的攻击机是Kali Linux 并且没有安装 <code>exiftool</code>，则可以输入 <code>sudo apt install libimage-exiftool-perl</code> 命令安装<code>exiftool</code>）</p>
<p>只要执行简单的 <code>exiftool IMAGE</code>命令，就能读取嵌入到图像文件中的所有 EXIF 数据：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">user@TryHackMe$ </span><span class="language-bash">exiftool IMAGE.jpg</span></span><br><span class="line">[...]</span><br><span class="line">GPS Position : 51 deg 31&#x27; 4.00&quot; N, 0 deg 5&#x27; 48.30&quot; W</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></div>

<p>如果我们通过在线地图搜索上述得到的坐标位置，则将了解有关照片拍摄位置的更多信息。我们可以在 <a class="link"   href="https://www.bing.com/maps" >Microsoft Bing 地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或者 <a class="link"   href="https://www.google.com/maps" >谷歌地图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 上搜索 51° 31’ 4.00” N，0° 5’ 48.30” W ，我们会发现这些坐标将表明 目标照片是在一个非常靠近伦敦博物馆的地方拍摄的（我们用 ° 替换 deg，以便我们使用地图搜索），同时，我们还能注意到 以上坐标在搜索页面上会被转换为十进制表示——51.517776,-0.09675 。</p>
<p><strong>答题</strong></p>
<p><em>问题：使用 exiftool 或任何类似工具，尝试找到 和本实验房间页面所提供的图像附件相关的街道名称。(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">exiftool letter-image.jpg | grep GPS</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323181841107.png"
                      alt="image-20230323181841107"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323180223367.png"
                      alt="image-20230323180223367"
                ></p>
<blockquote>
<p>从 exiftool 获得的 GPS 坐标是 51 deg 30’ 51.90” N，0 deg 5’ 38.73” W （在使用地图检索时，请用 ° 替换 deg 并在搜索前 删除数字和 ° 符号之间的空格）。</p>
<p>最终我们将使用在线地图搜索以下坐标：51°30’51.9”N 0°05’38.7”W</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175531086.png"
                      alt="image-20230323175531086"
                ></p>
<p><em>问题：继续分析以上图像附件，拍摄目标照片所用的相机型号名称是什么？(我们使用和本文相关的 TryHackMe实验房间页面 所提供的 AttackBox 进行分析)</em></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">要仅显示带有单词“Camera”的行，可以使用 exiftool PHOTO.jpg | grep Camera 命令</span></span><br><span class="line">exiftool letter-image.jpg | grep Camera</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323182006160.png"
                      alt="image-20230323182006160"
                ></p>
<blockquote>
<p>拍摄目标照片所用的相机型号名称为：Canon EOS R6</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323175540323.png"
                      alt="image-20230323175540323"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Security Operations(安全运营介绍)-学习</title>
    <url>/2024/01/16/THM-Security%20Operations(%E5%AE%89%E5%85%A8%E8%BF%90%E8%90%A5%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/securityoperations" >https://tryhackme.com/room/securityoperations <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解安全运营中心(SOC)的相关职责、服务和数据来源。</p>
<h2 id="安全运营简介"><a href="#安全运营简介" class="headerlink" title="安全运营简介"></a>安全运营简介</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/47bec18ccc60451eda390ef07b4daf54.png"
                      alt="An image showing a Security Operations Center: a team of IT security professionals tasked with monitoring a company&#39;s network and systems."
                ></p>
<p>安全运营中心 (SOC) 是一类 IT 安全专业人员团队，负责每周 7 天、每天 24 小时监控公司的网络和系统，他们监控的目的是：</p>
<ul>
<li><p>查找网络上的漏洞（Find vulnerabilities on the network）：漏洞可以被攻击者利用，以执行超出许可级别的操作，在网络上的任何设备（操作系统和程序）中都可能发现漏洞，包括服务器设备或计算机设备等；在现实情况中，SOC 可能会发现一组必须针对已发布的特定漏洞进行修补的 MS Windows 计算机。严格来说，查找并发现漏洞不一定是 SOC 的责任范畴，但是，未修复的漏洞肯定会影响整个公司的安全级别。</p>
</li>
<li><p>检测未经授权的活动（Detect unauthorized activity）：例如，攻击者发现了某个员工的用户名和密码并使用这些凭据登录到公司系统——这就是一种未经过授权的活动，而在攻击者造成任何损害之前快速检测到未经授权的活动至关重要；有许多线索可以帮助我们检测到发生了未经授权的活动，例如登录ip所对应的地理位置异常等。</p>
</li>
<li><p>发现策略违规（Discover policy violations）：安全策略是一组规则和程序，旨在保护公司免受安全威胁并确保公司数据的合规性，什么行为被视为违规因公司而异，比如：下载盗版媒体文件、不安全地发送公司机密文件等行为。</p>
</li>
<li><p>检测入侵（Detect intrusions）：入侵是指针对系统和网络进行攻击或窃密的行为，例如攻击者对目标Web 应用程序进行漏洞利用，或者攻击者诱导用户访问恶意站点并感染用户计算机等。</p>
</li>
<li><p>支持事件响应（Support with the incident response）：此处的事件指的是安全事件，事件可以是策略违规、攻击入侵企图或者其他更具破坏性的网络攻击行为，例如发现了某个重大漏洞正在被攻击者利用；正确应对严重安全事件并非易事，而SOC 可以支持事件响应团队更好地处理安全事件。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<blockquote>
<p>SOC代表：Security Operations Center（安全运营中心）</p>
<p>SOC每天监控网络多少小时：24</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222314909.png"
                      alt="image-20230320222314909"
                ></p>
<h2 id="安全运营的要素"><a href="#安全运营的要素" class="headerlink" title="安全运营的要素"></a>安全运营的要素</h2><p>在本小节中，我们将讨论：</p>
<ul>
<li>SOC 所依赖的示例数据源。</li>
<li>SOC 所提供的服务。</li>
<li>一个示例场景。</li>
</ul>
<p><strong>数据源（Data Sources）</strong></p>
<p>SOC 将通过多种数据源来监控网络环境中是否存在入侵迹象并检测任何恶意行为，其中一些数据来源是：</p>
<ul>
<li>服务器日志：网络上有多种类型的服务器，例如邮件服务器、Web 服务器和 MS Windows 网络上的域控制器等，日志会包含有关各种活动的信息，例如成功和失败的登录尝试等；在服务器日志中，我们可以找到大量和服务器相关的活动信息。</li>
<li>DNS 活动：DNS 代表域名系统，它是负责将域名（例如 tryhackme.com）转换为 IP 地址（例如 10.3.13.37）的协议，同时也支持其他与域名相关的查询；DNS 查询的一个类比是 用户询问“我怎样才能到达 TryHackMe？” 然后就会有人回复一个对应的邮政地址。在实际情况中，如果有人试图浏览 tryhackme.com，DNS 服务器就会对这个域名进行解析，并会将相关的 DNS 查询记录到监控中；SOC 可以仅通过检查 DNS 查询记录来收集有关内部系统尝试与之进行通信的域名的信息。 </li>
<li>防火墙日志：防火墙是一种控制网络数据包进出网络的设备，主要通过放行数据包或者阻断数据包来进行控制流量；因此，防火墙日志可以揭示 有关哪些数据包通过了或者试图通过防火墙的相关大量信息。</li>
<li>DHCP 日志：DHCP 代表的是动态主机配置协议，它主要负责 为尝试连接到某个指定网络的计算机系统分配 IP 地址。DHCP 请求的一个类比是 当你进入一家高级餐厅时，服务员会说欢迎你并引导你到一张空桌子处；使用了DHCP协议后，你无需手动配置即可尝试让你的电脑加入某个网络，因为DHCP 会自动为你的设备提供 加入网络所需的网络设置。通过检查 DHCP 事务，SOC 就可以了解加入到某个指定网络的设备的信息。</li>
</ul>
<p>以上只是一些最常见的数据源，另外还有许多其他资源可用于帮助完善网络安全监控 以及 有利于 SOC 完成其他工作任务；SOC 可能还会使用 安全信息和事件管理系统 (SIEM-Security Information and Event Management) 来开展工作， SIEM 会聚合来自于不同来源的数据信息，以便于 SOC 可以有效地关联数据并响应攻击事件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/ff0d15f07e9889f26931fa5665a4c871.png"
                      alt="img"
                ></p>
<p><strong>SOC服务（SOC Services）</strong></p>
<p>SOC 服务可分为反应式服务和主动式服务。</p>
<p>反应式服务是指在检测到入侵或恶意事件后启动的任务，包括以下示例：</p>
<ul>
<li>监控安全态势：这是 SOC 的主要职责，它包括监控网络和计算机的相关安全警报、安全通知，并根据需要做出及时响应。</li>
<li>漏洞管理：这是指发现公司系统中的漏洞并修补（修复）它们，SOC 可以协助完成这项任务，但不一定要亲自执行它。</li>
<li>恶意软件分析：SOC 可能需要获取网络中的恶意程序，SOC 可以通过在受控环境中执行恶意程序来进行基本的恶意软件分析，但是，更高级的分析需要由其他专门的安全团队来完成。</li>
<li>入侵检测：入侵检测系统 (IDS) 可用于检测和记录入侵行为和一些可疑数据包，而SOC 的工作就是维护这样一个系统，监控其警报，并根据需要检查其日志。</li>
<li>报告：报告安全事件和警报至关重要，及时进行报告 对于确保工作流程顺畅和支持合规性要求是必要的措施。</li>
</ul>
<p>主动式服务是指在没有任何入侵迹象的情况下由 SOC 处理的任务，需要 SOC 执行的主动服务示例包括：</p>
<ul>
<li><p>网络安全监控（NSM-Network security monitoring）：侧重于监控网络数据和分析流量以检测是否存在入侵迹象。</p>
</li>
<li><p>威胁搜寻：威胁搜寻指的是 SOC 先假定入侵行为已经发生 然后再进行验证，SOC会通过搜寻网络安全威胁 以明确某种入侵行为是否存在。</p>
</li>
<li><p>威胁情报：威胁情报侧重于了解潜在的攻击者及其攻击策略、攻击技术，从而提高公司的防御能力。收集威胁情报的目的是为了建立威胁知情防御。</p>
</li>
</ul>
<p>除了以上服务外，SOC 提供的其他服务还包括网络安全培训，该服务将帮助提高用户的安全意识并为用户提供扎实的安全培训，这可以避免发生过多的数据泄露事件以及网络入侵行为。</p>
<p><strong>示例场景（Example Scenario）</strong></p>
<p>SOC 中有一个角色是 SOC 分析师，SOC 分析师主要负责网络安全监控和日志管理。 </p>
<p>让我们考虑以下场景：在监控网络流量时，SOC 分析师注意到 当前受监控的网络环境中 存在每分钟重复一次的特定 DNS 查询行为，这种行为并不像是用户在正常浏览网络。</p>
<p>SOC 分析师可能的应对流程如下：</p>
<ol>
<li><p>SOC 分析师检查 DNS 查询的来源并将源头确定为网络上的一台笔记本电脑。</p>
</li>
<li><p>SOC 分析师将这台笔记本隔离并检查该机器是否有感染迹象，结果发现该机器上有一个进程（程序）正在使用 DNS 与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师通过查看计算机日志发现该计算机是在访问恶意网站后被感染的，这种感染的结果是：受害计算机通过将消息隐藏在 DNS 查询中来与恶意服务器通信。</p>
</li>
<li><p>SOC 分析师将这台笔记本电脑清理干净，并开始进行威胁搜寻以确保没有其他计算机被感染。</p>
</li>
</ol>
<p><strong>答题</strong></p>
<blockquote>
<p>NSM代表：Network security monitoring（网络安全监控）</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230322231522117.png"
                      alt="image-20230322231522117"
                ></p>
<h2 id="关于SOC的实例"><a href="#关于SOC的实例" class="headerlink" title="关于SOC的实例"></a>关于SOC的实例</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/4d68ffe73a45b4974a36d0947d4b27d8.png"
                      alt="img"
                ></p>
<p>防火墙是一种检查进入和离开网络或系统的网络数据包的设备，我们可以使用防火墙来阻止一些正在进行的网络攻击，最基本的防火墙检查类型包括：</p>
<ul>
<li><p>源 IP 地址和目标 IP 地址：IP 地址是允许你通过 Internet 进行通信的逻辑地址。你可以把 IP 地址类比为邮政地址，例如，一家公司需要使用一个有效的邮政地址来发送和接收包裹，你可以进而将 IP 数据包想象成一个邮递包裹。</p>
</li>
<li><p>源端口号和目标端口号（在适用的情况下）：一台计算机有一个 IP 地址，此外，计算机上的每个程序还需要一个对应的端口号才能通过网络进行通信。你可以把端口号类比为一家公司内的房间号。</p>
</li>
</ul>
<p>基本的防火墙规则可能类似于以下内容：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">源IP地址     目标IP地址    源端口 目标端口  操作</span><br><span class="line"></span><br><span class="line">172.16.4.1  10.10.10.41   ANY    80      PASS（通过）</span><br><span class="line">172.16.8.1  10.10.10.81   ANY    23      DROP（丢弃）</span><br></pre></td></tr></table></figure></div>

<p>以上两条规则规定了以下内容：</p>
<ul>
<li>所有从源 IP 地址 172.16.4.1 到目标 IP 地址 10.10.10.41 并且到目标端口号 80 的 IP 数据包都会被防火墙允许，相关的数据包可以通过防火墙。</li>
<li>所有从源 IP 地址 172.16.8.1 到目标 IP 地址 10.10.10.81 并且到目标端口号 23 的 IP 数据包都会被防火墙阻塞，相关的数据包会被丢弃——无法通过防火墙。</li>
</ul>
<p><strong>答题</strong></p>
<p><em>在本文相关的Tryhackme实验房间页面 部署虚拟实验环境，并完成本小节对应的实例。</em></p>
<p>我们将模拟在防火墙级别拦截恶意IP地址所发出的数据包，这需要我们快速添加一些防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230516322.png"
                      alt="image-20230323230516322"
                ></p>
<p>发现恶意ip及其数据包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230712062.png"
                      alt="image-20230323230712062"
                ></p>
<p>快速添加防火墙规则：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230832936.png"
                      alt="image-20230323230832936"
                ></p>
<p>成功拦截并得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230323230915180.png"
                      alt="image-20230323230915180"
                ></p>
<blockquote>
<p>最后得到的flag内容为：THM{ATTACK_BLOCKED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230320222055186.png"
                      alt="image-20230320222055186"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>在Kali中配置clash代理(含终端流量)</title>
    <url>/2024/01/18/%E5%9C%A8Kali%E4%B8%AD%E9%85%8D%E7%BD%AEclash%E4%BB%A3%E7%90%86(%E5%90%AB%E7%BB%88%E7%AB%AF%E6%B5%81%E9%87%8F)/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本文内容概述：</p>
<ul>
<li>在Kali中安装clash；</li>
<li>在Kali中配置终端流量代理，以便终端命令在必要的时候可以走代理流量；</li>
<li>在Kali中配置浏览器端流量代理，以便通过kali机器访问谷歌等网站；</li>
<li>解决在使用BurpSuite抓包时遇到的“谷歌recaptcha验证码国内调试”等相关问题。</li>
</ul>
<h2 id="下载Clash"><a href="#下载Clash" class="headerlink" title="下载Clash"></a>下载Clash</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Dreamacro/clash/releases/download/v1.15.1/clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">gunzip clash-linux-amd64-v1.15.1.gz</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64-v1.15.1 clash#重命名文件夹</span><br><span class="line"></span><br><span class="line">cd clash/</span><br><span class="line"></span><br><span class="line">mv clash-linux-amd64 clash#重命名文件</span><br><span class="line"></span><br><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure></div>

<h2 id="配置clash节点-请自行购买vpn节点"><a href="#配置clash节点-请自行购买vpn节点" class="headerlink" title="配置clash节点(请自行购买vpn节点)"></a>配置clash节点(请自行购买vpn节点)</h2><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nano /root/.config/clash/config.yaml#将config.yaml配置文件内容更换为已订阅的VPN节点文件内容√</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可能需要手动复制粘贴节点文件内容</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230745920-1379638961.png"
                      alt="image-20230505071036891"
                ></p>
<h2 id="Kali终端流量代理设置"><a href="#Kali终端流量代理设置" class="headerlink" title="Kali终端流量代理设置"></a>Kali终端流量代理设置</h2><h3 id="修改proxychains4配置文件"><a href="#修改proxychains4配置文件" class="headerlink" title="修改proxychains4配置文件"></a>修改proxychains4配置文件</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/proxychains4.conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在配置文件的末尾部分 添加以下两行</span></span><br><span class="line">http 127.0.0.1 7890       #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br><span class="line">socks5 127.0.0.1 7890     #添加由clash所设置的代理√  端口号7890可通过查看配置文件/root/.config/clash/config.yaml得知</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230746676-1972959411.png"
                      alt="image-20230505071106289"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747239-1590817637.png"
                      alt="image-20230501215816004"
                ></p>
<h3 id="通过终端启动clash程序"><a href="#通过终端启动clash程序" class="headerlink" title="通过终端启动clash程序"></a>通过终端启动clash程序</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/hekeats/桌面/clash</span><br><span class="line">./clash</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230747812-1957154928.png"
                      alt="image-20230501215450971"
                ></p>
<p>在浏览器中访问<code>http://clash.razord.top/</code> ，此URL对应的是clash的图形用户界面。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748314-203330223.png"
                      alt="image-20230501215534594"
                ></p>
<h3 id="测试终端流量代理"><a href="#测试终端流量代理" class="headerlink" title="测试终端流量代理"></a>测试终端流量代理</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试终端流量是否被成功代理，返回结果为ok则说明终端代理配置成功！</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在所有想走代理的终端命令前面添加proxychains4即可</span></span><br><span class="line">proxychains4 curl -sSf http://www.google.com &gt; /dev/null    #test ok √</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230748722-1178580563.png"
                      alt="image-20230501215340251"
                ></p>
<h2 id="浏览器端流量代理设置"><a href="#浏览器端流量代理设置" class="headerlink" title="浏览器端流量代理设置"></a>浏览器端流量代理设置</h2><h3 id="添加浏览器代理"><a href="#添加浏览器代理" class="headerlink" title="添加浏览器代理"></a>添加浏览器代理</h3><p>以下两种方法任选其一即可：</p>
<ul>
<li><p>使用浏览器代理插件，以火狐浏览器为例，使用FoxyProxy添加代理<code>127.0.0.1 7890</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749103-359792420.png"
                      alt="image-20230501220409534"
                ></p>
</li>
<li><p>打开本地浏览器设置，在网络设置中选择手动配置代理，并填写<code>127.0.0.1 7890</code>。</p>
<p>通过地址栏快捷访问浏览器的设置界面：<code>about:preferences</code>。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749427-1894573037.png"
                      alt="image-20230501222137401"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230749757-395404947.png"
                      alt="image-20230501220932834"
                ></p>
<p>tips：上述端口号<code>7890</code>可通过查看配置文件<code>/root/.config/clash/config.yaml</code>得知。</p>
<h3 id="测试浏览器端流量代理"><a href="#测试浏览器端流量代理" class="headerlink" title="测试浏览器端流量代理"></a>测试浏览器端流量代理</h3><p>配置好浏览器代理之后，访问 <a class="link"   href="http://www.google.com/" >www.google.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，查看页面响应情况。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750113-568475238.png"
                      alt="image-20230501230523149"
                ></p>
<h2 id="BurpSuite和calsh代理兼容问题"><a href="#BurpSuite和calsh代理兼容问题" class="headerlink" title="BurpSuite和calsh代理兼容问题"></a>BurpSuite和calsh代理兼容问题</h2><p>在使用BurpSuite抓包时，如果遇到google recaptcha等需要VPN才能访问的验证码机制，我们就需要重新配置本地浏览器代理。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750487-443165563.png"
                      alt="image-20230501221558317"
                ></p>
<p>tips：设置好8080端口代理，这样BurpSuite才能抓到数据包。</p>
<p>然后打开BurpSuite，进入到“用户选项”下的“Connections(连接)”子选项卡界面，添加并编辑上游代理规则：</p>
<p>注意：新版BurpSuite要先点击“设置”按钮，才能开始选择“用户选项”。</p>
<p><u>中文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230750855-1248001512.png"
                      alt="image-20230501223436455"
                ></p>
<p><u>英文版界面</u></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/2857591-20230508230751240-481769820.png"
                      alt="image-20230501223806392"
                ></p>
<p>参考资料：</p>
<ul>
<li><a class="link"   href="https://www.iculture.cc/cybersecurity/pig=265" >https://www.iculture.cc/cybersecurity/pig=265 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/post/7223566884502011959" >https://juejin.cn/post/7223566884502011959 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash" >https://juejin.cn/s/kali%E5%AE%89%E8%A3%85clash <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <tags>
        <tag>常见问题-FAQ</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Extending Your Network(网络扩展基础介绍)-学习</title>
    <url>/2024/01/18/THM-Extending%20Your%20Network(%E7%BD%91%E7%BB%9C%E6%89%A9%E5%B1%95%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/extendingyournetwork" >https://tryhackme.com/room/extendingyournetwork <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些用于将网络扩展到 Internet(互联网公网) 的技术以及这样做的动机。</p>
<h2 id="端口转发介绍"><a href="#端口转发介绍" class="headerlink" title="端口转发介绍"></a>端口转发介绍</h2><p>端口转发是应用程序和服务连接到 Internet(互联网公网) 所需的重要步骤，如果没有端口转发，应用程序和服务(如web服务)只能对同一直连网络中的设备可用。</p>
<p>以下面的网络为例：在以下网络中，IP地址为“192.168.1.10”的服务器在端口80上运行着web服务，但该网络上只有另外两台计算机能够访问此web服务。(这种网络被称为内部网络)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163246516.png"
                      alt="image-20230327163246516"
                ></p>
<p>如果网络管理员想让公众(通过互联网)访问上图中的网站，管理员就必须实现端口转发，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327163735248.png"
                      alt="image-20230327163735248"
                ></p>
<p>通过上图这种设计，网络2现在可以使用网络1的公共IP地址(82.62.51.70)并通过80端口访问运行在网络1上的web服务器。</p>
<p>我们很容易将端口转发行为与防火墙的行为混淆，但是这两者是不一样的；防火墙能够决定流量是否可以通过某些端口(即使这些端口是通过端口转发开放的)。</p>
<p><em>tips：端口转发是在网络中的路由器上配置的。</em></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327165324795.png"
                      alt="image-20230327165324795"
                ></p>
<h2 id="防火墙简介"><a href="#防火墙简介" class="headerlink" title="防火墙简介"></a>防火墙简介</h2><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/roomicon.png"
                      alt="img" style="zoom:50%;" 
                >

<p>防火墙是网络中的一种设备，它负责确定允许哪些流量进入网络和退出网络，防火墙可以被视为网络的边界安全。网络管理员可以根据多种因素将防火墙配置为允许或拒绝某些流量进入或退出网络，例如：</p>
<ul>
<li>流量从哪里来？ （防火墙是否被告知：接受&#x2F;拒绝来自特定网络的流量？）</li>
<li>流量要往哪里去？ （防火墙是否被告知：接受&#x2F;拒绝发往特定网络的流量？）</li>
<li>流量流向哪个端口？ （防火墙是否被告知：仅接受&#x2F;拒绝发往端口 80 的流量？）</li>
<li>流量使用什么协议？ （防火墙是否被告知：接受&#x2F;拒绝 UDP、TCP 或两者的流量？）</li>
</ul>
<p><em><strong>tips：防火墙将通过执行数据包检查来确定以上这些问题的答案。</strong></em></p>
<p>防火墙有各种各样的形状和大小：从可以处理大量数据的专用硬件(通常存在于像企业这样的大型网络中)到住宅路由器(通常存在于家庭网络中)或者Snort软件(一种开源入侵防御系统-IPS)，防火墙可以分为2到5类。</p>
<p>我们将在下面介绍两种主要类型的防火墙：</p>
<ul>
<li>Stateful（有状态）：这种类型的防火墙将使用来自连接的全部信息，这种防火墙不是基于单个数据包检查，而是<em><strong>基于整个连接来确定设备的行为</strong></em>；与无状态防火墙相比，有状态防火墙会消耗很多资源，因为相关的流量决策是动态的，例如，有状态防火墙可以让TCP三次握手过程中的第一部分执行失败；如果来自主机的连接不正常，这将阻塞整个设备。</li>
<li>Stateless（无状态）：这种类型的防火墙将使用一组静态规则来<em><strong>确定单个数据包是否可接受</strong></em>，例如，某设备发送了一个坏数据包并不意味着此设备随后都将会被阻塞；虽然无状态防火墙比其他防火墙使用更少的资源，但无状态防火墙的表现也更笨，例如，无状态防火墙只有在定义了规则时才有效，如果规则没有完全匹配，那么此规则实际上将是无用的；当从一组主机接收大量流量时(例如发生了分布式拒绝服务攻击-DDoS攻击)，无状态防火墙将变得非常有用。</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327173045469.png"
                      alt="image-20230327173045469"
                ></p>
<h2 id="防火墙模拟示例"><a href="#防火墙模拟示例" class="headerlink" title="防火墙模拟示例"></a>防火墙模拟示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：正确配置防火墙规则以防止设备超载——示例中的203.0.110.1网站正在遭到攻击，请快速添加一些防火墙规则来阻止服务器崩溃（红色的数据包来自于攻击者的机器）。</em></p>
<p>添加规则：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180344996.png"
                      alt="image-20230327180344996" style="zoom: 67%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180155107.png"
                      alt="image-20230327180155107"
                ></p>
<blockquote>
<p>最后得到的flag是：THM{FIREWALLS_RULE} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327175546858.png"
                      alt="image-20230327175546858"
                ></p>
<h2 id="VPN基础"><a href="#VPN基础" class="headerlink" title="VPN基础"></a>VPN基础</h2><p>虚拟专用网络(VPN-Virtual Private Network)是一种允许不同网络上的设备通过在Internet(互联网公网)上彼此之间创建专用路径(称为隧道)进行安全通信的技术，在此隧道内连接的多个设备将形成它们自己的专用网络。</p>
<p>只有同一网络中的设备(如企业的内部网络)可以直接通信，而VPN允许两个局点相连，让我们看看下图，其中有三个网络：</p>
<ol>
<li>Network #1 (Office #1)</li>
<li>Network #2 (Office #2)</li>
<li>Network #3 (两个设备通过VPN连接)</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327180844134.png"
                      alt="image-20230327180844134"
                ></p>
<p>连接在Network#3上的设备仍然是Network#1和Network#2的一部分，但这些设备同时也形成了一个私有网络(Network#3)，只有通过相关的VPN连接的设备才能在这个专用网络(Network#3)上进行通信。</p>
<p>让我们介绍VPN提供的一些其他好处:</p>
<ul>
<li>允许不同地理位置的网络进行连接：例如，拥有多个办公室网络的企业会发现VPN是有益的，因为这意味着可以从办公室网络 直接访问远程服务器或基础设施等资源。</li>
<li>提供隐秘性：VPN使用了加密技术来保护数据，这意味着数据包只能在发送它的设备和目的地之间被理解，这些数据不容易被嗅探；VPN加密技术在有公共WiFi的地方可能很有用处，因为普通的公共WiFi网络并不提供加密；你可以使用VPN来保护你所使用的流量不被其他人查看。</li>
<li>提供匿名性：记者和其他活动人士可以依靠VPN技术 在言论自由受到控制的国家安全地报道全球问题；通常，你所使用的流量可以被你的ISP和其他中介机构查看，并能因此被跟踪，而VPN所提供的匿名级别也仅仅与网络上的其他设备如何尊重隐私有关，例如，使用一个会记录所有数据或者历史的VPN 本质上与不使用VPN的效果是一样的。</li>
</ul>
<p>例如TryHackMe网站可以使用VPN技术 将你的本地机和一些易受攻击的机器连接起来，并且不允许那些易受攻击的机器能被公众直接在互联网上访问，这意味着:</p>
<ul>
<li><p>你可以安全地与 TryHackMe网站所提供的那些易受攻击的机器 进行交互，从而进行攻击模拟；</p>
</li>
<li><p>服务提供商如ISP不会认为你在使用本地机攻击互联网上的正常机器(因为攻击正常机器可能违反了ISP的服务条款)；</p>
</li>
<li><p>使用VPN也为TryHackMe网站提供了安全性，因为 TryHackMe所提供的易受攻击的机器 无法直接通过Internet被公众访问。</p>
</li>
</ul>
<p>多年以来，VPN技术经过了不断改进，下面让我们来探讨一些现有的VPN技术：</p>
<ul>
<li><p>PPP：PPP是指点对点协议，它能提供加密以及数字验证功能，使用了PPP技术的VPN会通过私钥和公共证书(类似于SSH)来工作，如果要成功建立VPN连接，那么私钥和证书就必须完成匹配，但是，基于PPP技术进行传输的数据 并不能单独离开网络(即不可路由)；此外，PPTP将使用PPP技术来进行身份验证并提供数据加密。</p>
</li>
<li><p>PPTP：点对点隧道协议(PPTP-<strong>P</strong>oint-to-<strong>P</strong>oint <strong>T</strong>unneling <strong>P</strong>rotocol)是一种“允许PPP数据在网络中传输并离开网络”的技术，PPTP协议非常容易设置，大多数设备都支持它，然而，与其他VPN方案相比，PPTP是弱加密的。</p>
</li>
<li><p>IPSec：IPsec (Internet Protocol Security)将使用现有的IP (Internet Protocol)框架对数据进行加密，与其他VPN方案相比，IPSec更难建立，但只要建立完成，IPSec就能使用强大的加密功能，并且IPSec技术在许多设备上都能得到支持。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327202321786.png"
                      alt="image-20230327202321786"
                ></p>
<h2 id="局域网-LAN-网络设备"><a href="#局域网-LAN-网络设备" class="headerlink" title="局域网(LAN)网络设备"></a>局域网(LAN)网络设备</h2><p><strong>路由器（Router）</strong></p>
<p>路由器的工作是连接网络并在网络之间传递数据，它是通过使用路由来做到这一点的(因此得名路由器)。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据；路由器运行在OSI模型的第3层(网络层)，它通常具有交互式界面(如网页界面或控制台界面)，这能够允许管理员配置各种规则，如配置端口转发规则或配置防火墙规则。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用以采用最优路径：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327203318544.png"
                      alt="image-20230327203318544"
                ></p>
<p><em>tips：路由器是专用设备，它的功能与交换机不同。</em></p>
<p>从上图的例子中，我们可以看到计算机A的网络通过中间的路由器连接到计算机B的网络——共有两条路由路径可供选择，接下来的问题是：我们将采取什么路由路径？</p>
<p>使用不同的协议将决定采取不同的路由路径，此外，路径的选择还包括以下因素：</p>
<ul>
<li><p>哪条路径最短？（数据包需要通过的设备最少）</p>
</li>
<li><p>哪条路径最可靠？（之前在该路径上是否丢失过数据包）</p>
</li>
<li><p>哪条路径有更快的物理传输介质(铜缆线或光纤)？</p>
</li>
</ul>
<p><strong>交换机（Switch）</strong></p>
<p>交换机是一种专用的网络设备，它负责在网络上提供连接到多个设备的方法——一个交换机可以通过以太网电缆连接多个设备(从3到63个)。</p>
<p>交换机可以在OSI模型的第二层(数据链路层)和第三层(网络层)同时工作，然而，这是具有排他性的——第二层交换机不能在第三层运行。</p>
<p>以下图中的第二层交换机为例，交换机将通过MAC地址把帧(此处不是数据包，因为IP协议已被剥离)转发到它所连接的设备上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327210327136.png"
                      alt="image-20230327210327136"
                ></p>
<p><em><strong>tips：上图中的交换机是第二层交换机，OSI模型的第二层是数据链路层，所以上图中的交换机只负责将帧(数据帧)发送到正确的设备上。</strong></em></p>
<p>第三层交换机能够在OSI模型的第三层（网络层）工作，第三层交换机比第二层交换机更复杂，因为它还可以执行路由器的一些职责；也就是说，第三层交换机能向设备发送帧(就像第二层交换机一样)，并能使用IP协议将数据包路由到其他设备。</p>
<p>第三层交换机的使用还涉及到了VLAN(虚拟局域网)技术，我们稍后将介绍VLAN，先假设我们有以下IP地址备用：</p>
<ul>
<li>192.168.1.1</li>
<li>192.168.2.1</li>
</ul>
<p>虚拟局域网(<strong>V</strong>irtual <strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork)技术 能够允许网络中的特定设备被虚拟分割，这种分割意味着相关的网络设备可以在互联网连接等方面受益，同时相关的网络设备也将被分区处理；由VLAN技术所形成的网络隔离能够提供安全性，因为这意味着将由适当的规则来决定特定设备如何相互通信，这种网络隔离如下图所示：</p>
<p><em>tips：下图中的交换机是第三层交换机，下图示例将使用交换机划分VLAN，然后给VLAN分配IP。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327212506663.png"
                      alt="image-20230327212506663"
                ></p>
<p>如上图所示：“销售部门”和“会计部门”都能够访问Internet(互联网公网)，但这两个部门网络之间并不能实现相互通信(尽管这两个部门都连接到同一个交换机)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327214314866.png"
                      alt="image-20230327214314866"
                ></p>
<h2 id="网络模拟器示例"><a href="#网络模拟器示例" class="headerlink" title="网络模拟器示例"></a>网络模拟器示例</h2><p>部署附加到此示例的静态站点，用一个简单的网络模拟器进行实验。此模拟器将分解 数据包从点A传输到点B所需要的每一步，请尝试从computer1发送一个TCP包到computer3并得到一个flag。</p>
<p>注意：请使用Chrome或Firefox浏览器完成此练习。</p>
<p><strong>答题</strong></p>
<p>从 computer1 发送TCP包到 computer3 ：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012723958.png"
                      alt="image-20230327012723958" style="zoom:50%;" 
                >

<p>得到的flag结果：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327012919841.png"
                      alt="image-20230327012919841" style="zoom:50%;" 
                >

<blockquote>
<p>得到的flag为：THM{YOU’VE_GOT_DATA} 。</p>
</blockquote>
<p>对应的网络日志的内容（在TCP连接全过程中 所记录的日志如下）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Starting TCP/IP Handshake between computer1 and computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: Sending SYN Packet from computer1 to computer3</span></span><br><span class="line">ROUTING: computer1 says computer3 is not on my local network sending to gateway: router</span><br><span class="line">ARP REQUEST: Who has router tell computer1</span><br><span class="line">ARP RESPONSE: Hey computer1, I am router</span><br><span class="line">ARP REQUEST: Who has computer3 tell router</span><br><span class="line">ARP RESPONSE: Hey router, I am computer3</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received SYN Packet from computer1, sending SYN/ACK Packet to computer1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer1 received SYN/ACK Packet from computer3, sending ACK packet to computer3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">HANDSHAKE: computer3 received ACK packet from computer1, Handshake Complete</span></span><br><span class="line">TCP: Sending TCP packet from computer1 to computer3</span><br><span class="line">TCP: computer3 received TCP Packet from computer1, sending ACK Packet to computer1</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>网络日志中共有 5 个HANDSHAKE条目。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327013125313.png"
                      alt="image-20230327013125313"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-OSI Model(OSI模型介绍)-学习</title>
    <url>/2024/01/18/THM-OSI%20Model(OSI%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/osimodelzi" >https://tryhackme.com/room/osimodelzi <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解决定跨网络处理数据的各个阶段的基本网络框架。</p>
<h2 id="什么是OSI模型？"><a href="#什么是OSI模型？" class="headerlink" title="什么是OSI模型？"></a>什么是OSI模型？</h2><p>OSI模型(开放系统互连模型-Open Systems Interconnection Model)是网络中使用的绝对基本模型，这个关键模型提供了一个框架，规定了所有联网设备将如何发送、接收和解释数据。</p>
<p>OSI模型的主要好处之一是：当与其他设备进行通信时，网络上的设备可以具有不同的功能和设计，而且在遵循OSI模型一致性的网络上发送的数据也可以被其他设备理解。</p>
<p>OSI模型由七层组成，从第7层到第1层，每一层都有不同的职责。</p>
<p>数据传递在OSI的每一层都会发生特定的过程，OSI的每一层都会将部分信息添加到原数据中，这个过程被称为封装，下图为OSI模型示意图：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326005100677.png"
                      alt="image-20230326005100677" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326005200447.png"
                      alt="image-20230326005200447"
                ></p>
<h2 id="Layer-7-应用层-Application"><a href="#Layer-7-应用层-Application" class="headerlink" title="Layer 7 - 应用层(Application)"></a>Layer 7 - 应用层(Application)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/application.png"
                      alt="img"
                ></p>
<p>OSI模型的应用层是你最熟悉的一层，这种熟悉程度是因为应用程序层是协议和规则所在的层，应用层用于确定用户应该如何与发送或接收的数据进行交互。</p>
<p>日常的应用程序，如电子邮件客户端、浏览器或文件服务器浏览软件(如FileZilla) 等，它们能够为用户提供一个友好的图形用户界面(GUI)，这个GUI可用于用户与数据（发送的数据或接收的数据）进行交互；应用层中还包括了DNS协议(域名系统)，DNS能将网站地址转换为IP地址。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010503208.png"
                      alt="image-20230326010503208"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326010536829.png"
                      alt="image-20230326010536829"
                ></p>
<h2 id="Layer-6-表示层-Presentation"><a href="#Layer-6-表示层-Presentation" class="headerlink" title="Layer 6 - 表示层(Presentation)"></a>Layer 6 - 表示层(Presentation)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/presentation.png"
                      alt="img"
                ></p>
<p>OSI模型的第6层是标准化开始发生的层。软件开发人员可以以不同的方式开发应用程序，例如电子邮件客户端等，而无论应用程序如何工作，数据仍然需要以相同的方式进行处理。</p>
<p>这一层能够充当数据与应用层(第7层)之间的翻译器。接收信息的计算机也能理解以一种格式发送到计算机的数据以另一种格式发送，例如：当你通过某种类型的电子邮件客户端发送电子邮件时，其他用户可能使用的是另一种电子邮件客户端来接收信息，但是电子邮件的内容仍然能够正常显示。</p>
<p>数据加密（如访问安全站点时使用HTTPS协议）等安全特性也将在表示层得到应用。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326154514416.png"
                      alt="image-20230326154514416"
                ></p>
<h2 id="Layer-5-会话层-Session"><a href="#Layer-5-会话层-Session" class="headerlink" title="Layer 5 - 会话层(Session)"></a>Layer 5 - 会话层(Session)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/session.png"
                      alt="img"
                ></p>
<p>一旦数据从表示层(第6层)正确地转换或格式化，会话层(第5层)将开始创建到数据目的地(另一台计算机)的连接。当连接建立后，将同时创建一个会话，并且当该连接处于活动状态时，对应的会话也将处于活动状态。</p>
<p>会话层(第5层)将使两台计算机同步，以确保它们在发送数据和接收数据之前处于同一页面上，一旦相关的检查到位，会话层将开始把要发送的数据分成更小的数据块，并开始一次一个地发送这些数据块(Packets-数据包)；这种对数据分块处理的方式是有益的，因为如果连接发生丢失，则仅有尚未发送的部分数据块需要再次发送——而不需要重新发送全部数据块。</p>
<p>值得注意的是，会话是唯一的——这意味着数据不能在不同的会话之间传输，而只能在相同会话之间传输（一个会话将包含两端：发送数据端和接收数据端）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326155132061.png"
                      alt="image-20230326155132061"
                ></p>
<h2 id="Layer-4-传输层-Transport"><a href="#Layer-4-传输层-Transport" class="headerlink" title="Layer 4 - 传输层(Transport)"></a>Layer 4 - 传输层(Transport)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/transport.png"
                      alt="img"
                ></p>
<p>OSI模型的第4层在通过网络传输数据方面起着至关重要的作用。当数据在设备之间发送时，它将遵循以下两种不同的协议之一：</p>
<ul>
<li>TCP（传输控制协议）</li>
<li>UDP（用户数据报协议）</li>
</ul>
<p><strong>TCP协议</strong></p>
<p>传输控制协议（TCP-<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol）在设计时考虑到了数据传输的可靠性；并且TCP协议在发送数据和接收数据所需的时间内，将在两个设备之间保持恒定的连接——TCP协议是面向连接的。</p>
<p>不仅如此，TCP还在其设计中加入了错误检查，错误检查能够确认从会话层(第5层)发送的小块数据已经按顺序（按发送数据的顺序）被接收和重新组装。</p>
<p>让我们总结一下TCP的优点和缺点：</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，则无法使用整个数据块；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多工作。</li>
</ul>
<p>TCP主要用于文件共享、互联网浏览或发送电子邮件等情况，因为这些服务要求数据是准确和完整的，而TCP协议的特性能够满足这些要求。</p>
<p>在下图的例子中，我们可以看到一张照片是如何被分解成来自“网络服务器”的小数据块(称为数据包)，而接收数据的计算机会将照片重新按正确的顺序完成构建。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326164124956.png"
                      alt="image-20230326164124956"
                ></p>
<p><strong>UDP协议</strong></p>
<p>现在让我们介绍用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)。UDP协议远不如TCP协议先进，它没有TCP所提供的多种特性，如错误检查和数据传输的可靠性。任何基于UDP协议发送的数据都无法确保不会发生数据丢失，UDP协议在进行数据传输时并没有实现设备的同步过程，UDP的特性是：无连接、不可靠、快速传输。</p>
<p>让我们总结一下UDP的优点和缺点：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>我们使用与上面相同的例子，假设我们基于UDP协议传输数据，我们现在可以看到“接收数据的计算机”仅接收到数据包 #1 和 #3，这意味着图像发生了丢失。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326170113306.png"
                      alt="image-20230326170113306"
                ></p>
<p>UDP协议在需要发送小块数据的情况下很有用，例如，用于发现设备的协议(ARP协议和DHCP协议)或者视频流等更大的文件(视频的某些部分出现像素化是可允许的，像素化部分代表了对应数据的丢失)。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326160454354.png"
                      alt="image-20230326160454354"
                ></p>
<h2 id="Layer-3-网络层-Network"><a href="#Layer-3-网络层-Network" class="headerlink" title="Layer 3 - 网络层(Network)"></a>Layer 3 - 网络层(Network)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/network.png"
                      alt="img"
                ></p>
<p>OSI模型的第三层(网络层)是路由和重新组装数据之处，而路由能够确定发送数据块时应该选择的最优路径。</p>
<p>网络层的一些协议确切地确定了数据到达设备的“最佳”路径，这些协议包括了开放最短路径优先协议(OSPF-Open Shortest Path First)和路由信息协议(RIP-Routing Information Protocol)；此外，路径的选择还由以下因素决定：</p>
<ul>
<li>哪条路径最短?也就是说，数据包需要通过的设备最少。</li>
<li>哪条路径最可靠?例如，之前在该路径上丢失过数据包吗?</li>
<li>哪条路径的物理连接更快?例如，一条路径是使用铜缆线连接(较慢)还是光纤连接(相当快)?</li>
</ul>
<p>在这一层，一切都是通过IP地址(如192.168.1.100)进行处理的，能够使用IP地址发送数据包的路由器等设备也被称为第三层设备，因为它们能够在OSI模型的第三层工作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174126984.png"
                      alt="image-20230326174126984"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326174251520.png"
                      alt="image-20230326174251520"
                ></p>
<h2 id="Layer-2-数据链路层-Data-Link"><a href="#Layer-2-数据链路层-Data-Link" class="headerlink" title="Layer 2 - 数据链路层(Data Link)"></a>Layer 2 - 数据链路层(Data Link)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/datalink.png"
                      alt="img"
                ></p>
<p>数据链路层着重于数据传输过程中的物理寻址。该层级将接收来自网络层的数据包(包括远程计算机的IP地址)，并会在数据包中添加接收端点的物理MAC(媒体访问控制)地址。</p>
<p>在每一台联网计算机内部都有一个网络接口卡(NIC- Network Interface Card)，它带有一个唯一的MAC(Media Access Control)地址作为标识；MAC地址由制造商设置，并刻入网络接口卡中，MAC地址不能被改变——尽管MAC地址可以被欺骗；当信息通过网络发送时，实际上是使用物理地址来确定将信息发送到哪里。此外，以适合传输的格式表示数据也是数据链路层的工作之一。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175234403.png"
                      alt="image-20230326175234403"
                ></p>
<h2 id="Layer-1-物理层-Physical"><a href="#Layer-1-物理层-Physical" class="headerlink" title="Layer 1 - 物理层(Physical)"></a>Layer 1 - 物理层(Physical)</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/physical.png"
                      alt="img"
                ></p>
<p>物理层包括了在网络中所使用的硬件的物理组件，是OSI模型的最低层，这些设备将使用电信号在二进制编号系统( 0 和 1 )中相互传输数据。</p>
<p>例如，以太网电缆连接设备：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326180259445.png"
                      alt="image-20230326180259445" style="zoom: 67%;" 
                >

<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326175520887.png"
                      alt="image-20230326175520887"
                ></p>
<h2 id="OSI实例练习"><a href="#OSI实例练习" class="headerlink" title="OSI实例练习"></a>OSI实例练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p>根据数据发送时在OSI七层中所经过的顺序完成模拟实验，并得到最后的flag。</p>
<p><em>tips：使用左、右方向键控制移动，使用空格键进行爬楼。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181243963.png"
                      alt="image-20230326181243963" style="zoom: 67%;" 
                >

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326181212728.png"
                      alt="image-20230326181212728" style="zoom: 67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{OSI_DUNGEON_ESCAPED} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326180750610.png"
                      alt="image-20230326180750610"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Intro to LAN(局域网基础介绍)-学习</title>
    <url>/2024/01/18/THM-Intro%20to%20LAN(%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/introtolan" >https://tryhackme.com/room/introtolan <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解一些支持专用网络的技术和设计。</p>
<h2 id="局域网-LAN-Local-Area-Network-拓扑简介"><a href="#局域网-LAN-Local-Area-Network-拓扑简介" class="headerlink" title="局域网(LAN-Local Area Network)拓扑简介"></a>局域网(LAN-Local Area Network)拓扑简介</h2><p>多年以来，人们对各种网络设计进行了试验和实施，在网络中，当我们提到术语“拓扑-Topology”时，实际上指的是当前网络的设计或外观。下面我们将讨论一下这些拓扑的优缺点。</p>
<h3 id="Star-Topology（星型拓扑）"><a href="#Star-Topology（星型拓扑）" class="headerlink" title="Star Topology（星型拓扑）"></a><strong>Star Topology（星型拓扑）</strong></h3><p>星型拓扑结构的主要前提是设备通过中央网络设备(如交换机或集线器)单独连接；尽管成本高昂，但由于其可靠性和可伸缩性，这种拓扑在今天仍是最常见的。</p>
<p>在星型拓扑结构中 发送到设备的任何信息都是通过此设备所连接的中心设备发送的，下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于这种拓扑结构需要更多的电缆布线和购买专用的网络设备，因此它比其他任何拓扑结构都要昂贵。然而，尽管增加了成本，星型拓扑结构也确实提供了一些显著的优势：例如，这种拓扑本质上将具有更强的可伸缩性，这意味着随着网络需求的增加，我们可以很容易地添加更多设备。</p>
<p>但不幸的是，随着网络规模越来越大，在星星拓扑中保持网络功能所需的维护成本就越高，而这种对维护的依赖增加也会使得故障排除变得更加困难。此外，星形拓扑仍然可能失效(尽管这种拓扑结构减少了失效的可能性)，例如，如果连接各个设备的集中式硬件出现故障，那么这些设备将不再能够继续发送或接收数据，值得庆幸的是，这些集中式硬件设备通常都很健壮。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211744823.png"
                      alt="image-20230325211744823" style="zoom:50%;" 
                >

<h3 id="Bus-Topology（总线拓扑）"><a href="#Bus-Topology（总线拓扑）" class="headerlink" title="Bus Topology（总线拓扑）"></a><strong>Bus Topology（总线拓扑）</strong></h3><p>总线拓扑中的各个设备在连接时 依赖于主干电缆的单一连接，此类拓扑结构中的设备就类似于树的叶子，因为在某种意义上，设备(叶子)起源于主干电缆上的分支。</p>
<p>下面让我们探讨一下这种拓扑结构的一些优点和缺点:</p>
<p>由于发送到每个设备的所有数据都沿着同一条电缆传输，所以如果总线拓扑中的各个设备同时请求数据，就很容易让数据传输变得缓慢和阻塞。当数据传输的阻塞情况达到瓶颈后，就会导致故障排除变得非常困难，因为在进行故障排除时——很难确定哪个设备正在经历“由于所有数据都沿着相同的路线传输而导致数据阻塞”。</p>
<p>尽管如此，总线拓扑仍然是一种更容易配置且成本更低的拓扑结构，它主要的花费在于购买连接各个设备的电缆或专用网络设备。</p>
<p>总线拓扑的另一个缺点是在发生故障时几乎没有冗余，这个缺点的存在是因为：如果在主干电缆上有一个单点故障，即电缆线突然断了，那么设备就不能再沿着总线接收或传输数据。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211804758.png"
                      alt="image-20230325211804758" style="zoom:50%;" 
                >

<h3 id="Ring-Topology（环型拓扑）"><a href="#Ring-Topology（环型拓扑）" class="headerlink" title="Ring Topology（环型拓扑）"></a><strong>Ring Topology（环型拓扑）</strong></h3><p>环形拓扑(也称为令牌拓扑)，在此拓扑中将由计算机等设备直接相互连接形成环路，这意味着几乎不需要电缆布线（只需要一点点电缆布线），也不太依赖于星型拓扑结构中的专用硬件。</p>
<p>环形拓扑的工作原理是通过环路发送数据，直到数据到达目标设备，在这个过程中会使用环路上的其他设备转发数据。有趣的是，在这个拓扑中，如果一个设备本身没有任何数据要发送，那么它只会转发从另一个设备接收到的数据；而如果该设备恰好有数据要发送，它会先发送自己的数据，然后再转发来自于其他设备的数据。</p>
<p>因为数据在这个拓扑结构中只有一个传输方向，所以很容易排除出现的任何故障；然而，这是一把双刃剑，因为单向传输在网络中并不是一种有效的数据传输方式，在总线拓扑中传输数据时，数据必须先访问多个设备才能最终到达预期的目标设备。</p>
<p>环形拓扑不太容易出现数据传输瓶颈，因为在总线拓扑结构中，大量流量不会在任何时候同时通过网络传输。然而，这种拓扑结构的设计也意味着：如果剪断电缆或损坏设备则将导致整个网络中断。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325211833122.png"
                      alt="image-20230325211833122" style="zoom:50%;" 
                >

<h3 id="什么是交换机（Switch）？"><a href="#什么是交换机（Switch）？" class="headerlink" title="什么是交换机（Switch）？"></a><strong>什么是交换机（Switch）？</strong></h3><p>交换机是网络中的专用设备，它被设计用于聚合多个其他设备，如计算机、打印机或使用以太网的任何其他具有网络功能的设备；这些不同的设备都将插入交换机的端口。交换机通常存在于较大的网络中，如企业、学校或类似规模的网络，在这种环境下将有许多设备需要被连接到网络，此时交换机可以通过4、8、16、24、32、64端口来连接大量的设备。</p>
<p>交换机比它们的次要对应物(集线器&#x2F;中继器)更有效，交换机会跟踪哪些设备连接到哪个端口，因此，当交换机接收到一个数据包时，就不会像集线器那样将该数据包重复发送到每个端口，而是直接将数据包通过已知端口发送给预定的目标即可，从而减少了网络流量的消耗。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325122204859.png"
                      alt="image-20230325122204859"
                ></p>
<p>交换机和路由器都可以相互连接，这样做可通过为数据添加多条路径来增加网络的冗余(可靠性)——如果一条路走不通，就可以用另一条路。虽然这可能会降低网络的整体性能，因为数据包要花费更长的时间来传输，但这尽量保证了网络没有停机时间——考虑到其他替代方案，降低网络的整体性能只是一个很小的代价。</p>
<h3 id="什么是路由器（Router）？"><a href="#什么是路由器（Router）？" class="headerlink" title="什么是路由器（Router）？"></a><strong>什么是路由器（Router）？</strong></h3><p>路由器的工作是连接网络并在网络之间传递数据，它通过使用路由(因此得名路由器)来做到这一点。</p>
<p>路由是给“数据在网络中传输的过程”的标签，路由涉及在网络之间创建一条路径，以便能够成功地传递数据。</p>
<p>当设备由多条路径连接时，如下面的示例图所示，路由就能发挥作用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325121757937.png"
                      alt="image-20230325121757937"
                ></p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：该实验环境将带我们了解不同网络拓扑结构中的缺陷。</em></p>
<p>在环形拓扑结构中，所有设备都连接到其他两个设备，形成一个完整的圆圈，数据包从一个设备传输到下一个设备，直到到达目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214051829.png"
                      alt="image-20230325214051829" style="zoom:50%;" 
                >

<p>环形拓扑的主要缺陷之一是，如果设备故障或电缆损坏，则数据将不再传递，网络中的设备也无法再相互通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214218366.png"
                      alt="image-20230325214218366" style="zoom:50%;" 
                >

<p>在总线拓扑中，所有设备都连接到一根电缆上，这根电缆通常被称为主干电缆，数据将顺着主干电缆沿左右两个方向发送，直到到达数据包的目的地：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214458459.png"
                      alt="image-20230325214458459" style="zoom:50%;" 
                >

<p>总线拓扑的一个主要缺陷是它不能处理大量数据，如果同时发送的数据包过多，就会导致网络关闭：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214722436.png"
                      alt="image-20230325214722436" style="zoom:50%;" 
                >

<p>在星型拓扑中，所有设备都通过自己的电缆连接到中央交换机&#x2F;集线器，每个数据包都将通过中央交换机发送：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325214952528.png"
                      alt="image-20230325214952528" style="zoom:50%;" 
                >

<p>如果交换机发生故障，则网络将不再工作：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325215037202.png"
                      alt="image-20230325215037202" style="zoom:50%;" 
                >

<p>完成上述步骤，最后得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325215123783.png"
                      alt="image-20230325215123783"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{TOPOLOGY_FLAWS} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325213845669.png"
                      alt="image-20230325213845669"
                ></p>
<h2 id="子网划分入门"><a href="#子网划分入门" class="headerlink" title="子网划分入门"></a>子网划分入门</h2><p>在现实世界中，你可以找到各种形状和大小的网络，而子网划分是将网络内部划分为更小的微型网络的术语。你可以把子网划分想象成你正在给你的朋友们切蛋糕，只有一定份额的蛋糕可以分给大家，但每个人都想要得到一块蛋糕，子网划分就是由你来决定谁将得到哪块蛋糕（最后还需要保留一部分未划分区域）。</p>
<p>以一家企业为例，企业中有不同的部门，比如:</p>
<ul>
<li>会计（Accounting）</li>
<li>金融（Finance）</li>
<li>人力资源（Human Resources）</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325220009334.png"
                      alt="image-20230325220009334" style="zoom:50%;" 
                >

<p>在现实生活中，你知道要把信息发送到正确的企业部门，在网络中也同样需要知道这一点；网络管理员将使用子网划分来分类网络和分配网络的特定部分。</p>
<p>子网划分将通过划分网络中可以容纳的主机数量来实现，这将用一组被称为子网掩码的数字表示，让我们查看下图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325220503766.png"
                      alt="image-20230325220503766"
                ></p>
<p>我们知道，一个IP地址由四个“八位二进制数”组成，共四个字节，而子网掩码也是如此，子网掩码同样是被表示为四个字节(1个字节占8个二进制位，共32位)的一组数字，每个字节的范围是从0到255(0-255)。</p>
<p>子网通过三种不同的方式使用IP地址：</p>
<ul>
<li>标识网络地址（network address）</li>
<li>标识主机地址（host address）</li>
<li>标识默认网关（default gateway）</li>
</ul>
<p>让我们了解一下以上三种方式的目的，如下所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325221335603.png"
                      alt="image-20230325221335603"
                ></p>
<p>tips：默认网关是网络中的一个特殊设备，它能够向另一个网络上的设备发送信息。</p>
<p>在像家庭网络这样的小型网络中，你的计算机设备将处于一个子网中，你不太可能在这样的小型网络中需要一次连接超过254个设备；而像企业这样的大型网络中，将会有更多的设备(如各企业部门的pc、打印机、相机和传感器等)，在大型网络中更加需要进行子网划分。</p>
<p>子网划分提供了一系列好处，包括:</p>
<ul>
<li>效率</li>
<li>安全</li>
<li>完全控制</li>
</ul>
<p>我们将在以后继续探索子网划分是如何提供好处的，现在我们只需要了解子网划分所提供的安全元素；让我们以街上的咖啡馆为例，假设某家咖啡馆有两个网络：</p>
<ul>
<li>一个网络用于员工、收银机和其他店内联网设备。</li>
<li>一个网络供公众使用WiFi。</li>
</ul>
<p>子网划分允许你将以上例子中的两个网络彼此分开，同时还能连接到互联网等更大的网络。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325225950872.png"
                      alt="image-20230325225950872"
                ></p>
<h2 id="ARP协议介绍"><a href="#ARP协议介绍" class="headerlink" title="ARP协议介绍"></a>ARP协议介绍</h2><p>回顾我们上文所述，网络中的设备可以有两个标识符： MAC 地址和 IP 地址；而通过ARP协议可以允许设备在网络中识别自己，ARP协议即地址解析协议（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocol ）。</p>
<p>简而言之，ARP协议允许设备将其MAC地址与网络上的IP地址相关联，网络上的每个设备都将保存与其他设备关联的MAC地址的日志；每当一个设备希望与另一个设备进行通信时，它将向整个网络发送广播以搜索目标设备，也就是说——网络中的设备可以通过ARP协议找到目标设备的MAC地址(即物理标识符)从而进行通信。</p>
<p><strong>ARP协议是如何工作的?</strong></p>
<p>网络中的每个设备都有一个用于存储信息的分类账簿，被称为缓存，在ARP协议的上下文中，这个缓存会存储网络上其他设备的标识符。</p>
<p>为了将这两个标识符(IP地址和MAC地址)映射在一起，ARP协议会发送两种类型的消息：</p>
<ul>
<li>ARP Request（ARP请求）</li>
<li>ARP Reply（ARP应答）</li>
</ul>
<p>当发送ARP请求时，初始源设备会向网络上的其他设备广播一条消息，以询问其他设备的MAC地址是否与初始源设备所请求的IP地址相匹配；如果某个设备确实有初始源设备所请求的IP地址（此设备即为初始目标设备），则会向初始源设备返回一个ARP应答消息以进行确认，初始源设备随后将记住这一映射关系，并将其存储在初始源设备的缓存中(以一个ARP条目的形式存储)。</p>
<p>这个过程如下图所示：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325233634467.png"
                      alt="image-20230325233634467" style="zoom: 67%;" 
                >

<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325234520603.png"
                      alt="image-20230325234520603"
                ></p>
<h2 id="DHCP协议介绍"><a href="#DHCP协议介绍" class="headerlink" title="DHCP协议介绍"></a>DHCP协议介绍</h2><p>IP 地址可以手动分配，方法是将 IP 手动绑定到设备，IP 地址也可以自动分配，最常见的是使用动态主机配置协议（DHCP）服务器。当设备连接到网络时，如果尚未手动为其分配 IP 地址，它则会发出一个请求消息（DHCP Discover）以查看网络上是否有任何 DHCP 服务器，然后 DHCP 服务器将回复一个包含原设备可用的 IP 地址信息的消息（DHCP Offer）给原设备，紧接着原设备将再发送一个请求消息（DHCP Request）以确认它需要这个被提供的 IP 地址，最后，DHCP服务器将会发送一个应答消息（DHCP ACK）以确认IP分配操作已经完成，此后原设备就可以开始使用由DHCP服务器所提供的 IP 地址。</p>
<p>tips：DHCP-<strong>D</strong>ynamic <strong>H</strong>ost <strong>C</strong>onfiguration <strong>P</strong>rotocol（动态主机配置协议）</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325235958781.png"
                      alt="image-20230325235958781" style="zoom: 67%;" 
                >

<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326000851046.png"
                      alt="image-20230326000851046"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Packets &amp; Frames(了解数据包和帧)-学习</title>
    <url>/2024/01/18/THM-Packets&amp;Frames(%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%8C%85%E5%92%8C%E5%B8%A7)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/packetsframes" >https://tryhackme.com/room/packetsframes <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解数据如何被分成更小的部分并通过网络传输到另一台设备。</p>
<h2 id="什么是数据包和帧？"><a href="#什么是数据包和帧？" class="headerlink" title="什么是数据包和帧？"></a>什么是数据包和帧？</h2><p>数据包和帧是小块的数据，当它们组合在一起时，就构成了更大的信息或消息；然而，数据包和帧在OSI模型中是两种不同的东西，帧位于OSI的第2层——数据链路层，这意味着帧不包含IP地址这样的信息。类比案例：你可以想象把一个信封放在另外一个信封里，然后邮寄完整的信封，此完整信封对应的是发送的数据包，一旦打开完整信封，里面仍然会存在并包含一些数据(也就是一个帧)。</p>
<p>数据包和帧的组合过程被称为封装，在这个阶段中，我们可以安全地假设：任何包含IP地址的信息指的都是数据包，而当封装好的信息被剥离时，我们谈论的信息则是帧本身。</p>
<p>数据包是跨网络设备传输数据的有效方式，由于这些数据是分小块传输的，所以此时在整个网络中发生数据传输阻塞的几率 比一次性发送大消息进而造成传输阻塞的几率要小。</p>
<p>当你从网站加载图像时，该图像不会作为一个整体发送到你的计算机，而是在你的计算机上由小块图像开始重建进而得到一个完整图像；下面的图片说明了以上过程，来自于网站的图像将被分成三个数据包，当数据包到达计算机时，图像就会开始重建，最终形成完整的图像。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326193818536.png"
                      alt="image-20230326193818536"
                ></p>
<p>数据包有不同的结构，这些结构取决于正在发送的数据包的类型，网络上充满了各种标准和协议，这些标准和协议充当了设备上如何处理数据包的一组规则。</p>
<p>使用了协议的数据包将有一组标头，其中包含跨网络发送的数据的附加信息。</p>
<p>一些值得注意的标头信息包括：</p>
<ul>
<li>Time to Live（生存时间）：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Checksum（校验和）：该字段能够为TCP&#x2F;IP等协议提供完整性检查，如果数据被更改了，那么此时的Checksum值将变得与预期的Checksum值不同。</li>
<li>Source Address（源地址）：该字段表示发送数据包的设备的IP地址，这样数据就知道该返回到哪里。</li>
<li>Destination Address（目标地址）：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
</ul>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326201110685.png"
                      alt="image-20230326201110685"
                ></p>
<h2 id="TCP-IP（三次握手）介绍"><a href="#TCP-IP（三次握手）介绍" class="headerlink" title="TCP&#x2F;IP（三次握手）介绍"></a>TCP&#x2F;IP（三次握手）介绍</h2><p>传输控制协议(TCP-Transmission Control Protocol)是在网络中使用的一个规则。</p>
<p>基于TCP&#x2F;IP协议集的TCP&#x2F;IP模型与OSI模型非常相似，TCP&#x2F;IP模型由四层分级组成，可以说是OSI模型的一个简化版本，TCP&#x2F;IP模型所包含的分层有:</p>
<ul>
<li>Application（应用层）</li>
<li>Transport（传输层）</li>
<li>Internet（网际层）</li>
<li>Network Interface（网络接口层）</li>
</ul>
<p>与OSI模型的工作原理非常相似，数据包在经过TCP&#x2F;IP模型的每一层时都会被添加部分信息——这个过程被称为封装，而与此过程相反的是解封装。</p>
<p><strong>关于TCP协议</strong></p>
<p>TCP协议的一个定义特征是它是基于连接的，这意味着在发送数据之前，TCP必须在客户端和作为服务器的设备之间建立起一个持续的连接；因此，TCP能够保证发送的任何数据都会在另一端被正确地接收到，这个数据发送和接收过程被称为TCP&#x2F;IP三次握手。</p>
<p>下面是关于TCP优点和缺点的比较:</p>
<ul>
<li>TCP的优点：能够保证数据的准确性；能够同步两个设备，以防止彼此被数据淹没；将执行更多流程，以确保数据传输的可靠性。</li>
<li>TCP的缺点：要求两台设备之间有可靠的连接，如果没有接收到一小块数据，那么整个数据块就不能使用（必须重新发送）；TCP的慢速连接可能会导致其他设备达到数据传输的瓶颈，因为在数据传输完毕之前——相关的TCP连接将一直保留在接收端计算机上；TCP 比 UDP 慢得多，因为使用此协议的设备必须完成更多的工作（计算）。</li>
</ul>
<p>TCP数据包还将包含 在封装过程中所添加的被称为标头的信息部分，接下来让我们了解一些重要的TCP标头信息：</p>
<ul>
<li>Source Port（源端口）：发送方为发送TCP数据包而开放的端口，该值是随机选择的(从0-65535之间 选择尚未使用的端口)。</li>
<li>Destination Port（目标端口）：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Source IP（源IP地址）：这是发送数据包的设备的IP地址。</li>
<li>Destination IP（目标IP地址）：这是数据包要到达的设备的IP地址。</li>
<li>Sequence Number（序列号）：当TCP连接建立时，所传输的第一段数据将被赋予一个随机数。</li>
<li>Acknowledgement Number（确认号）：在一段数据被赋予序列号之后，下一段数据的序列号值将会是序列号+ 1。</li>
<li>Checksum（校验和）：这个值可用于对TCP数据包的完整性进行检查，如果校验和的值在数据传输过程中发生了变化，则说明数据已经被损坏。</li>
<li>Data（数据）：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
<li>Flag（标志）：这个TCP标头决定了在三次握手过程中任一设备应该如何处理数据包，特定的标志将决定特定的行为。</li>
</ul>
<p><strong>TCP&#x2F;IP三次握手</strong></p>
<p>接下来，我们将讨论TCP&#x2F;IP三次握手——这是用于在两个设备之间建立连接的过程的术语。</p>
<p>TCP&#x2F;IP三次握手会使用一些特殊的信息进行交流，下面是一些主要的信息：</p>
<ul>
<li>1-SYN：SYN消息是客户端在握手过程中发送的初始数据包。这个包用于发起连接并同步两个设备。</li>
<li>2-SYN&#x2F;ACK：此数据包将由接收设备(服务器)发送，以确认来自客户端的同步尝试。</li>
<li>3-ACK：客户端或服务器都可以使用确认数据包来确认已经成功接收了一系列消息&#x2F;数据包。</li>
<li>4-DATA：一旦两个设备建立了连接，数据(例如文件的字节)就会通过“DATA”消息发送。</li>
<li>5-FIN：此数据包可用于在TCP连接完成后 干净地(正确地)关闭TCP连接。</li>
<li>RST：RST数据包能够立刻终止所有的TCP通信，如果使用了RST数据包则表明在TCP握手过程中存在一些问题——比如发生了服务或应用程序异常以及系统资源不足等故障。</li>
</ul>
<p>下图显示了Alice和Bob之间正常的TCP三次握手过程，在现实生活中，这将发生在两个设备之间：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326214033986.png"
                      alt="image-20230326214033986"
                ></p>
<p>在TCP三次握手过程中，客户端所发送的数据将被赋予一个随机数序列，这个数字序列接下来将进行重构并递增1；两台计算机设备必须就相同的数字序列达成一致，才能以正确的顺序发送数据，这个顺序是在三个步骤中商定的（下面步骤中的序列号是随机值）：</p>
<ul>
<li>SYN-Client：客户端将设置用于同步的SYN标志位并生成一个随机初始序列号(ISN)——0 。</li>
<li>SYN&#x2F;ACK-Server：服务器端将设置SYN标志位和ACK标志位并生成一个随机初始序列号(5000)，并对客户端的初始序列号(0)进行确认（ACK&#x3D;0+1）。</li>
<li>ACK-Client： 客户端设置ACK标志位，并对服务器端的初始序列号(5000)进行确认（ACK&#x3D;5000+1）。</li>
</ul>
<p>tips：SYNchronise-SYN(同步)，ACKnowledge-ACK(确认)，Initial Sequence Number-ISN(初始序列号)；以上步骤的结果——客户端ISN+1，服务器端ISN+1。</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326221426557.png"
                      alt="image-20230326221426557" style="zoom: 50%;" 
                >

<p><strong>TCP连接的关闭</strong></p>
<p>接下来，让我们简单介绍一下TCP连接关闭背后的过程。</p>
<p>首先，一旦源设备确定目标设备成功接收了所有数据，那么TCP连接就将要被关闭；因为TCP会在设备上占用一些系统资源，所以最好在不需要的时候尽快关闭TCP连接。</p>
<p>为了启动TCP连接的关闭过程，设备将发送一个“FIN”数据包到另一个设备，当然，这仍基于TCP协议，其他设备也必须确认这个“FIN”数据包。</p>
<p>让我们像前文一样使用Alice和Bob来展示这个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326223520503.png"
                      alt="image-20230326223520503"
                ></p>
<p>在上图中，我们可以看到Alice首先向Bob发送一个“FIN”包，当Bob收到这个消息之后，Bob会让Alice知道他已经收到消息(ACK)，并且Bob将表示他也想要关闭连接(FIN)，而Alice在收到来自于Bob的消息(ACK+FIN)之后，将进行最终的确认(ACK)——结果是TCP连接被成功关闭。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326224720813.png"
                      alt="image-20230326224720813"
                ></p>
<h2 id="关于三次握手的模拟练习"><a href="#关于三次握手的模拟练习" class="headerlink" title="关于三次握手的模拟练习"></a>关于三次握手的模拟练习</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：以正确的顺序重新组装TCP握手过程，以帮助 Alice 和 Bob 进行通信，在 Alice 与 Bob 的对话结束后会给出一个flag值。</em></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em><strong>Part1：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225206394.png"
                      alt="image-20230326225206394" style="zoom:50%;" 
                >

<p><em><strong>Part2：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225315154.png"
                      alt="image-20230326225315154" style="zoom:50%;" 
                >

<p><em><strong>Part3：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225411070.png"
                      alt="image-20230326225411070" style="zoom:50%;" 
                >

<p><em><strong>Part4：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225512847.png"
                      alt="image-20230326225512847" style="zoom:50%;" 
                >

<p><em><strong>Part5：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225632300.png"
                      alt="image-20230326225632300" style="zoom:50%;" 
                >

<p><em><strong>Part6：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225759731.png"
                      alt="image-20230326225759731" style="zoom:50%;" 
                >

<p><em><strong>Part7：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225838033.png"
                      alt="image-20230326225838033" style="zoom:50%;" 
                >

<p><em><strong>Part8：</strong></em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230326225910031.png"
                      alt="image-20230326225910031" style="zoom:50%;" 
                >

<p>对话结束，得到一个flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225933032.png"
                      alt="image-20230326225933032"
                ></p>
<blockquote>
<p>最后得到的flag值为：THM{TCP_CHATTER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326225109100.png"
                      alt="image-20230326225109100"
                ></p>
<h2 id="UDP-IP介绍"><a href="#UDP-IP介绍" class="headerlink" title="UDP&#x2F;IP介绍"></a>UDP&#x2F;IP介绍</h2><p>用户数据报协议(UDP-<strong>U</strong>ser <strong>D</strong>atagram <strong>P</strong>rotocol)是另一种用于设备之间进行数据通信的协议。</p>
<p>与TCP不同，UDP是一种无状态协议，它不需要通过在两个设备之间保持恒定的连接来发送数据；UDP协议不会发生三次握手过程，两个互相通信的设备之间也不存在任何同步。</p>
<p>UDP主要用于应用程序可以容忍数据丢失的情况下(如视频流程序或语音聊天程序)，下面是对UDP协议的优缺点比较：</p>
<ul>
<li>UDP的优点：UDP比TCP快得多；UDP让应用层(用户软件)决定是否控制数据包的发送速度；UDP不像TCP那样在设备上保留连续连接。</li>
<li>UDP的缺点：UDP不关心发送的数据是否成功被接收，容易发生数据丢失；UDP这种不稳定的数据传输方式可能会给用户糟糕的体验。</li>
</ul>
<p>如前所述，在两台设备之间建立UDP连接时不会发生任何过程，这意味着UDP不考虑数据是否被接收，也没有TCP所提供的保护措施（例如保护数据完整性）。</p>
<p>UDP数据包比TCP数据包简单得多，并且有更少的标头，然而，这两个协议也能共享一些标准的标头，如下所示：</p>
<ul>
<li>Time to Live (TTL-生存时间)：该字段为数据包设置了一个过期计时器，即使数据包永远无法到达目标主机，这也不会阻塞你的网络。</li>
<li>Source Address(源地址)：发送数据包的设备的IP地址，以便数据知道返回到哪里。</li>
<li>Destination Address(目标地址)：数据包要发送到的设备的IP地址，以便数据知道下一步要传输到哪里。</li>
<li>Source Port(源端口)：此值是发送方为发送TCP数据包而打开的端口，该端口号的值是随机选择的(从0-65535之间 选择尚未被使用的端口)。</li>
<li>Destination Port(目标端口)：远程主机（接收数据的主机）上运行的应用程序或服务的端口号，例如，默认运行 Web 服务器的端口 80；与源端口不同，目标端口号并不是随机选择的。</li>
<li>Data(数据)：这个标头是存储数据的地方，所存储的是正在传输的文件的字节。</li>
</ul>
<p>通过UDP通信与通过TCP通信的过程是不同的，我们应该记住UDP协议是无状态的，在UDP传输数据期间并不会发送确认数据包（ACK）</p>
<p>下图显示了Alice和Bob之间的正常UDP通信，在现实生活中，UDP通信过程将发生在两个设备之间。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234005977.png"
                      alt="image-20230326234005977"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230326234125159.png"
                      alt="image-20230326234125159"
                ></p>
<h2 id="端口基础介绍-相关实例练习"><a href="#端口基础介绍-相关实例练习" class="headerlink" title="端口基础介绍&amp;相关实例练习"></a>端口基础介绍&amp;相关实例练习</h2><p><strong>端口基础介绍</strong></p>
<p>Port(端口)是数据进行交换的关键点，Port也有港口的含义，此名称或许恰如其分；你可以想象在海边有一个又一个港口，所有想要靠岸停放的船舶都必须前往与船舶尺寸和船舶用途相匹配的港口，例如，一艘游轮不能停靠在为渔船而建造的港口处，反之亦然。</p>
<p>这些端口会规定什么服务才可以使用什么端口号——如果某个服务和某个端口不兼容，就不能为该服务分配此端口；网络设备在相互通信时也将使用端口来执行一些严格的规则，当两个设备建立起连接之后，设备所发送或接收的任何数据都将通过端口进行通信。</p>
<p>在计算机中，端口号所对应的是 0 到 65535 之间的数值。</p>
<p>由于端口的范围可以是0-65535之间的任何数值，因此很快就会出现难以跟踪哪个应用程序正在使用哪个端口的风险，值得庆幸的是，我们能够将应用程序、软件和行为与一组标准规则相关联；例如，通过强制任何web浏览器的数据都必须通过端口80发送，软件开发人员可以设计出多种使用80端口进行通信的web浏览器，如Chrome浏览器、Firefox浏览器等，而这些浏览器最终都能以相同的方式解释数据。</p>
<p>这意味着现在所有的浏览器都有一个共同的标准规则——通过80端口发送数据；但是浏览器的外观、使用感觉和易用性则取决于设计师或用户的个人选择。</p>
<p>除了web浏览器的标准规则是“使用端口80进行通信”之外，其他一些协议也已经分配了对应的标准规则，接下来我们将探讨 和一些其他协议相对应的标准规则：</p>
<p><em>tips：任何在 0 到 1024 之间的端口都被称为普通端口。</em></p>
<ul>
<li><strong>F</strong>ile <strong>T</strong>ransfer <strong>P</strong>rotocol (<strong>FTP</strong>协议)：文件传输协议；默认使用21端口；此协议用于构建在客户机-服务器(C&#x2F;S)模型上的文件共享应用程序，这意味着你可以从FTP服务器上下载文件。</li>
<li><strong>S</strong>ecure <strong>Sh</strong>ell (<strong>SSH</strong>协议)：安全外壳协议；默认使用22端口；该协议可用于通过基于文本的管理界面安全地登录目标系统。</li>
<li><strong>H</strong>yper<strong>T</strong>ext Transfer Protocol (<strong>HTTP</strong>协议)：超文本传输协议；默认使用80端口；这个协议为万维网(WWW)提供了基础，你的浏览器能够使用该协议来访问或者下载网页上的文本、图像和视频等资源。</li>
<li><strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure (<strong>HTTPS</strong>协议)：超文本传输安全协议；默认使用443端口；该协议与HTTP协议相同，但是另外还增加了安全加密特性。</li>
<li><strong>S</strong>erver <strong>M</strong>essage <strong>B</strong>lock (<strong>SMB</strong>协议)：服务器消息块协议，是一种网络文件系统访问协议；默认使用445端口；该协议类似于文件传输协议(FTP)，但是，除了文件之外，SMB协议还允许你共享打印机等设备。</li>
<li><strong>R</strong>emote <strong>D</strong>esktop <strong>P</strong>rotocol (<strong>RDP</strong>协议)：远程桌面协议；默认使用3389端口；该协议是一种使用可视桌面界面登录目标系统的安全方法(与SSH协议基于文本界面的限制不同)。</li>
</ul>
<p>我们在此只是简单地介绍了网络安全中的一些常见协议，你可以在以下链接中找到1024个常用端口列表：</p>
<blockquote>
<p><a class="link"   href="http://www.vmaxx.net/techinfo/ports.htm" >http://www.vmaxx.net/techinfo/ports.htm <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>注意：上述这些协议只是默认会遵循标准规则来使用端口，也就是说，你其实可以在不同的端口上来管理与协议交互的应用程序，而不只是使用标准端口(比如在8080端口上而不是在80标准端口上运行web服务器)；但是应用程序将假定遵循标准规则来使用端口，因此你在通过浏览器访问目标服务器时——必须在URL的最后提供冒号(:)并加上具体的端口号。</p>
<p><strong>实例练习</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过端口“1234”连接到目标IP地址“8.8.8.8”，最后将收到一个flag。</em></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327011252012.png"
                      alt="image-20230327011252012" style="zoom:67%;" 
                >

<blockquote>
<p>最后得到的flag是：THM{YOU_CONNECTED_TO_A_PORT} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230327011307845.png"
                      alt="image-20230327011307845"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-What is Networking？(什么是网络？)-学习</title>
    <url>/2024/01/18/THM-What%20is%20Networking%EF%BC%9F(%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%EF%BC%9F)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/whatisnetworking" >https://tryhackme.com/room/whatisnetworking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：学习一些关于计算机网络的基础知识。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络是连接在一起的东西，例如，你的朋友圈：你们都因为相似的兴趣、爱好、技能和类型而联系在一起。</p>
<p>网络可以在各行各业中找到:</p>
<ul>
<li>城市公共交通系统</li>
<li>国家电网等基础设施</li>
<li>你和邻居会见和互相问候</li>
<li>邮寄信件和包裹的邮政系统</li>
</ul>
<p>在计算机领域，网络的概念和上述例子类似，只是分散到了各个技术设备上；以你的手机为例，你拥有它的原因是为了获取东西。我们将介绍这些设备如何相互通信以及它们遵循什么规则。</p>
<p>在计算机领域，一个网络可以由2个到数十亿个设备组成，这些设备包括你的笔记本电脑和手机，安全摄像头，交通信号灯，甚至农场。</p>
<p>网络已经融入了我们的日常生活，无论是收集天气数据，还是为家庭供电，甚至是确定谁在道路上有优先通行权都和网络有所关联；由于网络是嵌入在现代社会中的，所以网络也是网络安全中必须掌握的一个基本概念。</p>
<p>以下图为例，Alice, Bob和Jim已经组成了他们的网络。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111701678.png"
                      alt="image-20230325111701678"
                ></p>
<p>网络有各种各样的形状和大小，这也是我们将在本文中讨论的内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325111758447.png"
                      alt="image-20230325111758447"
                ></p>
<h2 id="什么是互联网？"><a href="#什么是互联网？" class="headerlink" title="什么是互联网？"></a>什么是互联网？</h2><p>现在我们已经了解了什么是网络，以及在计算机中网络是如何定义的(在计算机领域：网络表示多个连接的设备)，让我们来探索什么是互联网。</p>
<p>互联网是一个巨大的网络，它由许许多多小网络组成。基于上一小节中的例子，现在让我们想象 Alice 交了一些名叫 Zayn 和 Toby 的新朋友，她想把他们介绍给Bob和Jim，而问题是Alice是唯一一个和Zayn和Toby说同一种语言的人，所以Alice必须成为传达信息的信使。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325112358537.png"
                      alt="image-20230325112358537"
                ></p>
<p>因为Alice会说两种语言，上图中的其他人可以通过Alice实现互相交流——这从而形成一个新的网络。</p>
<p>互联网的第一次迭代是在20世纪60年代末的 ARPANET 项目中，该项目由美国国防部资助，是第一个记录在案的计算机网络；然而，直到1989年，蒂姆·伯纳斯·李 才通过创建万维网(WWW-<strong>W</strong>orld <strong>W</strong>ide <strong>W</strong>eb) 发明了我们现在所知道的互联网，至此，互联网才开始被用作存储和共享信息的存储库(就像今天一样)。</p>
<p>让我们将上面例子中的Alice的朋友网络与计算机设备联系起来，互联网看起来将像下面这类图表的放大版:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325113424671.png"
                      alt="image-20230325113424671"
                ></p>
<p>如前所述，互联网是由许多小型网络连接在一起组成的；这些小网络被称为专用网络(private networks)，连接这些小网络的网络被称为公共网络(private networks)——也就是Internet 。所以，我们可以概括得出，计算机网络可以是以下两种类型之一：</p>
<ul>
<li>Private network（专用网络）</li>
<li>Public network（公共网络）</li>
</ul>
<p>tips：在网络上，计算机设备将使用一组标签来标识自己。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325114031504.png"
                      alt="image-20230325114031504"
                ></p>
<h2 id="识别网络上的设备"><a href="#识别网络上的设备" class="headerlink" title="识别网络上的设备"></a>识别网络上的设备</h2><p>为了通信和维持秩序，网络上的设备必须具有识别性和可识别性，如果你都不知道你在和谁说话，那么网络又有什么用呢?</p>
<p>计算机网络中的设备与人类非常相似，人类有两种被识别的方式:</p>
<ul>
<li>名字</li>
<li>指纹</li>
</ul>
<p>我们可以改变名字，但是我们不能改变指纹，每个人都有自己的一套指纹，这意味着即使改了名字，我们仍然有唯一的身份标识；在网络中的计算机设备具有类似的被识别方式：</p>
<ul>
<li>IP地址</li>
<li>媒体访问控制(MAC-Media Access Control)地址——可以把它看作是一个类似于序列号的地址。</li>
</ul>
<h3 id="IP-Addresses"><a href="#IP-Addresses" class="headerlink" title="IP Addresses"></a><strong>IP Addresses</strong></h3><p>简单地说，IP地址(或Internet协议)可以在一段时间内用作识别网络上的主机的方式，然后该IP地址也可以（在前一个设备使用该IP地址的时间过期后）与另一个设备相关联，而不会使IP地址发生改变。</p>
<p>让我们精确地划分IP地址：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325182903071.png"
                      alt="image-20230325182903071"
                ></p>
<p>IP地址是一组共32位的二进制数字，可分为4个8位二进制数，这些 <u>8位二进制数(<em><strong>octet</strong></em>)</u> 的值将被汇总为网络设备的IP地址；这组数字是通过被称为 IP 寻址和子网划分的技术计算出来的，此处需要理解的重点是：IP 地址可以因设备而异，但不能在同一个网络中同时被多个设备使用。</p>
<p>tips：一个字节由8个二进制位组成，所以一个IPv4地址共四个字节。</p>
<p>IP地址遵循一组被称为协议的标准，这些协议是网络的主干，迫使许多设备使用同一种语言进行通信；设备既可以在私有网络（专用网络）上，也可以在公共网络上。根据设备所处的位置，将决定它们所拥有的IP地址类型：公共IP地址或者私有IP地址。</p>
<p>公共地址可用于在Internet上识别设备，而私有地址可用于在其他设备之中识别设备。以下面的表格和截图为例，假如我们有两个设备在专用网络（私有网络）上:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185159663.png"
                      alt="image-20230325185159663"
                ></p>
<p>以上两台设备将能够使用它们的私有IP地址相互通信，但是，从这两台设备发送到Internet的任何数据都将被相同的公共IP地址识别。公共IP地址可由你的互联网服务提供商(ISP-Internet Service Provider)提供，并且按月收费。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325185615792.png"
                      alt="image-20230325185615792"
                ></p>
<p>随着越来越多的设备联网，想要获得一个未被使用的公共地址也变得越来越难。根据网络行业巨头思科公司的估计，到2021年底，将有大约500亿台设备连接到互联网(<a class="link"   href="https://www.cisco.com/c/dam/en_us/about/ac79/docs/innov/IoT_IBSG_0411FINAL.pdf" >思科, 2021 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)。但是IP地址不止一个版本，到目前为止，我们只讨论了一个版本的互联网协议寻址方案，即 IPv4 ，它使用的是一个具有2^32(42.9亿)个IP地址的编号系统。</p>
<p>IPv6是互联网协议寻址方案的新迭代版本，能够帮助解决IP地址短缺的问题，IPv6有一些好处：</p>
<ul>
<li>支持最多2^128(340万亿+)个IP地址，有助于解决IPv4面临的地址短缺问题。</li>
<li>由于采用了新的方法，IPv6的效率更高。</li>
</ul>
<p>下面的截图显示了IPv6地址和IPv4地址的实例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325191000099.png"
                      alt="image-20230325191000099"
                ></p>
<h3 id="MAC-Addresses"><a href="#MAC-Addresses" class="headerlink" title="MAC Addresses"></a><strong>MAC Addresses</strong></h3><p>网络上的设备都有一个物理网络接口，和接口对应的是该设备主板上的一个微型芯片板；设备的物理网络接口会由制造芯片的工厂分配一个唯一的地址，此地址被称为MAC(媒体访问控制-<strong>M</strong>edia <strong>A</strong>ccess <strong>C</strong>ontrol)地址。MAC地址是一个具有十二个字符的十六进制数字(十六进制：是一种以16为基数的数字系统，可用于在计算机中表示数字)，每一位十六进制的数字都代表两个字符，在具体表示十六进制数时会用冒号分隔，这些冒号是分隔符，例如：<code>a4:c3:f0:85:ac:2d</code>。</p>
<p>MAC地址的前六个字符（前三位MAC地址）代表制作物理网络接口的公司，MAC地址的后六个字符则是唯一的数字。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325192759185.png"
                      alt="image-20230325192759185"
                ></p>
<p>然而，关于MAC地址的一个有趣的事是，它们可以被伪造或“欺骗”。当一台联网设备使用MAC地址伪装成另一台设备时，就会发生MAC地址欺骗，当MAC地址欺骗发生时，通常会破坏一些实现得很差的安全设计，这些（安全性差的）安全设计会假设在网络上通信的设备是可信的。以下面的场景为例：如果防火墙已被配置为允许管理员 MAC 地址之间发生任何通信，如果一个设备伪造或“欺骗”管理员的MAC地址，防火墙就会认为它正在接收来自管理员的通信（而实际上并没有）。</p>
<p>咖啡馆和酒店等场所在使用“Guest”或“Public”Wi-Fi时经常会使用MAC地址进行控制，这种配置可以提供更好的服务，也就是说，如果你愿意为每台设备支付费用，就可以以一定的价格获得更快的连接。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>在和本文相关的TryHackMe实验房间中 部署交互式实验环境并回答下面问题。</p>
<p><em>tips：此交互式实验环境模拟了酒店的Wi-Fi网络，你必须为上网服务付费。你可以注意到路由器不允许Bob的数据包(蓝色)进入TryHackMe网站，并将这些数据包放入垃圾箱中，但是Alice的数据包(绿色)却可以通过，因为Alice已经支付了使用Wi-Fi所需的费用；现在我们尝试将Bob的MAC地址更改为与Alice的MAC地址相同，看看会发生什么事情。</em></p>
<p>正常的通信情况：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200205269.png"
                      alt="image-20230325200205269" style="zoom:50%;" 
                >

<p>伪装MAC地址进行通信：</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230325200413832.png"
                      alt="image-20230325200413832" style="zoom:50%;" 
                >

<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200323536.png"
                      alt="image-20230325200323536"
                ></p>
<blockquote>
<p>最后得到的flag为：THM{YOU_GOT_ON_TRYHACKME} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325200012653.png"
                      alt="image-20230325200012653"
                ></p>
<h2 id="关于Ping-ICMP"><a href="#关于Ping-ICMP" class="headerlink" title="关于Ping (ICMP)"></a>关于Ping (ICMP)</h2><p>Ping是我们可用的最基本的网络工具之一。Ping使用ICMP (Internet Control Message Protocol)报文来判断设备之间连接的性能，例如连接是否存在或者连接是否可靠。</p>
<p>如下面的截图所示，ICMP报文在设备之间传输所花费的时间可通过ping来测量；这种测量是使用 ICMP 的回波数据包(echo packet)和来自目标设备的 ICMP 回波应答(echo reply)来完成的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325115450514.png"
                      alt="image-20230325115450514"
                ></p>
<p>Ping可以针对网络上的设备执行，例如你的家庭网络或者网站等资源。ping工具易于使用，并能安装在Linux和Windows等操作系统上，执行 ping 命令的简单语法是 <code>ping IP address or website URL</code> 。</p>
<p>基于上面的ping命令示例截图：我们正在ping一个私有地址为192.168.1.254的设备，我们可以看到已发送了6个ICMP数据包（手动按ctrl+c按键停止ping命令），所有这些数据包是在平均5.3秒的时间内收到的。</p>
<p><strong>答题</strong></p>
<p>在和本文相关的TryHackMe实验房间中部署实验环境并回答下面问题。</p>
<p><em>tips：在部署的实验环境中对地址“8.8.8.8”使用ping命令。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120527199.png"
                      alt="image-20230325120527199"
                ></p>
<blockquote>
<p>执行ping命令得到的flag为：THM{I_PINGED_THE_SERVER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230325120413513.png"
                      alt="image-20230325120413513"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-DNS in detail(DNS基础详解)-学习</title>
    <url>/2024/01/21/THM-DNS%20in%20detail(DNS%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/dnsindetail" >https://tryhackme.com/room/dnsindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解DNS协议是如何工作的，以及DNS如何帮助我们访问互联网服务。</p>
<h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 指 Domain Name System，即域名系统，DNS能为我们提供一种简单的方式来与互联网上的设备进行通信，而不需要记住复杂的IP地址。</p>
<p>就像每个家庭都有一个唯一的地址能够用来直接发送和接收邮件一样，互联网上的每台计算机也都有自己唯一的地址能够用于通信，这个地址被称为IP地址。</p>
<p>IP地址的格式如下：104.26.10.229，主要由4组0 ~ 255的二进制数字组成，中间用英文句点号隔开。当你想用浏览器来访问一个网站时，选择记住和目标网站相对应的那组复杂的IP地址 可能并不太方便，这就是DNS可以帮助我们的地方。在使用了DNS协议之后，我们就不需要记住类似于 104.26.10.229 的IP地址，而是可以选择记住和IP地址对应的域名如：tryhackme.com 。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231452919.png"
                      alt="image-20230327231452919"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327231521741.png"
                      alt="image-20230327231521741"
                ></p>
<h2 id="域层次结构"><a href="#域层次结构" class="headerlink" title="域层次结构"></a>域层次结构</h2><p><strong>Domain Hierarchy示意图</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233305530.png"
                      alt="image-20230327233305530"
                ></p>
<p><strong>Top-Level Domain(TLD-顶级域)</strong></p>
<p>TLD指的是域名最右边的部分，例如，tryhackme.com的顶级域名是.com；TLD有两种类型，包括gTLD(通用顶级域)和ccTLD(国家代码顶级域)。</p>
<p>在计算机历史上，通用顶级域名主要用于告诉用户“域名的用途”，例如，.com用于商业目的，.org用于组织，.edu用于教育，.gov用于政府；而ccTLD的用途是表示地理位置，例如.ca表示位于加拿大的网站，.co.uk表示位于英国的网站等等。基于用户需求，新的通用顶级域名在大量涌入，包括.online，.club，.website，.biz等等。</p>
<p>要查看超过2000个顶级域名的完整列表，请访问以下链接：</p>
<p><a class="link"   href="https://data.iana.org/TLD/tlds-alpha-by-domain.txt" >https://data.iana.org/TLD/tlds-alpha-by-domain.txt <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><em>tips：gTLD - Generic Top Level、ccTLD - Country Code Top Level Domain 。</em></p>
<p><strong>Second-Level Domain(二级域)</strong></p>
<p>以tryhackme.com为例，.com部分是TLD，tryhackme部分则是二级域名。在进行域名注册时，二级域名被限制最长可使用63个字符+顶级域名(TLD)，在具体的二级域名部分只能使用”<code>a-z</code>“、”<code>0-9</code>“和连字符”<code>-</code>“(不能以连字符开头或结尾，也不能使用连续的连字符)。</p>
<p><strong>Subdomain(子域)</strong></p>
<p>在一个完整的域名中，子域位于二级域的左侧，两者之间将使用英文句点分隔，例如，在一个域名 admin.tryhackme.com 中，admin部分就是子域。</p>
<p>子域名的创建限制与二级域名相同，都被限制为最长可用63个字符，并且同样只能使用A -z 0-9和连字符(不能以连字符开头或结尾或使用连续连字符)。</p>
<p>在一个域名中，我们可以同时使用多个子域，只要用英文句点分隔即可，由此我们便能创建一个较长的域名，例如 jupiter.servers.tryhackme.com ，但是域名的整体长度必须控制在253个字符以内，也就是说：在域名整体长度没超过限制的情况下，我们可以为一个域名创建多个子域名且无数量限制。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328001000917.png"
                      alt="image-20230328001000917"
                ></p>
<h2 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h2><p>我们已经知道DNS可用于寻找目标网站，此外，还存在多种类型的DNS记录，接下来我们将介绍一些常见的DNS记录类型。</p>
<p><strong>A 记录</strong></p>
<p>此类DNS记录将被解析为IPv4地址，例如：<code>104.26.10.229</code></p>
<p><strong>AAAA 记录</strong></p>
<p>此类DNS记录将被解析为IPv6地址，例如：<code>2606:4700:20::681a:be5</code></p>
<p><strong>CNAME 记录</strong></p>
<p>此类DNS记录将被解析到另一个域名，例如，TryHackMe的在线商店有一个子域名store.tryhackme.com，它能返回一个CNAME记录shops.shopify.com，然后再向shops.shopify.com发出另一个DNS请求，就能计算出相关的IP地址。</p>
<p><strong>MX 记录</strong></p>
<p>此类DNS记录将被解析为 处理你正在查询的域的电子邮件服务器地址，例如 tryhackme.com 的MX记录响应可能为 alt1.aspmx.l.google.com ；这类记录还会带有一个优先级值，此值将告诉客户端以什么顺序来尝试访问电子邮件服务器，如果主电子邮件服务器宕机，则可以将电子邮件发送到备份电子邮件服务器。</p>
<p><strong>TXT 记录</strong></p>
<p>TXT记录是自由文本字段，任何基于文本的数据都可以存储在其中。TXT记录有多种用途，一些常见的用途是 列出有权代表域发送电子邮件的服务器(这可以帮助对抗垃圾邮件和钓鱼邮件)，TXT记录还可用于 在注册第三方服务时验证域名的所有权。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003618226.png"
                      alt="image-20230328003618226"
                ></p>
<h2 id="发出DNS请求"><a href="#发出DNS请求" class="headerlink" title="发出DNS请求"></a>发出DNS请求</h2><p><strong>当你发出DNS请求时会发生什么？</strong></p>
<ol>
<li>当你请求一个域名时，你的计算机首先会检查它自身的本地缓存，看看你最近是否查询过这个地址(即查看缓存中是否已经为目标网站存储了一个相关的 IP 地址)，如果发现本地缓存中无相关记录，你的计算机则将向递归(<em><strong>recursive</strong></em>)DNS服务器发送DNS请求。</li>
<li>递归DNS服务器通常会由你的Internet 服务提供商(即ISP，在中国是移动、联通等)提供，但你也可以选择一些其他的递归DNS服务器。递归DNS服务器会带有一个关于“最近查找过的域名”的本地缓存，如果在此缓存中找到结果，则相关的信息将被发送回你的计算机，你的DNS请求也会在这里结束(这种域名请求情况对于谷歌、Facebook、Twitter等受欢迎以及域名请求频率很高的网站服务来说很常见)。如果在递归DNS服务器的本地缓存中无法找到域名请求的结果，接下来就会开始从互联网的根DNS服务器尝试寻找关于域名请求的正确答案。</li>
<li>根DNS服务器是互联网的DNS主干，它们的工作是将域名请求重定向到正确的顶级域服务器，重定向的结果取决于你的域名请求内容：例如，如果你请求<a class="link"   href="http://www.tryhackme.com,那么根dns服务器将识别到.com的顶级域名,并会将你指向处理.com地址的正确tld(顶级域)服务器./" >www.tryhackme.com，那么根DNS服务器将识别到.com的顶级域名，并会将你指向处理.com地址的正确TLD(顶级域)服务器。 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>TLD服务器会保存“在哪里能找到响应DNS请求的权威服务器”的记录。权威服务器通常也被称为域的名称服务器，例如<a class="link"   href="http://www.tryhackme.com/" >www.tryhackme.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 的名称服务器是<code>kip.ns.cloudflare.com</code>和<code>uma.ns.cloudflare.com</code>，一个域名可能会有多个域名服务器，这是为了形成备份以防宕机。（简而言之：当 TLD 服务器收到我们的域名请求时，TLD服务器会将域名请求信息传递给适当的权威名称服务器，而权威名称服务器主要用于直接存储域的 DNS 记录）</li>
<li>权威DNS服务器是负责存储特定域名的DNS记录的服务器，并且能对所存储的DNS记录进行及时更新。基于DNS记录的不同类型会有多条DNS记录内容，而这些与你的域名请求相关的DNS记录都存储在权威DNS服务器中，当域名请求到达权威DNS服务器之后，权威DNS服务器会将这些与你的域名请求相关的DNS记录 发送回递归DNS服务器，递归DNS服务器将会为这些DNS记录缓存一个本地副本 以备将来的请求所需，然后这些DNS记录将被转发回 发出域名请求的原始客户端机器。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328113758899.png"
                      alt="image-20230328113758899"
                ></p>
<p>Tips：每个DNS记录都会带有一个TTL（Time To Live-生存时间）值，这个值是一个以秒表示的数字，所有不超过TTL时间的DNS记录都会持续存储在计算机的本地缓存中，如果本地缓存中的DNS记录过期，那么在下次请求域名时，你可能需要再次获取相关的DNS记录（这将重复上述过程）。通过使用计算机本地缓存中的DNS记录——可以节省每次与目标服务器进行通信时 所消耗的DNS请求响应时间。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230328003958971.png"
                      alt="image-20230328003958971"
                ></p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>在和本文相关的TryHackMe实验房间中部署实验环境并回答问题。</p>
<p><em>tips：在模拟界面构建请求以进行DNS查询并查看结果。</em></p>
<p>查询 shop.website.thm 的CNAME记录：<code>nslookup --type=CNAME shop.website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232336558.png"
                      alt="image-20230327232336558"
                ></p>
<blockquote>
<p>shop.website.thm 的CNAME记录是：shops.myshopify.com 。</p>
</blockquote>
<p>查询 website.thm 的TXT记录：<code>nslookup --type=TXT website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232618617.png"
                      alt="image-20230327232618617"
                ></p>
<blockquote>
<p>website.thm 的TXT记录是：THM{7012BBA60997F35A9516C2E16D2944FF} 。</p>
</blockquote>
<p>查看 website.thm 的MX记录的数字优先级值：<code>nslookup --type=MX website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327232832550.png"
                      alt="image-20230327232832550"
                ></p>
<blockquote>
<p>website.thm 的MX记录的数字优先级值为：30 。</p>
</blockquote>
<p>查看 website.thm 的A记录的IP地址：<code>nslookup --type=A website.thm</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233114182.png"
                      alt="image-20230327233114182"
                ></p>
<blockquote>
<p>website.thm 的A记录的IP地址为：10.10.10.10 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/articleimg/image-20230327233202973.png"
                      alt="image-20230327233202973"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-HTTP in detail(HTTP协议介绍)-学习</title>
    <url>/2024/01/27/THM-HTTP%20in%20detail(HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/httpindetail" >https://tryhackme.com/room/httpindetail <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>通过学习相关知识点：了解如何使用 HTTP 协议向 Web 服务器请求内容。</p>
<h2 id="什么是-HTTP-S"><a href="#什么是-HTTP-S" class="headerlink" title="什么是 HTTP(S)?"></a>什么是 HTTP(S)?</h2><p><strong>什么是 HTTP？ （HyperText Transfer Protocol-超文本传输协议）</strong></p>
<p>HTTP 是你浏览网站时使用的，由 Tim Berners-Lee 和他的团队在 1989-1991 年间开发。 HTTP 是用于与web服务器进行通信以便传输网页数据的一组规则，这些网页数据包括 HTML、图像、视频等。</p>
<p><strong>什么是 HTTPS？ （HyperText Transfer Protocol Secure）</strong></p>
<p>HTTPS 是 HTTP 的安全版本。 HTTPS 数据经过了加密处理，因此它不仅可以阻止第三方看到你正在接收和发送的数据内容，而且还可以确保你正在与正确的 Web 服务器进行通信（而不是其他冒充你所访问的目标web服务器的东西）。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118214001544.png"
                      alt="image-20221118214001544"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221118215932057.png"
                      alt="image-20221118215932057"
                ></p>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>当我们访问一个网站时，你的浏览器将需要向一个web服务器发出请求，以获得诸如 HTML、图像等资源，并根据来自web服务器的响应得到下载权限。在此之前，你需要明确地告诉浏览器如何获取以及在哪里访问具体的资源文件，这里就需要 URL 来提供一些帮助。</p>
<p><strong>什么是 URL? (Uniform Resource Locator)</strong></p>
<p>如果你使用过互联网，那么你就使用过 URL，URL 主要用于指示如何访问互联网上的资源。下面的图片显示了一个 URL 的所有特性(它可能不会在每个请求中使用所有特性)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119090841555.png"
                      alt="image-20221119090841555"
                ></p>
<ul>
<li>Scheme：这说明了使用什么协议来访问资源，如HTTP、HTTPS、FTP(文件传输协议)。</li>
<li>User：有些服务需要认证以完成登录，你可以在URL中输入用户名和密码进行登录。</li>
<li>Host&#x2F;Domain：你希望访问的服务器的域名或IP地址。</li>
<li>Port：你将要连接到的端口，通常HTTP协议将使用 80 端口，HTTPS协议将使用 443 端口，但是这些协议也可以选择使用 1 - 65535 之间的任何端口号。</li>
<li>Path：你试图访问的资源的文件名或位置。</li>
<li>Query String：可以发送到请求路径的额外信息位。例如，&#x2F;blog?id &#x3D;1 将告诉blog path你希望接收id为1的博客文章。</li>
<li>Fragment：这是对所请求的实际页面上的位置的引用。这通常用于具有较长内容的页面，并且可以将页面的某一部分直接链接到该引用；因此，只要用户通过该URL访问页面，就可以看到链接所对应的部分内容。</li>
</ul>
<p><strong>发出请求</strong></p>
<p>只需要一行”GET &#x2F; HTTP&#x2F;1.1”就可以向web服务器发出请求。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119092848618.png"
                      alt="image-20221119092848618"
                ></p>
<p>但为了获得更丰富的网络体验，你还需要通过请求消息发送其他数据，这些数据将通过请求报头进行发送，在请求报头中也会包含一些额外的信息，以提供给与你进行通信的web服务器。</p>
<p><strong>请求示例（由浏览器客户端发送至服务器端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: tryhackme.com</span><br><span class="line">User-Agent: Mozilla/5.0 Firefox/87.0</span><br><span class="line">Referer: https://tryhackme.com/</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>分解以上请求示例的每一行:</p>
<ul>
<li>第1行：这个请求将发送GET方法(详见本文的HTTP方法小节)，用<code>/</code>请求主页，并告诉web服务器我们正在使用的HTTP协议版本为<code>1.1</code>。</li>
<li>第2行：我们将告诉web服务器我们想要访问域名为<code>tryhackme.com</code>的网站。</li>
<li>第3行：我们将告诉web服务器我们正在使用Firefox 87版本浏览器。</li>
<li>第4行：我们正在告诉web服务器，将我们指向当前页面的来源网址（引用页）是<code>https://tryhackme.com</code></li>
<li>第5行：HTTP请求总是以空行结束，以通知web服务器该HTTP请求已经完成。</li>
</ul>
<p><strong>响应示例（由服务器端发送至浏览器客户端）</strong></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.15.8</span><br><span class="line">Date: Fri, 09 Apr 2021 13:34:03 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 98</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>TryHackMe<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Welcome To TryHackMe.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>分解以上响应示例的每一行:</p>
<ul>
<li><p>第1行：HTTP 1.1是服务器正在使用的HTTP协议版本，然后是HTTP状态码(在本例中为“200 Ok”)，它告诉我们该响应对应的请求已经成功完成。</p>
</li>
<li><p>第2行：这告诉我们web服务器使用的软件和其版本号。</p>
</li>
<li><p>第3行：web服务器的当前日期、时间和时区。</p>
</li>
<li><p>第4行：Content-Type报头会告诉客户端该web服务器将要发送什么类型的信息，比如HTML、图像、视频、pdf、XML。</p>
</li>
<li><p>第5行：Content-Length将告诉客户端该响应的长度，这样我们就可以确认没有发生数据丢失。</p>
</li>
<li><p>第6行：HTTP响应包含一个空行，用于确认HTTP响应的结束。</p>
</li>
<li><p>第7-14行：被请求的信息，在本例中是关于目标主页的html代码。</p>
</li>
</ul>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119100339290.png"
                      alt="image-20221119100339290"
                ></p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP 方法是客户端在发出 HTTP 请求时显示其预期操作的一种方式。有很多 HTTP 方法，在此我们将介绍最常见的方法，在大多数情况下你将处理的是 GET 和 POST 方法。</p>
<p>GET 请求：用于从 Web 服务器中获取信息。</p>
<p>POST 请求：用于向 Web 服务器提交数据并可能创建新记录。</p>
<p>PUT 请求：用于向 Web 服务器提交数据以更新信息。</p>
<p>DELETE 请求：用于从Web服务器中删除信息&#x2F;记录。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119101025366.png"
                      alt="image-20221119101025366"
                ></p>
<h2 id="HTTP状态代码"><a href="#HTTP状态代码" class="headerlink" title="HTTP状态代码"></a>HTTP状态代码</h2><p><strong>HTTP状态码</strong></p>
<p>在前面的叙述中，你能了解到当 HTTP 服务器发出响应时，第一行总是会包含一个状态代码，该状态码用于通知客户端所发出请求对应的结果以及针对请求的可能处理方式。 这些状态码可以分为 5 个不同的范围：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119110901244.png"
                      alt="image-20221119110901244"
                ></p>
<p><strong>常见的HTTP状态码</strong></p>
<p>有很多不同的 HTTP 状态码，这还不包括应用程序自己定义的状态码，我们将介绍一些你可能遇到的最常见的 HTTP 响应状态码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111632793.png"
                      alt="image-20221119111632793"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119111654255.png"
                      alt="image-20221119111654255"
                ></p>
<h2 id="请求标头和响应标头"><a href="#请求标头和响应标头" class="headerlink" title="请求标头和响应标头"></a>请求标头和响应标头</h2><p>标头是你在发出请求时可以发送到 Web 服务器的额外数据位。</p>
<p>虽然在发出 HTTP 请求时没有严格要求标头，但在缺少标头的情况下，你会发现你很难正确地查看网站。</p>
<p><strong>常见的请求头</strong></p>
<p>以下是从客户端（通常是你的浏览器）发送到服务器端的标头信息。</p>
<p>Host：一些 Web 服务器可能会在多个网站上托管内容，因此通过提供主机标头，你可以告诉web服务器你需要访问哪个网站，否则你只会收到web服务器对应的默认网站的响应。</p>
<p>User-Agent：这是你所使用的浏览器软件类型和版本号，告诉web服务器你的浏览器软件类型能帮助它为你的浏览器正确格式化网站，而且网站相关的 HTML、JavaScript 和 CSS 的一些元素只在某些浏览器中可用。</p>
<p>Content-Length：当向 Web 服务器发送数据时，例如当浏览器通过表单向web服务器发送数据时，Content-Length将告诉 Web 服务器该 Web 请求所期望的数据长度，这样web服务器就可以确保它在响应浏览器请求时并不会丢失任何数据。</p>
<p>Accept-Encoding：这将告诉web服务器 当前使用的浏览器支持什么类型的压缩方法，这样数据就可以变小以便通过互联网进行传输。</p>
<p>Cookie：Cookie 是发送到服务器以帮助记住你的信息的数据。</p>
<p><strong>常见的响应头</strong></p>
<p>以下是发出请求后从服务器端返回给浏览器客户端的标头信息。</p>
<p>Set-Cookie：表示浏览器端要存储的Cookie信息，之后每次浏览器发出请求时，Cookie值都会发送回 Web 服务器。</p>
<p>Cache-Control：在再次请求之前，响应内容在浏览器缓存中将存储多长时间。</p>
<p>Content-Type：这将告诉客户端 从web服务器端所返回的数据类型，即 HTML、CSS、JavaScript、图像、PDF、视频等。使用Content-Type标头，浏览器才能知道如何处理数据。</p>
<p>Content-Encoding：在通过 Internet 发送数据时，web服务器将使用什么方法压缩数据以使其更小。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119173812275.png"
                      alt="image-20221119173812275"
                ></p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>Cookie是存储在你的计算机上的一小段数据。 当你从web服务器收到“Set-Cookie”标头时，对应的Cookie信息将被浏览器保存，然后，你发出的每一个进一步请求，都会将 Cookie 数据发送回web服务器。 由于 HTTP 是无状态的（不跟踪你之前的请求），所以 Cookie 可用于提醒web服务器你的身份、网站的一些个人设置或者你以前是否访问过该网站。 </p>
<p>让我们看一下下面这个 HTTP 请求示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119181012864.png"
                      alt="image-20221119181012864"
                ></p>
<p>Cookie 可用于多种用途，但最常用于网站身份验证。 cookie 值通常不会是一个可以让你直接看到密码的明文字符串，而会是一个令牌-token（具有不容易被猜到的唯一密码）。</p>
<p><strong>查看你的 Cookie</strong></p>
<p>你可以使用浏览器中的开发者工具查看你的浏览器向网站发送了哪些 cookie。 </p>
<p>打开开发人员工具后，单击“网络”选项卡。 此选项卡将向你显示你的浏览器已请求的所有资源的列表，你可以单击每一个子项以查看请求和响应的详细分类信息。 如果你的浏览器发送了 cookie，你将在请求消息的“Cookie”选项卡上看到具体的cookie内容。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119223656762.png"
                      alt="image-20221119223656762"
                ></p>
<h2 id="发送请求-练习"><a href="#发送请求-练习" class="headerlink" title="发送请求-练习"></a>发送请求-练习</h2><p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231104215.png"
                      alt="image-20221119231104215"
                ></p>
<p>问题一：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231159570.png"
                      alt="image-20221119231159570"
                ></p>
<p>问题二：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231302404.png"
                      alt="image-20221119231302404"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./../articleimg/image-20221119231321822.png"
                      alt="image-20221119231321822"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231429010.png"
                      alt="image-20221119231429010"
                ></p>
<p>问题三：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231552049.png"
                      alt="image-20221119231552049"
                ></p>
<p>问题四：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231713945.png"
                      alt="image-20221119231713945"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231851305.png"
                      alt="image-20221119231851305"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119231940989.png"
                      alt="image-20221119231940989"
                ></p>
<p>问题五：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232113263.png"
                      alt="image-20221119232113263"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232238841.png"
                      alt="image-20221119232238841"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119232319559.png"
                      alt="image-20221119232319559"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20221119230941300.png"
                      alt="image-20221119230941300"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-How websites work(网站运行基础)-学习</title>
    <url>/2024/01/27/THM-How%20websites%20work(%E7%BD%91%E7%AB%99%E8%BF%90%E8%A1%8C%E5%9F%BA%E7%A1%80)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/howwebsiteswork" >https://tryhackme.com/room/howwebsiteswork <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：要对网站进行漏洞利用，你首先需要知道网站是如何被创建的，本文将涉及HTML&amp;JS以及一些Web安全基础问题。</p>
<h2 id="网站是如何运行的？"><a href="#网站是如何运行的？" class="headerlink" title="网站是如何运行的？"></a>网站是如何运行的？</h2><p>本文将介绍如何创建网站，并介绍关于网站的一些基本的安全问题。</p>
<p>当你访问一个网站时，你的浏览器(如Safari或谷歌Chrome)会向web服务器发出请求，这将询问有关你正在访问的页面的信息，然后web服务器将以“用来显示页面的数据”响应你的浏览器；web服务器是一些位置在世界上其他地方的 并且 能够处理你的请求的专用计算机。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328120422537.png"
                      alt="image-20230328120422537"
                ></p>
<p>一个网站有两个主要组成部分：</p>
<ol>
<li>前端(客户端)-你的浏览器呈现(渲染)网站的方式。</li>
<li>后端(服务器端)-处理你的请求消息并返回响应消息的服务器。</li>
</ol>
<p>在你的浏览器向web服务器发出请求的过程中 还涉及许多其他过程，但现在，我们只需要了解：我们能够向web服务器发出请求，web服务器将响应我们的浏览器以提供一些用于向我们呈现信息的数据。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328121129257.png"
                      alt="image-20230328121129257"
                ></p>
<h2 id="用于网站运行的HTML"><a href="#用于网站运行的HTML" class="headerlink" title="用于网站运行的HTML"></a>用于网站运行的HTML</h2><p>网站的网页内容主要使用以下内容创建：</p>
<ul>
<li>HTML：用于构建网站并定义其结构；</li>
<li>CSS：通过添加样式选项使网站看起来更漂亮；</li>
<li>JavaScript： 使用交互性脚本在网站页面上实现复杂的功能。</li>
</ul>
<p>超文本标记语言(HTML-HyperText Markup Language)是专门用于编写网站的网页内容的语言，元素-Elements (也被称为标签-Tags)是HTML页面的构建模块，它能告诉浏览器如何显示网页内容。下面的代码片段显示了一个简单的HTML文档，HTML的结构对于每个网站来说都是一样的：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328232057953.png"
                      alt="image-20230328232057953"
                ></p>
<p>示例中的HTML结构(如上图所示)包含了以下组件:</p>
<ul>
<li><code>&lt;!DOCTYPE html&gt;</code>定义了此页面是HTML5文档，这有助于在不同浏览器之间实现标准化，并告诉浏览器使用HTML5来解释页面。</li>
<li><code>&lt;html&gt;</code>元素是是HTML页面的根元素——所有其他元素都在这个元素之后。</li>
<li><code>&lt;head&gt;</code>元素包含了关于页面的信息(例如页面标题)。</li>
<li><code>&lt;body&gt;</code>元素定义了HTML文档的正文，浏览器中只显示body(主体)内部的内容。</li>
<li><code>&lt;h1&gt;</code>元素定义了一个大标题（heading）。</li>
<li><code>&lt;p&gt;</code>元素定义了一个段落（paragraph）。</li>
</ul>
<p>还有许多可用于不同目的的其他HTML元素(标签)，例如，按钮(<code>&lt;button&gt;</code>)、图像(<code>&lt;img&gt;</code>)、列表等标签。</p>
<p>元素(标签)可以包含一些属性，比如class属性可以用来设置一个元素的样式(例如设置段落标签的颜色)–<code>&lt;p class=&quot;bold-text&quot;&gt;</code>，还有src属性可用于在图像标签中指定图像的位置–<code>&lt;img src=&quot;img/cat.jpg&quot;&gt;</code>。</p>
<p>一个元素(标签)可以有多个属性，并且每个属性都有自己独特的用途，例如<code>&lt;p attribute1=&quot;value1&quot; attribute2=&quot;value2&quot;&gt;</code></p>
<p>元素可以有id属性(例如<code>&lt;p id=&quot;example&quot;&gt;</code>)，id在元素的属性中具有唯一性。id属性不同于class属性(多个元素可以使用同一个class属性)，不同的元素会有不同的id来唯一地标识它们，元素的id属性主要用于样式化以及提供给JavaScript脚本识别。</p>
<p>你可以通过右键单击网页并选择“查看页面源代码”(Chrome)选项 或者选择“显示页面源代码”(Safari)选项，以此来查看任何网站网页的HTML页面。</p>
<p>tips：本小节只是简单介绍一下用于网站运行的HTML，关于HTML的更多教程请参考—— <a class="link"   href="https://www.runoob.com/html/html-tutorial.html" >https://www.runoob.com/html/html-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>补充图像文件的扩展名：<code>&lt;img src=&#39;img/cat-2.jpg&#39;&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235728518.png"
                      alt="image-20230328235728518"
                ></p>
<p>修复图像显示后，在网页中会显示一张带有字符内容的图像：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235902146.png"
                      alt="image-20230328235902146"
                ></p>
<blockquote>
<p>修复显示的图像内容中的字符为：HTMLHERO</p>
</blockquote>
<p>在网页中添加一张新图片：<code>&lt;img src=&#39;img/dog-1.png&#39;&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329000308629.png"
                      alt="image-20230329000308629"
                ></p>
<blockquote>
<p>新添加的图像中的字符内容为：DOGHTML</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328235613254.png"
                      alt="image-20230328235613254"
                ></p>
<h2 id="用于网站运行的JS"><a href="#用于网站运行的JS" class="headerlink" title="用于网站运行的JS"></a>用于网站运行的JS</h2><p>JavaScript (JS)是世界上最流行的编码语言之一，它允许网站的页面变得具有交互性。HTML用于创建网站的结构和内容，而JavaScript用于控制网页的功能——没有JavaScript，页面就不会有交互元素，将永远是静态的；在网站页面上发生特定事件时，JS可以对应地实时动态更新网站页面，比如我们可以使用JS来设置——每当用户单击按钮，则动态改变按钮的样式或者动态显示移动动画等等。</p>
<p>JavaScript可以被添加到网站的页面源代码中，JS代码可以通过以下两种方式进行加载：</p>
<ul>
<li>可以通过<code>&lt;script&gt;&lt;/script&gt;</code>标签直接进行加载，将具体的JS代码包含在<code>script</code>标签之间即可；</li>
<li>通过src属性远程包含js脚本文件：<code>&lt;script src=&quot;/location/of/javascript_file.js&quot;&gt;&lt;/script&gt;</code>。</li>
</ul>
<p>下面的JavaScript代码能够在网站的页面上找到id为“demo”的HTML元素，并能将元素内容更改为“Hack The Planet”：</p>
<p><code>document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hack the Planet&quot;;</code></p>
<p>通过HTML元素也可以设置事件，如“onclick”或“onhover”，当事件发生时则会自动执行和事件对应的JS代码；例如，下面的代码能够将带有“demo”ID的元素的文本内容更改为“Button Clicked”:</p>
<p><code>&lt;button onclick=&#39;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Button Clicked&quot;;&#39;&gt;Click Me!&lt;/button&gt;</code></p>
<p>在实际情况中，“onclick”事件一般会在JavaScript脚本标签中定义，而不是直接通过HTML元素定义。</p>
<p>tips：本小节只是简单介绍一下用于网站运行的JS，关于JavaScript的更多教程请参考——  <a class="link"   href="https://www.runoob.com/js/js-tutorial.html" >https://www.runoob.com/js/js-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>将以下内容添加到模拟编辑器界面的第 9 行，然后单击“渲染 HTML+JS 代码”按钮：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;Hack the Planet&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>添加代码前：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003439859.png"
                      alt="image-20230329003439859"
                ></p>
<p>添加代码并渲染后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003413451.png"
                      alt="image-20230329003413451"
                ></p>
<p>将以下内容放在 HTML 编辑器中（第 7 行和第 8 行之间）：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&#x27;document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hack the Planet&quot;;&#x27;</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329173108490.png"
                      alt="image-20230329173108490"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329173148889.png"
                      alt="image-20230329173148889"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329003029466.png"
                      alt="image-20230329003029466"
                ></p>
<h2 id="敏感数据泄露介绍"><a href="#敏感数据泄露介绍" class="headerlink" title="敏感数据泄露介绍"></a>敏感数据泄露介绍</h2><p>敏感数据泄露是指网站没有正确保护(或删除)用户的敏感明文信息（通常是在站点的前端源代码中找到一些敏感数据）。</p>
<p>我们知道，网站是用许多HTML元素(标签)构建的，所有这些元素我们都可以通过浏览器中的“viewing the page source”选项来查看，而网站开发人员可能会忘记删除登录凭据、网站隐私部分的隐藏链接或其他以HTML&#x2F;JavaScript形式显示的敏感数据——也就是说，我们可以尝试通过浏览器的“viewing the page source”选项来发现一些敏感数据。</p>
<p>敏感信息可能会被潜在地利用，从而进一步扩大攻击者对web应用程序不同部分的访问权限；例如，网站的页面源代码中可能存在带有临时登录凭据的HTML注释，当你查看页面的源代码时就可能发现这一点，这使得你可以使用所发现的凭据在应用程序的其他地方实现登录(或者更糟，将凭据用于访问站点的其他后端组件)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329174411351.png"
                      alt="image-20230329174411351"
                ></p>
<p>无论何时评估web应用程序的安全性问题，首先应该做的事情之一就是检查网站的页面源代码，看看是否可以找到任何暴露的登录凭据或隐藏的链接。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>通过查看页面源代码发现以及泄露的敏感信息（右键单击以下页面并选择查看框架的源代码）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329174717883.png"
                      alt="image-20230329174717883"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329175056256.png"
                      alt="image-20230329175056256"
                ></p>
<blockquote>
<p>隐藏在源代码中的密码是：testpasswd 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329175143632.png"
                      alt="image-20230329175143632"
                ></p>
<h2 id="HTML注入介绍"><a href="#HTML注入介绍" class="headerlink" title="HTML注入介绍"></a>HTML注入介绍</h2><p>HTML注入是一种漏洞(发生在客户端侧)，这会将未经过滤的用户输入直接显示在网站页面上。如果一个网站未能过滤用户输入(过滤用户输入到网站的任何“恶意”文本)，并且该输入能被显示在网站页面上，那么攻击者就可以针对易受攻击的网站实现HTML代码注入操作。</p>
<p>输入消毒(即过滤恶意输入)对于保持网站安全性非常重要，因为用户输入到网站的信息通常会用于其他前端或者后端的功能实现；比如，有一类漏洞是数据库注入漏洞，如果存在这种漏洞——你就可以通过控制SQL查询的输入来操作数据库并查找其中的数据，从而实现以另一个用户的身份登录网站。</p>
<p>当用户可以控制如何显示他们的输入内容时，用户就可以向网站提交HTML(或JavaScript)代码，而浏览器就可能在网站页面中使用这些代码，从而允许用户能够控制网站页面的外观和功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329181051842.png"
                      alt="image-20230329181051842"
                ></p>
<p>上图显示了表单如何将文本输出到网站页面：无论用户在“What’s your name”的输入框中输入什么，用户所输入的内容都将传递给网站的JavaScript函数，然后输出结果将被显示在网站页面上；这意味着用户能够在输入框中添加自己构造的HTML或JavaScript代码，而这些代码将生效并能附加相关结果以显示在网站页面上。</p>
<p>一般的安全规则是“永远不要相信用户输入”。为了防止用户的恶意输入影响网站的正常功能，网站开发人员应该在使用JavaScript函数之前对用户所输入的所有内容进行消毒（即过滤），在这种情况下，网站开发人员应该删除“用户输入内容”中的HTML标签。</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的TryHackMe实验房间中的模拟界面 并回答问题。</p>
<p>利用模拟页面注入HTML，让页面显示一个恶意链接：<code>&lt;a href=&quot;http://hacker.com&quot;&gt;hacker link&lt;/a&gt;</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183033723.png"
                      alt="image-20230329183033723"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183134511.png"
                      alt="image-20230329183134511"
                ></p>
<blockquote>
<p>得到的answer为：HTML_INJ3CTI0N 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329183220725.png"
                      alt="image-20230329183220725"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Putting it all together(网站组件协同工作介绍)-学习</title>
    <url>/2024/01/27/THM-Putting%20it%20all%20together(%E7%BD%91%E7%AB%99%E7%BB%84%E4%BB%B6%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E4%BB%8B%E7%BB%8D)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/puttingitalltogether" >https://tryhackme.com/room/puttingitalltogether <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：了解Web服务的所有单独组件如何协同工作，这种协同工作能让我们可以访问自己喜欢的网站。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当我们在浏览器中请求网页信息时，幕后还发生了很多事情。在请求一个网站时，我们的计算机需要知道它需要与之通信的Web服务器的 IP 地址，为此，本地计算机需要使用DNS，然后，我们的计算机将使用一组被称为 HTTP 协议的特殊命令与 Web 服务器进行通信， Web 服务器随后将返回 HTML 、JavaScript 、CSS、图像文件等资源，最后，我们本地计算机的浏览器将使用这些资源 并通过正确格式化来向我们呈现网站的相关网页内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230328122449214.png"
                      alt="image-20230328122449214"
                ></p>
<p>此外，还有一些其他组件可以帮助web服务更有效地运行，并提供额外的功能。</p>
<h2 id="Web服务的其他组件"><a href="#Web服务的其他组件" class="headerlink" title="Web服务的其他组件"></a>Web服务的其他组件</h2><p><strong>负载均衡器（Load Balancers）</strong></p>
<p>当一个网站的流量开始变得相当大，或者正在运行一个需要高可用性的应用程序时，一个web服务器也许不再能够胜任工作——此时我们就需要使用负载均衡器。</p>
<p>负载均衡器能提供两个主要功能：确保高流量网站可以处理负载(load)；在服务器变得无响应时提供故障转移功能。</p>
<p>当你请求一个使用了负载均衡器的网站时，负载均衡器将首先接收到你的请求，然后它会将请求转发到它后面的多个服务器之一；在此过程中，负载均衡器会使用不同的算法来帮助决定哪台服务器最适合处理请求消息，这些算法的两个例子是：轮询(round-robin)和加权(weighted)——前者会依次将请求发送到每个服务器，后者会检查服务器当前正在处理多少请求，再将请求发送到最不繁忙的服务器。</p>
<p>负载均衡器还会对每个服务器执行定期检查，以确保它们能够正常运行，这被称为健康检查（<strong>health check</strong>）；如果服务器没有正确响应或无响应，负载均衡器将停止向服务器发送流量，直到服务器再次正确响应为止。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194420901.png"
                      alt="image-20230329194420901"
                ></p>
<p><strong>CDN (Content Delivery Networks)</strong></p>
<p>CDN是一个很好的资源，它可以帮助降低“繁忙网站”的流量压力。CND允许网站管理者托管网站的一些静态文件，如JavaScript, CSS，图像，视频等，使用CDN能将网站静态文件托管在世界各地的数千台服务器上。每当用户请求一个被托管的文件时，CDN就会计算出最近的服务器的物理位置，并将用户的请求发送到那里，而不是发送到遥远的世界另一端。</p>
<p><strong>数据库（Databases）</strong></p>
<p>每个网站通常都需要一种为用户存储信息的方法，这就需要使用数据库。</p>
<p>web服务器可以与数据库进行通信，从而能将数据存储到数据库中以及能从数据库中提取数据。数据库可以是简单的纯文本文件，也可以是 由能够提供速度和弹性的多台服务器组成的复杂集群，一些常见的数据库有：MySQL，MSSQL，MongoDB，GraphQL，Postgres等，每一种数据库都有其具体的特性。</p>
<p><strong>WAF (Web Application Firewall)</strong></p>
<p>Web应用程序防火墙(WAF-Web Application Firewall)位于你的web请求和web服务器之间，它的主要目的是保护web服务器免受黑客攻击或拒绝服务(DoS)攻击。</p>
<p>WAF能够分析带有常见攻击技术的恶意web请求，无论这些恶意请求是来自何处；WAF还会利用速率限制来检查是否有过多的网络请求正在被发送，这将只允许一个IP每秒发送一定数量的请求消息。</p>
<p>如果一个请求被认为是潜在的攻击载荷，那么此请求将被WAF拦截以及丢弃，这意味着此请求将永远不会被发送到web服务器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194500670.png"
                      alt="image-20230329194500670"
                ></p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194637044.png"
                      alt="image-20230329194637044"
                ></p>
<h2 id="Web服务器如何工作"><a href="#Web服务器如何工作" class="headerlink" title="Web服务器如何工作"></a>Web服务器如何工作</h2><p><strong>什么是Web服务器?</strong></p>
<p>web服务器是一种软件，它会监听传入的请求连接，然后利用HTTP协议将web内容传递给客户端浏览器。</p>
<p>常见的web服务器软件有：Apache，Nginx，IIS，NodeJS等。Web服务器将从根目录下(在服务器软件的设置中定义)开始传输文件，例如，Nginx和Apache在Linux操作系统中有相同的默认根目录路径<code>/var/www/html</code>，而IIS在Windows操作系统中的默认根目录路径是<code>C:\inetpub\wwwroot</code>。</p>
<p>如果你向web服务器请求文件- <a class="link"   href="http://www.example.com/picture.jpg" >http://www.example.com/picture.jpg <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> ，web服务器将从它的本地硬盘驱动器中发送文件<code>/var/www/html/picture.jpg</code>。</p>
<p><strong>Virtual Hosts（虚拟主机）</strong></p>
<p>Web服务器可以托管多个具有不同域名的网站，为了实现这一点，Web服务器需要使用虚拟主机。web服务器软件会检查HTTP请求头中的主机名，并将其与虚拟主机进行匹配(虚拟主机只是基于文本的配置文件)。如果HTTP请求中的主机名和虚拟主机成功匹配，web服务器就会向浏览器用户提供一个正确的网站；如果没有找到匹配项，则将提供一个默认网站给浏览器用户。</p>
<p>虚拟主机可以将其根目录映射到web服务器的硬盘驱动器上的不同位置：</p>
<ul>
<li><code>one.com</code>可能被映射到web服务器中的<code>/var/www/website_one</code> ；</li>
<li><code>two.com</code>可能被映射到web服务器中的<code>/var/www/website_two</code> 。</li>
</ul>
<p>你能在一个web服务器上托管不同网站的数量没有限制。</p>
<p><strong>Static Vs Dynamic Content（静态与动态内容）</strong></p>
<p>静态内容，顾名思义，是网站中永不改变的内容，常见的例子是网站的图片、javascript代码、CSS代码等，也可以包括永不更改的HTML内容。此外，静态内容文件是直接由web服务器所提供的文件，web服务器在提供这些静态文件时，无需对这些文件的内容进行任何更改。</p>
<p>另一方面，动态内容是网站中可以随不同的HTTP请求而发生变化的内容。以博客为例，在你的博客主页上会展示文章条目，如果你创建了一个新条目，那么博客主页就会向你显示最新的文章条目，或者以博客上的搜索页面为例，根据你搜索的单词不同，博客网站将会向你显示不同的搜索结果。</p>
<p>你最终看到的网站动态内容都是在所谓的后端中使用编程和脚本语言来完成的，之所以被称为后端，是因为它们所做的一切都是在幕后完成的。你不能查看网站的全部HTML源代码，也不能看到网站的后端具体发生了什么（HTML是后端处理的结果）；你在浏览器中能看到的所有东西都被称为前端。</p>
<p><strong>脚本和后端语言</strong></p>
<p>服务器对后端语言所能实现的功能并没有多少限制，而这些功能的实现正是使网站与用户能够互动的原因。</p>
<p>常见的后端语言包括：PHP，Python，Ruby，NodeJS，Perl等；这些后端语言可以与数据库交互、调用外部服务、处理来自用户的数据……</p>
<p>一个非常基本的PHP示例是：你可以通过访问服务器上的PHP脚本来获得一个网站页面—— <a href="http://example.com/index.php?name=adam">http://example.com/index.php?name=adam</a> 。</p>
<p>如果index.php的内容如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;Hello &lt;?php echo $_GET[&quot;name&quot;]; ?&gt;&lt;/body&gt;&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<p>它将向客户端输出以下内容：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello adam<span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>你能注意到在客户端看不到任何PHP代码，因为PHP代码位于后端，而后端代码所提供的交互性功能 将为(未安全创建的)web应用程序带来更多的安全问题。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329194949800.png"
                      alt="image-20230329194949800"
                ></p>
<h2 id="示例练习"><a href="#示例练习" class="headerlink" title="示例练习"></a>示例练习</h2><p>进入本文相关的TryHackMe实验房间，展开由实验房间所提供的模拟页面，在模拟页面中将磁贴拖放到正确的网站请求顺序中，最后将得到一个flag。</p>
<p><strong>注意</strong>：当磁贴被放置在正确位置时，它会以绿色标注显示，当磁贴位于错误的位置时，它将以红色标注显示；请<strong>不要</strong>随意刷新模拟页面，因为这将重置模拟环境。</p>
<p>正确的网站请求顺序如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200155133.png"
                      alt="image-20230329200155133"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329201018085.png"
                      alt="image-20230329201018085"
                ></p>
<p>得到flag：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200657201.png"
                      alt="image-20230329200657201"
                ></p>
<blockquote>
<p>得到的flag内容为：THM{YOU_GOT_THE_ORDER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230329200737830.png"
                      alt="image-20230329200737830"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part2(Linux基础知识2)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part2(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart2" >https://tryhackme.com/room/linuxfundamentalspart2 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：继续你的 Linux 学习之旅，你将学习如何使用 SSH 登录到 Linux 机器，以及了解更多Linux命令。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux基础”系列的第二部分，在本文中我们将开始了解能够登录和控制远程Linux机器终端的基本技能，并且，我们还将学习以下内容：</p>
<ul>
<li>介绍参数标志和参数开关以便我们更高效地使用Linux命令；</li>
<li>通过学习更多命令，如复制文件和移动文件等，加强我们对Linux文件系统的了解；</li>
<li>介绍访问权限控制机制，并且了解如何识别当前用户是否具有相关的访问权限，以确保文件和文件夹的安全；</li>
<li>介绍一些Linux中的常见目录。</li>
</ul>
<h2 id="使用-SSH-访问-Linux-机器"><a href="#使用-SSH-访问-Linux-机器" class="headerlink" title="使用 SSH 访问 Linux 机器"></a>使用 SSH 访问 Linux 机器</h2><p>SSH协议是Secure Shell的简称，使用该协议是连接到远程Linux机器的常用方法，通过SSH我们可以使用命令行来与远程Linux机器进行交互。</p>
<p>我们将部署两台机器：</p>
<ul>
<li>TryHackMe所提供的Linux目标虚拟机</li>
<li>TryHackMe所提供的攻击机或者你的本地Kali虚拟机</li>
</ul>
<p><strong>什么是SSH &amp;它是如何工作的?（简单了解）</strong></p>
<p>Secure Shell或SSH 是一种能够对计算机设备之间的通信数据进行加密的协议。使用了SSH协议之后，计算机设备之间需要通过网络传输的数据将被加密处理，一旦加密数据到达远程机器，就会开始解密过程，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403100313265.png"
                      alt="image-20230403100313265"
                ></p>
<p>在本文中我们只需要对SSH有一个基础了解即可：</p>
<ul>
<li>SSH能够允许我们通过本地设备上针对另一个设备远程执行命令。</li>
<li>使用了SSH协议之后，设备之间所发送的任何数据 在通过网络传输时都会经过加密处理。</li>
</ul>
<p><strong>使用SSH登录Linux机器</strong></p>
<p>SSH的语法非常简单，我们只需要提供以下内容：</p>
<ol>
<li><p>远程计算机的IP地址；</p>
</li>
<li><p>远程计算机上可用于登录的有效帐户及凭据。</p>
</li>
</ol>
<p>在本文中，我们将以”tryhackme”用户帐户登录到远程Linux机器，相关的登录密码是”tryhackme”。</p>
<p>首先，我们需要在TryHackMe攻击机（或者你的本地Kali虚拟机）上打开一个终端；我们要在攻击机终端输入的SSH命令类似于<code>ssh tryhackme@MACHINE_IP</code>，在实际执行SSH命令时，我们需要将示例中的<code>MACHINE_IP</code>替换为Linux目标机的实际IP地址；当输入SSH命令并按下回车键之后，我们会被询问是否信任主机（输入”yes”即可），然后还要为”tryhackme”帐户提供密码（输入”tryhackme”即可）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403102459672.png"
                      alt="image-20230403102459672"
                ></p>
<p>现在我们应该成功通过SSH连接到远程Linux机器，我们接下来所输入的任何命令都将在远程机器上执行——而不会在我们自己的机器上执行。</p>
<p>注意：当你在ssh登录提示中输入密码时，并没有可见的反馈——你将无法在键入密码时看到任何文本或符号出现，我们只需输入密码并按enter即可。</p>
<p><strong>实践操作</strong></p>
<p>输入命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ssh tryhackme@10.10.241.39</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201425288.png"
                      alt="image-20230403201425288"
                ></p>
<h2 id="Linux命令的参数标志和参数开关"><a href="#Linux命令的参数标志和参数开关" class="headerlink" title="Linux命令的参数标志和参数开关"></a>Linux命令的参数标志和参数开关</h2><p>大多数Linux命令都允许提供参数，这些参数将由连字符以及被称为标志或开关的特定关键字标识。</p>
<p>接下来我们将讨论如何识别哪些命令允许提供参数，以及如何理解这些命令的具体功能。</p>
<p>在使用Linux命令时，除非另有指定，否则它将执行默认行为；例如，<code>ls</code>命令能够列出工作目录下的内容，但是，这并不会显示隐藏文件；所以，我们有时候需要使用参数标志和参数开关来扩展命令的行为。</p>
<p>以<code>ls</code>为例，<code>ls</code>能够告诉我们当前目录下只有一个名为“folder1”的文件夹（请注意，下面截图中的内容仅为示例）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403103507715.png"
                      alt="image-20230403103507715"
                ></p>
<p>然而，在使用<code>-a</code>参数(<code>--all</code>的缩写)对<code>ls</code>命令进行扩展之后，我们会得到一个包含更多文件和文件夹内容的输出结果，例如下图中的”<code>.hiddenfolder</code>“。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403104338287.png"
                      alt="image-20230403104338287"
                ></p>
<p>tips：名称中带”<code>.</code>“表示隐藏文件或者隐藏文件夹，带”<code>.</code>“的文件、文件夹无法通过简单的<code>ls</code>命令被列出。</p>
<p>允许提供参数的命令还可以使用<code>--help</code>选项，该选项会列出此Linux命令能够使用的参数信息（并会提供相关的简要描述和示例）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403104754236.png"
                      alt="image-20230403104754236"
                ></p>
<p>事实上，<code>--help</code>选项也是man page (manual page的缩写)的格式化输出，man page是关于Linux系统命令和应用程序的使用文档。</p>
<p><strong>The Man(ual) Page</strong></p>
<p>man page(手册页)是了解Linux机器上可用的系统命令和应用程序的重要信息来源，我们可以在Linux上访问man page，也可以通过网络<a class="link"   href="https://linux.die.net/man/" >在线访问man page <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>如果要在Linux上访问man page文档，我们可以使用<code>man</code>并将其与具体的Linux命令组合，以<code>ls</code>为例，我们可以使用<code>man ls</code>来查看<code>ls</code>命令的手册页：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403110008841.png"
                      alt="image-20230403110008841"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201750642.png"
                      alt="image-20230403201750642"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403201800338.png"
                      alt="image-20230403201800338"
                ></p>
<h2 id="可与文件系统交互的更多命令"><a href="#可与文件系统交互的更多命令" class="headerlink" title="可与文件系统交互的更多命令"></a>可与文件系统交互的更多命令</h2><p>在“Linux基础”系列的第一部分，我们介绍了与Linux机器上的文件系统进行交互的一些基本命令。</p>
<p>在本小节中，我们将学习更多可以与文件系统交互的命令，以允许我们：</p>
<ul>
<li>创建文件和文件夹</li>
<li>移动文件和文件夹</li>
<li>删除文件和文件夹</li>
</ul>
<p>更具体地说，我们将学习以下命令：</p>
<ul>
<li>touch（全称为-touch）：创建文件；</li>
<li>mkdir（全称为-make directory）：创建目录，即创建文件夹；</li>
<li>cp（全称为-copy）：复制文件或者文件夹；</li>
<li>mv（全称为-move）：移动文件或者文件夹；</li>
<li>rm（全称为-remove）：移除文件或者文件夹，即删除文件或者文件夹；</li>
<li>file（全称为-file）：确定文件类型。</li>
</ul>
<p>tips：与使用<code>cat</code>命令类似，我们可以为以上这些命令指定一个完整的文件路径，比如，directory1&#x2F;directory2&#x2F;note 。</p>
<p><strong>创建文件和文件夹(touch, mkdir)</strong></p>
<p>在Linux上创建文件和文件夹是一个简单的过程。首先，我们将介绍如何创建一个文件，<code>touch</code>命令只接受一个参数——我们想要给我们创建的文件所赋予的名称；例如，我们可以使用<code>touch note</code>创建“note”文件。值得注意的是，使用<code>touch</code>只会创建一个空白文件，你还需要使用<code>echo</code>之类的命令或<code>nano</code>之类的文本编辑器来向空白文件添加内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403112406458.png"
                      alt="image-20230403112406458"
                ></p>
<p>创建文件夹与创建文件的过程类似，我们只需要使用<code>mkdir</code>命令并提供我们想要赋予给目录的名称即可；例如，我们可以使用<code>mkdir mydirectory</code>创建一个目录“mydirectory”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403112648611.png"
                      alt="image-20230403112648611"
                ></p>
<p><strong>删除文件和文件夹(rm)</strong></p>
<p>我们可以使用<code>rm</code>命令简单地删除文件，但是，如果我们希望删除一个文件夹（目录）的话，我们就需要使用<code>-R</code>参数开关。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113006915.png"
                      alt="image-20230403113006915"
                ></p>
<p><strong>复制和移动文件、文件夹(cp, mv)</strong></p>
<p>复制和移动文件是Linux机器上的重要功能，<code>cp</code>命令可以结合以下两个参数使用：</p>
<ol>
<li><p>现有文件的名称；</p>
</li>
<li><p>复制时希望分配给新文件的名称。</p>
</li>
</ol>
<p>使用<code>cp</code>命令能够将现有文件的全部内容复制到新文件中，在下图的示例中，我们将“note”文件复制到“note2”文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113305603.png"
                      alt="image-20230403113305603"
                ></p>
<p>移动文件所使用的<code>mv</code>命令也需要两个参数，就像<code>cp</code>命令一样；然而，<code>mv</code>命令不会复制并创建一个新文件，而是合并或修改我们作为参数提供的第二个文件。</p>
<p>我们不仅可以使用<code>mv</code>命令将文件移动到新文件夹下，还可以使用<code>mv</code>命令重命名文件或文件夹；例如，在下图的示例中，我们使用<code>mv</code>将文件“note2”重命名为“note3”，现在“note3”文件将拥有“note2”文件的全部内容（“note2”文件会消失）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403113944078.png"
                      alt="image-20230403113944078"
                ></p>
<p><strong>确定文件类型(file)</strong></p>
<p>一个文件通常会有所谓的扩展名，例如，文本文件的扩展名通常是“.txt”，但是文件扩展名并不是文件所必要的（一个文本文件的名称也可以不带.txt）。</p>
<p>我们可以使用<code>file</code>命令来确定一个文件的类型，例如，我们可以使用<code>file</code>来确认“note”文件是否确实是一个文本文件：<code>file note</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403114529729.png"
                      alt="image-20230403114529729"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205420231.png"
                      alt="image-20230403205420231"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205330825.png"
                      alt="image-20230403205330825"
                ></p>
<h2 id="访问权限介绍"><a href="#访问权限介绍" class="headerlink" title="访问权限介绍"></a>访问权限介绍</h2><p>在Linux机器上，某些用户可能无权访问一些文件或文件夹，我们之前已经探讨了一些命令，这些命令可用于确定与文件或文件夹相关的访问权限。</p>
<p>在前面的知识点小节中，我们已经学习了如何通过参数标志和参数开关来扩展命令的使用；当我们使用<code>ls</code>命令结合<code>-lh</code>参数开关时，我们可以看到如下示例内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403115704554.png"
                      alt="image-20230403115704554"
                ></p>
<p>如上图所示，我们使用<code>ls -lh</code>命令列出了当前目录下的文件和文件夹的权限分配情况。</p>
<p>tips：<code>-l</code> 使用长列表格式列出内容；<code>-h</code> 全称为–human-readable（顾名思义，以可读形式列出内容） 。</p>
<p>以上输出结果对于确定文件或文件夹的某些特征以及我们是否有权访问它们非常重要，一个文件或文件夹可以有几个特征，这些特征决定了允许执行哪些操作以及哪些用户或组有能力执行给定的操作，例如：</p>
<ul>
<li>Read（读取）：对应的权限标志为“r”；</li>
<li>Write（写入）：对应的权限标志为“w”；</li>
<li>Execute（执行）：对应的权限标志为“x”。</li>
</ul>
<p>假设现在有一个文件名称为“cmnatic. pem”，它的文件权限分配情况如下是”-rw——-“，我们对“cmnatic. pem”文件进行分析：</p>
<ul>
<li>“-”表示“cmnatic. pem”的类型是一个文件；</li>
<li>“rw——-”表示只有“cmnatic.pem”文件的所有者才能读写该文件，并且此文件所有者无权执行该文件。</li>
</ul>
<p>关于权限分配指示符的说明：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">例子：-rwxrwxrwx</span><br><span class="line"></span><br><span class="line">0-9位指示符的说明</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第0位 用于确定文件类型(-,l,d,c,b)</span></span><br><span class="line">- 是文件</span><br><span class="line">l 是链接（link），相当于windows 的快捷方式</span><br><span class="line">d 是目录，相当于windows的文件夹</span><br><span class="line">c 是字符设备文件，鼠标，键盘</span><br><span class="line">b 是块设备，比如硬盘</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第1-3位 用于确定文件所有者（该文件的所有者）拥有该文件的权限情况 —User</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第4-6位 用于确定文件所在组（同用户组的用户）拥有该文件的权限情况 —Group</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第7-9位 用于确定其他用户拥有该文件的权限情况 —Other</span></span><br><span class="line">rwx分别代表的是可读、可写、可执行（如果没有取得对应权限，则会使用&quot;-&quot;符号表示没有该权限）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rwx作用到文件和rwx作用到目录（权限作用到文件和作用到目录有所不同）</span></span><br><span class="line">r: 如果对一个文件有r权限但对其所在文件夹没有r权限，那么使用ls和ll命令则会提示权限不足，但是可以通过cat来读取该文件内容</span><br><span class="line">w：对一个文件有w权限代表可以对该文件进行修改，但不可以删除该文件，删除一个文件的前提是对该文件所在的目录有w权限</span><br><span class="line">x：x作用到文件表示可以执行，x作用到目录表示可以进入该目录，如果对一个目录没有x权限，使用cd命令想进入该目录时则会提示权限不足</span><br></pre></td></tr></table></figure></div>

<p>修改权限：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">chmod(修改文件权限)</span><br><span class="line"></span><br><span class="line">u=user,g=group,o=other</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> u=rwx,g=r-x,o=--x 文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> g+w 文件名</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> o-x 文件名</span></span><br><span class="line"></span><br><span class="line">r=4,w=2,x=1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> 751 文件名</span></span><br><span class="line"></span><br><span class="line">chown(修改所有者)</span><br><span class="line"></span><br><span class="line">chgrp(修改所在组)</span><br></pre></td></tr></table></figure></div>

<p><strong>简述用户和组之间的区别</strong></p>
<p>我们在Linux基础知识第一部分(即普通用户和系统用户之间的区别)中简要地探讨了这一点。Linux的伟大之处在于，Linux系统中的权限可以划分得很细致，从技术上讲，在一个用户拥有一个文件的同时，如果对权限进行设置，那么另一组用户也可以对同一文件拥有相同或不同的权限集，而不会影响文件所有者本身。</p>
<p>让我们把权限划分的概念放到现实世界中，我们知道运行web服务器的系统用户必须具有有效的针对web应用程序的文件读写权限；然而，类似于提供网络托管服务的公司 将不得不允许他们的客户在不成为web服务器系统用户的情况下 就能为他们的网站上传自己的文件——而这可能会危及所有其他客户的安全。</p>
<p>下面我们将学习在用户之间进行切换所需的命令。</p>
<p><strong>切换用户</strong></p>
<p>由于有<code>su</code>命令，所以在Linux中切换用户变得非常简单。除非你是root用户(或者通过sudo使用root权限)，否则你需要知道以下内容来完成用户帐户的切换：</p>
<ol>
<li>我们希望切换到的有效用户名称；</li>
<li>有效用户的密码。</li>
</ol>
<p>在实际使用<code>su</code>命令时，我们可以将其与参数开关相结合以扩展命令的使用，例如，我们可以指定用户切换后执行命令或指定用户切换后要使用的特定shell。你可以通过阅读<code>su</code>的手册页（<code>man su</code>）以了解更多信息。</p>
<p>简单地说，通过向<code>su</code>命令提供<code>-l</code>（或者<code>--login</code>）参数开关，我们可以启动一个更类似于实际用户登录系统的shell——我们可以继承新用户的更多属性，如环境变量等。</p>
<p>我们可以使用简单的<code>su</code>命令切换到user2用户：<code>su user2</code>，此时我们得到的新会话会将我们放置到前一个用户的主目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403181030326.png"
                      alt="image-20230403181030326"
                ></p>
<p>我们也可以使用<code>su</code>命令结合参数开关<code>-l</code>切换到user2用户：<code>su -l user2</code>，此时我们的新会话会自动将我们放到新用户的主目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403181356768.png"
                      alt="image-20230403181356768"
                ></p>
<p><strong>答题</strong></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205736563.png"
                      alt="image-20230403205736563"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205844076.png"
                      alt="image-20230403205844076"
                ></p>
<h2 id="Linux中的常用目录"><a href="#Linux中的常用目录" class="headerlink" title="Linux中的常用目录"></a>Linux中的常用目录</h2><p><strong>&#x2F;etc目录</strong></p>
<p>这个目录是Linux系统上最重要的目录之一，”&#x2F;etc”文件夹(目录)是存储操作系统所使用的系统文件的常见位置。</p>
<p>例如，下图显示的etc&#x2F;sudoers文件包含了 能够以root用户权限运行<code>sudo</code>命令或其他Linux命令的用户和组的列表；下图还显示了etc&#x2F;passwd和etc&#x2F;shadow文件，这两个文件对于Linux也是特殊的，因为它们显示了系统如何以被称为sha512的加密格式存储每个用户的密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403185401761.png"
                      alt="image-20230403185401761"
                ></p>
<p>tips：etc是etcetera的缩写，etcetera的意思是——“等等；附加物”。</p>
<p><strong>&#x2F;var目录</strong></p>
<p>接下来我们要介绍的是”&#x2F;var”目录，其中”var”是” variable data”（可变数据）的缩写，此目录是Linux系统中的主要目录之一，存储着在系统中运行的服务、应用程序所频繁访问或写入的数据；例如，来自于服务和应用程序运行时的日志文件将被写入到此目录下(<code>/var/log</code>)，其他不一定与特定用户相关联的数据(如数据库等)也会被存储到”&#x2F;var”目录下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403190816800.png"
                      alt="image-20230403190816800"
                ></p>
<p>&#x2F;<strong>root目录</strong></p>
<p>与”&#x2F;home”目录不同，”&#x2F;root”文件夹实际上是”root”系统用户的主目录；除了理解这是”root”用户的主目录之外，这个文件夹没有其他内容。基于逻辑上的假设，用户会将其数据默认保存在”&#x2F;home&#x2F;root”目录中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403191227461.png"
                      alt="image-20230403191227461"
                ></p>
<p><strong>&#x2F;tmp目录</strong></p>
<p>该目录是Linux中的唯一目录，”&#x2F;tmp”目录中的”tmp”是”temporary”（临时）的缩写，它是不稳定的，可用于存储只需要被访问一次或两次的数据；”&#x2F;tmp”在存储数据时与计算机上的内存类似，一旦计算机重新启动，”&#x2F;tmp”文件夹中的内容则将会被自动清除。</p>
<p>我们要知道的是：在默认情况下，任何用户都可以写入内容到这个”&#x2F;tmp”文件夹，这意味着一旦我们访问了一台机器，”&#x2F;tmp”就可以作为存储脚本等内容的极佳选择。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403192005422.png"
                      alt="image-20230403192005422"
                ></p>
<p><strong>答题</strong></p>
<p>通过阅读本小节的内容回答以下问题：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403205931526.png"
                      alt="image-20230403205931526"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文涵盖了相当多的Linux基础知识，让我们简单回顾一下本文所包含的学习内容：</p>
<ul>
<li>学习使用SSH远程连接到Linux机器；</li>
<li>通过了解参数标志、参数开关以及每个命令的相关信息(手册页)来加强对Linux命令的使用；</li>
<li>学习使用一些常用命令与文件系统及其内容进行交互；</li>
<li>简要介绍了文件权限和怎样切换当前用户；</li>
<li>介绍Ubuntu Linux在默认情况下的常用目录，了解我们应该如何使用存储在这些常用目录中的数据。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part1(Linux基础知识1)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part1(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart1" >https://tryhackme.com/room/linuxfundamentalspart1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：踏上学习 Linux 基础知识的旅程，学习在交互式终端上运行一些最基本的Linux命令。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux 基础”系列的第一部分。你很可能使用的是 Windows 或 Mac 机器，这两者在视觉设计和操作方式上都有很多不同，就像 Windows、iOS 和 MacOS 一样，Linux只是另一种操作系统，也是世界上最流行的操作系统之一，Linux系统正在为智能汽车、安卓设备、超级计算机、家用电器、企业服务器等提供动力。</p>
<p>本文将为你提供以下Linux基础内容：</p>
<ul>
<li>在交互式Linux机器中运行你的第一个命令</li>
<li>介绍一些用于与文件系统交互的基本Linux命令</li>
<li>向你介绍用户和组如何在Linux上工作（以及这对渗透测试人员意味着什么）</li>
</ul>
<h2 id="Linux的一些背景知识"><a href="#Linux的一些背景知识" class="headerlink" title="Linux的一些背景知识"></a>Linux的一些背景知识</h2><p><strong>Linux在哪里使用?</strong></p>
<p>相比于Windows系统，Linux操作系统要轻量级得多，你会惊讶地发现，你每天都有机会以某种形式使用Linux系统，Linux能够支持以下功能：</p>
<ul>
<li><p>用于搭建用户访问的网站</p>
</li>
<li><p>用于车载娱乐信息系统和相关控制面板</p>
</li>
<li><p>销售点(PoS-Point of Sale)系统，如商店的收银台</p>
</li>
<li><p>关键基础设施，如交通灯控制器或工业传感器</p>
</li>
</ul>
<p><strong>Linux的特色</strong></p>
<p>“Linux”这个名字实际上是基于UNIX(另一种操作系统)的多个操作系统的总称，由于UNIX是开源的，所以Linux的变体也各种各样——操作系统的不同用途催生出了不同的Linux变体。</p>
<p>例如，Ubuntu和Debian是比较常见的Linux发行版，Linux的可扩展非常强，也就是说，你可以把Ubuntu作为服务器(比如网站和web应用程序)运行，也可以把它作为一个成熟的个人操作系统运行。在本文中，我们将使用Ubuntu系统进行练习。</p>
<p>tips：Ubuntu服务器可以在只有512MB内存的系统上运行。</p>
<p>tips：类似于不同版本的Windows(7、8和10)，Linux也有许多不同的版本以及发行版。</p>
<p><strong>答题</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402214844561.png"
                      alt="image-20230402214844561"
                ></p>
<h2 id="运行简单的Linux命令"><a href="#运行简单的Linux命令" class="headerlink" title="运行简单的Linux命令"></a>运行简单的Linux命令</h2><p>正如我们之前所讨论的那样，使用 Ubuntu 等Linux操作系统的关键原因是由于Linux操作系统的轻量级，但是，这并非意味着Linux并非没有缺点，例如，如果我们没有为Linux系统安装GUI，那么在Linux操作系统中通常就没有 GUI（图形用户界面，能提供与机器交互的桌面环境）可供我们使用。</p>
<p>如果我们想要与没有GUI的Linux操作系统发生交互，我们就必须通过“终端”来完成（即使系统安装了GUI，还是免不了依赖于“终端”来和Linux系统进行交互）。</p>
<p>“终端”是纯粹基于文本的，Linux操作系统的“终端”（Terminal）界面类似于下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402220603219.png"
                      alt="image-20230402220603219"
                ></p>
<p>我们可以通过终端命令来实现一些基本的操作，如导航到文件、输出文件内容以及创建文件等，这些命令的含义有时候是不言自明的。</p>
<p>让我们先了解以下两个基本命令：</p>
<ul>
<li><code>echo</code>：输出我们所提供的任何文本内容；</li>
<li><code>whoami</code>：显示我们当前登录的用户名。</li>
</ul>
<p>以下是相关命令的示例：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221322991.png"
                      alt="image-20230402221322991"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221333903.png"
                      alt="image-20230402221333903"
                ></p>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221632147.png"
                      alt="image-20230402221632147"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402221505119.png"
                      alt="image-20230402221505119"
                ></p>
<h2 id="使用Linux命令与文件系统交互"><a href="#使用Linux命令与文件系统交互" class="headerlink" title="使用Linux命令与文件系统交互"></a>使用Linux命令与文件系统交互</h2><p>我们只介绍了“ echo”和“ whoami”命令，这还不能帮助我们实现导航到文件系统、读取文件内容以及写入内容到文件等操作；所以我们还需要学习更多的命令。</p>
<p><strong>与文件系统交互</strong></p>
<p>如前所述，能够在不依赖桌面环境的情况下浏览所登录的Linux机器是非常重要的，我们可以使用以下命令：</p>
<ul>
<li><code>ls</code>：该命令的全名是“listing”；</li>
<li><code>cd</code>：该命令的全名是“change directory”；</li>
<li><code>cat</code>：该命令的全名是“concatenate”；</li>
<li><code>pwd</code>：该命令的全名是“print working directory”。</li>
</ul>
<p>tips：上述四个命令是不言自明的，我们可以从上面四个命令的全名中猜测出各个命令的用途。</p>
<p><strong>列出当前目录中的文件(ls)</strong></p>
<p>在我们查找任何文件或文件夹的内容之前，我们需要知道Linux机器的当前目录下存在什么，我们可以使用<code>ls</code>命令(ls是listing的缩写)来列出当前目录中的文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402225034052.png"
                      alt="image-20230402225034052"
                ></p>
<p>在上面的截图中，我们可以看到当前有以下目录&#x2F;文件夹：</p>
<ul>
<li>Important Files</li>
<li>My Documents</li>
<li>Notes</li>
<li>Pictures</li>
</ul>
<p>根据以上文件夹的名称，你可能会猜测到这些文件夹将包含什么内容。</p>
<p>tips：你可以直接列出某个目录(文件夹)下的内容，而无需事先导航到对应目录，如使用<code>ls Pictures</code>命令将直接列出Pictures目录下的内容。</p>
<p><strong>更改当前目录(cd)</strong></p>
<p>现在我们知道当前目录下存在哪些文件夹，我们可以使用<code>cd</code>命令(change directory的简称)来切换到对应目录中；例如，如果我们想打开“Pictures”目录，就可以执行<code>cd Pictures</code>命令来切换目录，然后再使用<code>ls</code>命令——即可列出“Pictures”目录下的内容。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402230130734.png"
                      alt="image-20230402230130734"
                ></p>
<p>如上图所示，在Pictures目录下有四个jpg图像文件。</p>
<p><strong>查看文件内容(cat)</strong></p>
<p>当我们知道文件的存在之后，我们还可能想要查看文件的具体内容，此时我们可以使用<code>cat</code>命令，该命令可以简单地查看文本文件(或其他文件)的内容。</p>
<p>“<code>cat</code>”是concatating的缩写，该命令可用于输出文件的具体内容(不仅仅是文本文件)。</p>
<p>在下面的截图中，我们可以看到如何使用<code>ls</code>和<code>cat</code>来查看“Documents”目录下的文件具体内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402230319216.png"
                      alt="image-20230402230319216"
                ></p>
<p>让我们来分析一下上图内容：</p>
<ol>
<li>我们首先使用了<code>ls</code>命令，这让我们知道这台机器的“Documents”文件夹中有哪些文件可用，如上图中的“todo.txt”文件；</li>
<li>然后，我们使用<code>cat todo.txt</code>命令来输出这个“todo.txt”文件的内容，随后显示的内容为“Here’s something important for me to do later!”</li>
</ol>
<p>tips：我们也可以使用<code>cat /home/ubuntu/Documents/todo.txt</code>命令直接输出目标文本文件的内容。</p>
<p>用户名、密码、配置设置等敏感信息有时候也可能会存储在文件中，因此，我们可以尝试使用<code>cat</code>命令来查看一些可能包含敏感信息的文件的具体内容。</p>
<p><strong>查找当前工作目录的完整路径(pwd)</strong></p>
<p>在你使用终端浏览Linux机器的过程中，你当前的工作目录名称可以通过终端提示符得知；但是我们很容易忘记我们当前在文件系统中的确切位置（即当前工作目录的完整路径），这时我们就可以使用<code>pwd</code>命令来进行查看，<code>pwd</code>表示打印工作目录的完整路径（<strong>p</strong>rint <strong>w</strong>orking <strong>d</strong>irectory）。</p>
<p>假设我们目前在“Documents”文件夹中——但是该文件夹在Linux机器文件系统的哪个具体位置呢?</p>
<p>我们可以使用<code>pwd</code>命令进行查看，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402223817265.png"
                      alt="image-20230402223817265"
                ></p>
<p>让我们来分析一下上图内容：</p>
<ol>
<li>根据当前的终端提示符，我们已经知道我们在“Documents”目录中，假设我们不知道“Documents”在系统中的具体位置。</li>
<li>我们可以使用<code>pwd</code>(打印工作目录)命令找到这个“Documents”文件夹的完整路径。</li>
<li>在输入<code>pwd</code>命令之后，Linux会告诉我们这个“Documents”目录存储在当前机器上的“&#x2F;home&#x2F;ubuntu&#x2F;Documents”路径。</li>
<li>现在，如果我们发现自己在其他目录中，我们就可以使用<code>cd /home/ubuntu/Documents</code>将当前工作目录重新更改为“Documents”目录。</li>
</ol>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402224702955.png"
                      alt="image-20230402224702955"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402224506668.png"
                      alt="image-20230402224506668"
                ></p>
<h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p>Linux的一个可取之处是使用它可能会帮助我们提高工作效率，话虽如此，你的效率当然取决于你对Linux命令的熟悉程度；随着时间的推移，当你习惯与操作系统(如Ubuntu)进行交互时，那些常用的Linux命令将开始变成你的肌肉记忆。</p>
<p>在Linux终端界面中，我们可以使用一组命令来快速搜索用户（在整个系统中）可以访问的文件，而不只是一直使用<code>cd</code>和<code>ls</code>来查找文件位置。</p>
<p><strong>使用“find”命令</strong></p>
<p>find命令既可以非常简单地使用，也可以和其他参数或命令组合使用，这取决于你具体想要做什么。</p>
<p>假设我们可以看到如下的一个可用目录列表：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403080111411.png"
                      alt="image-20230403080111411"
                ></p>
<ol>
<li>Desktop</li>
<li>Documents</li>
<li>Pictures</li>
<li>folder1</li>
</ol>
<p>一个目录可以包含更多的目录或文件，当我们为了寻找特定的文件而不得不查看每一个目录时，这就变得令人头疼了，所以我们可以使用find命令来简化上述过程。</p>
<p>假设我们已经知道我们正在寻找的文件的名称-但我们不知道它的确切位置，比如，我们想找到”password.txt”文件。</p>
<p>如果我们已经知道文件名，我们就可以简单地使用<code>find -name password .txt</code>命令，这将在当前目录下的每个文件夹中查找指定的文件，如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403080529617.png"
                      alt="image-20230403080529617"
                ></p>
<p>如上图所示，find命令已经设法找到目标文件——相关路径是folder1&#x2F;passwords.txt；但是，如果我们不知道文件的具体名称或者想要搜索每个具有相同扩展名(如“.txt”)的文件，我们应该怎么做？</p>
<p>我们可以简单地使用通配符(<code>*</code>)来搜索任何以“.txt”（或者其他扩展名）结尾的文件和目录。</p>
<p>假设我们希望找到当前目录中的每个.txt文件，我们就可以构造<code>find -name *.txt</code>命令，这样我们就能够找到当前目录下的每个.txt文件以及它们的具体位置：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403081402271.png"
                      alt="image-20230403081402271"
                ></p>
<p>如上图所示，我们已经成功找到了：</p>
<ol>
<li>位于.&#x2F;folder1目录下的passwords.txt文件；</li>
<li>位于.&#x2F;Document目录下的todo.txt文件。</li>
</ol>
<p><strong>使用“grep”命令</strong></p>
<p>另一个值得学习的实用程序是<code>grep</code>命令的使用，<code>grep</code>命令能够允许我们在文件的内容中搜索我们正在寻找的特定值。</p>
<p>以web服务器的访问日志为例，假设某个web服务器的access.log有244条日志记录。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403082019508.png"
                      alt="image-20230403082019508"
                ></p>
<p>在此处，使用像<code>cat</code>这样的命令并不能很好地解决内容查找问题，例如，如果我们想搜索这个日志文件，以查看某个用户&#x2F;IP地址访问了哪些内容，考虑到我们想要找到一个特定的值，所以用<code>cat</code>命令直接查看这个包含244个条目的日志文件内容并不是那么有效。</p>
<p>我们可以尝试使用<code>grep</code>来搜索一个文件的全部内容，以找到我们想要查找的特定值；以上述的访问日志文件为例，假设我们希望找到IP地址“81.143.211.90”访问过的所有内容(注意，这是虚构的)，我们可以如下操作：使用<code>grep &quot;81.143.211.90&quot; access.log</code>命令。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403082642585.png"
                      alt="image-20230403082642585"
                ></p>
<p>如上图所示，我们已经使用<code>grep</code>命令搜索了access.log文件，然后终端界面向我们显示了一些条目，这些条目都是在access.log日志文件中与目标IP相关的内容。</p>
<p>tips：“grep”的全称为Global search REgular expression and Print out the line（全局搜索正则表达式并打印成行）</p>
<p><strong>答题</strong></p>
<p>使用和本文相关的实验房间所提供的Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">grep &quot;THM&quot; access.log</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403084038773.png"
                      alt="image-20230403084038773"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403084117471.png"
                      alt="image-20230403084117471"
                ></p>
<h2 id="Shell操作符介绍"><a href="#Shell操作符介绍" class="headerlink" title="Shell操作符介绍"></a>Shell操作符介绍</h2><p>学习Linux操作符能够加强你对Linux命令的了解，有一些重要的操作符值得我们注意。</p>
<p>本小节将简单介绍以下几个基础操作符：</p>
<ul>
<li><code>&amp;</code>：此操作符允许你在终端的后台运行命令。</li>
<li><code>&amp;&amp;</code>：此操作符允许你在终端的一行中组合多个命令。</li>
<li><code>&gt;</code>：这个操作符是一个重定向器——这意味着我们可以从命令中获取输出(例如使用cat输出一个文件)并将其定向到其他地方，当我们将输出重定向到一个有内容的文本文件时，原文件的文本内容会被自动覆盖。</li>
<li><code>&gt;&gt;</code>：此操作符执行与<code>&gt;</code>操作符相同的功能，但最终效果是附加输出内容到原文件内容的结尾而不是直接替换(这意味着不会覆盖任何内容)。</li>
</ul>
<p>接下来，让我们简单地介绍一下以上四种操作符。</p>
<p><strong>操作符 “&amp;”</strong></p>
<p>这个操作符允许我们在后台执行命令。</p>
<p>假设我们现在想复制一个大文件，这将花费很长时间，并且在复制文件期间我们无法做任何其他事情；因此，我们可以选择使用”&amp;”操作符将命令后台化，该操作符的作用是允许我们执行一个命令并将其放置在后台，而当命令在后台执行时，我们就可以继续利用终端来做其他事情。</p>
<p><strong>操作符”&amp;&amp;”</strong></p>
<p>我们可以使用”&amp;&amp;”操作符来组合我们要执行的命令列表，并且使用该操作符组合的每个有效命令都会得到执行，例如<code>command1 &amp;&amp; command2</code>，但是要注意的一点是：只有在<code>command1</code>命令执行成功时，<code>command2</code>命令才会随后得到执行。</p>
<p><strong>操作符 “&gt;”</strong></p>
<p>这个操作符就是所谓的重定向器。使用该操作符时，我们可以从命令中获取输出内容，并能将该输出内容发送到其他地方。</p>
<p>一个很好的例子是使用”&gt;”操作符重定向<code>echo</code>命令的输出，假设我们想要创建一个名为，并且要求它的内容为“hey”，我们就可以使用以下命令：<code>echo hey &gt; welcome</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403090231983.png"
                      alt="image-20230403090231983"
                ></p>
<p>tips：如果上图例子中的“welcome”文件本身就有内容，那么使用上述之后，“welcome”文件的原内容将被“hey”所覆盖。</p>
<p><strong>操作符 “&gt;&gt;”</strong></p>
<p>这个操作符其实也是一个输出重定向器，就像我们前面所讨论的操作符(“&gt;”)一样；然而， “&gt;&gt;”操作符的不同之处在于：它不会覆盖原文件中的任何内容，而是会将输出内容附加到原文件内容的最后。</p>
<p>在前面的例子中，我们有一个包含“hey”内容的文件“welcome”，如果我们使用<code>echo</code>命令组合 “&gt;”操作符向文件中添加“hello”，那么“welcome”文件的内容将只有“hello”而没有“hey”（因为使用”&gt;”操作符会覆盖原文件的内容）。</p>
<p>当我们使用 “&gt;&gt;”操作符时，重定向的输出内容将附加到原文件内容的末尾，而不会直接替换（覆盖）原文件的内容：<code>echo hello &gt;&gt; welcome</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403090722301.png"
                      alt="image-20230403090722301"
                ></p>
<p><strong>答题</strong></p>
<p>阅读本小节的内容，并且使用和本文相关的实验房间所提供的Linux虚拟机进行操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403092012788.png"
                      alt="image-20230403092012788"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403092433553.png"
                      alt="image-20230403092433553"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文所介绍的内容是你在与 Linux 机器交互时将要使用的最基本功能，只要你经常使用这些Linux命令，你将能够很快熟悉这些Linux基础内容。</p>
<p>现在快速回顾一下，本文简单介绍了以下内容：</p>
<ul>
<li>了解关于Linux的一些简单背景知识。</li>
<li>与Linux机器进行简单交互。</li>
<li>运行一些最基本的Linux命令。</li>
<li>介绍如何简单地与Linux中的文件系统进行交互，使用<code>find</code>和<code>grep</code>等命令来更有效地查找目标文件。</li>
<li>通过了解一些 shell 操作符来增强你的命令使用基础。</li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Linux Fundamentals Part3(Linux基础知识3)-学习</title>
    <url>/2024/01/27/THM-Linux%20Fundamentals%20Part3(Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/linuxfundamentalspart3" >https://tryhackme.com/room/linuxfundamentalspart3 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文相关内容：进一步提升你的Linux使用技能，了解一些Linux系统常见的实用程序。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>欢迎来到“Linux基础”系列的第三部分(也是最后一部分)。到目前为止，在本系列文章中，你已经学习了一些基本概念并使用了一些重要的命令；接下来，本文将展示一些你可能经常会用到的实用工具和应用程序，你还将通过了解Linux中的自动化任务、包管理、服务日志及应用程序日志来提高你的Linux技能。</p>
<p><strong>环境准备</strong></p>
<p>在TryHackMe攻击机或者你的本地Kali机上，使用以下凭据 通过SSH远程访问TryHackMe实验房间所提供的Linux目标机器：</p>
<ul>
<li>IP Address：MACHINE_IP（在与本文相关的TryHackMe实验房间中部署目标机器，即可得到一个对应的目标IP地址）</li>
<li>Username：tryhackme</li>
<li>Password：tryhackme</li>
</ul>
<p>tips：语法示例——<code>ssh tryhackme@MACHINE_IP</code>。</p>
<h2 id="终端文本编辑器"><a href="#终端文本编辑器" class="headerlink" title="终端文本编辑器"></a>终端文本编辑器</h2><p>到目前为止（在本系列的文章中），我们使用过<code>echo</code>命令与操作符(<code>&gt;</code>和<code>&gt;&gt;</code>)的组合，实现了写入文本内容到指定文件中；但是当我们处理具有多行内容的文件时，前述写入方式并不是一种有效的处理数据的方法，此时我们就需要使用文本编辑器来处理文件内容。</p>
<p>有很多文本编辑器可供Linux终端使用，它们都有各种各样的友好性和实用性，接下来我们将简单介绍以下两种终端文本编辑器：</p>
<ul>
<li>nano编辑器</li>
<li>vim编辑器</li>
</ul>
<p><strong>Nano编辑器简介</strong></p>
<p>Nano很容易上手，如果要使用nano创建或编辑文件，我们只需输入<code>nano filename</code>命令（在实际执行时，将”filename”替换为你所希望编辑的文件名即可）。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Introducing Nano 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# nano myfile</span><br><span class="line">  GNU nano 4.8                                             myfile                                                       </span><br><span class="line"></span><br><span class="line">^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo       M-A Mark Text</span><br><span class="line">^X Exit        ^R Read File   ^\ Replace     ^U Paste Text  ^T To Spell    ^_ Go To Line  M-E Redo       M-6 Copy Text</span><br></pre></td></tr></table></figure></div>

<p>一旦我们按下回车键执行nano命令，nano编辑器将会被启动，然后我们就可以开始输入或修改文件的文本内容；我们可以使用“向上”和“向下”方向键浏览文本的每一行，也可以使用键盘上的“Enter”键开始新的一行。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Nano to write text 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# nano myfile</span><br><span class="line">  GNU nano 4.8                                             myfile                                             Modified  </span><br><span class="line"></span><br><span class="line">Hello TryHackMe</span><br><span class="line">I can write things into &quot;myfile&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">^G Get Help    ^O Write Out   ^W Where Is    ^K Cut Text    ^J Justify     ^C Cur Pos     M-U Undo       M-A Mark Text</span><br><span class="line">^X Exit        ^R Read File   ^\ Replace     ^U Paste Text  ^T To Spell    ^_ Go To Line  M-E Redo       M-6 Copy Text</span><br></pre></td></tr></table></figure></div>

<p>Nano编辑器有一些很容易记住的功能，包括以下内容：</p>
<ul>
<li>搜索文本</li>
<li>复制和粘贴</li>
<li>跳转到某行号对应的行</li>
<li>找出你当前所在行的行号</li>
</ul>
<p>你可以通过按“Ctrl”键(在Linux上会被表示为<code>^</code>)并结合相应的字母来使用nano编辑器的功能；例如，如果我们要退出编辑器界面，我们可以按“Ctrl”+“X”退出Nano编辑器。</p>
<p><strong>VIM编辑器简介</strong></p>
<p>VIM是一个更高级的文本编辑器，虽然你不需要知道VIM的所有高级特性，但是使用VIM编辑器特性 对于提高你的Linux技能有很大帮助。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403214825176.png"
                      alt="image-20230403214825176"
                ></p>
<p>尽管需要更长的时间来熟悉，但是VIM编辑器有很多优点，包括以下内容：</p>
<ul>
<li>可自定义——你可以自主选择修改键盘快捷键；</li>
<li>语法高亮显示——如果你正在编写或维护代码，这可能非常有用，VIM编辑器是软件开发人员的流行选择之一；</li>
<li>VIM编辑器可以在没有安装nano的所有终端上工作（VIM编辑器可以完全替代nano编辑器）；</li>
<li>有很多VIM资源可供你使用，如<a class="link"   href="https://vim.rtorr.com/" >VIM备忘单 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://www.runoob.com/linux/linux-vim.html" >VIM教程 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>等。</li>
</ul>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230557870.png"
                      alt="image-20230403230557870"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230208035.png"
                      alt="image-20230403230208035"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230403230317863.png"
                      alt="image-20230403230317863"
                ></p>
<h2 id="Linux常见实用程序介绍"><a href="#Linux常见实用程序介绍" class="headerlink" title="Linux常见实用程序介绍"></a>Linux常见实用程序介绍</h2><p><strong>下载文件-wget</strong></p>
<p>计算机设备的一个相当基本的特征是具有传输文件的能力，例如，你可能想要从网上下载一个程序、一个脚本或者一张图片。</p>
<p>在本小节我们将介绍<code>wget</code>命令的使用，这个命令允许我们通过HTTP从网络上下载文件——就像你在浏览器中访问文件一样；在使用<code>wget</code>命令下载文件时，我们还需要提供所希望下载的资源的地址，例如，如果我们想下载一个名为“myfile.txt”的文件到本地Linux机器上，假设我们已经知道了目标资源文件的网址，我们所使用的命令看起来会是下面这样：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://assets.tryhackme.com/additional/linux-fundamentals/part3/myfile.txt</span><br></pre></td></tr></table></figure></div>

<p>**传输文件-scp **</p>
<p>SCP（secure copy）是一种能够安全复制文件的方法，与常规的<code>cp</code>复制命令不同，使用<code>scp</code>命令可以在两台计算机之间传输文件，并且该命令将使用SSH协议来提供身份验证和数据加密功能。</p>
<p>基于SOURCE（源）和DESTINATION（目的地），SCP能够允许你：</p>
<ul>
<li>将文件和目录从当前系统中复制到远程系统；</li>
<li>从远程系统中复制文件和目录到当前系统。</li>
</ul>
<p>使用<code>scp</code>命令的前提是：我们已经知道当前的本地系统和远程系统上有效用户的名称及其密码。</p>
<p>接下来我们要将一个示例文件从我们的本地机器复制到远程机器，假设我们已经知道如下信息：</p>
<ul>
<li>远程系统的IP地址——192.168.1.30；</li>
<li>远程系统上的有效用户名称——ubuntu；</li>
<li>本地系统上的文件名——important.txt；</li>
<li>我们希望将文件存储在远程系统上所使用的新文件名称——transferred.txt。</li>
</ul>
<p>有了以上这些信息，我们就可以编写<code>scp</code>命令将文件从本地系统中复制到远程系统：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在本地系统的终端界面输入以下命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在需要提供密码的时候：请输入密码进行身份验证</span></span><br><span class="line">scp important.txt ubuntu@192.168.1.30:/home/ubuntu/transferred.txt</span><br></pre></td></tr></table></figure></div>

<p>现在，让我们颠倒过来，让我们使用<code>scp</code>命令从远程计算机上复制文件到本地计算机。</p>
<p>同样，我们需要事先知道以下信息：</p>
<ul>
<li>远程系统的IP地址——192.168.1.30；</li>
<li>远程系统上的有效用户名称——ubuntu；</li>
<li>远程系统上的文件名——documents.txt；</li>
<li>我们希望将文件存储在本地系统上所使用的新文件名称——notes.txt</li>
</ul>
<p>有了以上这些信息，我们就可以编写<code>scp</code>命令从远程系统上复制文件到本地计算机：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在本地系统的终端界面输入以下命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在需要提供密码的时候：请输入密码进行身份验证</span></span><br><span class="line">scp ubuntu@192.168.1.30:/home/ubuntu/documents.txt notes.txt </span><br></pre></td></tr></table></figure></div>

<p><strong>托管文件到web服务器</strong></p>
<p>Ubuntu机器预先打包了python3，而Python能够提供了一个轻量级且易于使用的web模块，称为“HTTPServer”；该模块能够将你的计算机变成一个快捷和简易的web服务器，你可以使用它来托管你本地计算机上的文件，然后就可以通过其他计算机设备使用<code>curl</code>和<code>wget</code>等命令进行文件下载操作。</p>
<p>Python3的“HTTPServer”默认将托管你当前运行命令时所在的目录中的文件，但这可以通过添加在手册页中找到的参数选项来更改。</p>
<p>我们可以直接在本地计算机的终端中运行<code>python3 -m http.server</code>命令以启动“HTTPServer”模块，如下例所示（没有指定端口则会使用8000端口）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Python to start a web server 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br></pre></td></tr></table></figure></div>

<p>tips：如果需要指定该简易web服务器所绑定的端口，则可以使用像 <code>python3 -m http.server 1234</code>这样的命令（其中的1234为指定的端口号）。 </p>
<p>现在，我们就可以在其他计算机设备上使用<code>wget</code>并通过指定本地计算机的IP地址和文件名来下载文件。Python3所提供的这个“HTTPServer”模块的一个缺陷是无法编制索引，因此必须知道我们所希望下载的文件的确切名称和位置。</p>
<p>除了Python3所提供的“HTTPServer”模块之外，你还可以使用Updog来托管文件，Updog能提供一个更高级但仍属于轻量级的web服务器以便你托管本地计算机上的文件。</p>
<p>Updog的GitHub项目链接：<a class="link"   href="https://github.com/sc0tfree/updog" >https://github.com/sc0tfree/updog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下面是通过Python3的”HTTPServer”模块下载所托管的文件的示例（承接前面的本地文件托管示例）：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Downloading a file from our webserver using wget 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# wget http://127.0.0.1:8000/file</span><br><span class="line"></span><br><span class="line">2021-05-04 14:26:16  http://127.0.0.1:8000/file</span><br><span class="line">Connecting to http://127.0.0.1:8000... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 51095 (50K) [text]</span><br><span class="line">Saving to: ‘file’</span><br><span class="line"></span><br><span class="line">file                    100%[=================================================&gt;]  49.90K  --.-KB/s    in 0.04s</span><br><span class="line"></span><br><span class="line">2021-05-04 14:26:16 (1.31 MB/s) - ‘file’ saved [51095/51095]</span><br></pre></td></tr></table></figure></div>

<p>在上面的示例中，我们可以看到<code>wget</code>命令成功地将名为“file”的文件下载到我们的机器上，这个http请求会被HTTPServer记录(就像任何web服务器一样)：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Using Python to start a web server 终端界面示例</span></span><br><span class="line">tryhackme@linux3:/tmp# python3 -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">127.0.0.1 - - [04/May/2021/14:26:09] &quot;GET /file HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure></div>

<p>tips： 关于Python3”HTTPServer”模块的文档—— <a class="link"   href="https://docs.python.org/3/library/http.server.html" >https://docs.python.org/3/library/http.server.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。</p>
<h3 id="答题-1"><a href="#答题-1" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p>使用 Python3 的“HTTPServer”模块在目标机器的“tryhackme”用户的主目录中启动 Web 服务器。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">python3 -m http.server</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404095742155.png"
                      alt="image-20230404095742155"
                ></p>
<p>在本地攻击机上下载刚才启动的简易web服务器所托管的文件。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">wget http://MACHINE_IP:8000/.flag.txt</span> </span><br><span class="line">wget http://10.10.85.109:8000/.flag.txt </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404100122129.png"
                      alt="image-20230404100122129"
                ></p>
<blockquote>
<p>flag为：THM{WGET_WEBSERVER} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404100230199.png"
                      alt="image-20230404100230199"
                ></p>
<h2 id="Linux进程基础"><a href="#Linux进程基础" class="headerlink" title="Linux进程基础"></a>Linux进程基础</h2><p>进程（Process）是指在你的计算机中正在运行的程序，它们由操作系统内核进行管理，并且每个进程都会有一个与之关联的ID，这个ID被称为PID。PID会根据进程启动的顺序而递增，也就是说，第60个进程的PID即为60。</p>
<p><strong>查看进程(Viewing Processes)</strong></p>
<p>Linux <code>ps</code>（英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。</p>
<p>我们可以使用<code>ps</code>命令来列出正在运行的进程的一个列表，该列表将提供一些附加信息，如进程的PID、进程的状态码、进程相关的CPU占用情况、正在执行的实际程序或命令的名称等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404110917497.png"
                      alt="image-20230404110917497"
                ></p>
<p>从上图中我们可以看到：我们第一次执行<code>ps</code>命令时，<code>ps</code>本身的进程PID是204，然后当我们再次执行<code>ps</code>命令时，<code>ps</code>本身的进程PID增加到了205（这说明PID确实会根据进程启动的顺序而递增）。</p>
<p>如果我们要查看由其他用户运行的进程和那些不在会话中运行的进程(即系统进程)，我们需要为<code>ps</code>命令提供<code>aux</code>参数：<code>ps aux</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404112406775.png"
                      alt="image-20230404112406775"
                ></p>
<p>从上图中我们可以看到现在总共有5个进程，相关的用户名称为“root”和“cmnatic”。</p>
<p>另一个非常有用的命令是<code>top</code>命令，此命令能为你提供有关系统上正在运行的进程的实时统计信息，而不仅是一次性视图；<code>top</code>命令所提供的统计信息将每几秒钟刷新一次，但是每当你使用方向键浏览各行信息时也会进行刷新。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404120541306.png"
                      alt="image-20230404120541306"
                ></p>
<p>关于ps命令的使用参考：<a class="link"   href="https://www.runoob.com/linux/linux-comm-ps.html" >https://www.runoob.com/linux/linux-comm-ps.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>终止进程(Managing Processes)</strong></p>
<p>我们可以通过发送一些信号来终止进程，这些终止进程的信号有多种类型，这主要与系统内核如何“干净”地处理进程有关。</p>
<p>如果我们要终止一个命令(在Linux中，我们可以把进程理解为正在运行的命令)，我们可以使用适当命名的<code>kill</code>命令与我们所希望kill的相关PID组合在一起；例如，我们想要kill一个PID为1337的进程，我们可以使用以下命令：<code>kill 1337</code></p>
<p>下面是当进程被杀死时我们可以发送给进程的一些信号（使用<code>kill -l</code>可列出当前所支持的所有信号类型）：</p>
<ul>
<li>SIGTERM（<code>kill -15</code>）：终止进程，但允许它事先执行一些清理任务；</li>
<li>SIGKILL（<code>kill -9</code>）：默认信号，<code>-9</code>参数可以省略，表示终止进程并且不做任何事后清理；</li>
<li>SIGSTOP（<code>kill -19</code>）：停止或者挂起进程；</li>
<li>SIGHUP（<code>kill -1</code>）：重启进程；</li>
<li>SIGCONT（<code>kill -18</code>）：继续进程。</li>
</ul>
<p><strong>进程如何启动</strong></p>
<p>操作系统(OS)使用名称空间并最终能将计算机上的可用资源分配给(如CPU、RAM和高优先级)进程，你可以把这个过程想象成将你的计算机资源分成几片——类似于切割一块蛋糕；在切片内的进程将拥有一定的计算机资源，然而，这部分资源也只是所有进程实际可用的一小部分。</p>
<p>名称空间对于安全性非常重要，因为它是将一个进程与其他进程隔离的方式——只有相同名称空间中的进程才能相互看到。</p>
<p>我们之前讨论过PID是如何工作的，这就是名称空间可发挥作用的地方；PID为1的进程为系统启动时会自动运行的进程，这个进程在Ubuntu中是系统的初始化(init)进程，比如<code>systemd</code>，它能够用于提供一种在操作系统和用户之间管理用户进程的方法。</p>
<p>一旦系统启动并初始化，<code>systemd</code>就会成为首先自动运行的进程之一，而我们想要运行的任何程序或软件都将作为<code>systemd</code>进程的子进程启动；虽然这些子进程由<code>systemd</code>控制，但仍将作为单独的进程运行(尽管会共享来自<code>systemd</code>的资源)，这能使我们更容易识别各个进程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404183329221.png"
                      alt="image-20230404183329221"
                ></p>
<p><strong>在系统启动时启动进程&#x2F;服务</strong></p>
<p>一些应用程序可以在我们的计算机系统启动时启动，例如，web服务器、数据库服务器或文件传输服务器等，这些软件通常很关键，因而经常被管理员告知在系统启动期间启动。</p>
<p>为了在系统启动时启动进程&#x2F;服务，我们可以使用<code>systemctl</code>命令，该命令允许我们与<code>systemd</code> 进程（守护进程）交互；<code>systemctl</code>是一个易于使用的命令，它采用以下语法格式：<code>systemctl [option] [service]</code></p>
<p>如果我们要让apache服务启动，我们可以使用<code>systemctl start apache2</code>，如果想让apache服务停止，我们只需将<code>[option]</code>替换成<code>stop</code>即可。</p>
<p>我们可以为<code>systemctl</code>命令设置以下四个选项：</p>
<ul>
<li>Start</li>
<li>Stop</li>
<li>Enable</li>
<li>Disable</li>
</ul>
<p><strong>Linux前台和后台介绍</strong></p>
<p>进程可以以两种状态运行：在前台运行、在后台运行。</p>
<p>你在Linux终端中运行的命令，如“echo”将在终端的前台运行，<code>echo</code>命令是一个很好的例子，因为<code>echo</code>命令的输出将在前台返回，并且无法在后台返回：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404190321839.png"
                      alt="image-20230404190321839"
                ></p>
<p>如上图所示：当我们运行<code>echo &quot;Hi THM&quot;</code>命令时，我们能在终端前台看到命令的输出；但当我们在<code>echo &quot;Hi THM&quot;</code>之后添加<code>&amp;</code>操作符之后，我们只能在终端前台看到<code>echo</code>进程的ID（而不是命令的输出）——因为此时<code>echo</code>命令正在后台运行。</p>
<p>前后台机制对于复制文件之类的命令非常有用，因为这将允许我们同时在终端前台和终端后台执行不同的命令；以使用复制文件命令为例，后台化此命令意味着——我们不必等待文件复制命令执行完成，就能同时执行其他命令。</p>
<p>当我们在执行脚本之类的程序文件时，我们也可以让这个进程后台化，此处不依赖于<code>&amp;</code>操作符，而是需要我们在键盘上使用<code>Ctrl + Z</code>来设置进程的后台化，这也是一种“暂停”脚本运行或命令执行的有效方法，如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404192831824.png"
                      alt="image-20230404192831824"
                ></p>
<p>由上图可知：示例脚本会持续输出内容 “This will keep on looping until I stop!”，直到我们停止或者挂起与该脚本对应的进程，我们可以通过在键盘上使用Ctrl + Z(在终端界面由T^Z表示)来停止示例脚本的运行。</p>
<p><strong>前台化进程</strong></p>
<p>假设现在有一个进程（”background.sh”脚本）在后台运行，我们可以通过使用<code>ps aux</code>命令来确认这一点：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404194127042.png"
                      alt="image-20230404194127042"
                ></p>
<p>我们已经知道，在键盘上使用<code>Ctrl + Z</code>或者在命令中添加<code>&amp;</code>操作符能够使进程后台化；同样，我们还可以通过使用<code>fg</code>命令将后台进程重新前台化。</p>
<p>如下所示：在我们使用<code>fg</code>命令之后，”background.sh”脚本所对应的进程能够重新回到终端前台（此时的”background.sh”脚本仍将处于运行状态）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404195229427.png"
                      alt="image-20230404195229427"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404195245222.png"
                      alt="image-20230404195245222"
                ></p>
<h3 id="答题-2"><a href="#答题-2" class="headerlink" title="答题"></a><strong>答题</strong></h3><p><em>tips：阅读本小节的内容以帮助回答以下问题</em></p>
<p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ps aux </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202323290.png"
                      alt="image-20230404202323290"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202348522.png"
                      alt="image-20230404202348522"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202407739.png"
                      alt="image-20230404202407739"
                ></p>
<blockquote>
<p>隐藏的flag为：THM{PROCESSES} 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404202510832.png"
                      alt="image-20230404202510832"
                ></p>
<h2 id="Linux定时任务"><a href="#Linux定时任务" class="headerlink" title="Linux定时任务"></a>Linux定时任务</h2><p>用户可能希望设置某个操作或任务在系统启动后得到执行，例如：运行一些命令、备份指定文件、启动某个程序等等。</p>
<p>为了对操作或任务的执行进行定时设置，我们接下来将讨论<code>cron</code>进程，更具体地说：我们将学习如何通过<code>crontab</code>与<code>cron</code>进程进行交互，<code>crontab</code>是在系统引导期间所启动的进程之一，它负责促进和管理cron jobs（定时任务）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404214102711.png"
                      alt="image-20230404214102711"
                ></p>
<p>crontab是一个特殊的文件，其格式可被<code>cron</code>进程识别以逐步执行crontab的每一行，crontab需要具有以下 6 个特定字段值：</p>
<ul>
<li>MIN：每多少分钟（minute ）执行；</li>
<li>HOUR：每多少小时（hour）执行 ；</li>
<li>DOM：在一个月的每哪一天（Day Of the Month）执行 ；</li>
<li>MON：在一年的每哪个月（Month of the year）执行；</li>
<li>DOW：在一个星期的每哪一天（Day Of the Week）执行；</li>
<li>CMD：实际上将被执行的命令（command）。</li>
</ul>
<p>以备份文件为例，你可能希望每12小时备份一次”cmnatic”用户的”Documents”，我们将为此使用以下格式命令：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">0 *12 * * * cp -R /home/cmnatic/Documents /var/backups/</span><br></pre></td></tr></table></figure></div>

<p>crontab的一个有趣特性是支持通配符(<code>*</code>)，如果我们不希望为某个特定的字段提供一个值，我们就可以用<code>*</code>代替；如上面的定时任务示例（备份文件），我们不关心这个任务执行的月份、日期以及年份——我们只关心它做到每12小时执行一次，所以我们只需放置星号来代替我们所不关心的值。</p>
<p>我们可以使用在线的“<a class="link"   href="https://crontab-generator.org/" >Crontab Generator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”工具，它可以帮助生成符合格式的crontab命令；我们还可以使用“<a class="link"   href="https://crontab.guru/" >Cron Guru <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>”工具，它会分析crontab执行的时间点。</p>
<p>我们可以通过使用<code>crontab -e</code>命令并且选择一个编辑器(比如Nano)来编辑crontab文件的内容：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404220822701.png"
                      alt="image-20230404220822701"
                ></p>
<p>tips：我们通过<code>crontab</code>命令可以添加、删除、编辑自动化任务（定时任务）。</p>
<h3 id="答题-3"><a href="#答题-3" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404230933785.png"
                      alt="image-20230404230933785"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404230914685.png"
                      alt="image-20230404230914685"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404231038141.png"
                      alt="image-20230404231038141"
                ></p>
<h2 id="Linux软件包管理"><a href="#Linux软件包管理" class="headerlink" title="Linux软件包管理"></a>Linux软件包管理</h2><p><strong>介绍软件包和软件存储库</strong></p>
<p>当开发人员希望向Linux社区提交软件时，他们会将其提交到“apt”存储库，如果获得Linux官方批准，那么他们所提交的程序和工具将被发布到公共区域。</p>
<p>Linux最可取的两个特性在这里脱颖而出：具有用户可访问性、能够发挥开源工具的优点。</p>
<p>当我们在 Ubuntu 20.04 Linux 机器上的&#x2F;etc&#x2F;apt目录中使用 <code>ls</code> 命令时，能够看到以下文件，这些文件可用作网关&#x2F;注册表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404232002556.png"
                      alt="image-20230404232002556"
                ></p>
<p>虽然操作系统供应商将维护他们自己的存储库，但你也可以选择将一些社区存储库添加到你的源列表中，这将允许你扩展Linux操作系统的功能。</p>
<p>例如：我们可以使用<code>add-apt-repository</code>命令添加其他存储库到我们的系统，在实际使用这个命令时，我们可以择优添加系统资源供应商所提供的存储库（一些系统资源供应商会拥有一个更接近我们机器的地理位置的存储库）。</p>
<p><strong>管理存储库(添加和删除)</strong></p>
<p>通常我们可以使用<code>apt</code>命令将软件安装到我们的Linux系统中，<code>apt</code>命令是apt包管理软件的一部分；apt包管理软件（即包管理器）包含了一整套工具，这些工具允许我们管理软件包和软件源，同时还能帮助我们安装软件或者删除软件。</p>
<p>添加存储库的一种方法是使用我们上面提到的<code>add-apt-repository</code>命令，但是我们也可以手动添加和删除存储库。</p>
<p>虽然你也可以选择使用其他包安装程序(如<code>dpkg</code>)来安装软件，但是使用apt包管理器的好处是：每当我们更新系统时，它都会检查包含我们添加的软件的存储库是否有更新。</p>
<p>在接下来的示例中，我们将把Sublime text文本编辑器作为一个存储库添加到Ubuntu机器中(这个文本编辑器并不是默认的Ubuntu存储库的一部分)；在我们添加软件时，我们所下载的软件的完整性是通过使用所谓的GPG (Gnu Privacy Guard)密钥来保证的，这些密钥本质上是开发人员所提供的安全检查，能够表明“这是我们的软件”，如果当前密钥与操作系统所信任的密钥（即开发人员使用的密钥）不匹配，那么计算机就不会执行下载软件的操作。</p>
<p>因此，我们首先需要添加Sublime Text 3开发人员所使用的GPG密钥。(此过程需要访问互联网)</p>
<p>添加存储库的示例：</p>
<p>1.下载GPG密钥并使用apt-key信任这个密钥：<code>wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -</code></p>
<p>2.现在我们已经将密钥添加到我们的可信列表中，我们可以开始将Sublime Text 3的存储库添加到我们的apt源列表中；一个好的做法是为我们添加的每个不同的社区&#x2F;第三方存储库都分配一个单独的文件。</p>
<p>2.1让我们在 &#x2F;etc&#x2F;apt&#x2F;sources.list.d目录中创建一个名为sublime-text.list的文件：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230405000525903.png"
                      alt="image-20230405000525903"
                ></p>
<p>2.2使用Nano或其他文本编辑器，添加并保存Sublime text 3存储库到刚才新创建的文件中：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230405000715814.png"
                      alt="image-20230405000715814"
                ></p>
<p>2.3在我们添加了以上条目之后，我们需要更新apt包以识别这个新条目——这是通过使用<code>apt update</code>命令完成的。</p>
<p>2.4成功更新apt包之后，我们现在可以继续安装我们所信任的并且已经添加到apt包中的软件——<code>apt install sublime-text</code></p>
<p>删除软件包的方法很简单，我们可以使用<code>add-apt-repository --remove ppa:PPA_Name/ppa</code>命令来完成，也可以通过手动删除之前添加的文件来完成。</p>
<p>当我们成功删除了软件包之后，我们还需要使用<code>apt remove [software-name-here]</code>来清理apt包，例如：<code>apt remove sublime-text</code> 。</p>
<p>tips：在删除软件包时，我们要将上述示例命令中的<code>PPA_Name</code>替换为我们期望删掉的<code>PPA</code>的名称（该名称在以上示例中为“sublime-text”）。</p>
<h2 id="Linux日志"><a href="#Linux日志" class="headerlink" title="Linux日志"></a>Linux日志</h2><p>我们在 Linux 基础知识第一部分中简要介绍了日志文件以及它们所在的位置，现在，让我们快速回顾一下：这些包含日志信息的文件和文件夹位于<code>/var/log</code>目录中，主要包含了在系统上所运行的应用程序、服务的日志记录信息。 </p>
<p>操作系统 (OS) 擅长通过一个被称为“轮换-rotating”的过程来自动管理日志信息。</p>
<p>以下是Linux机器上正在运行的三个服务以及和这些服务相关的日志信息（此处仅为示例）：</p>
<ul>
<li>Apache2 web服务器；</li>
<li>fail2ban服务（此服务的日志信息可用于监视攻击者所尝试的暴力操作）；</li>
<li>UFW服务，用作防火墙；</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404204023732.png"
                      alt="image-20230404204023732"
                ></p>
<p>通过查看这些服务日志，能够很好地监视系统运行状况以及保护系统的安全；而且，像web server这样的服务所对应的日志文件，还包含了关于每个请求的信息——这将允许网站开发人员或网站管理员诊断web服务的性能，并且有助于调查网络入侵者的活动。</p>
<p>关于web服务，下面两种类型的日志文件是值得我们注意的：</p>
<ul>
<li>access log</li>
<li>error log</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404204753923.png"
                      alt="image-20230404204753923"
                ></p>
<p>tips：日志文件会存储关于操作系统如何运行的信息，还会存储用户所执行的操作，例如身份验证尝试。</p>
<h3 id="答题-4"><a href="#答题-4" class="headerlink" title="答题"></a><strong>答题</strong></h3><p>通过SSH会话对目标Linux虚拟机进行操作：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404210233373.png"
                      alt="image-20230404210233373"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230404210347221.png"
                      alt="image-20230404210347221"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>欢迎来到Linux基础模块的末尾，随着你与Linux交互时间的增加，你对Linux的熟悉程度也将会得到提高。</p>
<p>本文主要介绍了以下内容：</p>
<ul>
<li>关于两种终端文本编辑器（nano和vim）的简介；</li>
<li>了解Linux中的一般实用程序，如下载文件、传输文件、使用python web服务器托管本地内容；</li>
<li>了解Linux中的进程；</li>
<li>通过学习crontab定时任务、软件包管理和日志检查来维护和自动化你的Linux系统。</li>
</ul>
<p>可参考的Linux中文学习资源：</p>
<ul>
<li>Linux中文教程：<a class="link"   href="https://www.runoob.com/linux/linux-tutorial.html" >https://www.runoob.com/linux/linux-tutorial.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Linux 命令大全：<a class="link"   href="https://www.runoob.com/linux/linux-command-manual.html" >https://www.runoob.com/linux/linux-command-manual.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Linux 常用命令英文全拼：<a class="link"   href="https://www.runoob.com/w3cnote/linux-command-full-fight.html" >https://www.runoob.com/w3cnote/linux-command-full-fight.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>你可以通过以下TryHackMe实验房间继续扩展你的Linux基础学习：</p>
<ul>
<li>Bash Scripting（Bash脚本基础） - <a class="link"   href="https://tryhackme.com/room/bashscripting" >https://tryhackme.com/room/bashscripting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>Regular Expressions（正则表达式基础） - <a class="link"   href="https://tryhackme.com/room/catregex" >https://tryhackme.com/room/catregex <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals 1(Windows基础知识1)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%201(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals1xbx" >https://tryhackme.com/room/windowsfundamentals1xbx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是Windows 基础模块的第 1 部分，我们将了解 Windows 桌面、NTFS 文件系统、UAC、控制面板等Windows基础组件。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Windows操作系统(OS)是一个复杂的产品，有许多系统文件、实用程序、设置、功能等。</p>
<p>本文将尝试对Windows操作系统作一般概述，比如浏览用户界面，对系统进行更改等。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过<a class="link"   href="https://www.cyberark.com/resources/threat-research-blog/explain-like-i-m-5-remote-desktop-protocol-rdp" >远程桌面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>访问Windows虚拟机，请使用以下凭据：</p>
<ul>
<li><p>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</p>
</li>
<li><p>User: <code>administrator</code></p>
</li>
<li><p>Password: <code>letmein123!</code></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331090333532.png"
                      alt="image-20230331090333532"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="Windows版本"><a href="#Windows版本" class="headerlink" title="Windows版本"></a>Windows版本</h2><p>Windows操作系统有很长的历史，可以追溯到1985年，目前，它是家庭和公司网络的主要操作系统。正因为如此，Windows操作系统一直是黑客和恶意软件作者的目标。</p>
<p>Windows XP是Windows的一个流行版本，运行时间很长；微软还发布过Windows Vista，Vista是对Windows操作系统的一次彻底改造。Windows Vista存在很多问题，因此它在Windows用户中反响不佳，并很快就被淘汰了。</p>
<p>当微软(Microsoft)宣布Windows XP寿终待寝时，许多用户都陷入了恐慌。企业、医院等组织争先恐后地在许多其他硬件和设备上测试下一个可行的Windows版本，即Windows 7；厂商们不得不争分夺秒地工作，以确保他们的产品与Windows 7能够兼容，如果他们做不到，他们的客户就不得不撕毁协议，并寻找另一家可升级他们的产品以兼容Windows 7的供应商。</p>
<p>Windows 7虽然很快就发布了，但它也被标记上了终止支持的日期，然后是Windows 8.x，8.x出现时间很短暂，就像Vista一样。</p>
<p>后面出现了Windows 10，这是目前普遍用于台式电脑的Windows操作系统版本。Windows 10有两种版本，家庭版和专业版，<a class="link"   href="https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro" >家庭版和专业版存在一些区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：尽管我们没有谈论服务器，但也有可用于服务器的Windows操作系统，比如<a class="link"   href="https://www.microsoft.com/en-us/windows-server" >Windows Server 2022 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>许多批评人士喜欢抨击微软，但微软每一个新版本的Windows操作系统的可用性和安全性方面都取得了长足进步。</p>
<p>注：本文所探索的Windows虚拟机的操作系统版本为“Windows Server 2019 Standard”，详见此Windows虚拟机中的“系统信息”界面。</p>
<p>截至2021年6月，微软宣布了<a class="link"   href="https://docs.microsoft.com/en-us/lifecycle/products/windows-10-home-and-pro?ranMID=24542&ranEAID=kXQk6*ivFEQ&ranSiteID=kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA&epi=kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA&irgwc=1&OCID=AID2000142_aff_7593_1243925&tduid=(ir__uszrgcddyskfqz3fkk0sohz3wv2xuurc01kgzkod00)(7593)(1243925)(kXQk6.ivFEQ-M28j3qbUhtM2JFCT2wmhOA)()&irclickid=_uszrgcddyskfqz3fkk0sohz3wv2xuurc01kgzkod00&ranMID=24542&ranEAID=kXQk6*ivFEQ&ranSiteID=kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw&epi=kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw&irgwc=1&OCID=AID2000142_aff_7593_1243925&tduid=(ir__feexvhocigkfqna9kk0sohznb32xutanagupypus00)(7593)(1243925)(kXQk6.ivFEQ-4cKUPfbv9lM_IR2EX7K_hw)()&irclickid=_feexvhocigkfqna9kk0sohznb32xutanagupypus00" >Windows 10的退休日期 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：“微软将继续支持至少一个Windows 10版本，直到2025年10月14日。”</p>
<p>截至2021年10月5日，Windows 11已经成为终端用户可用的Windows操作系统。</p>
<p>访问以下链接，可阅读更多关于Windows 11的信息：<a class="link"   href="https://www.microsoft.com/en-us/windows?wa=wsignin1.0" >https://www.microsoft.com/en-us/windows?wa=wsignin1.0 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p>阅读以下链接，查看Windows 10家庭版和专业版的区别：</p>
<p><a class="link"   href="https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro" >https://www.microsoft.com/en-us/windows/compare-windows-10-home-vs-pro <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331100052164.png"
                      alt="image-20230331100052164"
                ></p>
<blockquote>
<p>答案：BitLocker</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331095806462.png"
                      alt="image-20230331095806462"
                ></p>
<h2 id="桌面（图形用户界面）"><a href="#桌面（图形用户界面）" class="headerlink" title="桌面（图形用户界面）"></a>桌面（图形用户界面）</h2><p>Windows 桌面，简称Windows图形用户界面(GUI)，是你登录 Windows 计算机后能看到并使用的主屏幕界面。</p>
<p>通常情况下，你需要先通过登录界面完成系统登录，然后才能看到Windows桌面。在登录界面上，你需要输入有效的帐户名称和登录凭据，这通常是该特定系统使用者的用户名和密码或者是Active Directory环境(如果是加入域的机器)中先前存在的Windows帐户的用户名和密码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331100826045.png"
                      alt="image-20230331100826045"
                ></p>
<p>上面的截图就是一个典型的Windows Desktop的例子，以下是组成上述GUI的一些组件名称：</p>
<ol>
<li>The Desktop（主桌面）</li>
<li>Start Menu（开始菜单）</li>
<li>Search Box (搜索框-Cortana)</li>
<li>Task View（任务视图）</li>
<li>Taskbar（任务栏）</li>
<li>Toolbars（工具栏）</li>
<li>Notification Area（通知区域）</li>
</ol>
<p><strong>The Desktop（主桌面）</strong></p>
<p>桌面是你可以快捷进入程序、文件夹、文件等的地方。计算机程序和文件的图标要么按照字母顺序排列在文件夹中，要么随机分散在桌面上，并没有特定的组织；但是，放在文件夹中的程序通常也可以通过桌面上的对应快捷方式被用户快速访问。</p>
<p>桌面的外观和风格可以根据用户的喜好自行进行更改。你可以右键单击桌面上的任何位置，然后就能出现一个上下文菜单，此菜单将允许你更改桌面图标的大小、指定图标的排列方式，并且还能允许你将项目复制&#x2F;粘贴到桌面，以及在桌面上创建新项目(如创建文件夹、快捷方式或文本文档)等等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183522221.png"
                      alt="image-20230331183522221"
                ></p>
<p>通过“显示设置-Display settings”功能，你还可以更改屏幕的分辨率和屏幕方向，如果你有多个电脑屏幕，你可以在这里对多屏幕设置进行配置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183648774.png"
                      alt="image-20230331183648774"
                ></p>
<p><em>注意:在远程桌面会话中，某些显示设置将被禁用。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184113446.png"
                      alt="image-20230331184113446"
                ></p>
<p>你也可以通过选择“个性化-Personalize”来更改壁纸。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331183829228.png"
                      alt="image-20230331183829228"
                ></p>
<p>通过“个性化-Personalize”功能，你可以更改桌面的背景图像，以及更改字体、主题、配色方案等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184043358.png"
                      alt="image-20230331184043358"
                ></p>
<p><strong>The Start Menu（开始菜单）</strong></p>
<p>在之前的Windows版本中，桌面GUI的左下角还可以看到“开始-Start ”一词；但是，在Windows 10等现代版本的操作系统中，“开始-Start ”一词不再出现，取而代之的是一个Windows Logo。尽管开始菜单的外观发生了变化，但其总体功能还是和以前一样的。</p>
<p>“开始菜单”为计算机用户提供了对所有最有用的程序、文件、实用工具等的访问，当你点击Windows logo之后，开始菜单就会打开，它将由三个部分共同组成。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331184759638.png"
                      alt="image-20230331184759638"
                ></p>
<p>**1.**“开始菜单”的第一个部分(Start Menu从左到右的第一个区域)为你对帐户或登录会话的可执行操作提供了快速快捷方式，例如更改用户帐户、锁定屏幕或注销帐户，其他特定于你的帐户的快捷方式还有“文档”文件夹(文档图标)和“图片”文件夹(图片图标)，最后，点击齿轮图标将允许你进入设置屏幕界面，点击电源图标将允许你关闭计算机、重新启动计算机或者断开远程桌面会话(如果存在远程桌面会话)。</p>
<p>如下图所示，你可以看到多个附加了功能的图标，如果你要展开此部分的更多内容，请单击顶部的图标：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331190016903.png"
                      alt="image-20230331190016903"
                ></p>
<p>**2.**“开始菜单”的第二个部分(Start Menu从左到右的第二个区域)将在顶部显示所有最近添加的程序和所有已安装的程序(可配置为出现在开始菜单中)，在此部分中，应用程序&#x2F;程序将会按字母顺序被列出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331190757774.png"
                      alt="image-20230331190757774"
                ></p>
<p>如上图所示，第一个框是最近添加的应用程序&#x2F;程序将出现的地方，第二个框将显示所有已安装的应用程序&#x2F;程序 并且按字母排列。</p>
<p>如果你有一个很长的已安装程序列表，你可以点击字母网格中的字母标题，从而实现跳转到已安装程序列表中的特定部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331191141034.png"
                      alt="image-20230331191141034"
                ></p>
<p><em>注意：上图中的白色字母与已安装程序的字母标题相匹配。</em></p>
<p>**3.**“开始菜单”的第三个部分(Start Menu从左到右的第三个区域)，也就是开始菜单的右侧，此区域是你可以找到特定应用程序&#x2F;程序或者实用程序的图标的地方；这些图标被称为磁贴，一些磁贴在默认情况下会被添加到此区域。</p>
<p>右键单击任何一个磁贴，都会出现一个菜单，这个菜单可以允许你对所选磁贴执行更多操作：例如调整平铺大小，从开始菜单中取消固定，查看其属性等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331192202260.png"
                      alt="image-20230331192202260"
                ></p>
<p>在前述的“开始菜单”第二个区域中的应用程序&#x2F;程序，都可以通过右键单击并选择“Pin to Start”以形成新的磁贴，而这些新的磁贴会出现在“开始菜单”的第三个区域中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331192854403.png"
                      alt="image-20230331192854403"
                ></p>
<p><strong>The Taskbar（任务栏）</strong></p>
<p>在任务栏中(任务栏一般在桌面GUI的底部)，某些组件是默认启用且可见的，例如，下图中的工具栏（Toolbars）就是为了演示目的而启用的。</p>
<p>如果你想要禁用一些任务栏可用组件，你可以右键单击任务栏，这将弹出一个上下文菜单以允许你进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331193428534.png"
                      alt="image-20230331193428534"
                ></p>
<p>所有你已经打开或者启动的任何应用程序&#x2F;程序、文件夹、文件等都会出现在任务栏中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331194347701.png"
                      alt="image-20230331194347701"
                ></p>
<p>当你将鼠标悬停在任务栏中的应用程序图标上时，这将提供关于此应用程序的预览运行缩略图以及提示信息，这个提示信息是有用的，如果你打开了很多不同的或者相同的应用&#x2F;程序，如多个谷歌Chrome浏览器界面，你可能会希望找到一个你想要的谷歌Chrome实例，此时你就可以根据提示信息来找到目标实例。</p>
<p>当你关闭应用程序时，相关的应用程序的图标将从任务栏中消失(除非你显式地将应用程序图标固定到任务栏)。</p>
<p><strong>The Notification Area（通知区域）</strong></p>
<p>通知区域通常位于Windows屏幕的右下方，它是显示日期和时间的地方。在通知区域中，你可能看到的其他图标还包括音量图标、网络&#x2F;无线图标、电池状态图标等等，你可以通过任务栏设置来添加或删除通知区域中的图标。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331195748338.png"
                      alt="image-20230331195748338"
                ></p>
<p>进入任务栏设置界面，然后向下滚动到通知区域部分即可进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331195842358.png"
                      alt="image-20230331195842358"
                ></p>
<p>下面是微软官方关于用户桌面GUI中的“开始菜单”和“通知区域”的简要文档。</p>
<ul>
<li><a class="link"   href="https://support.microsoft.com/en-us/windows/see-what-s-on-the-start-menu-a8ccb400-ad49-962b-d2b1-93f453785a13" >https://support.microsoft.com/en-us/windows/see-what-s-on-the-start-menu-a8ccb400-ad49-962b-d2b1-93f453785a13 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://support.microsoft.com/en-us/windows/customize-the-taskbar-notification-area-e159e8d2-9ac5-b2bd-61c5-bb63c1d437c3#WindowsVersion=Windows_10" >https://support.microsoft.com/en-us/windows/customize-the-taskbar-notification-area-e159e8d2-9ac5-b2bd-61c5-bb63c1d437c3#WindowsVersion=Windows_10 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p>tips：你可以右键单击任何文件夹、文件、应用程序&#x2F;程序的图标来查看更多信息或者对所单击的项目执行相关操作。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>问题1：哪个选项可以隐藏&#x2F;禁用搜索框？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220154338.png"
                      alt="image-20230331220154338"
                ></p>
<blockquote>
<p>答案1:Hidden</p>
</blockquote>
<p>问题2：哪个选项可以隐藏&#x2F;禁用任务视图按钮？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220607941.png"
                      alt="image-20230331220607941"
                ></p>
<blockquote>
<p>答案2：Show Task View button</p>
</blockquote>
<p>问题3：除了“时钟”和“网络”之外，通知区域中还有哪些其他图标可见？</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220953527.png"
                      alt="image-20230331220953527"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331221057862.png"
                      alt="image-20230331221057862"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331220827367.png"
                      alt="image-20230331220827367"
                ></p>
<blockquote>
<p>答案3：Action Center</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331200408557.png"
                      alt="image-20230331200408557"
                ></p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在现代版本的Windows中所使用的文件系统是“New Technology File System-新技术文件系统-NT文件系统”，可简称为<a class="link"   href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/ntfs-overview" >NTFS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>在NTFS之前，还有其他文件系统：比如 FAT16&#x2F;FAT32(File Allocation Table-文件分配表)和HPFS(High Performance File System-高性能文件系统)。</p>
<p>现在你仍然可以看到FAT分区的使用，例如，你通常可以在一些USB设备、MicroSD卡中看到FAT分区，但你通常不会在个人Windows电脑或Windows服务器上看到FAT分区。</p>
<p>NTFS也是一种日志文件系统(具有故障恢复能力的文件系统)，当出现故障时，NTFS文件系统可以根据日志文件中所存储的信息 自动修复磁盘上的文件夹&#x2F;文件（这个功能是FAT文件系统所不具备的）。</p>
<p>NTFS解决了以前的文件系统的许多限制，如：</p>
<ul>
<li>支持大于4GB的文件</li>
<li>能够对文件夹和文件设置特定的权限</li>
<li>能够对文件夹和文件进行压缩</li>
<li>支持加密(属于EFS-<a class="link"   href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-encryption" >Encryption File System <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>-加密文件系统)</li>
</ul>
<p>如果你正在运行Windows，你的Windows所安装使用的文件系统是什么?你可以查看操作系统的驱动器属性(右键单击)，通常是C驱动器(<code>C:\</code>)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331210623069.png"
                      alt="image-20230331210623069"
                ></p>
<p>关于文件系统的概述，你可以阅读 Microsoft <a class="link"   href="https://docs.microsoft.com/en-us/troubleshoot/windows-client/backup-and-storage/fat-hpfs-and-ntfs-file-systems" >关于 FAT、HPFS 和 NTFS 的官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>接下来，让我们简要谈谈 NTFS 特有的一些功能。</p>
<p>在 NTFS volumes(volumes–磁盘“卷标”)上，你可以设置授予访问或者拒绝访问文件、文件夹的权限，具体的权限有：</p>
<ul>
<li><strong>Read-读</strong></li>
<li><strong>Write-写</strong></li>
<li><strong>Read &amp; Execute-读、执行</strong></li>
<li><strong>List folder contents-列出文件夹内容</strong></li>
<li><strong>Modify-修改</strong></li>
<li><strong>Full control-完全控制</strong></li>
</ul>
<p>下图列出了每个权限的含义以及这些权限如何应用于文件和文件夹。 （出自<a class="link"   href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10)?redirectedfrom=MSDN" >微软官方文档-文件和文件夹权限 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331211513652.png"
                      alt="image-20230331211513652"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331211943792.png"
                      alt="image-20230331211943792"
                ></p>
<p>如何查看文件或文件夹的权限？</p>
<ol>
<li><p>右键单击要检查权限的文件或文件夹。</p>
</li>
<li><p>在弹出的上下文菜单中单击选择“属性”（<code>Properties</code>）。</p>
</li>
<li><p>在“属性”中，单击“安全”（<code>Security</code>）选项卡。</p>
</li>
<li><p>在组或用户名（<code>Group or user names</code>）列表中，选择要查看其权限的用户、计算机或组。</p>
</li>
</ol>
<p>在下图中，你可以看到 Windows 文件夹的用户(<code>Users</code>)组的权限。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331213944033.png"
                      alt="image-20230331213944033"
                ></p>
<p>NTFS 文件系统的另一个特性是备用数据流 (ADS-Alternate Data Streams)。</p>
<p>备用数据流(ADS)是特定于Windows NTFS(New Technology File System-新技术文件系统)的文件属性。</p>
<p>每个文件都至少有一个数据流(<code>$DATA</code>)，而ADS（备用数据流）将允许文件包含多个数据流。本机<a class="link"   href="https://support.microsoft.com/en-us/windows/what-s-changed-in-file-explorer-ef370130-1cca-9dc5-e0df-2f7416fe1cb1" >Windows文件资源管理器 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>并不会向用户显示ADS（备用数据流），你可以使用第三方可执行文件来查看ADS（备用数据流），或者你也可以选择使用<a class="link"   href="https://learn.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7.3&viewFallbackFrom=powershell-7.1" >Powershell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来查看文件的ADS（备用数据流）。</p>
<p>从安全的角度来看，恶意软件编写者会使用ADS来隐藏数据，但是这并非意味着所有的ADS使用都是恶意的；例如，当你从Internet(互联网)下载一个文件时，会向ADS写入标识符，以识别该文件确实是从Internet下载的。</p>
<p>要了解更多关于ADS的知识，请参考<a class="link"   href="https://www.malwarebytes.com/blog/news/2015/07/introduction-to-alternate-data-streams" >MalwareBytes所提供的相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331222543571.png"
                      alt="image-20230331222543571"
                ></p>
<h2 id="Windows-System32文件夹"><a href="#Windows-System32文件夹" class="headerlink" title="Windows\System32文件夹"></a>Windows\System32文件夹</h2><p>Windows文件夹(<code>C:\Windows</code>)通常被称为包含Windows操作系统的文件夹。</p>
<p>这个文件夹不一定要位于C盘，它可以驻留在任何其他磁盘驱动器中，在技术上还可以实现驻留在不同的文件夹中；这就是环境变量，更具体地说是系统环境变量能够发挥作用的地方，Windows文件夹(目录)的系统环境变量是<code>%windir%</code>。</p>
<p>根据<a class="link"   href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_environment_variables?view=powershell-7.1" >微软相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>：“环境变量存储着有关操作系统环境的信息，这些信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息。”</p>
<p>在“Windows”文件夹中有很多文件夹：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224546618.png"
                      alt="image-20230331224546618"
                ></p>
<p>其中一个文件夹是System32：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224616743.png"
                      alt="image-20230331224616743"
                ></p>
<p>System32文件夹中保存着一些对操作系统至关重要的文件，在与此文件夹交互时，你应该要非常谨慎，不小心删除System32中的任何文件或者文件夹都可能会导致Windows操作系统无法正常操作。</p>
<p>可参考资料：<a class="link"   href="https://www.howtogeek.com/346997/what-is-the-system32-directory-and-why-you-shouldnt-delete-it/" >https://www.howtogeek.com/346997/what-is-the-system32-directory-and-why-you-shouldnt-delete-it/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>注意：Windows基础所涉及的许多工具都位于System32文件夹中。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331224902472.png"
                      alt="image-20230331224902472"
                ></p>
<h2 id="用户帐户、配置文件和权限"><a href="#用户帐户、配置文件和权限" class="headerlink" title="用户帐户、配置文件和权限"></a>用户帐户、配置文件和权限</h2><p>在典型的本地Windows系统上，用户帐户可以是以下两种类型之一：管理员（Administrator）和标准用户（Standard User）。</p>
<p>用户帐户的类型将决定用户可以在特定的Windows系统上执行什么操作。</p>
<ul>
<li>管理员可以对系统进行更改，如添加用户、删除用户、修改组、修改系统设置等。</li>
<li>标准用户只能对归属于该用户的文件夹&#x2F;文件进行更改，不能执行系统级更改。</li>
</ul>
<p>假设你当前以管理员身份登录到Windows机器，你可以通过一些方法来确定当前系统上存在哪些用户帐户。</p>
<p>你可以单击<code>Start Menu</code>并输入<code>Other User</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331230819292.png"
                      alt="image-20230331230819292"
                ></p>
<p>如果你点击上图中的<code>Other Users</code>，则应该会出现一个设置窗口：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331230932138.png"
                      alt="image-20230331230932138"
                ></p>
<p>由于你现在是管理员，你将能够看到一个将其他人添加到此PC的选项（Add someone else to this PC）。</p>
<p><em>注意：标准用户将看不到此选项。</em></p>
<p>继续单击本地用户帐户，此时应该会出现更多选项：更改帐户类型和删除。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231440182.png"
                      alt="image-20230331231440182"
                ></p>
<p>单击上图中的Change account type，下拉框中的当前值即表示当前的帐户类型。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231216995.png"
                      alt="image-20230331231216995"
                ></p>
<p>当系统创建用户帐户时，将同时为该用户创建一个配置文件，每个用户配置文件的文件夹位置将落在<code>C:\Users</code>下；例如，用户帐号Max的用户配置文件所在的文件夹为<code>C:\Users\Max</code>。</p>
<p>用户配置文件的创建会在用户账户初次登录时完成。</p>
<p>当一个新用户帐户第一次登录到本地系统时，他将在登录屏幕上看到几条消息，其中一条消息User Profile Service会在登录屏幕上停留一段时间，这表示它正在创建相关的用户配置文件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331231928100.png"
                      alt="image-20230331231928100"
                ></p>
<p>一旦登录成功，用户将看到一个类似于下面的对话框，这表明配置文件正在创建中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331232138839.png"
                      alt="image-20230331232138839"
                ></p>
<p>每个用户配置文件都会有一些相同的文件夹，其中的一些是：</p>
<ul>
<li>Desktop</li>
<li>Documents</li>
<li>Downloads</li>
<li>Music</li>
<li>Pictures</li>
</ul>
<p>访问用户账户信息的另一种方法是使用本地用户和组管理界面（ Local User and Group Management）。</p>
<p>你可以右键单击“开始菜单- Start Menu”并单击Run，然后输入<code>lusrmgr.msc</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233204501.png"
                      alt="image-20230331233204501"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233318791.png"
                      alt="image-20230331233318791"
                ></p>
<p><em>注意：Run对话框可以允许我们快速打开项目。</em></p>
<p>使用Run对话框并访问<code>lusrmgr.msc</code>之后，我们就进入到了“本地用户和组管理”界面，在这个界面，你可以看到两个文件夹：Users和Groups。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331233829846.png"
                      alt="image-20230331233829846"
                ></p>
<p>如果单击Groups，你将看到所有本地组的名称以及每个组的简要描述。每个组都有其权限，计算机用户将由管理员分配&#x2F;添加到组中，当用户被分配到某个组时，该用户将会继承该组的权限，并且一个用户可以被分配给多个组。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331234311751.png"
                      alt="image-20230331234311751"
                ></p>
<p><em>注意：如果你从“其他用户-Other users”中单击“将其他人添加到此PC”，这将自动打开一个“本地用户和组管理”界面。</em></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>查看Other users账户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331235802326.png"
                      alt="image-20230331235802326"
                ></p>
<p>使用<code>win + r</code>打开Run对话框，然后输入<code>lusrmgr.msc</code>并点击确定，成功进入到“本地用户和组管理”界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000117411.png"
                      alt="image-20230401000117411"
                ></p>
<blockquote>
<p>Other users所对应的账户Name为：tryhackmebilly</p>
</blockquote>
<p>查看这个用户(tryhackmebilly)属于哪个组：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000445572.png"
                      alt="image-20230401000445572"
                ></p>
<blockquote>
<p>tryhackmebilly用户属于：Remote Desktop Users组和Users组。</p>
</blockquote>
<p>查看用于来宾用户访问的内置帐户：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401000749028.png"
                      alt="image-20230401000749028"
                ></p>
<blockquote>
<p>用于来宾用户访问的内置帐户是：Guest</p>
</blockquote>
<p>查看来宾用户帐户的帐户状态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401001211417.png"
                      alt="image-20230401001211417"
                ></p>
<blockquote>
<p>帐户状态为：Account is disabled</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331234547668.png"
                      alt="image-20230331234547668"
                ></p>
<h2 id="用户帐户控制"><a href="#用户帐户控制" class="headerlink" title="用户帐户控制"></a>用户帐户控制</h2><p>大多数家庭用户都以本地管理员身份登录到他们的 Windows 系统，而帐户类型为管理员的用户可以对系统进行任意更改。</p>
<p>计算机用户在执行某些操作时，其实并不需要系统为这些操作分配一个很高的权限，例如网上冲浪、处理 Word 文档等；这种提升的权限增加了系统被攻破的风险，也使得恶意软件更容易感染系统（因为这可能会使恶意软件在一个较高的权限下得到运行）。</p>
<p>为了保护本地用户的权限分配安全，Microsoft 引入了用户帐户控制机制(UAC-User Account Control)，这个概念最初是在<a class="link"   href="https://en.wikipedia.org/wiki/Windows_Vista" >Windows Vista <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>系统中引入的，并且在随后的 Windows 版本中也得到继续使用。</p>
<p>注意：UAC在默认情况下不适用于内置的本地管理员帐户。 </p>
<p>UAC是如何工作的？当具有管理员帐户类型的用户登录系统时，当前会话并不会以提升的权限运行(此时用户具有管理员权限，无需再提升)；当具有标准帐户类型的用户登录系统时，如果用户想要执行一些需要更高级别权限的操作时，UAC机制会提示用户是否允许执行 并可能需要我们输入管理员密码。 </p>
<p>我们可以查看当前所登录的帐户（假设为内置管理员帐户）上的程序信息——右键单击程序并查看其属性即可。</p>
<p>在程序属性的“安全-Security ”选项卡中，我们可以看到该程序所属的用户&#x2F;组以及它们对此程序文件的权限（从下图可知：标准用户没有被列出）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401081039434.png"
                      alt="image-20230401081039434"
                ></p>
<p>如果我们以标准用户登录并尝试运行上图中的程序，那么就会触发UAC机制。</p>
<p>注意：当我们以管理员帐户登录之后，可以通过lusrmgr.msc界面查看到标准用户的用户名和密码(知道用户名和密码之后，我们就能通过远程桌面进行登录)。</p>
<p>当我们作为标准用户登录时，上述可执行程序的默认图标上会有一个盾牌标志。程序上的盾牌标志代表该程序受UAC限制，当我们点击运行该程序时，会提示是否允许以更高级别的权限运行。（如果要继续运行该程序，就需要我们输入管理员密码）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401083931178.png"
                      alt="image-20230401083931178"
                ></p>
<p>双击上图中的程序，你将看到UAC提示（此时需要输入管理员帐户的密码，然后才能继续运行该程序）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401084355843.png"
                      alt="image-20230401084355843"
                ></p>
<p>一段时间无操作之后，上图中的UAC提示符就会消失，然后程序就不会运行。</p>
<p>UAC功能降低了恶意软件成功破坏系统的可能性，你可以阅读<a class="link"   href="https://learn.microsoft.com/en-us/windows/security/identity-protection/user-account-control/how-user-account-control-works" >微软官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>了解更多关于UAC的信息。</p>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读本小节内容即可回答以下问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401085221414.png"
                      alt="image-20230401085221414"
                ></p>
<h2 id="设置和控制面板"><a href="#设置和控制面板" class="headerlink" title="设置和控制面板"></a>设置和控制面板</h2><p>在Windows系统上，进行系统更改的主要位置是“设置菜单”和“控制面板”。</p>
<p>长期以来，“控制面板”一直是进行系统更改(如添加打印机、卸载程序等)的首选位置；而“设置菜单”是在Windows 8 版本中引入的，此版本是第一个适用于触摸屏平板电脑的Windows操作系统，而且“设置菜单”在Windows 10中也仍然可用。事实上，如果用户现在想要进行系统更改，“设置菜单”将会是用户所使用的主要位置。</p>
<p>“设置菜单”和“控制面板”既有相似之处，也有不同之处。</p>
<p><strong>设置菜单</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090019326.png"
                      alt="image-20230401090019326"
                ></p>
<p><strong>控制面板</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090327928.png"
                      alt="image-20230401090327928"
                ></p>
<p>注意：如果个人计算机设备上的Windows操作系统版本不同，那么“设置菜单”中的图标也可能不同。</p>
<p>设置菜单和控制面板都可以通过开始菜单进行访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090517708.png"
                      alt="image-20230401090517708"
                ></p>
<p>控制面板能够让你访问更复杂的设置和执行更复杂的操作。在某些情况下，当你使用“设置菜单”开始进行系统更改时，最后还是会进入到“控制面板”中的相关界面。</p>
<p>例如，你可以在“设置菜单”中单击“网络和Internet”，然后再单击“更改适配器选项”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401090924855.png"
                      alt="image-20230401090924855"
                ></p>
<p>然后你就会注意到：接下来所弹出的窗口来自于控制面板。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091210493.png"
                      alt="image-20230401091210493"
                ></p>
<p>如果你不清楚在更改设置时应该打开设置菜单还是控制面板，你可以使用开始菜单并进行搜索。</p>
<p>在下面的例子中，正在搜索的内容是“wallpaper”，并且最后得到的返回结果会很少。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091556674.png"
                      alt="image-20230401091556674"
                ></p>
<p>如果我们点击上图中的“最佳匹配”，将会出现一个“设置”菜单窗口，能够让我们对壁纸进行更改。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091737337.png"
                      alt="image-20230401091737337"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>进入到控制面板界面，将视图更改为小图标显示，查看最后一项设置名称：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401093612966.png"
                      alt="image-20230401093612966"
                ></p>
<blockquote>
<p>最后一项设置名称为：Windows Defender Firewall 。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401091808960.png"
                      alt="image-20230401091808960"
                ></p>
<h2 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h2><p>本文所涉及的最后一个主题是任务管理器。</p>
<p>任务管理器可以提供 有关当前在系统上运行的应用程序和进程的信息，任务管理器中还有一些其他信息也是可用的，比如正在使用多少CPU和RAM，这是属于系统性能的部分。</p>
<p>你可以通过右键单击任务栏来访问任务管理器。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092305061.png"
                      alt="image-20230401092305061"
                ></p>
<p>任务管理器界面将会以一个简单视图的形式打开，视图中可能并不会显示太多信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092416660.png"
                      alt="image-20230401092416660"
                ></p>
<p>我们可以单击上图中的<code>More details</code>，然后视图内容将会发生变化。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092538793.png"
                      alt="image-20230401092538793"
                ></p>
<p>有关任务管理器的更多内容，请参阅以下博客文章：</p>
<blockquote>
<p><a class="link"   href="https://www.howtogeek.com/405806/windows-task-manager-the-complete-guide/" >https://www.howtogeek.com/405806/windows-task-manager-the-complete-guide/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.howtogeek.com/66622/stupid-geek-tricks-6-ways-to-open-windows-task-manager/" >https://www.howtogeek.com/66622/stupid-geek-tricks-6-ways-to-open-windows-task-manager/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>答题</strong></p>
<p><em>tips：通过阅读上述链接相关的博客文章，可回答下面问题。</em></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401092709123.png"
                      alt="image-20230401092709123"
                ></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals 2(Windows基础知识2)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%202(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals2x0x" >https://tryhackme.com/room/windowsfundamentals2x0x <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是Windows 基础模块的第 2 部分，了解有关系统配置、UAC 设置、资源监控、Windows 注册表等更多信息。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Windows Fundamentals 1中，我们已经介绍了Windows的桌面、文件系统、用户帐户控制、控制面板、设置和任务管理器。 </p>
<p>本文将继续尝试概述 Windows 操作系统中可用的其他一些实用程序以及访问这些实用程序的不同方法。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过远程桌面访问虚拟机，请使用以下凭据：</p>
<ul>
<li>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</li>
<li>User: <code>administrator</code></li>
<li>Password: <code>letmein123!</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331102855386.png"
                      alt="image-20230331102855386"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="系统配置面板（-System-Configuration）"><a href="#系统配置面板（-System-Configuration）" class="headerlink" title="系统配置面板（ System Configuration）"></a>系统配置面板（ System Configuration）</h2><p>系统配置实用程序 (<code>MSConfig</code>)可用于高级故障排除，其主要目的是帮助诊断启动问题，系统配置面板可以帮助我们导航到其他 Windows 应用程序。</p>
<p>有关系统配置实用程序的更多信息，请参阅下面的文档。</p>
<blockquote>
<p><a class="link"   href="https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/system-configuration-utility-troubleshoot-configuration-errors" >https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/system-configuration-utility-troubleshoot-configuration-errors <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>有几种方法可以启动系统配置，其中一种方法是从开始菜单启动–在开始菜单处输入MSConfig即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401185721094.png"
                      alt="image-20230401185721094"
                ></p>
<p>注意:你需要本地管理员权限才能打开系统配置实用程序。</p>
<p>该实用程序顶部有五个选项卡，下面是每个选项卡的名称，在本小节中，我们将简要对每个选项卡进行介绍。</p>
<ul>
<li><p>General-常规</p>
</li>
<li><p>Boot-引导</p>
</li>
<li><p>Services-服务</p>
</li>
<li><p>Startup-启动</p>
</li>
<li><p>Tools-工具</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190049438.png"
                      alt="image-20230401190049438"
                ></p>
</li>
</ul>
<p>在General选项卡中，我们可以选择Windows启动时要加载的设备和服务，相关的选项包括:标准（Normal,）、诊断性（Diagnostic）以及选择性（Selective）。</p>
<p>在Boot选项卡中，我们可以为操作系统定义各种启动选项。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190444870.png"
                      alt="image-20230401190444870"
                ></p>
<p>在Services选项卡中，会列出系统中配置的所有服务，而不考虑其状态(运行或停止)，服务是指在后台运行的一种特殊类型的应用程序。Services选项卡允许我们启用或禁用出现在列表中的服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190621227.png"
                      alt="image-20230401190621227"
                ></p>
<p>Startup选项卡会将用户引导至任务管理器以管理启动项，下面是本地机器上MSConfig的Startup选项卡的截图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401190728279.png"
                      alt="image-20230401190728279"
                ></p>
<p>如上图所示，微软会建议你使用任务管理器(<code>taskmgr</code>)来管理(启用&#x2F;禁用)启动项，系统配置实用程序并不是一个启动管理程序。</p>
<p>在Tools选项卡中，有一个关于各种实用程序(工具)的列表，我们可以运行这些工具来进一步配置操作系统。Tools选项卡中的每个工具都有一个简短的描述，以让我们对工具用途有一些了解。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401191148145.png"
                      alt="image-20230401191148145"
                ></p>
<p>注意上图中的<code>Selected command</code>部分，此文本框中的信息将根据工具的不同而变化。</p>
<p>关于工具的运行：我们可以通过Run提示符使用命令运行工具，也可以通过命令提示符使用命令运行工具，或者可以通过单击上图中的<code>launch</code>按钮启动对应工具。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：将 Systems Internals 列为制造商的服务的名称是什么？</strong></em></p>
<p>导航到系统配置面板(<code>MSConfig</code>)的“服务”选项卡并单击“制造商-Manufacturer”，这将按服务制造商的字母顺序对服务进行排序，然后寻找由“Systems Internals”所制造的服务。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201614902.png"
                      alt="image-20230401201614902"
                ></p>
<blockquote>
<p>由Systems Internals所制造的服务名称为：PsShutdown</p>
</blockquote>
<p><em><strong>问题2：Windows 许可证注册给谁？</strong></em></p>
<p>导航到系统配置面板的“工具”选项卡并选择“关于 Windows”工具。</p>
<p>单击“启动”按钮启动该工具，你将看到有关操作系统的信息，包括了Windows许可证的注册对象。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201811501.png"
                      alt="image-20230401201811501"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401201840541.png"
                      alt="image-20230401201840541"
                ></p>
<blockquote>
<p>Windows许可证的注册对象是：Windows User</p>
</blockquote>
<p><em><strong>问题3：Windows 故障排除的命令是什么？</strong></em></p>
<p>在系统配置面板的“工具”选项卡中 选择Windows 故障排除工具，注意此时选项卡的“Selected command”部分，我们可以使用选项卡中对应的命令启动工具（在cmd或者Powershell中运行命令即可）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203319568.png"
                      alt="image-20230401203319568"
                ></p>
<blockquote>
<p>Windows 故障排除的命令是：C:\Windows\System32\control.exe &#x2F;name Microsoft.Troubleshooting</p>
</blockquote>
<p><em><strong>问题4：什么命令将打开控制面板？（答案是.exe的名字，并非全路径）</strong></em></p>
<p>虽然不是很明显，但是有多个工具的启动命令都引用了同一个exe 文件——系统属性以及Windows 故障排除，两者都使用了control.exe。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203904805.png"
                      alt="image-20230401203904805"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401203932302.png"
                      alt="image-20230401203932302"
                ></p>
<blockquote>
<p>打开控制面板的命令中将包含control.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401191632414.png"
                      alt="image-20230401191632414"
                ></p>
<h2 id="更改UAC设置"><a href="#更改UAC设置" class="headerlink" title="更改UAC设置"></a>更改UAC设置</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Change UAC Settings。</p>
<p>用户帐户控制(UAC-User Account Control) 机制和Windows中的权限分配有关，UAC能够在日常使用时 为具有管理员访问权限的用户帐户保持较低级别的权限，并能在实际需要管理员访问权限时临时提升权限级别。</p>
<p>UAC可以通过UAC设置进行更改，甚至能够完全关闭(不推荐完全关闭UAC)。</p>
<p>我们能够导航至MSConfig 系统配置实用程序中的“工具”选项卡，然后选择对应程序以更改 UAC 设置。</p>
<p>在UAC设置界面，你可以通过移动滑块来改变UAC提示的优先级（从总是提示到完全不提示）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401204502203.png"
                      alt="image-20230401204502203"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>单击MSConfig的“工具”选项卡中的“更改 UAC 设置”工具，查看“Selected command”部分。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401205525109.png"
                      alt="image-20230401205525109"
                ></p>
<blockquote>
<p>与启动UAC设置的命令 相关联的程序为：UserAccountControlSettings.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401204813864.png"
                      alt="image-20230401204813864"
                ></p>
<h2 id="计算机管理界面"><a href="#计算机管理界面" class="headerlink" title="计算机管理界面"></a>计算机管理界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Computer Management（<code>compmgmt</code>）。</p>
<p>计算机管理（<code>compmgmt</code>) 实用程序包含三个主要部分：系统工具(System Tools)、 存储(Storage)以及服务和应用程序(Services and Applications)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401205855916.png"
                      alt="image-20230401205855916"
                ></p>
<p><strong>System Tools（系统工具）</strong></p>
<p>系统工具菜单由六部分组成：<em><strong>Task Scheduler、Event Viewer、Shared Folders、Local Users and Groups、Performance、Device Manager</strong></em>。</p>
<p>让我们首先从任务调度器(<em><strong>Task Scheduler</strong></em>)开始，根据微软的说法：通过任务调度器，我们可以创建和管理 计算机在指定的时间自动执行的常见任务。</p>
<p>任务可以是运行应用程序、脚本等，并且任务可以被配置为在任何时间运行。比如计算机任务可以在用户登录或注销时运行，任务也可以被配置为按特定的时间表运行，例如，设置每五分钟运行一次指定的计算机任务。</p>
<p>如果你要创建一个基本任务，可以单击“操作-Actions”(计算机管理页面的右侧窗格)下的“创建基本任务-Create Basic Task”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401211603366.png"
                      alt="image-20230401211603366"
                ></p>
<p>接下来的系统工具是事件查看器（<em><strong>Event Viewer</strong></em>）。</p>
<p>事件查看器允许我们查看计算机上发生的事件，这些事件的记录可以被看作是一种审计跟踪，能够用来了解计算机系统的活动；这些事件信息通常可用于诊断问题以及调查系统上已执行的操作。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225150680.png"
                      alt="image-20230401225150680"
                ></p>
<p>事件查看器有三个窗格。</p>
<ol>
<li>左边的窗格显示了一个关于事件日志提供程序的分层树列表。(如上图所示)</li>
<li>中间的窗格将显示一个总体概述和特定于选定提供者的事件摘要。</li>
<li>右边的窗格是一个操作（Action）界面。</li>
</ol>
<p>可以记录的事件有五种类型，下面是来自<a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/eventlog/event-types" >docs.microsoft.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的一个表格，提供了对每种事件类型的简要描述。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401212813748.png"
                      alt="image-20230401212813748"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402103926626.png"
                      alt="image-20230402103926626"
                ></p>
<p>事件日志能够在 Windows logs下可见，下面是来自于<a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/eventlog/eventlog-key" >微软官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的一个表格，它提供了对标准日志和自定义日志的简要描述。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401213048340.png"
                      alt="image-20230401213048340"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402104244808.png"
                      alt="image-20230402104244808"
                ></p>
<p>接下来的系统工具是共享文件夹（<em><strong>Shared Folders</strong></em>），在此系统工具中——你将看到其他人可以连接到的共享和共享文件夹的完整列表。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401224757803.png"
                      alt="image-20230401224757803"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401213444809.png"
                      alt="image-20230401213444809"
                ></p>
<p>上图是打开Shares文件夹之后所看到的共享列表，此列表会显示 Windows 的默认共享<code>C$</code>和 Windows 所创建的默认远程管理共享，如<code>ADMIN$</code>。</p>
<p>与Windows中的任何对象一样，你可以右键单击共享文件夹以查看其属性，例如权限属性(谁可以访问共享资源)。</p>
<p>在Sessions文件夹下，你将看到当前连接到“共享”的用户列表（为空）；而正在连接共享的用户可访问的文件夹和文件将在“Open Files”下被列出。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225023683.png"
                      alt="image-20230401225023683"
                ></p>
<p>接下来的系统工具是本地用户和组（<em><strong>Local Users and Groups</strong></em>），我们可通过在Run提示符下输入<code>lusrmgr.msc</code>打开本地用户和组界面（在之前的文章中已有介绍，此处不再赘述）。</p>
<p>接下来的系统工具是性能（<em><strong>Performance</strong></em>），你将看到一个名为Performance Monitor (<code>perfmon</code>)的实用程序。</p>
<p>Perfmon（即性能监视器）可用于实时或者从日志文件中查看性能数据，此实用程序可用于排除计算机系统(本地或远程)上的性能问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401220426705.png"
                      alt="image-20230401220426705"
                ></p>
<p>我们最后要介绍的系统工具是 设备管理器（<em><strong>Device Manager</strong></em>），它允许我们查看和配置硬件，例如允许我们禁用任何连接到计算机的硬件。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225612103.png"
                      alt="image-20230401225612103"
                ></p>
<p><strong>Storage（存储）</strong> </p>
<p>在“存储”菜单下的是“Windows服务器备份”和“磁盘管理”，在这里，我们只讨论“磁盘管理”部分。</p>
<p>注意：由于本文相关实验所使用的虚拟机是 Windows Server，所以会有一些在Windows 10系统中通常看不到的实用程序。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401220930240.png"
                      alt="image-20230401220930240"
                ></p>
<p>磁盘管理是Windows中的一个系统实用程序，它使你能够执行高级存储任务，这些任务包括：</p>
<ul>
<li>Set up a new drive——建立一个新的驱动器；</li>
<li>Extend a partition——扩展分区；</li>
<li>Shrink a partition——缩小分区；</li>
<li>Assign or change a drive letter (ex. E:) ——分配或更改驱动器盘符(例如E:)</li>
</ul>
<p><strong>Services and Applications（服务和应用程序）</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401221421693.png"
                      alt="image-20230401221421693"
                ></p>
<p>如上图所示，计算机管理页面的“服务和应用程序”菜单列表将包含“路由和远程访问”、“服务”和“WMI控制”三部分。</p>
<p>“服务”是在后台运行的一种特殊类型的应用程序，通过计算机管理页面的“服务和应用程序”菜单，你不仅可以启用和禁用服务，还可以查看服务的Properties（属性）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401221511583.png"
                      alt="image-20230401221511583"
                ></p>
<p>此外，“服务和应用程序”菜单中的“WMI Control”将用于配置和控制WMI服务。</p>
<p><em>tips：WMI是指Windows管理工具，它的全称为——Windows Management Instrumentation。</em></p>
<p>根据维基百科的说法：“WMI允许脚本语言(如VBScript或Windows PowerShell)在本地和远程 对Microsoft Windows个人电脑与服务器进行管理，微软还为WMI提供了一个命令行接口，被称为Windows管理工具命令行(WMIC：Windows Management Instrumentation Command-line)。”</p>
<p>注意：WMIC工具在Windows 10 21H1版本中已弃用，Windows PowerShell取代了WMI服务。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：打开计算机管理界面的命令是什么？（使用.msc 文件名称作答即可）</strong></em></p>
<p>单击 MSConfig 的“工具”选项卡中的“计算机管理”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225315207.png"
                      alt="image-20230401225315207"
                ></p>
<blockquote>
<p>答案1：compmgmt.msc</p>
</blockquote>
<p><em><strong>问题2：GoogleUpdateTaskMachineUA 任务配置为每天什么时间运行？</strong></em></p>
<p>通过系统配置面板启动“计算机管理”工具并导航到“任务调度器”，在计划任务列表中，你可以看到“GoogleUpdateTaskMachineUA”任务，和此任务关联的运行时间可以在“触发器-Triggers”栏目下找到。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225451929.png"
                      alt="image-20230401225451929"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225532208.png"
                      alt="image-20230401225532208"
                ></p>
<blockquote>
<p>答案2：6:15 AM</p>
</blockquote>
<p><em><strong>问题3：共享的隐藏文件夹的名称是什么？</strong></em></p>
<p>通过系统配置面板启动“计算机管理”工具并导航到系统工具下的“共享文件夹”部分，打开包含共享列表的Shares文件夹：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401225743498.png"
                      alt="image-20230401225743498"
                ></p>
<blockquote>
<p>答案3：sh4r3dF0Ld3r</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401222619478.png"
                      alt="image-20230401222619478"
                ></p>
<h2 id="系统信息界面"><a href="#系统信息界面" class="headerlink" title="系统信息界面"></a>系统信息界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具—— System Information（<code>msinfo32</code>）。</p>
<p><strong>什么是系统信息( <code>msinfo32</code>) 工具？</strong></p>
<p>根据 Microsoft 的说法，“ Windows 包含一个名为Microsoft System Information (Msinfo32.exe) 的工具，此工具可收集有关你的计算机的信息并显示计算机硬件、系统组件和软件环境的综合视图，你可以使用它来诊断计算机问题。”</p>
<p>系统信息工具的主窗口是系统摘要（System Summary），它提供了很多关于操作系统、系统、处理器、BIOS、内存等的信息。</p>
<p>系统摘要(System Summary)中的信息分为以下三部分：</p>
<ul>
<li>硬件资源：有关系统硬件的高级信息；</li>
<li>组件：有关计算机上安装的不同设备的信息，如存储、显示器、键盘、鼠标、打印机等；</li>
<li>软件环境：提供有关系统上安装的软件的详细信息，包括驱动程序、服务、任务和启动程序等，还有一个被称为环境变量的部分，环境变量用于存储有关操作系统的详细信息。</li>
</ul>
<p>系统摘要(System Summary)将显示计算机所使用的一般技术规格，例如计算机的处理器品牌和型号等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401233204758.png"
                      alt="image-20230401233204758"
                ></p>
<p>“硬件资源”中显示的信息不适用于普通计算机用户，如果你想了解更多关于此部分的信息，请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/hardware-resources#:~:text=Hardware%20resources%20are%20the%20assignable,of%20bus%2Drelative%20memory%20addresses." >Microsoft官方页面 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401234718952.png"
                      alt="image-20230401234718952"
                ></p>
<p>在“组件”下，你可以看到有关计算机上安装的硬件设备的特定信息（此处存在部分信息不会显示）。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401234913754.png"
                      alt="image-20230401234913754"
                ></p>
<p>在Software Environment部分中，你可以看到有关嵌入到操作系统中的软件(如：驱动程序)和已安装软件的信息，在此处还可以看到其他详细信息，例如环境变量和网络连接等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230401235447963.png"
                      alt="image-20230401235447963"
                ></p>
<p>根据微软的说法，“环境变量存储着有关操作系统环境的信息，这些信息包括操作系统路径、操作系统使用的处理器数量以及临时文件夹的位置等详细信息。具体而言：环境变量存储着操作系统和其他程序所使用的数据，例如，WINDIR环境变量（<code>%windir%</code>）所包含的是Windows安装目录的位置，程序可以通过查询这个变量的值来确定Windows操作系统文件的位置。”</p>
<p>单击Environment Variables即可查看已经为计算机分配好的环境变量值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402000123298.png"
                      alt="image-20230402000123298"
                ></p>
<p>可用于查看环境变量的方法还包括：</p>
<ol>
<li>Control Panel &gt; System and Security &gt; System &gt; Advanced system settings &gt; Environment Variables</li>
<li>Settings &gt; System &gt; About &gt; system info &gt; Advanced system settings &gt; Environment Variables</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402000305026.png"
                      alt="image-20230402000305026"
                ></p>
<p>在系统信息实用程序（<code>msinfo32</code>）的最底部，还有一个搜索栏可以帮助我们快速定位，例如：我们可以选择“组件”并搜索“<code>IP address</code>”。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402001026708.png"
                      alt="image-20230402001026708"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：打开系统信息的命令是什么？（以相关的exe文件名称作答即可）</strong></em></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“系统信息”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402002650839.png"
                      alt="image-20230402002650839"
                ></p>
<blockquote>
<p>答案1：msinfo32.exe</p>
</blockquote>
<p><em><strong>问题2：系统名称下列出的是什么？</strong></em></p>
<p>导航到MSConfig面板的工具选项卡并启动“系统信息”工具，然后选择“系统摘要”并查看“系统名称”条目。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402002833201.png"
                      alt="image-20230402002833201"
                ></p>
<blockquote>
<p>答案2：THM-WINFUN2</p>
</blockquote>
<p><em><strong>问题3：ComSpec的环境变量值是多少？</strong></em></p>
<p>我们导航到MSConfig面板的工具选项卡并启动“系统信息”工具，然后展开“软件环境”菜单并查看“环境变量”页面，以找到ComSpec条目和相应的变量值。</p>
<p>ComSpec 环境变量将指向命令行解释器，即 cmd.exe。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003006483.png"
                      alt="image-20230402003006483"
                ></p>
<blockquote>
<p>答案3：%SystemRoot%\system32\cmd.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402001112874.png"
                      alt="image-20230402001112874"
                ></p>
<h2 id="资源监视器"><a href="#资源监视器" class="headerlink" title="资源监视器"></a>资源监视器</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Resource Monitor（<code>resmon</code>）。</p>
<p><strong>什么是资源监视器( <code>resmon</code>)？</strong></p>
<p>根据Microsoft的说法：“资源监视器用于显示每个进程和聚合 CPU、内存、磁盘、网络的使用信息，此外它还提供有关哪些进程正在使用单个文件句柄和模块的详细信息；它的高级过滤功能将允许用户隔离与一个或多个进程(应用程序或服务)相关的数据，并能启动、停止、暂停和恢复服务，以及从用户界面关闭无响应的应用程序；它还包括一个进程分析功能，可以帮助识别死锁进程和文件锁定冲突，以便用户可以尝试解决冲突，而不是直接关闭应用程序并遭受丢失数据的风险。 ”</p>
<p>正如本文所提到的其他一些工具一样，资源监视器实用程序主要面向——那些需要在计算机系统上执行高级故障排除的用户。</p>
<p>在概述(Overview)选项卡中，Resmon 有四个部分：</p>
<ul>
<li>CPU-中央处理器</li>
<li>Disk-磁盘</li>
<li>Network-网络</li>
<li>Memory-内存</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003146897.png"
                      alt="image-20230402003146897"
                ></p>
<p>上图中的四个部分在资源监视器界面的顶部 也有相应的选项卡。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003326346.png"
                      alt="image-20230402003326346"
                ></p>
<p>请注意，上图每个选项卡都有各自的附加信息，四个选项卡的具体图像信息如下所示。 </p>
<p><strong>中央处理器</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003355546.png"
                      alt="image-20230402003355546"
                ></p>
<p><strong>内存</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003410757.png"
                      alt="image-20230402003410757"
                ></p>
<p><strong>磁盘</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003427038.png"
                      alt="image-20230402003427038"
                ></p>
<p><strong>网络</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402003441094.png"
                      alt="image-20230402003441094"
                ></p>
<p>资源监视器界面的最右侧还有窗格区域：当你查看概述选项卡时，窗格区域会实时显示和以上四个部分相关的图形视图；当你查看单个选项卡时，窗格区域则会实时显示和选项卡类型对应的图形视图。 </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085550790.png"
                      alt="image-20230402085550790"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085443134.png"
                      alt="image-20230402085443134"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><strong>问题：打开资源监视器的命令是什么？（以相关的exe文件名称作答即可）</strong></p>
<p>导航到MSConfig面板的工具选项卡并找到“资源监视器”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402004626723.png"
                      alt="image-20230402004626723"
                ></p>
<blockquote>
<p>答案：resmon.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402004955219.png"
                      alt="image-20230402004955219"
                ></p>
<h2 id="命令提示符界面"><a href="#命令提示符界面" class="headerlink" title="命令提示符界面"></a>命令提示符界面</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Command Prompt（<code>cmd</code>）。</p>
<p>命令提示符(<code>cmd</code>)一开始似乎令人生畏，但一旦你了解如何与它进行交互，你就会发现它没有那么难理解。</p>
<p>在早期的操作系统中，命令行是与操作系统交互的唯一方式，随着GUI(图形用户界面)被引入，用户就能够使用GUI并点击一些按钮来执行复杂的计算机任务，用户也不再局限于 只能使用命令提示符来与操作系统发生交互。</p>
<p>即使现在GUI是与操作系统进行交互的主要方式，但是计算机用户仍然可以通过命令提示符和操作系统发生交互。</p>
<p>在本小节中，我们将只讨论计算机用户可以在命令提示符中运行以获取有关计算机系统的信息的几个简单命令。</p>
<p>让我们从一些简单的命令开始，比如<code>hostname</code>和<code>whoami</code>。</p>
<p>命令<code>hostname</code>将输出计算机名。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085935253.png"
                      alt="image-20230402085935253"
                ></p>
<p>命令<code>whoami</code>将输出登录用户的名称。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090001407.png"
                      alt="image-20230402090001407"
                ></p>
<p>接下来，让我们看看在故障排除时有用的一些命令。</p>
<p>经常使用的命令是<code>ipconfig</code>，这个命令将显示计算机的网络地址设置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090043093.png"
                      alt="image-20230402090043093"
                ></p>
<p>每个命令都有一个帮助手册，用于解释正确执行命令所需的语法，以及可添加到命令中以扩展其执行的任何其他参数。</p>
<p>检索命令帮助手册的命令是<code>/?</code></p>
<p>例如，如果要查看<code>ipconfig</code>的帮助手册，可以使用如下命令：<code>ipconfig /?</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090216859.png"
                      alt="image-20230402090216859"
                ></p>
<p>注意：清除命令提示符界面的命令为<code>cls</code>。</p>
<p>下一个命令是<code>netstat</code>，根据帮助手册，此命令将显示协议统计信息和当前TCP&#x2F;IP网络连接信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090331950.png"
                      alt="image-20230402090331950"
                ></p>
<p>上图中的红框部分向我们展示了<code>netstat</code>命令的示例语法，此语法结构告诉我们<code>netstat</code>命令可以单独运行，也可以带参数运行，例如<code>-a</code>、<code>-b</code>、<code>-e</code>等。</p>
<p>当任何参数附加到根命令(本例中为<code>netstat</code>)时，对应的命令输出也将发生变化。</p>
<p>接下来我们介绍<code>net</code>命令，此命令主要用于管理网络资源，<code>net</code>命令支持子命令。</p>
<p>如果输入<code>net</code>而不带子命令，则输出结果将显示根命令的语法，并会显示一些你可以使用的子命令。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090824244.png"
                      alt="image-20230402090824244"
                ></p>
<p>对于<code>net</code>命令，显示帮助手册<code>/?</code>不会起作用，在这种情况下，我们需要使用不同的语法以查看帮助信息，即<code>net help</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402090931154.png"
                      alt="image-20230402090931154"
                ></p>
<p>如果你希望查看<code>net user</code>的帮助信息，则相关的命令为<code>net help user</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402091028314.png"
                      alt="image-20230402091028314"
                ></p>
<p>你可以使用类似的命令查看其他有用的<code>net</code>子命令的帮助信息，例如<code>localgroup</code>、<code>use</code>、<code>share</code>和<code>session</code>。</p>
<p>请参考下面的链接，以查看你可以在命令提示符中执行的命令的相关列表： <a class="link"   href="https://ss64.com/nt/" >https://ss64.com/nt/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><em><strong>问题1：在系统配置中，Internet 协议配置的完整命令是什么？</strong></em></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“Internet 协议配置”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402092105770.png"
                      alt="image-20230402092105770"
                ></p>
<blockquote>
<p>答案1：C:\Windows\System32\cmd.exe &#x2F;k %windir%\system32\ipconfig.exe</p>
</blockquote>
<p><em><strong>问题2：对于 ipconfig 命令，如何显示其详细信息？</strong></em></p>
<p>启动cmd工具，并输入<code>ipconfig /?</code>命令以查看相关的帮助信息：</p>
<p>tips：ipconfig 命令将显示计算机的网络地址设置。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402094749041.png"
                      alt="image-20230402094749041"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402094951203.png"
                      alt="image-20230402094951203"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402095102296.png"
                      alt="image-20230402095102296"
                ></p>
<blockquote>
<p>答案2：ipconfig &#x2F;all</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005656334.png"
                      alt="image-20230402005656334"
                ></p>
<h2 id="注册表编辑器"><a href="#注册表编辑器" class="headerlink" title="注册表编辑器"></a>注册表编辑器</h2><p>我们将继续探索可通过“系统配置”面板使用的工具——Registry Editor （<code>regedit</code>）。</p>
<p>Windows注册表是一个中央分层数据库，它用于存储配置系统所需的信息，这些信息适用于一个或多个用户、应用程序和硬件设备。</p>
<p>注册表包含 Windows 在运行期间不断引用的信息，例如：</p>
<ul>
<li>每个用户的配置文件。</li>
<li>计算机上安装的应用程序和每个应用程序可以创建的文档类型。</li>
<li>文件夹和应用程序图标的属性表设置。</li>
<li>系统上存在哪些硬件。</li>
<li>正在使用的端口。</li>
</ul>
<p>警告：注册表仅适用于高级计算机用户设置，随意更改注册表会影响正常的计算机操作。 </p>
<p>有多种方法可以查看&#x2F;编辑注册表。其中一种方法是使用注册表编辑器( <code>regedit</code>)。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005424423.png"
                      alt="image-20230402005424423"
                ></p>
<p>请参阅<a class="link"   href="https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users" >Microsoft相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解更多有关Windows注册表的信息。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p><strong>问题：打开注册表编辑器的命令是什么？（以相关的exe文件名称作答即可）</strong></p>
<p>导航到MSConfig面板的“工具”选项卡并找到“注册表编辑器”工具，查看“Selected command”部分即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402085801146.png"
                      alt="image-20230402085801146"
                ></p>
<blockquote>
<p>答案：regedt32.exe</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402005539209.png"
                      alt="image-20230402005539209"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>回顾：本文所介绍的主要内容是一些可以从Windows<code>MSConfig</code> 启动的工具。</p>
<p>在Window操作系统中，实用程序的命令和快捷方式是共享的，这意味着你不必启动<code>MSConfig</code>（系统配置）也可运行一些实用程序。</p>
<p>比如：你也可以直接从“开始菜单”界面运行其中一些实用程序：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331104050610.png"
                      alt="image-20230331104050610"
                ></p>
<p><code>MSConfig</code>中所列出的工具并未在本文中全部提及，你可以自行探索<code>MSConfig</code>中的其他工具。</p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
  <entry>
    <title>THM-Windows Fundamentals  3(Windows基础知识3)-学习</title>
    <url>/2024/01/27/THM-Windows%20Fundamentals%203(Windows%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%863)-%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>本文相关的TryHackMe实验房间链接：<a class="link"   href="https://tryhackme.com/room/windowsfundamentals3xzx" >https://tryhackme.com/room/windowsfundamentals3xzx <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>本文介绍：本文所涉及的内容是 Windows 基础模块的第 3 部分，了解有助于保护设备安全的内置 Microsoft 工具，例如 Windows 更新、Windows 安全、BitLocker等…</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Windows Fundamentals 1中，我们介绍了Windows的桌面、文件系统、用户帐户控制、控制面板、设置和任务管理器。 </p>
<p>在Windows Fundamentals 2中，我们介绍了Windows的各种实用程序，例如系统配置面板、计算机管理界面、资源监视器等。</p>
<p>本文将尝试概述 Windows 操作系统中的一些安全功能。</p>
<p>启动本文相关实验房间中所附加的Windows虚拟机（你可以直接在浏览器中访问），如果你希望通过远程桌面访问虚拟机，请使用以下凭据：</p>
<ul>
<li>Machine IP: <code>MACHINE_IP</code>（在实验房间中启动Windows虚拟机之后，你将获得一个相关的ip地址）</li>
<li>User: <code>administrator</code></li>
<li>Password: <code>letmein123!</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230331104939724.png"
                      alt="image-20230331104939724"
                ></p>
<p>当上述界面弹出提示时，点击接受证书，然后你现在应该可以登录到远程系统。</p>
<h2 id="Windows更新（-Windows-Update）"><a href="#Windows更新（-Windows-Update）" class="headerlink" title="Windows更新（ Windows Update）"></a>Windows更新（ Windows Update）</h2><p>让我们从Windows Update开始。</p>
<p>Windows Update是微软提供的一项服务，可为Windows操作系统和其他微软产品(如Microsoft Defender)提供安全更新、功能增强和补丁。</p>
<p>Windows 更新通常在每个月的第二个星期二发布，这一天被称为补丁星期二，但是这并不一定意味着一个关键的更新&#x2F;补丁必须等到下一个补丁星期二才会发布；如果某个更新补丁很重要，微软则将通过Windows更新服务向Windows设备推送更新。</p>
<p>Windows更新服务可通过“设置-Settings”面板找到并访问，更多相关信息可查看<a class="link"   href="https://msrc.microsoft.com/update-guide" >微软安全更新指南 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：另一种访问Windows更新服务的方法是使用Run对话框或者使用CMD界面，然后运行以下命令<code>control /name Microsoft.WindowsUpdate</code>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402112207713.png"
                      alt="image-20230402112207713"
                ></p>
<p>Windows更新设置是“受监管的”(通常情况下，家庭用户不会看到这种类型的消息)，如果计算机没有连接到Internet，则无法与Microsoft通信以获取最新的更新信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402112622623.png"
                      alt="image-20230402112622623"
                ></p>
<p>多年以来，Windows用户已经习惯于将Windows更新推迟到较晚的日期或者根本不安装更新，导致此类操作的原因有很多，其中一个原因是：Windows在更新之后通常需要重新启动。</p>
<p>微软在Windows 10中尝试解决了用户更新问题，现在的Windows更新不能再被忽视或完全不管不顾，也就是说Windows更新虽然能推迟，但最终还是会发生，更新完成之后你的电脑也会重新启动。微软通过提供此类强制更新服务来尽量保证设备的安全。</p>
<p>如下图所示，在Windows更新界面中可看到此时计算机需要重启，此更新界面还提供了关于安排重启的几个可用选项。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402113525741.png"
                      alt="image-20230402113525741"
                ></p>
<p>更多信息请参考<a class="link"   href="https://support.microsoft.com/en-us/windows/windows-update-faq-8a903416-6f45-0718-f5c7-375e92dddeb2" >Windows更新常见问题解答 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>通过“设置”面板访问Windows更新服务，在Windows更新界面点击“查看更新历史”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132839575.png"
                      alt="image-20230402132839575"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132937163.png"
                      alt="image-20230402132937163"
                ></p>
<blockquote>
<p>自定义更新的安装日期是：5&#x2F;3&#x2F;2021</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402113919880.png"
                      alt="image-20230402113919880"
                ></p>
<h2 id="Windows安全（Windows-Security）"><a href="#Windows安全（Windows-Security）" class="headerlink" title="Windows安全（Windows Security）"></a>Windows安全（Windows Security）</h2><p>根据微软的说法，“Windows Security是管理保护你的设备和数据的工具的主界面。”</p>
<p>和Windows更新服务一样，Windows安全服务也可以通过“设置-Settings”面板进行访问。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402132307179.png"
                      alt="image-20230402132307179"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402114542296.png"
                      alt="image-20230402114542296"
                ></p>
<p>请查看上图，并将注意力集中在<em><strong>Protection areas</strong></em>（保护区域），其中包括：</p>
<ul>
<li>Virus &amp; threat protection（病毒和威胁防护）</li>
<li>Firewall &amp; network protection（防火墙和网络保护）</li>
<li>App &amp; browser control（应用程序和浏览器控制）</li>
<li>Device security（设备安全）</li>
</ul>
<p>tips：在下面几个小节中我们会简要地介绍以上四部分内容（在本小节中我们不展开讲解）。</p>
<p>在继续介绍Windows安全服务之前，让我们快速了解一下状态图标：</p>
<ul>
<li>绿色图标：表示你的设备已得到充分保护，并且没有任何建议操作。</li>
<li>黄色图标：表示有安全建议供你查看。</li>
<li>红色图标：表示警告，即有某件事情需要你立即关注。</li>
</ul>
<p>我们点击“设置-Settings”界面中的“Windows Security”下的<code>Open Windows Security</code>，将看到如下界面（一个红色图标，三个绿色图标）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402115417123.png"
                      alt="image-20230402115417123"
                ></p>
<p>注意：由于本文所附的实验机是Windows Server 2019，因此相关页面看起来会与Windows 10家庭版或专业版不同。</p>
<p>下图是来自于Windows 10设备的Windows Security相关页面（点击<code>Open Windows Security</code>即可看到具体界面）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402115601501.png"
                      alt="image-20230402115601501"
                ></p>
<p>在下一小节，我们将继续查看Windows安全服务中的“病毒和威胁防护”部分。</p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>查看“Windows安全”界面，我们可以发现Virus &amp; threat protection（病毒和威胁防护）对应的图标是红色的——红色图标表示警告，所以需要我们立即关注。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135755579.png"
                      alt="image-20230402135755579"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402120607299.png"
                      alt="image-20230402120607299"
                ></p>
<h2 id="病毒和威胁防护（Virus-threat-protection）"><a href="#病毒和威胁防护（Virus-threat-protection）" class="headerlink" title="病毒和威胁防护（Virus &amp; threat protection）"></a>病毒和威胁防护（Virus &amp; threat protection）</h2><p>病毒和威胁防护分为以下部分：</p>
<ul>
<li>当前威胁——Current threats</li>
<li>病毒和威胁防护设置——Virus &amp; threat protection settings</li>
<li>病毒和威胁防护更新——Virus &amp; threat protection updates</li>
<li>勒索软件防护——Ransomware protection</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135055783.png"
                      alt="image-20230402135055783"
                ></p>
<p><strong>Current threats(当前威胁)</strong></p>
<p>下图是“当前威胁”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402122307444.png"
                      alt="image-20230402122307444"
                ></p>
<p>我们可以通过Current threats界面点击并选择“扫描选项”（Scan options），相关的内容如下：</p>
<ul>
<li>Quick scan（快速扫描）：检查系统中通常可能存在威胁项目的文件夹。</li>
<li>Full scan（全面扫描）：检查硬盘上的所有文件和正在运行的程序，此扫描可能需要一个多小时。</li>
<li>Custom scan（自定义扫描）：任意选择你想要检查的文件和位置，然后开始扫描。</li>
</ul>
<p>我们可以通过Current threats界面点击并查看“威胁历史”（Threat history），相关的内容如下：</p>
<ul>
<li>Last scan（上次扫描）：Windows Defender防病毒软件会自动扫描你的设备是否存在病毒和其他威胁，以帮助保护你的设备安全。</li>
<li>Quarantined threats（隔离的威胁）：是指已被隔离的威胁项目，隔离能有效阻止威胁项目在你的设备上运行，此外，被隔离的威胁项目将会被定期删除。</li>
<li>Allowed threats（允许的威胁）：是指你允许“已经被识别为威胁的项目”在你的设备上运行。</li>
</ul>
<p>警告：只有在100%确定自己在做什么时，才允许运行已被识别为威胁的项目。</p>
<p><strong>Virus &amp; threat protection settings(病毒和威胁防护设置)</strong></p>
<p>下图是“病毒和威胁防护设置”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134413535.png"
                      alt="image-20230402134413535"
                ></p>
<p>在上图中的Virus &amp; threat protection settings界面点击并查看“管理设置”（Manage settings），相关的内容如下：</p>
<ul>
<li>Real-time protection（实时保护）：实时定位并阻止恶意软件在你的设备上安装或运行。</li>
<li>Cloud-delivered protection（云提供的保护）：通过访问云中的最新保护数据以提供增强保护和更快的保护。</li>
<li>Automatic sample submission（自动提交样本）：将可能具有安全威胁的样本文件发送到 Microsoft，以帮助保护你和其他人免受潜在威胁。 </li>
<li>Controlled folder access（控制文件夹访问权限）：保护你设备上的文件、文件夹和内存区域免受不友好应用程序未经授权的更改。</li>
<li>Exclusions（排除）：Windows Defender防病毒软件不会扫描你已排除的项目。</li>
<li>Notifications（通知）：允许Windows Defender防病毒软件发送通知，其中会包含有关设备健康和安全的重要信息。</li>
</ul>
<p>警告：你所排除的项目也可能会包含一些能让你的设备受到攻击的危险应用程序，所以，只有当你100%确定自己在做什么时才能使用此选项。</p>
<p><strong>Virus &amp; threat protection updates(病毒和威胁防护更新)</strong></p>
<p>下图是“病毒和威胁防护更新”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134527557.png"
                      alt="image-20230402134527557"
                ></p>
<p>查看上图中的“病毒和威胁防护更新”（Virus &amp; threat protection updates）下的“Check for updates”：</p>
<ul>
<li><p>Check for updates（检查更新）： 手动检查更新以更新 Windows Defender防病毒软件的反病毒规则。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134647659.png"
                      alt="image-20230402134647659"
                ></p>
</li>
</ul>
<p><strong>Ransomware protection(勒索软件防护)</strong></p>
<p>下图是“勒索软件防护”部分界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402134558602.png"
                      alt="image-20230402134558602"
                ></p>
<p>查看上图中的“勒索软件防护”（Ransomware protection）下的“Manage ransomware protection”：</p>
<ul>
<li><p>Controlled folder access（控制文件夹访问权限）：勒索软件防护需要启用此功能，但是为了启用此功能你需要首先启用实时保护功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402133423850.png"
                      alt="image-20230402133423850"
                ></p>
</li>
</ul>
<p><em>tips：你可以对任何文件&#x2F;文件夹执行按需安全扫描，只需右键单击项目并选择“使用Microsoft Defender扫描”即可。</em></p>
<p>下图是来自于另一个Windows设备，以展示按需扫描功能：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402123519987.png"
                      alt="image-20230402123519987"
                ></p>
<p><strong>答题</strong></p>
<p><em>tips：阅读本小节内容并且访问Windows虚拟机进行探索，然后回答以下问题。</em></p>
<p>访问由实验房间所提供的Windows虚拟机，并进行相关探索。</p>
<p>基于上一小节的答题任务可知，我们需要关注的内容是“病毒和威胁防护”，因此我们可以查看“病毒和威胁防护”面板以找到更多详细信息：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402135608336.png"
                      alt="image-20230402135608336"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402140016742.png"
                      alt="image-20230402140016742"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402123705311.png"
                      alt="image-20230402123705311"
                ></p>
<h2 id="防火墙和网络保护（Firewall-network-protection）"><a href="#防火墙和网络保护（Firewall-network-protection）" class="headerlink" title="防火墙和网络保护（Firewall &amp; network protection）"></a>防火墙和网络保护（Firewall &amp; network protection）</h2><p><strong>什么是firewall（防火墙）?</strong></p>
<p>根据微软的说法，“流量是通过端口流入和流出设备的，而防火墙能够控制什么可以（更重要的是不可以）通过这些端口；你可以把防火墙想象成一个站在门口的保安，它会检查所有试图进出的人的ID信息”。</p>
<p>我们可以导航到“防火墙和网络保护”界面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402143136894.png"
                      alt="image-20230402143136894"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402140909388.png"
                      alt="image-20230402140909388"
                ></p>
<p>注意：上图中的每个选项可能会有不同的状态图标。</p>
<p>我们在“防火墙和网络保护”界面中所看到的“Domain network”、“Private network ”和“Public network ”三者之间有什么区别?</p>
<p>根据微软的说法，“Windows防火墙会提供三种防火墙配置：域、私有和公共”。</p>
<ul>
<li>Domain（域）：防火墙的域配置适用于主机系统可以向域控制器进行身份验证的网络。</li>
<li>Private （私有）：防火墙的私有配置是用户分配的配置，可用于指定私有或家庭网络。</li>
<li>Public （公共）：防火墙的默认配置为Public，可用于指定公共网络，例如咖啡店、机场和其他地点的Wi-Fi热点。</li>
</ul>
<p>如果你单击任何一种防火墙配置，则将出现对应的相关配置页面，其中会包含两个选项：打开&#x2F;关闭防火墙、阻止所有传入连接。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402141951302.png"
                      alt="image-20230402141951302"
                ></p>
<p>警告：除非你对你正在做的事情有100%的信心，否则建议你开启Windows Defender 防火墙。</p>
<p>接下来我们关注“防火墙和网络保护”界面的“Allow an app through firewall”和“Advanced Settings”：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142228875.png"
                      alt="image-20230402142228875"
                ></p>
<p><strong>Allow an app through firewall</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142409767.png"
                      alt="image-20230402142409767"
                ></p>
<p>你可以查看任何防火墙配置的当前设置，在上图中，我们可以看到有一些应用程序可以访问私有或者公共防火墙配置，如果你点击“详细信息-Details”按钮，则能获取到对应应用程序所提供的一些额外信息。</p>
<p><strong>Advanced Settings</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402142440552.png"
                      alt="image-20230402142440552"
                ></p>
<p>配置Windows Defender防火墙的操作适用于Windows高级用户，你可以参考<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-firewall/best-practices-configuring" >相关的Microsoft 官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p>tips：打开Windows Defender防火墙的命令为<code>WF.msc</code>。</p>
<p><strong>答题</strong></p>
<p>tips：通过阅读本小节相关内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402143709102.png"
                      alt="image-20230402143709102"
                ></p>
<h2 id="应用程序和浏览器控制（App-browser-control）"><a href="#应用程序和浏览器控制（App-browser-control）" class="headerlink" title="应用程序和浏览器控制（App &amp; browser control）"></a>应用程序和浏览器控制（App &amp; browser control）</h2><p>在此部分中，你可以更改Microsoft Defender SmartScreen的设置。</p>
<p>根据 Microsoft 的说法，“ Microsoft Defender SmartScreen 可以防止网络钓鱼、恶意软件网站和应用程序以及潜在恶意文件的下载”。</p>
<p>有关 Microsoft Defender SmartScreen 的更多信息，请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-smartscreen/microsoft-defender-smartscreen-overview" >相关的Microsoft官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402184152523.png"
                      alt="image-20230402184152523"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144528956.png"
                      alt="image-20230402144528956"
                ></p>
<p><strong>Check apps and files</strong></p>
<p>Windows Defender SmartScreen 通过检查来自网络的 无法识别的应用程序和文件来帮助保护你的设备。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144656769.png"
                      alt="image-20230402144656769"
                ></p>
<p><strong>Exploit protection</strong></p>
<p>Exploit protection 内置在Windows 10操作系统(本文相关的实验机为Windows Server 2019)中，能够帮助保护你的设备免受恶意攻击。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402144921155.png"
                      alt="image-20230402144921155"
                ></p>
<p>警告：除非你对所做的事情有100%的信心，否则建议你保持上图中的默认设置。</p>
<h2 id="设备安全（Device-security）"><a href="#设备安全（Device-security）" class="headerlink" title="设备安全（Device security）"></a>设备安全（Device security）</h2><p>尽管你可能永远不会更改以下设置，但我们还是会简要介绍一下。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402184241911.png"
                      alt="image-20230402184241911"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150319201.png"
                      alt="image-20230402150319201"
                ></p>
<p><strong>Core isolation（核心隔离）</strong></p>
<ul>
<li>Memory Integrity（内存完整性）：防止攻击者将恶意代码插入高安全性进程。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402145704103.png"
                      alt="image-20230402145704103"
                ></p>
<p>警告：除非你对所做的事情有100%的信心，否则建议你保持默认设置。</p>
<p>下面的图片来自于另一台机器，展示了个人Windows 10设备应该具备的另一个安全功能——Security processor。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402145809858.png"
                      alt="image-20230402145809858"
                ></p>
<p>下面是Security processor（安全处理器）的详细信息。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150039454.png"
                      alt="image-20230402150039454"
                ></p>
<p>上图所提及的可信平台模块(TPM-Trusted Platform Module)是什么？</p>
<p>根据微软的说法，“可信平台模块(TPM)技术旨在提供基于硬件的安全相关功能。TPM芯片是一种安全的加密处理器，被设计用于执行加密操作，该芯片包括多种物理安全机制，使其具有抗篡改性，恶意软件无法篡改TPM的安全功能”。</p>
<p><strong>答题</strong></p>
<p>tips：阅读本小节内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402150412883.png"
                      alt="image-20230402150412883"
                ></p>
<h2 id="BitLocker"><a href="#BitLocker" class="headerlink" title="BitLocker"></a>BitLocker</h2><p>什么是<strong>BitLocker</strong>？</p>
<p>根据微软的说法，“ BitLocker驱动器加密是一种数据保护功能，它与操作系统集成在一起，可以解决数据被盗的威胁，数据被盗指的是由于计算机丢失、计算机被盗或者不当停用的旧计算机被利用等因素而导致的数据泄露”。</p>
<p>在安装了 TPM 的设备上，BitLocker 能提供最好的数据保护。</p>
<p>根据 Microsoft 的说法，“ BitLocker 在与可信平台模块 (TPM) 1.2 或更高版本的TPM一起使用时能够提供最大的保护。TPM 是一种计算机制造商安装在许多较新计算机中的硬件组件，它可以与 BitLocker 一起帮助保护用户数据以及能够确保计算机在系统离线时不被篡改数据”。</p>
<p>请参阅<a class="link"   href="https://docs.microsoft.com/en-us/windows/security/information-protection/bitlocker/bitlocker-overview" >相关的Microsoft官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解有关 BitLocker 的更多信息。 </p>
<p>注意：本文相关的实验房间所附加的虚拟机中不包含 BitLocker 功能。</p>
<p><strong>答题</strong></p>
<p>tips：请参阅有关 BitLocker 的 Microsoft 文档，然后回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183226395.png"
                      alt="image-20230402183226395"
                ></p>
<p>翻译页面：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183931261.png"
                      alt="image-20230402183931261"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402183012938.png"
                      alt="image-20230402183012938"
                ></p>
<h2 id="卷影复制服务（Volume-Shadow-Copy-Service）"><a href="#卷影复制服务（Volume-Shadow-Copy-Service）" class="headerlink" title="卷影复制服务（Volume Shadow Copy Service）"></a>卷影复制服务（Volume Shadow Copy Service）</h2><p>根据<a class="link"   href="https://learn.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service" >微软官方相关文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的说法：卷影复制服务(VSS-Volume Shadow Copy Service)能够协调所需的操作 以创建与要备份的数据一致的影子副本(也被称为快照或时间点拷贝)。</p>
<p>卷影副本会存储在每个启用了保护功能的驱动器上的“系统卷信息”文件夹中。</p>
<p>如果启用了VSS(这需要先启动系统保护)，你就可以在“高级系统设置”页面中执行以下任务：</p>
<ul>
<li>创建还原点</li>
<li>执行系统恢复（还原）</li>
<li>配置还原设置</li>
<li>删除还原点</li>
</ul>
<p>从安全的角度来看，恶意软件编写者可能知道这个Windows特性（此处指的是VSS），并会在恶意软件中编写代码 以便查找备份文件并删除它们；这样攻击者这样做，那么我们就不可能从勒索软件攻击中恢复数据，除非我们另有离线&#x2F;异地备份。</p>
<p>如果你希望配置影子副本，请参考以下图片：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402191730722.png"
                      alt="image-20230402191730722"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402192812926.png"
                      alt="image-20230402192812926"
                ></p>
<p>注意：选中系统卷（如c:\）并点击上图中的“Enable”，即可成功创建一个卷影副本。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402192739427.png"
                      alt="image-20230402192739427"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402193151086.png"
                      alt="image-20230402193151086"
                ></p>
<p><strong>答题</strong></p>
<p>tips：阅读本小节内容，可回答以下问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../articleimg/image-20230402191908942.png"
                      alt="image-20230402191908942"
                ></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在本文中，我们介绍了几个内置的 Windows 安全工具，这些工具会随 Windows 操作系统一起被提供给用户，以帮助我们更好地保护计算机设备。</p>
<p>关于 Windows 操作系统，还有很多内容需要解释和涵盖。本文包括前两篇系列文章都只是对Windows操作系统进行了一些基础介绍，如果想了解有关 Windows 操作系统的更多信息，你还需要自己继续开展相关的学习。</p>
<p>延伸阅读材料：</p>
<ul>
<li><a class="link"   href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" >Antimalware Scan Interface <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard-manage" >Credential Guard <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>[Windows 10 Hello](<a class="link"   href="https://support.microsoft.com/en-us/windows/learn-about-windows-hello-and-set-it-up-dae28983-8242-bb2a-d3d1-87c9d265a5f0#:~:text=Windows" >https://support.microsoft.com/en-us/windows/learn-about-windows-hello-and-set-it-up-dae28983-8242-bb2a-d3d1-87c9d265a5f0#:~:text=Windows <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 10,in with just your PIN.)</li>
<li><a class="link"   href="https://www.csoonline.com/article/3253899/the-best-new-windows-10-security-features.html" >CSO Online - The best new Windows 10 security features <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<p><strong>注意：</strong></p>
<p>攻击者可以使用内置的 Windows 工具和实用程序来完成进一步的攻击操作，这种方式能够试图让攻击者在受害者环境中不被轻易发现；此策略被称为 Living Off The Land（LotL策略），你可以参阅以下链接以了解更多相关信息。</p>
<p>LOLBAS：<a class="link"   href="https://lolbas-project.github.io/" >https://lolbas-project.github.io/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>TryHackMe笔记</category>
      </categories>
      <tags>
        <tag>TryHackMe</tag>
        <tag>网络安全基础</tag>
        <tag>BlueTeam</tag>
      </tags>
  </entry>
</search>
